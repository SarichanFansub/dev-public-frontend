(function (root, factory) {
  (typeof module === 'object' && module.exports) ? module.exports = factory() : root.IPFS = factory()
}(typeof self !== 'undefined' ? self : this, function () {
  var Ipfs = (() => {
    var g4e = Object.defineProperty;
    var gi = (r, e) => () => (r && (e = r(r = 0)), e),
      y = (r, e) => () => (e || r((e = {
        exports: {}
      }).exports, e), e.exports),
      vP = (r, e) => {
        for (var t in e) g4e(r, t, {
          get: e[t],
          enumerable: !0
        })
      };
    var V4 = y(xm => {
      l();
      "use strict";
      xm.byteLength = b4e;
      xm.toByteArray = m4e;
      xm.fromByteArray = v4e;
      var Sa = [],
        Ws = [],
        w4e = typeof Uint8Array != "undefined" ? Uint8Array : Array,
        j4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (var Vh = 0, _4e = j4.length; Vh < _4e; ++Vh) Sa[Vh] = j4[Vh], Ws[j4.charCodeAt(Vh)] = Vh;
      Ws["-".charCodeAt(0)] = 62;
      Ws["_".charCodeAt(0)] = 63;

      function wP(r) {
        var e = r.length;
        if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var t = r.indexOf("=");
        t === -1 && (t = e);
        var i = t === e ? 0 : 4 - t % 4;
        return [t, i]
      }

      function b4e(r) {
        var e = wP(r),
          t = e[0],
          i = e[1];
        return (t + i) * 3 / 4 - i
      }

      function E4e(r, e, t) {
        return (e + t) * 3 / 4 - t
      }

      function m4e(r) {
        var e, t = wP(r),
          i = t[0],
          n = t[1],
          s = new w4e(E4e(r, i, n)),
          o = 0,
          a = n > 0 ? i - 4 : i,
          c;
        for (c = 0; c < a; c += 4) e = Ws[r.charCodeAt(c)] << 18 | Ws[r.charCodeAt(c + 1)] << 12 | Ws[r.charCodeAt(c + 2)] << 6 | Ws[r.charCodeAt(c + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
        return n === 2 && (e = Ws[r.charCodeAt(c)] << 2 | Ws[r.charCodeAt(c + 1)] >> 4, s[o++] = e & 255), n === 1 && (e = Ws[r.charCodeAt(c)] << 10 | Ws[r.charCodeAt(c + 1)] << 4 | Ws[r.charCodeAt(c + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s
      }

      function S4e(r) {
        return Sa[r >> 18 & 63] + Sa[r >> 12 & 63] + Sa[r >> 6 & 63] + Sa[r & 63]
      }

      function x4e(r, e, t) {
        for (var i, n = [], s = e; s < t; s += 3) i = (r[s] << 16 & 16711680) + (r[s + 1] << 8 & 65280) + (r[s + 2] & 255), n.push(S4e(i));
        return n.join("")
      }

      function v4e(r) {
        for (var e, t = r.length, i = t % 3, n = [], s = 16383, o = 0, a = t - i; o < a; o += s) n.push(x4e(r, o, o + s > a ? a : o + s));
        return i === 1 ? (e = r[t - 1], n.push(Sa[e >> 2] + Sa[e << 4 & 63] + "==")) : i === 2 && (e = (r[t - 2] << 8) + r[t - 1], n.push(Sa[e >> 10] + Sa[e >> 4 & 63] + Sa[e << 2 & 63] + "=")), n.join("")
      }
    });
    var x1 = y(H4 => {
      l();
      H4.read = function (r, e, t, i, n) {
        var s, o, a = n * 8 - i - 1,
          c = (1 << a) - 1,
          u = c >> 1,
          f = -7,
          h = t ? n - 1 : 0,
          d = t ? -1 : 1,
          p = r[e + h];
        for (h += d, s = p & (1 << -f) - 1, p >>= -f, f += a; f > 0; s = s * 256 + r[e + h], h += d, f -= 8);
        for (o = s & (1 << -f) - 1, s >>= -f, f += i; f > 0; o = o * 256 + r[e + h], h += d, f -= 8);
        if (s === 0) s = 1 - u;
        else {
          if (s === c) return o ? NaN : (p ? -1 : 1) * Infinity;
          o = o + Math.pow(2, i), s = s - u
        }
        return (p ? -1 : 1) * o * Math.pow(2, s - i)
      };
      H4.write = function (r, e, t, i, n, s) {
        var o, a, c, u = s * 8 - n - 1,
          f = (1 << u) - 1,
          h = f >> 1,
          d = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          p = i ? 0 : s - 1,
          g = i ? 1 : -1,
          m = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e), isNaN(e) || e === Infinity ? (a = isNaN(e) ? 1 : 0, o = f) : (o = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -o)) < 1 && (o--, c *= 2), o + h >= 1 ? e += d / c : e += d * Math.pow(2, 1 - h), e * c >= 2 && (o++, c /= 2), o + h >= f ? (a = 0, o = f) : o + h >= 1 ? (a = (e * c - 1) * Math.pow(2, n), o = o + h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, n), o = 0)); n >= 8; r[t + p] = a & 255, p += g, a /= 256, n -= 8);
        for (o = o << n | a, u += n; u > 0; r[t + p] = o & 255, p += g, o /= 256, u -= 8);
        r[t + p - g] |= m * 128
      }
    });
    var Wt = y(Hh => {
      l();
      "use strict";
      var G4 = V4(),
        Gh = x1(),
        _P = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      Hh.Buffer = _e;
      Hh.SlowBuffer = A4e;
      Hh.INSPECT_MAX_BYTES = 50;
      var Am = 2147483647;
      Hh.kMaxLength = Am;
      _e.TYPED_ARRAY_SUPPORT = I4e();
      !_e.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

      function I4e() {
        try {
          let r = new Uint8Array(1),
            e = {
              foo: function () {
                return 42
              }
            };
          return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(r, e), r.foo() === 42
        } catch (r) {
          return !1
        }
      }
      Object.defineProperty(_e.prototype, "parent", {
        enumerable: !0,
        get: function () {
          if (!!_e.isBuffer(this)) return this.buffer
        }
      });
      Object.defineProperty(_e.prototype, "offset", {
        enumerable: !0,
        get: function () {
          if (!!_e.isBuffer(this)) return this.byteOffset
        }
      });

      function Cc(r) {
        if (r > Am) throw new RangeError('The value "' + r + '" is invalid for option "size"');
        let e = new Uint8Array(r);
        return Object.setPrototypeOf(e, _e.prototype), e
      }

      function _e(r, e, t) {
        if (typeof r == "number") {
          if (typeof e == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
          return $4(r)
        }
        return EP(r, e, t)
      }
      _e.poolSize = 8192;

      function EP(r, e, t) {
        if (typeof r == "string") return T4e(r, e);
        if (ArrayBuffer.isView(r)) return R4e(r);
        if (r == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
        if (xa(r, ArrayBuffer) || r && xa(r.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (xa(r, SharedArrayBuffer) || r && xa(r.buffer, SharedArrayBuffer))) return W4(r, e, t);
        if (typeof r == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        let i = r.valueOf && r.valueOf();
        if (i != null && i !== r) return _e.from(i, e, t);
        let n = k4e(r);
        if (n) return n;
        if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof r[Symbol.toPrimitive] == "function") return _e.from(r[Symbol.toPrimitive]("string"), e, t);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r)
      }
      _e.from = function (r, e, t) {
        return EP(r, e, t)
      };
      Object.setPrototypeOf(_e.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(_e, Uint8Array);

      function SP(r) {
        if (typeof r != "number") throw new TypeError('"size" argument must be of type number');
        if (r < 0) throw new RangeError('The value "' + r + '" is invalid for option "size"')
      }

      function P4e(r, e, t) {
        return SP(r), r <= 0 ? Cc(r) : e !== void 0 ? typeof t == "string" ? Cc(r).fill(e, t) : Cc(r).fill(e) : Cc(r)
      }
      _e.alloc = function (r, e, t) {
        return P4e(r, e, t)
      };

      function $4(r) {
        return SP(r), Cc(r < 0 ? 0 : Y4(r) | 0)
      }
      _e.allocUnsafe = function (r) {
        return $4(r)
      };
      _e.allocUnsafeSlow = function (r) {
        return $4(r)
      };

      function T4e(r, e) {
        if ((typeof e != "string" || e === "") && (e = "utf8"), !_e.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
        let t = xP(r, e) | 0,
          i = Cc(t),
          n = i.write(r, e);
        return n !== t && (i = i.slice(0, n)), i
      }

      function J4(r) {
        let e = r.length < 0 ? 0 : Y4(r.length) | 0,
          t = Cc(e);
        for (let i = 0; i < e; i += 1) t[i] = r[i] & 255;
        return t
      }

      function R4e(r) {
        if (xa(r, Uint8Array)) {
          let e = new Uint8Array(r);
          return W4(e.buffer, e.byteOffset, e.byteLength)
        }
        return J4(r)
      }

      function W4(r, e, t) {
        if (e < 0 || r.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
        if (r.byteLength < e + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let i;
        return e === void 0 && t === void 0 ? i = new Uint8Array(r) : t === void 0 ? i = new Uint8Array(r, e) : i = new Uint8Array(r, e, t), Object.setPrototypeOf(i, _e.prototype), i
      }

      function k4e(r) {
        if (_e.isBuffer(r)) {
          let e = Y4(r.length) | 0,
            t = Cc(e);
          return t.length === 0 || r.copy(t, 0, 0, e), t
        }
        if (r.length !== void 0) return typeof r.length != "number" || X4(r.length) ? Cc(0) : J4(r);
        if (r.type === "Buffer" && Array.isArray(r.data)) return J4(r.data)
      }

      function Y4(r) {
        if (r >= Am) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Am.toString(16) + " bytes");
        return r | 0
      }

      function A4e(r) {
        return +r != r && (r = 0), _e.alloc(+r)
      }
      _e.isBuffer = function (e) {
        return e != null && e._isBuffer === !0 && e !== _e.prototype
      };
      _e.compare = function (e, t) {
        if (xa(e, Uint8Array) && (e = _e.from(e, e.offset, e.byteLength)), xa(t, Uint8Array) && (t = _e.from(t, t.offset, t.byteLength)), !_e.isBuffer(e) || !_e.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (e === t) return 0;
        let i = e.length,
          n = t.length;
        for (let s = 0, o = Math.min(i, n); s < o; ++s)
          if (e[s] !== t[s]) {
            i = e[s], n = t[s];
            break
          } return i < n ? -1 : n < i ? 1 : 0
      };
      _e.isEncoding = function (e) {
        switch (String(e).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1
        }
      };
      _e.concat = function (e, t) {
        if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (e.length === 0) return _e.alloc(0);
        let i;
        if (t === void 0)
          for (t = 0, i = 0; i < e.length; ++i) t += e[i].length;
        let n = _e.allocUnsafe(t),
          s = 0;
        for (i = 0; i < e.length; ++i) {
          let o = e[i];
          if (xa(o, Uint8Array)) s + o.length > n.length ? (_e.isBuffer(o) || (o = _e.from(o)), o.copy(n, s)) : Uint8Array.prototype.set.call(n, o, s);
          else if (_e.isBuffer(o)) o.copy(n, s);
          else throw new TypeError('"list" argument must be an Array of Buffers');
          s += o.length
        }
        return n
      };

      function xP(r, e) {
        if (_e.isBuffer(r)) return r.length;
        if (ArrayBuffer.isView(r) || xa(r, ArrayBuffer)) return r.byteLength;
        if (typeof r != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r);
        let t = r.length,
          i = arguments.length > 2 && arguments[2] === !0;
        if (!i && t === 0) return 0;
        let n = !1;
        for (; ;) switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return t;
          case "utf8":
          case "utf-8":
            return Z4(r).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return t * 2;
          case "hex":
            return t >>> 1;
          case "base64":
            return AP(r).length;
          default:
            if (n) return i ? -1 : Z4(r).length;
            e = ("" + e).toLowerCase(), n = !0
        }
      }
      _e.byteLength = xP;

      function B4e(r, e, t) {
        let i = !1;
        if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e)) return "";
        for (r || (r = "utf8"); ;) switch (r) {
          case "hex":
            return q4e(this, e, t);
          case "utf8":
          case "utf-8":
            return IP(this, e, t);
          case "ascii":
            return O4e(this, e, t);
          case "latin1":
          case "binary":
            return N4e(this, e, t);
          case "base64":
            return C4e(this, e, t);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return M4e(this, e, t);
          default:
            if (i) throw new TypeError("Unknown encoding: " + r);
            r = (r + "").toLowerCase(), i = !0
        }
      }
      _e.prototype._isBuffer = !0;

      function Jf(r, e, t) {
        let i = r[e];
        r[e] = r[t], r[t] = i
      }
      _e.prototype.swap16 = function () {
        let e = this.length;
        if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let t = 0; t < e; t += 2) Jf(this, t, t + 1);
        return this
      };
      _e.prototype.swap32 = function () {
        let e = this.length;
        if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let t = 0; t < e; t += 4) Jf(this, t, t + 3), Jf(this, t + 1, t + 2);
        return this
      };
      _e.prototype.swap64 = function () {
        let e = this.length;
        if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let t = 0; t < e; t += 8) Jf(this, t, t + 7), Jf(this, t + 1, t + 6), Jf(this, t + 2, t + 5), Jf(this, t + 3, t + 4);
        return this
      };
      _e.prototype.toString = function () {
        let e = this.length;
        return e === 0 ? "" : arguments.length === 0 ? IP(this, 0, e) : B4e.apply(this, arguments)
      };
      _e.prototype.toLocaleString = _e.prototype.toString;
      _e.prototype.equals = function (e) {
        if (!_e.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
        return this === e ? !0 : _e.compare(this, e) === 0
      };
      _e.prototype.inspect = function () {
        let e = "",
          t = Hh.INSPECT_MAX_BYTES;
        return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">"
      };
      _P && (_e.prototype[_P] = _e.prototype.inspect);
      _e.prototype.compare = function (e, t, i, n, s) {
        if (xa(e, Uint8Array) && (e = _e.from(e, e.offset, e.byteLength)), !_e.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
        if (t === void 0 && (t = 0), i === void 0 && (i = e ? e.length : 0), n === void 0 && (n = 0), s === void 0 && (s = this.length), t < 0 || i > e.length || n < 0 || s > this.length) throw new RangeError("out of range index");
        if (n >= s && t >= i) return 0;
        if (n >= s) return -1;
        if (t >= i) return 1;
        if (t >>>= 0, i >>>= 0, n >>>= 0, s >>>= 0, this === e) return 0;
        let o = s - n,
          a = i - t,
          c = Math.min(o, a),
          u = this.slice(n, s),
          f = e.slice(t, i);
        for (let h = 0; h < c; ++h)
          if (u[h] !== f[h]) {
            o = u[h], a = f[h];
            break
          } return o < a ? -1 : a < o ? 1 : 0
      };

      function RP(r, e, t, i, n) {
        if (r.length === 0) return -1;
        if (typeof t == "string" ? (i = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, X4(t) && (t = n ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
          if (n) return -1;
          t = r.length - 1
        } else if (t < 0)
          if (n) t = 0;
          else return -1;
        if (typeof e == "string" && (e = _e.from(e, i)), _e.isBuffer(e)) return e.length === 0 ? -1 : TP(r, e, t, i, n);
        if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : TP(r, [e], t, i, n);
        throw new TypeError("val must be string, number or Buffer")
      }

      function TP(r, e, t, i, n) {
        let s = 1,
          o = r.length,
          a = e.length;
        if (i !== void 0 && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
          if (r.length < 2 || e.length < 2) return -1;
          s = 2, o /= 2, a /= 2, t /= 2
        }

        function c(f, h) {
          return s === 1 ? f[h] : f.readUInt16BE(h * s)
        }
        let u;
        if (n) {
          let f = -1;
          for (u = t; u < o; u++)
            if (c(r, u) === c(e, f === -1 ? 0 : u - f)) {
              if (f === -1 && (f = u), u - f + 1 === a) return f * s
            } else f !== -1 && (u -= u - f), f = -1
        } else
          for (t + a > o && (t = o - a), u = t; u >= 0; u--) {
            let f = !0;
            for (let h = 0; h < a; h++)
              if (c(r, u + h) !== c(e, h)) {
                f = !1;
                break
              } if (f) return u
          }
        return -1
      }
      _e.prototype.includes = function (e, t, i) {
        return this.indexOf(e, t, i) !== -1
      };
      _e.prototype.indexOf = function (e, t, i) {
        return RP(this, e, t, i, !0)
      };
      _e.prototype.lastIndexOf = function (e, t, i) {
        return RP(this, e, t, i, !1)
      };

      function D4e(r, e, t, i) {
        t = Number(t) || 0;
        let n = r.length - t;
        i ? (i = Number(i), i > n && (i = n)) : i = n;
        let s = e.length;
        i > s / 2 && (i = s / 2);
        let o;
        for (o = 0; o < i; ++o) {
          let a = parseInt(e.substr(o * 2, 2), 16);
          if (X4(a)) return o;
          r[t + o] = a
        }
        return o
      }

      function L4e(r, e, t, i) {
        return Im(Z4(e, r.length - t), r, t, i)
      }

      function U4e(r, e, t, i) {
        return Im(F4e(e), r, t, i)
      }

      function K4e(r, e, t, i) {
        return Im(AP(e), r, t, i)
      }

      function j4e(r, e, t, i) {
        return Im(z4e(e, r.length - t), r, t, i)
      }
      _e.prototype.write = function (e, t, i, n) {
        if (t === void 0) n = "utf8", i = this.length, t = 0;
        else if (i === void 0 && typeof t == "string") n = t, i = this.length, t = 0;
        else if (isFinite(t)) t = t >>> 0, isFinite(i) ? (i = i >>> 0, n === void 0 && (n = "utf8")) : (n = i, i = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let s = this.length - t;
        if ((i === void 0 || i > s) && (i = s), e.length > 0 && (i < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        n || (n = "utf8");
        let o = !1;
        for (; ;) switch (n) {
          case "hex":
            return D4e(this, e, t, i);
          case "utf8":
          case "utf-8":
            return L4e(this, e, t, i);
          case "ascii":
          case "latin1":
          case "binary":
            return U4e(this, e, t, i);
          case "base64":
            return K4e(this, e, t, i);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return j4e(this, e, t, i);
          default:
            if (o) throw new TypeError("Unknown encoding: " + n);
            n = ("" + n).toLowerCase(), o = !0
        }
      };
      _e.prototype.toJSON = function () {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        }
      };

      function C4e(r, e, t) {
        return e === 0 && t === r.length ? G4.fromByteArray(r) : G4.fromByteArray(r.slice(e, t))
      }

      function IP(r, e, t) {
        t = Math.min(r.length, t);
        let i = [],
          n = e;
        for (; n < t;) {
          let s = r[n],
            o = null,
            a = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
          if (n + a <= t) {
            let c, u, f, h;
            switch (a) {
              case 1:
                s < 128 && (o = s);
                break;
              case 2:
                c = r[n + 1], (c & 192) == 128 && (h = (s & 31) << 6 | c & 63, h > 127 && (o = h));
                break;
              case 3:
                c = r[n + 1], u = r[n + 2], (c & 192) == 128 && (u & 192) == 128 && (h = (s & 15) << 12 | (c & 63) << 6 | u & 63, h > 2047 && (h < 55296 || h > 57343) && (o = h));
                break;
              case 4:
                c = r[n + 1], u = r[n + 2], f = r[n + 3], (c & 192) == 128 && (u & 192) == 128 && (f & 192) == 128 && (h = (s & 15) << 18 | (c & 63) << 12 | (u & 63) << 6 | f & 63, h > 65535 && h < 1114112 && (o = h))
            }
          }
          o === null ? (o = 65533, a = 1) : o > 65535 && (o -= 65536, i.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), i.push(o), n += a
        }
        return V4e(i)
      }
      var kP = 4096;

      function V4e(r) {
        let e = r.length;
        if (e <= kP) return String.fromCharCode.apply(String, r);
        let t = "",
          i = 0;
        for (; i < e;) t += String.fromCharCode.apply(String, r.slice(i, i += kP));
        return t
      }

      function O4e(r, e, t) {
        let i = "";
        t = Math.min(r.length, t);
        for (let n = e; n < t; ++n) i += String.fromCharCode(r[n] & 127);
        return i
      }

      function N4e(r, e, t) {
        let i = "";
        t = Math.min(r.length, t);
        for (let n = e; n < t; ++n) i += String.fromCharCode(r[n]);
        return i
      }

      function q4e(r, e, t) {
        let i = r.length;
        (!e || e < 0) && (e = 0), (!t || t < 0 || t > i) && (t = i);
        let n = "";
        for (let s = e; s < t; ++s) n += H4e[r[s]];
        return n
      }

      function M4e(r, e, t) {
        let i = r.slice(e, t),
          n = "";
        for (let s = 0; s < i.length - 1; s += 2) n += String.fromCharCode(i[s] + i[s + 1] * 256);
        return n
      }
      _e.prototype.slice = function (e, t) {
        let i = this.length;
        e = ~~e, t = t === void 0 ? i : ~~t, e < 0 ? (e += i, e < 0 && (e = 0)) : e > i && (e = i), t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), t < e && (t = e);
        let n = this.subarray(e, t);
        return Object.setPrototypeOf(n, _e.prototype), n
      };

      function Ui(r, e, t) {
        if (r % 1 != 0 || r < 0) throw new RangeError("offset is not uint");
        if (r + e > t) throw new RangeError("Trying to access beyond buffer length")
      }
      _e.prototype.readUintLE = _e.prototype.readUIntLE = function (e, t, i) {
        e = e >>> 0, t = t >>> 0, i || Ui(e, t, this.length);
        let n = this[e],
          s = 1,
          o = 0;
        for (; ++o < t && (s *= 256);) n += this[e + o] * s;
        return n
      };
      _e.prototype.readUintBE = _e.prototype.readUIntBE = function (e, t, i) {
        e = e >>> 0, t = t >>> 0, i || Ui(e, t, this.length);
        let n = this[e + --t],
          s = 1;
        for (; t > 0 && (s *= 256);) n += this[e + --t] * s;
        return n
      };
      _e.prototype.readUint8 = _e.prototype.readUInt8 = function (e, t) {
        return e = e >>> 0, t || Ui(e, 1, this.length), this[e]
      };
      _e.prototype.readUint16LE = _e.prototype.readUInt16LE = function (e, t) {
        return e = e >>> 0, t || Ui(e, 2, this.length), this[e] | this[e + 1] << 8
      };
      _e.prototype.readUint16BE = _e.prototype.readUInt16BE = function (e, t) {
        return e = e >>> 0, t || Ui(e, 2, this.length), this[e] << 8 | this[e + 1]
      };
      _e.prototype.readUint32LE = _e.prototype.readUInt32LE = function (e, t) {
        return e = e >>> 0, t || Ui(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216
      };
      _e.prototype.readUint32BE = _e.prototype.readUInt32BE = function (e, t) {
        return e = e >>> 0, t || Ui(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
      };
      _e.prototype.readBigUInt64LE = Ou(function (e) {
        e = e >>> 0, $h(e, "offset");
        let t = this[e],
          i = this[e + 7];
        (t === void 0 || i === void 0) && A1(e, this.length - 8);
        let n = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24,
          s = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + i * 2 ** 24;
        return BigInt(n) + (BigInt(s) << BigInt(32))
      });
      _e.prototype.readBigUInt64BE = Ou(function (e) {
        e = e >>> 0, $h(e, "offset");
        let t = this[e],
          i = this[e + 7];
        (t === void 0 || i === void 0) && A1(e, this.length - 8);
        let n = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e],
          s = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + i;
        return (BigInt(n) << BigInt(32)) + BigInt(s)
      });
      _e.prototype.readIntLE = function (e, t, i) {
        e = e >>> 0, t = t >>> 0, i || Ui(e, t, this.length);
        let n = this[e],
          s = 1,
          o = 0;
        for (; ++o < t && (s *= 256);) n += this[e + o] * s;
        return s *= 128, n >= s && (n -= Math.pow(2, 8 * t)), n
      };
      _e.prototype.readIntBE = function (e, t, i) {
        e = e >>> 0, t = t >>> 0, i || Ui(e, t, this.length);
        let n = t,
          s = 1,
          o = this[e + --n];
        for (; n > 0 && (s *= 256);) o += this[e + --n] * s;
        return s *= 128, o >= s && (o -= Math.pow(2, 8 * t)), o
      };
      _e.prototype.readInt8 = function (e, t) {
        return e = e >>> 0, t || Ui(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
      };
      _e.prototype.readInt16LE = function (e, t) {
        e = e >>> 0, t || Ui(e, 2, this.length);
        let i = this[e] | this[e + 1] << 8;
        return i & 32768 ? i | 4294901760 : i
      };
      _e.prototype.readInt16BE = function (e, t) {
        e = e >>> 0, t || Ui(e, 2, this.length);
        let i = this[e + 1] | this[e] << 8;
        return i & 32768 ? i | 4294901760 : i
      };
      _e.prototype.readInt32LE = function (e, t) {
        return e = e >>> 0, t || Ui(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
      };
      _e.prototype.readInt32BE = function (e, t) {
        return e = e >>> 0, t || Ui(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
      };
      _e.prototype.readBigInt64LE = Ou(function (e) {
        e = e >>> 0, $h(e, "offset");
        let t = this[e],
          i = this[e + 7];
        (t === void 0 || i === void 0) && A1(e, this.length - 8);
        let n = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (i << 24);
        return (BigInt(n) << BigInt(32)) + BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24)
      });
      _e.prototype.readBigInt64BE = Ou(function (e) {
        e = e >>> 0, $h(e, "offset");
        let t = this[e],
          i = this[e + 7];
        (t === void 0 || i === void 0) && A1(e, this.length - 8);
        let n = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
        return (BigInt(n) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + i)
      });
      _e.prototype.readFloatLE = function (e, t) {
        return e = e >>> 0, t || Ui(e, 4, this.length), Gh.read(this, e, !0, 23, 4)
      };
      _e.prototype.readFloatBE = function (e, t) {
        return e = e >>> 0, t || Ui(e, 4, this.length), Gh.read(this, e, !1, 23, 4)
      };
      _e.prototype.readDoubleLE = function (e, t) {
        return e = e >>> 0, t || Ui(e, 8, this.length), Gh.read(this, e, !0, 52, 8)
      };
      _e.prototype.readDoubleBE = function (e, t) {
        return e = e >>> 0, t || Ui(e, 8, this.length), Gh.read(this, e, !1, 52, 8)
      };

      function fs(r, e, t, i, n, s) {
        if (!_e.isBuffer(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > n || e < s) throw new RangeError('"value" argument is out of bounds');
        if (t + i > r.length) throw new RangeError("Index out of range")
      }
      _e.prototype.writeUintLE = _e.prototype.writeUIntLE = function (e, t, i, n) {
        if (e = +e, t = t >>> 0, i = i >>> 0, !n) {
          let a = Math.pow(2, 8 * i) - 1;
          fs(this, e, t, i, a, 0)
        }
        let s = 1,
          o = 0;
        for (this[t] = e & 255; ++o < i && (s *= 256);) this[t + o] = e / s & 255;
        return t + i
      };
      _e.prototype.writeUintBE = _e.prototype.writeUIntBE = function (e, t, i, n) {
        if (e = +e, t = t >>> 0, i = i >>> 0, !n) {
          let a = Math.pow(2, 8 * i) - 1;
          fs(this, e, t, i, a, 0)
        }
        let s = i - 1,
          o = 1;
        for (this[t + s] = e & 255; --s >= 0 && (o *= 256);) this[t + s] = e / o & 255;
        return t + i
      };
      _e.prototype.writeUint8 = _e.prototype.writeUInt8 = function (e, t, i) {
        return e = +e, t = t >>> 0, i || fs(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1
      };
      _e.prototype.writeUint16LE = _e.prototype.writeUInt16LE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || fs(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
      };
      _e.prototype.writeUint16BE = _e.prototype.writeUInt16BE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || fs(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
      };
      _e.prototype.writeUint32LE = _e.prototype.writeUInt32LE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || fs(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4
      };
      _e.prototype.writeUint32BE = _e.prototype.writeUInt32BE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || fs(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
      };

      function CP(r, e, t, i, n) {
        PP(e, i, n, r, t, 7);
        let s = Number(e & BigInt(4294967295));
        r[t++] = s, s = s >> 8, r[t++] = s, s = s >> 8, r[t++] = s, s = s >> 8, r[t++] = s;
        let o = Number(e >> BigInt(32) & BigInt(4294967295));
        return r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, t
      }

      function OP(r, e, t, i, n) {
        PP(e, i, n, r, t, 7);
        let s = Number(e & BigInt(4294967295));
        r[t + 7] = s, s = s >> 8, r[t + 6] = s, s = s >> 8, r[t + 5] = s, s = s >> 8, r[t + 4] = s;
        let o = Number(e >> BigInt(32) & BigInt(4294967295));
        return r[t + 3] = o, o = o >> 8, r[t + 2] = o, o = o >> 8, r[t + 1] = o, o = o >> 8, r[t] = o, t + 8
      }
      _e.prototype.writeBigUInt64LE = Ou(function (e, t = 0) {
        return CP(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
      });
      _e.prototype.writeBigUInt64BE = Ou(function (e, t = 0) {
        return OP(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
      });
      _e.prototype.writeIntLE = function (e, t, i, n) {
        if (e = +e, t = t >>> 0, !n) {
          let c = Math.pow(2, 8 * i - 1);
          fs(this, e, t, i, c - 1, -c)
        }
        let s = 0,
          o = 1,
          a = 0;
        for (this[t] = e & 255; ++s < i && (o *= 256);) e < 0 && a === 0 && this[t + s - 1] !== 0 && (a = 1), this[t + s] = (e / o >> 0) - a & 255;
        return t + i
      };
      _e.prototype.writeIntBE = function (e, t, i, n) {
        if (e = +e, t = t >>> 0, !n) {
          let c = Math.pow(2, 8 * i - 1);
          fs(this, e, t, i, c - 1, -c)
        }
        let s = i - 1,
          o = 1,
          a = 0;
        for (this[t + s] = e & 255; --s >= 0 && (o *= 256);) e < 0 && a === 0 && this[t + s + 1] !== 0 && (a = 1), this[t + s] = (e / o >> 0) - a & 255;
        return t + i
      };
      _e.prototype.writeInt8 = function (e, t, i) {
        return e = +e, t = t >>> 0, i || fs(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1
      };
      _e.prototype.writeInt16LE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || fs(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
      };
      _e.prototype.writeInt16BE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || fs(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
      };
      _e.prototype.writeInt32LE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || fs(this, e, t, 4, 2147483647, -2147483648), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
      };
      _e.prototype.writeInt32BE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || fs(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
      };
      _e.prototype.writeBigInt64LE = Ou(function (e, t = 0) {
        return CP(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
      });
      _e.prototype.writeBigInt64BE = Ou(function (e, t = 0) {
        return OP(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
      });

      function NP(r, e, t, i, n, s) {
        if (t + i > r.length) throw new RangeError("Index out of range");
        if (t < 0) throw new RangeError("Index out of range")
      }

      function qP(r, e, t, i, n) {
        return e = +e, t = t >>> 0, n || NP(r, e, t, 4, 34028234663852886e22, -34028234663852886e22), Gh.write(r, e, t, i, 23, 4), t + 4
      }
      _e.prototype.writeFloatLE = function (e, t, i) {
        return qP(this, e, t, !0, i)
      };
      _e.prototype.writeFloatBE = function (e, t, i) {
        return qP(this, e, t, !1, i)
      };

      function MP(r, e, t, i, n) {
        return e = +e, t = t >>> 0, n || NP(r, e, t, 8, 17976931348623157e292, -17976931348623157e292), Gh.write(r, e, t, i, 52, 8), t + 8
      }
      _e.prototype.writeDoubleLE = function (e, t, i) {
        return MP(this, e, t, !0, i)
      };
      _e.prototype.writeDoubleBE = function (e, t, i) {
        return MP(this, e, t, !1, i)
      };
      _e.prototype.copy = function (e, t, i, n) {
        if (!_e.isBuffer(e)) throw new TypeError("argument should be a Buffer");
        if (i || (i = 0), !n && n !== 0 && (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < i && (n = i), n === i || e.length === 0 || this.length === 0) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (i < 0 || i >= this.length) throw new RangeError("Index out of range");
        if (n < 0) throw new RangeError("sourceEnd out of bounds");
        n > this.length && (n = this.length), e.length - t < n - i && (n = e.length - t + i);
        let s = n - i;
        return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, i, n) : Uint8Array.prototype.set.call(e, this.subarray(i, n), t), s
      };
      _e.prototype.fill = function (e, t, i, n) {
        if (typeof e == "string") {
          if (typeof t == "string" ? (n = t, t = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), n !== void 0 && typeof n != "string") throw new TypeError("encoding must be a string");
          if (typeof n == "string" && !_e.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
          if (e.length === 1) {
            let o = e.charCodeAt(0);
            (n === "utf8" && o < 128 || n === "latin1") && (e = o)
          }
        } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
        if (t < 0 || this.length < t || this.length < i) throw new RangeError("Out of range index");
        if (i <= t) return this;
        t = t >>> 0, i = i === void 0 ? this.length : i >>> 0, e || (e = 0);
        let s;
        if (typeof e == "number")
          for (s = t; s < i; ++s) this[s] = e;
        else {
          let o = _e.isBuffer(e) ? e : _e.from(e, n),
            a = o.length;
          if (a === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
          for (s = 0; s < i - t; ++s) this[s + t] = o[s % a]
        }
        return this
      };
      var Wh = {};

      function Q4(r, e, t) {
        Wh[r] = class extends t {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: e.apply(this, arguments),
              writable: !0,
              configurable: !0
            }), this.name = `${this.name} [${r}]`, this.stack, delete this.name
          }
          get code() {
            return r
          }
          set code(n) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: n,
              writable: !0
            })
          }
          toString() {
            return `${this.name} [${r}]: ${this.message}`
          }
        }
      }
      Q4("ERR_BUFFER_OUT_OF_BOUNDS", function (r) {
        return r ? `${r} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
      }, RangeError);
      Q4("ERR_INVALID_ARG_TYPE", function (r, e) {
        return `The "${r}" argument must be of type number. Received type ${typeof e}`
      }, TypeError);
      Q4("ERR_OUT_OF_RANGE", function (r, e, t) {
        let i = `The value of "${r}" is out of range.`,
          n = t;
        return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? n = BP(String(t)) : typeof t == "bigint" && (n = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (n = BP(n)), n += "n"), i += ` It must be ${e}. Received ${n}`, i
      }, RangeError);

      function BP(r) {
        let e = "",
          t = r.length,
          i = r[0] === "-" ? 1 : 0;
        for (; t >= i + 4; t -= 3) e = `_${r.slice(t - 3, t)}${e}`;
        return `${r.slice(0, t)}${e}`
      }

      function G4e(r, e, t) {
        $h(e, "offset"), (r[e] === void 0 || r[e + t] === void 0) && A1(e, r.length - (t + 1))
      }

      function PP(r, e, t, i, n, s) {
        if (r > t || r < e) {
          let o = typeof e == "bigint" ? "n" : "",
            a;
          throw s > 3 ? e === 0 || e === BigInt(0) ? a = `>= 0${o} and < 2${o} ** ${(s + 1) * 8}${o}` : a = `>= -(2${o} ** ${(s + 1) * 8 - 1}${o}) and < 2 ** ${(s + 1) * 8 - 1}${o}` : a = `>= ${e}${o} and <= ${t}${o}`, new Wh.ERR_OUT_OF_RANGE("value", a, r)
        }
        G4e(i, n, s)
      }

      function $h(r, e) {
        if (typeof r != "number") throw new Wh.ERR_INVALID_ARG_TYPE(e, "number", r)
      }

      function A1(r, e, t) {
        throw Math.floor(r) !== r ? ($h(r, t), new Wh.ERR_OUT_OF_RANGE(t || "offset", "an integer", r)) : e < 0 ? new Wh.ERR_BUFFER_OUT_OF_BOUNDS : new Wh.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${e}`, r)
      }
      var $4e = /[^+/0-9A-Za-z-_]/g;

      function W4e(r) {
        if (r = r.split("=")[0], r = r.trim().replace($4e, ""), r.length < 2) return "";
        for (; r.length % 4 != 0;) r = r + "=";
        return r
      }

      function Z4(r, e) {
        e = e || Infinity;
        let t, i = r.length,
          n = null,
          s = [];
        for (let o = 0; o < i; ++o) {
          if (t = r.charCodeAt(o), t > 55295 && t < 57344) {
            if (!n) {
              if (t > 56319) {
                (e -= 3) > -1 && s.push(239, 191, 189);
                continue
              } else if (o + 1 === i) {
                (e -= 3) > -1 && s.push(239, 191, 189);
                continue
              }
              n = t;
              continue
            }
            if (t < 56320) {
              (e -= 3) > -1 && s.push(239, 191, 189), n = t;
              continue
            }
            t = (n - 55296 << 10 | t - 56320) + 65536
          } else n && (e -= 3) > -1 && s.push(239, 191, 189);
          if (n = null, t < 128) {
            if ((e -= 1) < 0) break;
            s.push(t)
          } else if (t < 2048) {
            if ((e -= 2) < 0) break;
            s.push(t >> 6 | 192, t & 63 | 128)
          } else if (t < 65536) {
            if ((e -= 3) < 0) break;
            s.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128)
          } else if (t < 1114112) {
            if ((e -= 4) < 0) break;
            s.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128)
          } else throw new Error("Invalid code point")
        }
        return s
      }

      function F4e(r) {
        let e = [];
        for (let t = 0; t < r.length; ++t) e.push(r.charCodeAt(t) & 255);
        return e
      }

      function z4e(r, e) {
        let t, i, n, s = [];
        for (let o = 0; o < r.length && !((e -= 2) < 0); ++o) t = r.charCodeAt(o), i = t >> 8, n = t % 256, s.push(n), s.push(i);
        return s
      }

      function AP(r) {
        return G4.toByteArray(W4e(r))
      }

      function Im(r, e, t, i) {
        let n;
        for (n = 0; n < i && !(n + t >= e.length || n >= r.length); ++n) e[n + t] = r[n];
        return n
      }

      function xa(r, e) {
        return r instanceof e || r != null && r.constructor != null && r.constructor.name != null && r.constructor.name === e.name
      }

      function X4(r) {
        return r !== r
      }
      var H4e = function () {
        let r = "0123456789abcdef",
          e = new Array(256);
        for (let t = 0; t < 16; ++t) {
          let i = t * 16;
          for (let n = 0; n < 16; ++n) e[i + n] = r[t] + r[n]
        }
        return e
      }();

      function Ou(r) {
        return typeof BigInt == "undefined" ? Y4e : r
      }

      function Y4e() {
        throw new Error("BigInt not supported")
      }
    });
    var KP = y((zyt, DP) => {
      l();
      var ci = DP.exports = {},
        Aa, Ia;

      function eE() {
        throw new Error("setTimeout has not been defined")
      }

      function tE() {
        throw new Error("clearTimeout has not been defined")
      } (function () {
        try {
          typeof setTimeout == "function" ? Aa = setTimeout : Aa = eE
        } catch (r) {
          Aa = eE
        }
        try {
          typeof clearTimeout == "function" ? Ia = clearTimeout : Ia = tE
        } catch (r) {
          Ia = tE
        }
      })();

      function LP(r) {
        if (Aa === setTimeout) return setTimeout(r, 0);
        if ((Aa === eE || !Aa) && setTimeout) return Aa = setTimeout, setTimeout(r, 0);
        try {
          return Aa(r, 0)
        } catch (e) {
          try {
            return Aa.call(null, r, 0)
          } catch (t) {
            return Aa.call(this, r, 0)
          }
        }
      }

      function J4e(r) {
        if (Ia === clearTimeout) return clearTimeout(r);
        if ((Ia === tE || !Ia) && clearTimeout) return Ia = clearTimeout, clearTimeout(r);
        try {
          return Ia(r)
        } catch (e) {
          try {
            return Ia.call(null, r)
          } catch (t) {
            return Ia.call(this, r)
          }
        }
      }
      var Oc = [],
        Yh = !1,
        Xf, Tm = -1;

      function X4e() {
        !Yh || !Xf || (Yh = !1, Xf.length ? Oc = Xf.concat(Oc) : Tm = -1, Oc.length && FP())
      }

      function FP() {
        if (!Yh) {
          var r = LP(X4e);
          Yh = !0;
          for (var e = Oc.length; e;) {
            for (Xf = Oc, Oc = []; ++Tm < e;) Xf && Xf[Tm].run();
            Tm = -1, e = Oc.length
          }
          Xf = null, Yh = !1, J4e(r)
        }
      }
      ci.nextTick = function (r) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
        Oc.push(new UP(r, e)), Oc.length === 1 && !Yh && LP(FP)
      };

      function UP(r, e) {
        this.fun = r, this.array = e
      }
      UP.prototype.run = function () {
        this.fun.apply(null, this.array)
      };
      ci.title = "browser";
      ci.browser = !0;
      ci.env = {};
      ci.argv = [];
      ci.version = "";
      ci.versions = {};

      function Nc() { }
      ci.on = Nc;
      ci.addListener = Nc;
      ci.once = Nc;
      ci.off = Nc;
      ci.removeListener = Nc;
      ci.removeAllListeners = Nc;
      ci.emit = Nc;
      ci.prependListener = Nc;
      ci.prependOnceListener = Nc;
      ci.listeners = function (r) {
        return []
      };
      ci.binding = function (r) {
        throw new Error("process.binding is not supported")
      };
      ci.cwd = function () {
        return "/"
      };
      ci.chdir = function (r) {
        throw new Error("process.chdir is not supported")
      };
      ci.umask = function () {
        return 0
      }
    });
    var Buffer, process, l = gi(() => {
      ({
        Buffer
      } = Wt()), process = KP()
    });
    var zP = y(() => {
      l()
    });
    var rE = y(Rm => {
      l();
      "use strict";
      var jP = class extends Error {
        constructor(e = "Request timed out") {
          super(e);
          this.name = "TimeoutError"
        }
      };
      Rm.TimeoutError = jP;
      var VP = class extends Error {
        constructor(e = "The operation was aborted.") {
          super(e);
          this.name = "AbortError"
        }
      };
      Rm.AbortError = VP;
      var HP = class extends Error {
        constructor(e) {
          super(e.statusText);
          this.name = "HTTPError", this.response = e
        }
      };
      Rm.HTTPError = HP
    });
    var km = y(($yt, GP) => {
      l();

      function Z4e() {
        return typeof window != "undefined" && typeof window.process == "object" && window.process.type === "renderer" || typeof process != "undefined" && typeof process.versions == "object" && !!process.versions.electron || typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Electron") >= 0
      }
      GP.exports = Z4e
    });
    var iE = y((Wyt, $P) => {
      l();
      "use strict";
      var Q4e = km(),
        Pm = typeof window == "object" && typeof document == "object" && document.nodeType === 9,
        I1 = Q4e(),
        eEe = Pm && !I1,
        tEe = I1 && !Pm,
        rEe = I1 && Pm,
        iEe = typeof process != "undefined" && typeof process.release != "undefined" && process.release.name === "node" && !I1,
        nEe = typeof importScripts == "function" && typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope,
        sEe = typeof process != "undefined" && typeof process.env != "undefined" && process.env.NODE_ENV === "test",
        oEe = typeof navigator != "undefined" && navigator.product === "ReactNative";
      $P.exports = {
        isTest: sEe,
        isElectron: I1,
        isElectronMain: tEe,
        isElectronRenderer: rEe,
        isNode: iEe,
        isBrowser: eEe,
        isWebWorker: nEe,
        isEnvWithDom: Pm,
        isReactNative: oEe
      }
    });
    var WP = y(() => {
      l()
    });
    var T1 = y((Jh, YP) => {
      l();
      "use strict";
      var aEe = function () {
        if (typeof self != "undefined") return self;
        if (typeof window != "undefined") return window;
        if (typeof qc != "undefined") return qc;
        throw new Error("unable to locate global object")
      },
        qc = aEe();
      YP.exports = Jh = qc.fetch;
      qc.fetch && (Jh.default = qc.fetch.bind(qc));
      Jh.Headers = qc.Headers;
      Jh.Request = qc.Request;
      Jh.Response = qc.Response
    });
    var sE = y((Xyt, nE) => {
      l();
      "use strict";
      globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response ? nE.exports = {
        default: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response
      } : nE.exports = {
        default: T1().default,
        Headers: T1().Headers,
        Request: T1().Request,
        Response: T1().Response
      }
    });
    var JP = y((Zyt, oE) => {
      l();
      "use strict";
      var {
        isElectronMain: cEe
      } = iE();
      cEe ? oE.exports = WP() : oE.exports = sE()
    });
    var eC = y((Qyt, XP) => {
      l();
      "use strict";
      var {
        TimeoutError: uEe,
        AbortError: fEe
      } = rE(), {
        Response: ZP,
        Request: lEe,
        Headers: aE,
        default: hEe
      } = JP(), pEe = (r, e = {}) => {
        let t = new XMLHttpRequest;
        t.open(e.method || "GET", r.toString(), !0);
        let {
          timeout: i,
          headers: n
        } = e;
        if (i && i > 0 && i < Infinity && (t.timeout = i), e.overrideMimeType != null && t.overrideMimeType(e.overrideMimeType), n)
          for (let [s, o] of new aE(n)) t.setRequestHeader(s, o);
        return e.signal && (e.signal.onabort = () => t.abort()), e.onUploadProgress && (t.upload.onprogress = e.onUploadProgress), t.responseType = "arraybuffer", new Promise((s, o) => {
          let a = c => {
            switch (c.type) {
              case "error": {
                s(ZP.error());
                break
              }
              case "load": {
                s(new QP(t.responseURL, t.response, {
                  status: t.status,
                  statusText: t.statusText,
                  headers: dEe(t.getAllResponseHeaders())
                }));
                break
              }
              case "timeout": {
                o(new uEe);
                break
              }
              case "abort": {
                o(new fEe);
                break
              }
              default:
                break
            }
          };
          t.onerror = a, t.onload = a, t.ontimeout = a, t.onabort = a, t.send(e.body)
        })
      }, yEe = hEe, gEe = (r, e = {}) => e.onUploadProgress != null ? pEe(r, e) : yEe(r, e), dEe = r => {
        let e = new aE;
        for (let t of r.trim().split(/[\r\n]+/)) {
          let i = t.indexOf(": ");
          i > 0 && e.set(t.slice(0, i), t.slice(i + 1))
        }
        return e
      }, QP = class extends ZP {
        constructor(e, t, i) {
          super(t, i);
          Object.defineProperty(this, "url", {
            value: e
          })
        }
      };
      XP.exports = {
        fetch: gEe,
        Request: lEe,
        Headers: aE
      }
    });
    var rC = y((egt, tC) => {
      l();
      "use strict";
      tC.exports = r => {
        if (Object.prototype.toString.call(r) !== "[object Object]") return !1;
        let e = Object.getPrototypeOf(r);
        return e === null || e === Object.prototype
      }
    });
    var Yr = y((iC, nC) => {
      l();
      "use strict";
      var Cm = rC(),
        {
          hasOwnProperty: sC
        } = Object.prototype,
        {
          propertyIsEnumerable: bEe
        } = Object,
        Xh = (r, e, t) => Object.defineProperty(r, e, {
          value: t,
          writable: !0,
          enumerable: !0,
          configurable: !0
        }),
        mEe = iC,
        oC = {
          concatArrays: !1,
          ignoreUndefined: !1
        },
        Om = r => {
          let e = [];
          for (let t in r) sC.call(r, t) && e.push(t);
          if (Object.getOwnPropertySymbols) {
            let t = Object.getOwnPropertySymbols(r);
            for (let i of t) bEe.call(r, i) && e.push(i)
          }
          return e
        };

      function Zh(r) {
        return Array.isArray(r) ? vEe(r) : Cm(r) ? wEe(r) : r
      }

      function vEe(r) {
        let e = r.slice(0, 0);
        return Om(r).forEach(t => {
          Xh(e, t, Zh(r[t]))
        }), e
      }

      function wEe(r) {
        let e = Object.getPrototypeOf(r) === null ? Object.create(null) : {};
        return Om(r).forEach(t => {
          Xh(e, t, Zh(r[t]))
        }), e
      }
      var aC = (r, e, t, i) => (t.forEach(n => {
        typeof e[n] == "undefined" && i.ignoreUndefined || (n in r && r[n] !== Object.getPrototypeOf(r) ? Xh(r, n, cE(r[n], e[n], i)) : Xh(r, n, Zh(e[n])))
      }), r),
        _Ee = (r, e, t) => {
          let i = r.slice(0, 0),
            n = 0;
          return [r, e].forEach(s => {
            let o = [];
            for (let a = 0; a < s.length; a++) !sC.call(s, a) || (o.push(String(a)), s === r ? Xh(i, n++, s[a]) : Xh(i, n++, Zh(s[a])));
            i = aC(i, s, Om(s).filter(a => !o.includes(a)), t)
          }), i
        };

      function cE(r, e, t) {
        return t.concatArrays && Array.isArray(r) && Array.isArray(e) ? _Ee(r, e, t) : !Cm(e) || !Cm(r) ? Zh(e) : aC(r, e, Om(e), t)
      }
      nC.exports = function (...r) {
        let e = cE(Zh(oC), this !== mEe && this || {}, oC),
          t = {
            _: {}
          };
        for (let i of r)
          if (i !== void 0) {
            if (!Cm(i)) throw new TypeError("`" + i + "` is not an Option Object");
            t = cE(t, {
              _: i
            }, e)
          } return t._
      }
    });
    var uE = y((tgt, cC) => {
      l();
      "use strict";
      var EEe = typeof navigator != "undefined" && navigator.product === "ReactNative";

      function SEe() {
        return EEe ? "http://localhost" : self.location.protocol + "//" + self.location.host
      }
      var R1 = self.URL,
        uC = SEe(),
        fC = class {
          constructor(e = "", t = uC) {
            this.super = new R1(e, t), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null
          }
          get hash() {
            return this.super.hash
          }
          get host() {
            return this.super.host
          }
          get hostname() {
            return this.super.hostname
          }
          get href() {
            return this.super.href
          }
          get origin() {
            return this.super.origin
          }
          get password() {
            return this.super.password
          }
          get pathname() {
            return this.super.pathname
          }
          get port() {
            return this.super.port
          }
          get protocol() {
            return this.super.protocol
          }
          get search() {
            return this.super.search
          }
          get searchParams() {
            return this.super.searchParams
          }
          get username() {
            return this.super.username
          }
          set hash(e) {
            this.super.hash = e
          }
          set host(e) {
            this.super.host = e
          }
          set hostname(e) {
            this.super.hostname = e
          }
          set href(e) {
            this.super.href = e
          }
          set password(e) {
            this.super.password = e
          }
          set pathname(e) {
            this.super.pathname = e
          }
          set port(e) {
            this.super.port = e
          }
          set protocol(e) {
            this.super.protocol = e
          }
          set search(e) {
            this.super.search = e
          }
          set username(e) {
            this.super.username = e
          }
          static createObjectURL(e) {
            return R1.createObjectURL(e)
          }
          static revokeObjectURL(e) {
            R1.revokeObjectURL(e)
          }
          toJSON() {
            return this.super.toJSON()
          }
          toString() {
            return this.super.toString()
          }
          format() {
            return this.toString()
          }
        };

      function xEe(r) {
        if (typeof r == "string") return new R1(r).toString();
        if (!(r instanceof R1)) {
          let e = r.username && r.password ? `${r.username}:${r.password}@` : "",
            t = r.auth ? r.auth + "@" : "",
            i = r.port ? ":" + r.port : "",
            n = r.protocol ? r.protocol + "//" : "",
            s = r.host || "",
            o = r.hostname || "",
            a = r.search || (r.query ? "?" + r.query : ""),
            c = r.hash || "",
            u = r.pathname || "",
            f = r.path || u + a;
          return `${n}${e || t}${s || o + i}${f}${c}`
        }
      }
      cC.exports = {
        URLWithLegacySupport: fC,
        URLSearchParams: self.URLSearchParams,
        defaultBase: uC,
        format: xEe
      }
    });
    var dC = y((rgt, lC) => {
      l();
      "use strict";
      var {
        URLWithLegacySupport: hC,
        format: AEe
      } = uE();
      lC.exports = (r, e = {}, t = {}, i) => {
        let n = e.protocol ? e.protocol.replace(":", "") : "http";
        n = (t[n] || i || n) + ":";
        let s;
        try {
          s = new hC(r)
        } catch (a) {
          s = {}
        }
        let o = Object.assign({}, e, {
          protocol: n || s.protocol,
          host: e.host || s.host
        });
        return new hC(r, AEe(o)).toString()
      }
    });
    var Qh = y((igt, pC) => {
      l();
      "use strict";
      var {
        URLWithLegacySupport: IEe,
        format: TEe,
        URLSearchParams: REe,
        defaultBase: kEe
      } = uE(), PEe = dC();
      pC.exports = {
        URL: IEe,
        URLSearchParams: REe,
        format: TEe,
        relative: PEe,
        defaultBase: kEe
      }
    });
    var Zf = y((ngt, Nm) => {
      l();
      "use strict";
      var {
        AbortController: yC,
        AbortSignal: CEe
      } = typeof self != "undefined" ? self : typeof window != "undefined" ? window : void 0;
      Nm.exports = yC;
      Nm.exports.AbortSignal = CEe;
      Nm.exports.default = yC
    });
    var k1 = y((sgt, gC) => {
      l();
      "use strict";
      var qm;
      globalThis.AbortController && globalThis.AbortSignal ? qm = globalThis : qm = Zf();
      gC.exports = {
        AbortController: qm.AbortController,
        AbortSignal: qm.AbortSignal
      }
    });
    var ed = y((ogt, fE) => {
      l();
      var {
        AbortController: OEe
      } = k1();

      function bC(r) {
        let e = new OEe;

        function t() {
          e.abort();
          for (let i of r) !i || !i.removeEventListener || i.removeEventListener("abort", t)
        }
        for (let i of r)
          if (!(!i || !i.addEventListener)) {
            if (i.aborted) {
              t();
              break
            }
            i.addEventListener("abort", t)
          } return e.signal
      }
      fE.exports = bC;
      fE.exports.anySignal = bC
    });
    var Mm = y((agt, mC) => {
      l();
      "use strict";
      var {
        fetch: NEe,
        Request: qEe,
        Headers: MEe
      } = eC(), {
        TimeoutError: lE,
        HTTPError: vC
      } = rE(), wC = Yr().bind({
        ignoreUndefined: !0
      }), {
        URL: _C,
        URLSearchParams: EC
      } = Qh(), {
        AbortController: BEe
      } = k1(), DEe = ed(), LEe = (r, e, t) => {
        if (e === void 0) return r;
        let i = Date.now(),
          n = () => Date.now() - i >= e;
        return new Promise((s, o) => {
          let a = setTimeout(() => {
            n() && (o(new lE), t.abort())
          }, e),
            c = u => h => {
              if (clearTimeout(a), n()) {
                o(new lE);
                return
              }
              u(h)
            };
          r.then(c(s), c(o))
        })
      }, FEe = {
        throwHttpErrors: !0,
        credentials: "same-origin"
      }, Kn = class {
        constructor(e = {}) {
          this.opts = wC(FEe, e)
        }
        async fetch(e, t = {}) {
          let i = wC(this.opts, t),
            n = new MEe(i.headers);
          if (typeof e != "string" && !(e instanceof _C || e instanceof qEe)) throw new TypeError("`resource` must be a string, URL, or Request");
          let s = new _C(e.toString(), i.base),
            {
              searchParams: o,
              transformSearchParams: a,
              json: c
            } = i;
          o && (typeof a == "function" ? s.search = a(new EC(i.searchParams)) : s.search = new EC(i.searchParams)), c && (i.body = JSON.stringify(i.json), n.set("content-type", "application/json"));
          let u = new BEe,
            f = DEe([u.signal, i.signal]),
            h = await LEe(NEe(s.toString(), {
              ...i,
              signal: f,
              timeout: void 0,
              headers: n
            }), i.timeout, u);
          if (!h.ok && i.throwHttpErrors) throw i.handleError && await i.handleError(h), new vC(h);
          return h.iterator = function () {
            return SC(h.body)
          }, h.ndjson = async function* () {
            for await (let d of UEe(h.iterator())) t.transform ? yield t.transform(d) : yield d
          }, h
        }
        post(e, t = {}) {
          return this.fetch(e, {
            ...t,
            method: "POST"
          })
        }
        get(e, t = {}) {
          return this.fetch(e, {
            ...t,
            method: "GET"
          })
        }
        put(e, t = {}) {
          return this.fetch(e, {
            ...t,
            method: "PUT"
          })
        }
        delete(e, t = {}) {
          return this.fetch(e, {
            ...t,
            method: "DELETE"
          })
        }
        options(e, t = {}) {
          return this.fetch(e, {
            ...t,
            method: "OPTIONS"
          })
        }
      }, UEe = async function* (r) {
        let e = new TextDecoder,
          t = "";
        for await (let i of r) {
          t += e.decode(i, {
            stream: !0
          });
          let n = t.split(/\r?\n/);
          for (let s = 0; s < n.length - 1; s++) {
            let o = n[s].trim();
            o.length > 0 && (yield JSON.parse(o))
          }
          t = n[n.length - 1]
        }
        t += e.decode(), t = t.trim(), t.length !== 0 && (yield JSON.parse(t))
      }, SC = r => {
        if (jEe(r)) {
          let e = r[Symbol.asyncIterator]();
          return {
            [Symbol.asyncIterator]() {
              return {
                next: e.next.bind(e),
                return(t) {
                  return r.destroy(), typeof e.return == "function" ? e.return() : Promise.resolve({
                    done: !0,
                    value: t
                  })
                }
              }
            }
          }
        }
        if (zEe(r)) {
          let e = r.getReader();
          return async function* () {
            try {
              for (; ;) {
                let {
                  done: t,
                  value: i
                } = await e.read();
                if (t) return;
                i && (yield i)
              }
            } finally {
              e.releaseLock()
            }
          }()
        }
        if (KEe(r)) return r;
        throw new TypeError("Body can't be converted to AsyncIterable")
      }, KEe = r => typeof r == "object" && r !== null && typeof r[Symbol.asyncIterator] == "function", zEe = r => r && typeof r.getReader == "function", jEe = r => Object.prototype.hasOwnProperty.call(r, "readable") && Object.prototype.hasOwnProperty.call(r, "writable");
      Kn.HTTPError = vC;
      Kn.TimeoutError = lE;
      Kn.streamToAsyncIterator = SC;
      Kn.post = (r, e) => new Kn(e).post(r, e);
      Kn.get = (r, e) => new Kn(e).get(r, e);
      Kn.put = (r, e) => new Kn(e).put(r, e);
      Kn.delete = (r, e) => new Kn(e).delete(r, e);
      Kn.options = (r, e) => new Kn(e).options(r, e);
      mC.exports = Kn
    });
    var AC = y((cgt, xC) => {
      l();
      "use strict";
      var VEe = Mm(),
        GEe = (r, e) => ({
          path: decodeURIComponent(new URL(r).pathname.split("/").pop() || ""),
          content: HEe(r, e)
        });
      async function* HEe(r, e) {
        yield* (await new VEe().get(r, e)).iterator()
      }
      xC.exports = GEe
    });
    var TC = y((ugt, IC) => {
      l();
      "use strict";

      function $Ee(r) {
        if (r.length >= 255) throw new TypeError("Alphabet too long");
        for (var e = new Uint8Array(256), t = 0; t < e.length; t++) e[t] = 255;
        for (var i = 0; i < r.length; i++) {
          var n = r.charAt(i),
            s = n.charCodeAt(0);
          if (e[s] !== 255) throw new TypeError(n + " is ambiguous");
          e[s] = i
        }
        var o = r.length,
          a = r.charAt(0),
          c = Math.log(o) / Math.log(256),
          u = Math.log(256) / Math.log(o);

        function f(p) {
          if (p instanceof Uint8Array || (ArrayBuffer.isView(p) ? p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength) : Array.isArray(p) && (p = Uint8Array.from(p))), !(p instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
          if (p.length === 0) return "";
          for (var g = 0, m = 0, E = 0, w = p.length; E !== w && p[E] === 0;) E++, g++;
          for (var O = (w - E) * u + 1 >>> 0, q = new Uint8Array(O); E !== w;) {
            for (var J = p[E], Z = 0, H = O - 1;
              (J !== 0 || Z < m) && H !== -1; H--, Z++) J += 256 * q[H] >>> 0, q[H] = J % o >>> 0, J = J / o >>> 0;
            if (J !== 0) throw new Error("Non-zero carry");
            m = Z, E++
          }
          for (var te = O - m; te !== O && q[te] === 0;) te++;
          for (var ae = a.repeat(g); te < O; ++te) ae += r.charAt(q[te]);
          return ae
        }

        function h(p) {
          if (typeof p != "string") throw new TypeError("Expected String");
          if (p.length === 0) return new Uint8Array;
          var g = 0;
          if (p[g] !== " ") {
            for (var m = 0, E = 0; p[g] === a;) m++, g++;
            for (var w = (p.length - g) * c + 1 >>> 0, O = new Uint8Array(w); p[g];) {
              var q = e[p.charCodeAt(g)];
              if (q === 255) return;
              for (var J = 0, Z = w - 1;
                (q !== 0 || J < E) && Z !== -1; Z--, J++) q += o * O[Z] >>> 0, O[Z] = q % 256 >>> 0, q = q / 256 >>> 0;
              if (q !== 0) throw new Error("Non-zero carry");
              E = J, g++
            }
            if (p[g] !== " ") {
              for (var H = w - E; H !== w && O[H] === 0;) H++;
              for (var te = new Uint8Array(m + (w - H)), ae = m; H !== w;) te[ae++] = O[H++];
              return te
            }
          }
        }

        function d(p) {
          var g = h(p);
          if (g) return g;
          throw new Error("Non-base" + o + " character")
        }
        return {
          encode: f,
          decodeUnsafe: h,
          decode: d
        }
      }
      IC.exports = $Ee
    });
    var Bm = y((fgt, RC) => {
      l();
      "use strict";
      var WEe = new TextDecoder,
        YEe = r => WEe.decode(r),
        JEe = new TextEncoder,
        XEe = r => JEe.encode(r);

      function ZEe(r, e) {
        let t = new Uint8Array(e),
          i = 0;
        for (let n of r) t.set(n, i), i += n.length;
        return t
      }
      RC.exports = {
        decodeText: YEe,
        encodeText: XEe,
        concat: ZEe
      }
    });
    var CC = y((lgt, kC) => {
      l();
      "use strict";
      var {
        encodeText: QEe
      } = Bm(), PC = class {
        constructor(e, t, i, n) {
          this.name = e, this.code = t, this.codeBuf = QEe(this.code), this.alphabet = n, this.codec = i(n)
        }
        encode(e) {
          return this.codec.encode(e)
        }
        decode(e) {
          for (let t of e)
            if (this.alphabet && this.alphabet.indexOf(t) < 0) throw new Error(`invalid character '${t}' in '${e}'`);
          return this.codec.decode(e)
        }
      };
      kC.exports = PC
    });
    var NC = y((hgt, OC) => {
      l();
      "use strict";
      var eSe = (r, e, t) => {
        let i = {};
        for (let u = 0; u < e.length; ++u) i[e[u]] = u;
        let n = r.length;
        for (; r[n - 1] === "=";) --n;
        let s = new Uint8Array(n * t / 8 | 0),
          o = 0,
          a = 0,
          c = 0;
        for (let u = 0; u < n; ++u) {
          let f = i[r[u]];
          if (f === void 0) throw new SyntaxError("Invalid character " + r[u]);
          a = a << t | f, o += t, o >= 8 && (o -= 8, s[c++] = 255 & a >> o)
        }
        if (o >= t || 255 & a << 8 - o) throw new SyntaxError("Unexpected end of data");
        return s
      },
        tSe = (r, e, t) => {
          let i = e[e.length - 1] === "=",
            n = (1 << t) - 1,
            s = "",
            o = 0,
            a = 0;
          for (let c = 0; c < r.length; ++c)
            for (a = a << 8 | r[c], o += 8; o > t;) o -= t, s += e[n & a >> o];
          if (o && (s += e[n & a << t - o]), i)
            for (; s.length * t & 7;) s += "=";
          return s
        },
        rSe = r => e => ({
          encode(t) {
            return tSe(t, e, r)
          },
          decode(t) {
            return eSe(t, e, r)
          }
        });
      OC.exports = {
        rfc4648: rSe
      }
    });
    var DC = y((dgt, qC) => {
      l();
      "use strict";
      var P1 = TC(),
        iSe = CC(),
        {
          rfc4648: fn
        } = NC(),
        {
          decodeText: nSe,
          encodeText: sSe
        } = Bm(),
        oSe = () => ({
          encode: nSe,
          decode: sSe
        }),
        MC = [
          ["identity", "\0", oSe, ""],
          ["base2", "0", fn(1), "01"],
          ["base8", "7", fn(3), "01234567"],
          ["base10", "9", P1, "0123456789"],
          ["base16", "f", fn(4), "0123456789abcdef"],
          ["base16upper", "F", fn(4), "0123456789ABCDEF"],
          ["base32hex", "v", fn(5), "0123456789abcdefghijklmnopqrstuv"],
          ["base32hexupper", "V", fn(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
          ["base32hexpad", "t", fn(5), "0123456789abcdefghijklmnopqrstuv="],
          ["base32hexpadupper", "T", fn(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
          ["base32", "b", fn(5), "abcdefghijklmnopqrstuvwxyz234567"],
          ["base32upper", "B", fn(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
          ["base32pad", "c", fn(5), "abcdefghijklmnopqrstuvwxyz234567="],
          ["base32padupper", "C", fn(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
          ["base32z", "h", fn(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
          ["base36", "k", P1, "0123456789abcdefghijklmnopqrstuvwxyz"],
          ["base36upper", "K", P1, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
          ["base58btc", "z", P1, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
          ["base58flickr", "Z", P1, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
          ["base64", "m", fn(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
          ["base64pad", "M", fn(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
          ["base64url", "u", fn(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
          ["base64urlpad", "U", fn(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
        ],
        BC = MC.reduce((r, e) => (r[e[0]] = new iSe(e[0], e[1], e[2], e[3]), r), {}),
        aSe = MC.reduce((r, e) => (r[e[1]] = BC[e[0]], r), {});
      qC.exports = {
        names: BC,
        codes: aSe
      }
    });
    var ln = y((Mc, LC) => {
      l();
      "use strict";
      var td = DC(),
        {
          encodeText: cSe,
          decodeText: Dm,
          concat: FC
        } = Bm();

      function fSe(r, e) {
        if (!e) throw new Error("requires an encoded Uint8Array");
        let {
          name: t,
          codeBuf: i
        } = Qf(r);
        return uSe(t, e), FC([i, e], i.length + e.length)
      }

      function lSe(r, e) {
        let t = Qf(r),
          i = cSe(t.encode(e));
        return FC([t.codeBuf, i], t.codeBuf.length + i.length)
      }

      function hSe(r) {
        r instanceof Uint8Array && (r = Dm(r));
        let e = r[0];
        return ["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(e) && (r = r.toLowerCase()), Qf(r[0]).decode(r.substring(1))
      }

      function dSe(r) {
        if (r instanceof Uint8Array && (r = Dm(r)), Object.prototype.toString.call(r) !== "[object String]") return !1;
        try {
          return Qf(r[0]).name
        } catch (e) {
          return !1
        }
      }

      function uSe(r, e) {
        Qf(r).decode(Dm(e))
      }

      function Qf(r) {
        if (Object.prototype.hasOwnProperty.call(td.names, r)) return td.names[r];
        if (Object.prototype.hasOwnProperty.call(td.codes, r)) return td.codes[r];
        throw new Error(`Unsupported encoding: ${r}`)
      }

      function pSe(r) {
        return r instanceof Uint8Array && (r = Dm(r)), Qf(r[0])
      }
      Mc = LC.exports = fSe;
      Mc.encode = lSe;
      Mc.decode = hSe;
      Mc.isEncoded = dSe;
      Mc.encoding = Qf;
      Mc.encodingFromData = pSe;
      var ySe = Object.freeze(td.names),
        gSe = Object.freeze(td.codes);
      Mc.names = ySe;
      Mc.codes = gSe
    });
    var jC = y((pgt, UC) => {
      l();
      UC.exports = KC;
      var zC = 128,
        bSe = 127,
        mSe = ~bSe,
        vSe = Math.pow(2, 31);

      function KC(r, e, t) {
        e = e || [], t = t || 0;
        for (var i = t; r >= vSe;) e[t++] = r & 255 | zC, r /= 128;
        for (; r & mSe;) e[t++] = r & 255 | zC, r >>>= 7;
        return e[t] = r | 0, KC.bytes = t - i + 1, e
      }
    });
    var GC = y((ygt, VC) => {
      l();
      VC.exports = hE;
      var wSe = 128,
        HC = 127;

      function hE(r, e) {
        var t = 0,
          e = e || 0,
          i = 0,
          n = e,
          s, o = r.length;
        do {
          if (n >= o) throw hE.bytes = 0, new RangeError("Could not decode varint");
          s = r[n++], t += i < 28 ? (s & HC) << i : (s & HC) * Math.pow(2, i), i += 7
        } while (s >= wSe);
        return hE.bytes = n - e, t
      }
    });
    var WC = y((ggt, $C) => {
      l();
      var _Se = Math.pow(2, 7),
        ESe = Math.pow(2, 14),
        SSe = Math.pow(2, 21),
        xSe = Math.pow(2, 28),
        ASe = Math.pow(2, 35),
        ISe = Math.pow(2, 42),
        TSe = Math.pow(2, 49),
        RSe = Math.pow(2, 56),
        kSe = Math.pow(2, 63);
      $C.exports = function (r) {
        return r < _Se ? 1 : r < ESe ? 2 : r < SSe ? 3 : r < xSe ? 4 : r < ASe ? 5 : r < ISe ? 6 : r < TSe ? 7 : r < RSe ? 8 : r < kSe ? 9 : 10
      }
    });
    var JC = y((bgt, YC) => {
      l();
      YC.exports = {
        encode: jC(),
        decode: GC(),
        encodingLength: WC()
      }
    });
    var ZC = y((mgt, XC) => {
      l();
      "use strict";
      var PSe = Object.freeze({
        identity: 0,
        sha1: 17,
        "sha2-256": 18,
        "sha2-512": 19,
        "sha3-512": 20,
        "sha3-384": 21,
        "sha3-256": 22,
        "sha3-224": 23,
        "shake-128": 24,
        "shake-256": 25,
        "keccak-224": 26,
        "keccak-256": 27,
        "keccak-384": 28,
        "keccak-512": 29,
        blake3: 30,
        "murmur3-128": 34,
        "murmur3-32": 35,
        "dbl-sha2-256": 86,
        md4: 212,
        md5: 213,
        bmt: 214,
        "sha2-256-trunc254-padded": 4114,
        "ripemd-128": 4178,
        "ripemd-160": 4179,
        "ripemd-256": 4180,
        "ripemd-320": 4181,
        x11: 4352,
        kangarootwelve: 7425,
        "sm3-256": 21325,
        "blake2b-8": 45569,
        "blake2b-16": 45570,
        "blake2b-24": 45571,
        "blake2b-32": 45572,
        "blake2b-40": 45573,
        "blake2b-48": 45574,
        "blake2b-56": 45575,
        "blake2b-64": 45576,
        "blake2b-72": 45577,
        "blake2b-80": 45578,
        "blake2b-88": 45579,
        "blake2b-96": 45580,
        "blake2b-104": 45581,
        "blake2b-112": 45582,
        "blake2b-120": 45583,
        "blake2b-128": 45584,
        "blake2b-136": 45585,
        "blake2b-144": 45586,
        "blake2b-152": 45587,
        "blake2b-160": 45588,
        "blake2b-168": 45589,
        "blake2b-176": 45590,
        "blake2b-184": 45591,
        "blake2b-192": 45592,
        "blake2b-200": 45593,
        "blake2b-208": 45594,
        "blake2b-216": 45595,
        "blake2b-224": 45596,
        "blake2b-232": 45597,
        "blake2b-240": 45598,
        "blake2b-248": 45599,
        "blake2b-256": 45600,
        "blake2b-264": 45601,
        "blake2b-272": 45602,
        "blake2b-280": 45603,
        "blake2b-288": 45604,
        "blake2b-296": 45605,
        "blake2b-304": 45606,
        "blake2b-312": 45607,
        "blake2b-320": 45608,
        "blake2b-328": 45609,
        "blake2b-336": 45610,
        "blake2b-344": 45611,
        "blake2b-352": 45612,
        "blake2b-360": 45613,
        "blake2b-368": 45614,
        "blake2b-376": 45615,
        "blake2b-384": 45616,
        "blake2b-392": 45617,
        "blake2b-400": 45618,
        "blake2b-408": 45619,
        "blake2b-416": 45620,
        "blake2b-424": 45621,
        "blake2b-432": 45622,
        "blake2b-440": 45623,
        "blake2b-448": 45624,
        "blake2b-456": 45625,
        "blake2b-464": 45626,
        "blake2b-472": 45627,
        "blake2b-480": 45628,
        "blake2b-488": 45629,
        "blake2b-496": 45630,
        "blake2b-504": 45631,
        "blake2b-512": 45632,
        "blake2s-8": 45633,
        "blake2s-16": 45634,
        "blake2s-24": 45635,
        "blake2s-32": 45636,
        "blake2s-40": 45637,
        "blake2s-48": 45638,
        "blake2s-56": 45639,
        "blake2s-64": 45640,
        "blake2s-72": 45641,
        "blake2s-80": 45642,
        "blake2s-88": 45643,
        "blake2s-96": 45644,
        "blake2s-104": 45645,
        "blake2s-112": 45646,
        "blake2s-120": 45647,
        "blake2s-128": 45648,
        "blake2s-136": 45649,
        "blake2s-144": 45650,
        "blake2s-152": 45651,
        "blake2s-160": 45652,
        "blake2s-168": 45653,
        "blake2s-176": 45654,
        "blake2s-184": 45655,
        "blake2s-192": 45656,
        "blake2s-200": 45657,
        "blake2s-208": 45658,
        "blake2s-216": 45659,
        "blake2s-224": 45660,
        "blake2s-232": 45661,
        "blake2s-240": 45662,
        "blake2s-248": 45663,
        "blake2s-256": 45664,
        "skein256-8": 45825,
        "skein256-16": 45826,
        "skein256-24": 45827,
        "skein256-32": 45828,
        "skein256-40": 45829,
        "skein256-48": 45830,
        "skein256-56": 45831,
        "skein256-64": 45832,
        "skein256-72": 45833,
        "skein256-80": 45834,
        "skein256-88": 45835,
        "skein256-96": 45836,
        "skein256-104": 45837,
        "skein256-112": 45838,
        "skein256-120": 45839,
        "skein256-128": 45840,
        "skein256-136": 45841,
        "skein256-144": 45842,
        "skein256-152": 45843,
        "skein256-160": 45844,
        "skein256-168": 45845,
        "skein256-176": 45846,
        "skein256-184": 45847,
        "skein256-192": 45848,
        "skein256-200": 45849,
        "skein256-208": 45850,
        "skein256-216": 45851,
        "skein256-224": 45852,
        "skein256-232": 45853,
        "skein256-240": 45854,
        "skein256-248": 45855,
        "skein256-256": 45856,
        "skein512-8": 45857,
        "skein512-16": 45858,
        "skein512-24": 45859,
        "skein512-32": 45860,
        "skein512-40": 45861,
        "skein512-48": 45862,
        "skein512-56": 45863,
        "skein512-64": 45864,
        "skein512-72": 45865,
        "skein512-80": 45866,
        "skein512-88": 45867,
        "skein512-96": 45868,
        "skein512-104": 45869,
        "skein512-112": 45870,
        "skein512-120": 45871,
        "skein512-128": 45872,
        "skein512-136": 45873,
        "skein512-144": 45874,
        "skein512-152": 45875,
        "skein512-160": 45876,
        "skein512-168": 45877,
        "skein512-176": 45878,
        "skein512-184": 45879,
        "skein512-192": 45880,
        "skein512-200": 45881,
        "skein512-208": 45882,
        "skein512-216": 45883,
        "skein512-224": 45884,
        "skein512-232": 45885,
        "skein512-240": 45886,
        "skein512-248": 45887,
        "skein512-256": 45888,
        "skein512-264": 45889,
        "skein512-272": 45890,
        "skein512-280": 45891,
        "skein512-288": 45892,
        "skein512-296": 45893,
        "skein512-304": 45894,
        "skein512-312": 45895,
        "skein512-320": 45896,
        "skein512-328": 45897,
        "skein512-336": 45898,
        "skein512-344": 45899,
        "skein512-352": 45900,
        "skein512-360": 45901,
        "skein512-368": 45902,
        "skein512-376": 45903,
        "skein512-384": 45904,
        "skein512-392": 45905,
        "skein512-400": 45906,
        "skein512-408": 45907,
        "skein512-416": 45908,
        "skein512-424": 45909,
        "skein512-432": 45910,
        "skein512-440": 45911,
        "skein512-448": 45912,
        "skein512-456": 45913,
        "skein512-464": 45914,
        "skein512-472": 45915,
        "skein512-480": 45916,
        "skein512-488": 45917,
        "skein512-496": 45918,
        "skein512-504": 45919,
        "skein512-512": 45920,
        "skein1024-8": 45921,
        "skein1024-16": 45922,
        "skein1024-24": 45923,
        "skein1024-32": 45924,
        "skein1024-40": 45925,
        "skein1024-48": 45926,
        "skein1024-56": 45927,
        "skein1024-64": 45928,
        "skein1024-72": 45929,
        "skein1024-80": 45930,
        "skein1024-88": 45931,
        "skein1024-96": 45932,
        "skein1024-104": 45933,
        "skein1024-112": 45934,
        "skein1024-120": 45935,
        "skein1024-128": 45936,
        "skein1024-136": 45937,
        "skein1024-144": 45938,
        "skein1024-152": 45939,
        "skein1024-160": 45940,
        "skein1024-168": 45941,
        "skein1024-176": 45942,
        "skein1024-184": 45943,
        "skein1024-192": 45944,
        "skein1024-200": 45945,
        "skein1024-208": 45946,
        "skein1024-216": 45947,
        "skein1024-224": 45948,
        "skein1024-232": 45949,
        "skein1024-240": 45950,
        "skein1024-248": 45951,
        "skein1024-256": 45952,
        "skein1024-264": 45953,
        "skein1024-272": 45954,
        "skein1024-280": 45955,
        "skein1024-288": 45956,
        "skein1024-296": 45957,
        "skein1024-304": 45958,
        "skein1024-312": 45959,
        "skein1024-320": 45960,
        "skein1024-328": 45961,
        "skein1024-336": 45962,
        "skein1024-344": 45963,
        "skein1024-352": 45964,
        "skein1024-360": 45965,
        "skein1024-368": 45966,
        "skein1024-376": 45967,
        "skein1024-384": 45968,
        "skein1024-392": 45969,
        "skein1024-400": 45970,
        "skein1024-408": 45971,
        "skein1024-416": 45972,
        "skein1024-424": 45973,
        "skein1024-432": 45974,
        "skein1024-440": 45975,
        "skein1024-448": 45976,
        "skein1024-456": 45977,
        "skein1024-464": 45978,
        "skein1024-472": 45979,
        "skein1024-480": 45980,
        "skein1024-488": 45981,
        "skein1024-496": 45982,
        "skein1024-504": 45983,
        "skein1024-512": 45984,
        "skein1024-520": 45985,
        "skein1024-528": 45986,
        "skein1024-536": 45987,
        "skein1024-544": 45988,
        "skein1024-552": 45989,
        "skein1024-560": 45990,
        "skein1024-568": 45991,
        "skein1024-576": 45992,
        "skein1024-584": 45993,
        "skein1024-592": 45994,
        "skein1024-600": 45995,
        "skein1024-608": 45996,
        "skein1024-616": 45997,
        "skein1024-624": 45998,
        "skein1024-632": 45999,
        "skein1024-640": 46e3,
        "skein1024-648": 46001,
        "skein1024-656": 46002,
        "skein1024-664": 46003,
        "skein1024-672": 46004,
        "skein1024-680": 46005,
        "skein1024-688": 46006,
        "skein1024-696": 46007,
        "skein1024-704": 46008,
        "skein1024-712": 46009,
        "skein1024-720": 46010,
        "skein1024-728": 46011,
        "skein1024-736": 46012,
        "skein1024-744": 46013,
        "skein1024-752": 46014,
        "skein1024-760": 46015,
        "skein1024-768": 46016,
        "skein1024-776": 46017,
        "skein1024-784": 46018,
        "skein1024-792": 46019,
        "skein1024-800": 46020,
        "skein1024-808": 46021,
        "skein1024-816": 46022,
        "skein1024-824": 46023,
        "skein1024-832": 46024,
        "skein1024-840": 46025,
        "skein1024-848": 46026,
        "skein1024-856": 46027,
        "skein1024-864": 46028,
        "skein1024-872": 46029,
        "skein1024-880": 46030,
        "skein1024-888": 46031,
        "skein1024-896": 46032,
        "skein1024-904": 46033,
        "skein1024-912": 46034,
        "skein1024-920": 46035,
        "skein1024-928": 46036,
        "skein1024-936": 46037,
        "skein1024-944": 46038,
        "skein1024-952": 46039,
        "skein1024-960": 46040,
        "skein1024-968": 46041,
        "skein1024-976": 46042,
        "skein1024-984": 46043,
        "skein1024-992": 46044,
        "skein1024-1000": 46045,
        "skein1024-1008": 46046,
        "skein1024-1016": 46047,
        "skein1024-1024": 46048,
        "poseidon-bls12_381-a2-fc1": 46081,
        "poseidon-bls12_381-a2-fc1-sc": 46082
      });
      XC.exports = {
        names: PSe
      }
    });
    var ct = y((vgt, QC) => {
      l();
      "use strict";
      var {
        encoding: CSe
      } = ln(), OSe = new TextDecoder("utf8");

      function NSe(r) {
        let e = "";
        for (let t = 0; t < r.length; t++) e += String.fromCharCode(r[t]);
        return e
      }

      function qSe(r, e = "utf8") {
        return e === "utf8" || e === "utf-8" ? OSe.decode(r) : e === "ascii" ? NSe(r) : CSe(e).encode(r)
      }
      QC.exports = qSe
    });
    var gt = y((wgt, eO) => {
      l();
      "use strict";
      var {
        encoding: MSe
      } = ln(), BSe = new TextEncoder;

      function DSe(r) {
        let e = new Uint8Array(r.length);
        for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);
        return e
      }

      function LSe(r, e = "utf8") {
        return e === "utf8" || e === "utf-8" ? BSe.encode(r) : e === "ascii" ? DSe(r) : MSe(e).decode(r)
      }
      eO.exports = LSe
    });
    var xi = y((_gt, tO) => {
      l();
      "use strict";

      function FSe(r, e) {
        e || (e = r.reduce((n, s) => n + s.length, 0));
        let t = new Uint8Array(e),
          i = 0;
        for (let n of r) t.set(n, i), i += n.length;
        return t
      }
      tO.exports = FSe
    });
    var Do = y((Egt, rO) => {
      l();
      "use strict";
      var iO = ln(),
        rd = JC(),
        {
          names: C1
        } = ZC(),
        Lm = ct(),
        USe = gt(),
        KSe = xi(),
        id = {};
      for (let r in C1) {
        let e = r;
        id[C1[e]] = e
      }
      Object.freeze(id);

      function zSe(r) {
        if (!(r instanceof Uint8Array)) throw new Error("must be passed a Uint8Array");
        return Lm(r, "base16")
      }

      function jSe(r) {
        return USe(r, "base16")
      }

      function VSe(r) {
        if (!(r instanceof Uint8Array)) throw new Error("must be passed a Uint8Array");
        return Lm(iO.encode("base58btc", r)).slice(1)
      }

      function HSe(r) {
        let e = r instanceof Uint8Array ? Lm(r) : r;
        return iO.decode("z" + e)
      }

      function sO(r) {
        if (!(r instanceof Uint8Array)) throw new Error("multihash must be a Uint8Array");
        if (r.length < 2) throw new Error("multihash too short. must be > 2 bytes.");
        let e = rd.decode(r);
        if (!nO(e)) throw new Error(`multihash unknown function code: 0x${e.toString(16)}`);
        r = r.slice(rd.decode.bytes);
        let t = rd.decode(r);
        if (t < 0) throw new Error(`multihash invalid length: ${t}`);
        if (r = r.slice(rd.decode.bytes), r.length !== t) throw new Error(`multihash length inconsistent: 0x${Lm(r, "base16")}`);
        return {
          code: e,
          name: id[e],
          length: t,
          digest: r
        }
      }

      function GSe(r, e, t) {
        if (!r || e === void 0) throw new Error("multihash encode requires at least two args: digest, code");
        let i = oO(e);
        if (!(r instanceof Uint8Array)) throw new Error("digest should be a Uint8Array");
        if (t == null && (t = r.length), t && r.length !== t) throw new Error("digest length should be equal to specified length.");
        let n = rd.encode(i),
          s = rd.encode(t);
        return KSe([n, s, r], n.length + s.length + r.length)
      }

      function oO(r) {
        let e = r;
        if (typeof r == "string") {
          if (C1[r] === void 0) throw new Error(`Unrecognized hash function named: ${r}`);
          e = C1[r]
        }
        if (typeof e != "number") throw new Error(`Hash function code should be a number. Got: ${e}`);
        if (id[e] === void 0 && !dE(e)) throw new Error(`Unrecognized function code: ${e}`);
        return e
      }

      function dE(r) {
        return r > 0 && r < 16
      }

      function nO(r) {
        return !!(dE(r) || id[r])
      }

      function aO(r) {
        sO(r)
      }

      function $Se(r) {
        return aO(r), r.subarray(0, 2)
      }
      rO.exports = {
        names: C1,
        codes: id,
        toHexString: zSe,
        fromHexString: jSe,
        toB58String: VSe,
        fromB58String: HSe,
        decode: sO,
        encode: GSe,
        coerceCode: oO,
        isAppCode: dE,
        validate: aO,
        prefix: $Se,
        isValidCode: nO
      }
    });
    var lO = y((Sgt, cO) => {
      l();
      cO.exports = uO;
      var fO = 128,
        WSe = 127,
        YSe = ~WSe,
        JSe = Math.pow(2, 31);

      function uO(r, e, t) {
        e = e || [], t = t || 0;
        for (var i = t; r >= JSe;) e[t++] = r & 255 | fO, r /= 128;
        for (; r & YSe;) e[t++] = r & 255 | fO, r >>>= 7;
        return e[t] = r | 0, uO.bytes = t - i + 1, e
      }
    });
    var pO = y((xgt, hO) => {
      l();
      hO.exports = pE;
      var XSe = 128,
        dO = 127;

      function pE(r, e) {
        var t = 0,
          e = e || 0,
          i = 0,
          n = e,
          s, o = r.length;
        do {
          if (n >= o) throw pE.bytes = 0, new RangeError("Could not decode varint");
          s = r[n++], t += i < 28 ? (s & dO) << i : (s & dO) * Math.pow(2, i), i += 7
        } while (s >= XSe);
        return pE.bytes = n - e, t
      }
    });
    var gO = y((Agt, yO) => {
      l();
      var ZSe = Math.pow(2, 7),
        QSe = Math.pow(2, 14),
        e5e = Math.pow(2, 21),
        t5e = Math.pow(2, 28),
        r5e = Math.pow(2, 35),
        i5e = Math.pow(2, 42),
        n5e = Math.pow(2, 49),
        s5e = Math.pow(2, 56),
        o5e = Math.pow(2, 63);
      yO.exports = function (r) {
        return r < ZSe ? 1 : r < QSe ? 2 : r < e5e ? 3 : r < t5e ? 4 : r < r5e ? 5 : r < i5e ? 6 : r < n5e ? 7 : r < s5e ? 8 : r < o5e ? 9 : 10
      }
    });
    var yE = y((Igt, bO) => {
      l();
      bO.exports = {
        encode: lO(),
        decode: pO(),
        encodingLength: gO()
      }
    });
    var gE = y((Tgt, mO) => {
      l();
      "use strict";
      var vO = yE(),
        a5e = ct(),
        c5e = gt();
      mO.exports = {
        numberToUint8Array: u5e,
        uint8ArrayToNumber: wO,
        varintUint8ArrayEncode: f5e,
        varintEncode: l5e
      };

      function wO(r) {
        return parseInt(a5e(r, "base16"), 16)
      }

      function u5e(r) {
        let e = r.toString(16);
        return e.length % 2 == 1 && (e = "0" + e), c5e(e, "base16")
      }

      function f5e(r) {
        return Uint8Array.from(vO.encode(wO(r)))
      }

      function l5e(r) {
        return Uint8Array.from(vO.encode(r))
      }
    });
    var EO = y((Rgt, _O) => {
      l();
      "use strict";
      var h5e = Object.freeze({
        identity: 0,
        cidv1: 1,
        cidv2: 2,
        cidv3: 3,
        ip4: 4,
        tcp: 6,
        sha1: 17,
        "sha2-256": 18,
        "sha2-512": 19,
        "sha3-512": 20,
        "sha3-384": 21,
        "sha3-256": 22,
        "sha3-224": 23,
        "shake-128": 24,
        "shake-256": 25,
        "keccak-224": 26,
        "keccak-256": 27,
        "keccak-384": 28,
        "keccak-512": 29,
        blake3: 30,
        dccp: 33,
        "murmur3-128": 34,
        "murmur3-32": 35,
        ip6: 41,
        ip6zone: 42,
        path: 47,
        multicodec: 48,
        multihash: 49,
        multiaddr: 50,
        multibase: 51,
        dns: 53,
        dns4: 54,
        dns6: 55,
        dnsaddr: 56,
        protobuf: 80,
        cbor: 81,
        raw: 85,
        "dbl-sha2-256": 86,
        rlp: 96,
        bencode: 99,
        "dag-pb": 112,
        "dag-cbor": 113,
        "libp2p-key": 114,
        "git-raw": 120,
        "torrent-info": 123,
        "torrent-file": 124,
        "leofcoin-block": 129,
        "leofcoin-tx": 130,
        "leofcoin-pr": 131,
        sctp: 132,
        "dag-jose": 133,
        "dag-cose": 134,
        "eth-block": 144,
        "eth-block-list": 145,
        "eth-tx-trie": 146,
        "eth-tx": 147,
        "eth-tx-receipt-trie": 148,
        "eth-tx-receipt": 149,
        "eth-state-trie": 150,
        "eth-account-snapshot": 151,
        "eth-storage-trie": 152,
        "bitcoin-block": 176,
        "bitcoin-tx": 177,
        "bitcoin-witness-commitment": 178,
        "zcash-block": 192,
        "zcash-tx": 193,
        docid: 206,
        "stellar-block": 208,
        "stellar-tx": 209,
        md4: 212,
        md5: 213,
        bmt: 214,
        "decred-block": 224,
        "decred-tx": 225,
        "ipld-ns": 226,
        "ipfs-ns": 227,
        "swarm-ns": 228,
        "ipns-ns": 229,
        zeronet: 230,
        "secp256k1-pub": 231,
        "bls12_381-g1-pub": 234,
        "bls12_381-g2-pub": 235,
        "x25519-pub": 236,
        "ed25519-pub": 237,
        "bls12_381-g1g2-pub": 238,
        "dash-block": 240,
        "dash-tx": 241,
        "swarm-manifest": 250,
        "swarm-feed": 251,
        udp: 273,
        "p2p-webrtc-star": 275,
        "p2p-webrtc-direct": 276,
        "p2p-stardust": 277,
        "p2p-circuit": 290,
        "dag-json": 297,
        udt: 301,
        utp: 302,
        unix: 400,
        thread: 406,
        p2p: 421,
        ipfs: 421,
        https: 443,
        onion: 444,
        onion3: 445,
        garlic64: 446,
        garlic32: 447,
        tls: 448,
        quic: 460,
        ws: 477,
        wss: 478,
        "p2p-websocket-star": 479,
        http: 480,
        json: 512,
        messagepack: 513,
        "libp2p-peer-record": 769,
        "sha2-256-trunc254-padded": 4114,
        "ripemd-128": 4178,
        "ripemd-160": 4179,
        "ripemd-256": 4180,
        "ripemd-320": 4181,
        x11: 4352,
        "p256-pub": 4608,
        "p384-pub": 4609,
        "p521-pub": 4610,
        "ed448-pub": 4611,
        "x448-pub": 4612,
        "ed25519-priv": 4864,
        kangarootwelve: 7425,
        "sm3-256": 21325,
        "blake2b-8": 45569,
        "blake2b-16": 45570,
        "blake2b-24": 45571,
        "blake2b-32": 45572,
        "blake2b-40": 45573,
        "blake2b-48": 45574,
        "blake2b-56": 45575,
        "blake2b-64": 45576,
        "blake2b-72": 45577,
        "blake2b-80": 45578,
        "blake2b-88": 45579,
        "blake2b-96": 45580,
        "blake2b-104": 45581,
        "blake2b-112": 45582,
        "blake2b-120": 45583,
        "blake2b-128": 45584,
        "blake2b-136": 45585,
        "blake2b-144": 45586,
        "blake2b-152": 45587,
        "blake2b-160": 45588,
        "blake2b-168": 45589,
        "blake2b-176": 45590,
        "blake2b-184": 45591,
        "blake2b-192": 45592,
        "blake2b-200": 45593,
        "blake2b-208": 45594,
        "blake2b-216": 45595,
        "blake2b-224": 45596,
        "blake2b-232": 45597,
        "blake2b-240": 45598,
        "blake2b-248": 45599,
        "blake2b-256": 45600,
        "blake2b-264": 45601,
        "blake2b-272": 45602,
        "blake2b-280": 45603,
        "blake2b-288": 45604,
        "blake2b-296": 45605,
        "blake2b-304": 45606,
        "blake2b-312": 45607,
        "blake2b-320": 45608,
        "blake2b-328": 45609,
        "blake2b-336": 45610,
        "blake2b-344": 45611,
        "blake2b-352": 45612,
        "blake2b-360": 45613,
        "blake2b-368": 45614,
        "blake2b-376": 45615,
        "blake2b-384": 45616,
        "blake2b-392": 45617,
        "blake2b-400": 45618,
        "blake2b-408": 45619,
        "blake2b-416": 45620,
        "blake2b-424": 45621,
        "blake2b-432": 45622,
        "blake2b-440": 45623,
        "blake2b-448": 45624,
        "blake2b-456": 45625,
        "blake2b-464": 45626,
        "blake2b-472": 45627,
        "blake2b-480": 45628,
        "blake2b-488": 45629,
        "blake2b-496": 45630,
        "blake2b-504": 45631,
        "blake2b-512": 45632,
        "blake2s-8": 45633,
        "blake2s-16": 45634,
        "blake2s-24": 45635,
        "blake2s-32": 45636,
        "blake2s-40": 45637,
        "blake2s-48": 45638,
        "blake2s-56": 45639,
        "blake2s-64": 45640,
        "blake2s-72": 45641,
        "blake2s-80": 45642,
        "blake2s-88": 45643,
        "blake2s-96": 45644,
        "blake2s-104": 45645,
        "blake2s-112": 45646,
        "blake2s-120": 45647,
        "blake2s-128": 45648,
        "blake2s-136": 45649,
        "blake2s-144": 45650,
        "blake2s-152": 45651,
        "blake2s-160": 45652,
        "blake2s-168": 45653,
        "blake2s-176": 45654,
        "blake2s-184": 45655,
        "blake2s-192": 45656,
        "blake2s-200": 45657,
        "blake2s-208": 45658,
        "blake2s-216": 45659,
        "blake2s-224": 45660,
        "blake2s-232": 45661,
        "blake2s-240": 45662,
        "blake2s-248": 45663,
        "blake2s-256": 45664,
        "skein256-8": 45825,
        "skein256-16": 45826,
        "skein256-24": 45827,
        "skein256-32": 45828,
        "skein256-40": 45829,
        "skein256-48": 45830,
        "skein256-56": 45831,
        "skein256-64": 45832,
        "skein256-72": 45833,
        "skein256-80": 45834,
        "skein256-88": 45835,
        "skein256-96": 45836,
        "skein256-104": 45837,
        "skein256-112": 45838,
        "skein256-120": 45839,
        "skein256-128": 45840,
        "skein256-136": 45841,
        "skein256-144": 45842,
        "skein256-152": 45843,
        "skein256-160": 45844,
        "skein256-168": 45845,
        "skein256-176": 45846,
        "skein256-184": 45847,
        "skein256-192": 45848,
        "skein256-200": 45849,
        "skein256-208": 45850,
        "skein256-216": 45851,
        "skein256-224": 45852,
        "skein256-232": 45853,
        "skein256-240": 45854,
        "skein256-248": 45855,
        "skein256-256": 45856,
        "skein512-8": 45857,
        "skein512-16": 45858,
        "skein512-24": 45859,
        "skein512-32": 45860,
        "skein512-40": 45861,
        "skein512-48": 45862,
        "skein512-56": 45863,
        "skein512-64": 45864,
        "skein512-72": 45865,
        "skein512-80": 45866,
        "skein512-88": 45867,
        "skein512-96": 45868,
        "skein512-104": 45869,
        "skein512-112": 45870,
        "skein512-120": 45871,
        "skein512-128": 45872,
        "skein512-136": 45873,
        "skein512-144": 45874,
        "skein512-152": 45875,
        "skein512-160": 45876,
        "skein512-168": 45877,
        "skein512-176": 45878,
        "skein512-184": 45879,
        "skein512-192": 45880,
        "skein512-200": 45881,
        "skein512-208": 45882,
        "skein512-216": 45883,
        "skein512-224": 45884,
        "skein512-232": 45885,
        "skein512-240": 45886,
        "skein512-248": 45887,
        "skein512-256": 45888,
        "skein512-264": 45889,
        "skein512-272": 45890,
        "skein512-280": 45891,
        "skein512-288": 45892,
        "skein512-296": 45893,
        "skein512-304": 45894,
        "skein512-312": 45895,
        "skein512-320": 45896,
        "skein512-328": 45897,
        "skein512-336": 45898,
        "skein512-344": 45899,
        "skein512-352": 45900,
        "skein512-360": 45901,
        "skein512-368": 45902,
        "skein512-376": 45903,
        "skein512-384": 45904,
        "skein512-392": 45905,
        "skein512-400": 45906,
        "skein512-408": 45907,
        "skein512-416": 45908,
        "skein512-424": 45909,
        "skein512-432": 45910,
        "skein512-440": 45911,
        "skein512-448": 45912,
        "skein512-456": 45913,
        "skein512-464": 45914,
        "skein512-472": 45915,
        "skein512-480": 45916,
        "skein512-488": 45917,
        "skein512-496": 45918,
        "skein512-504": 45919,
        "skein512-512": 45920,
        "skein1024-8": 45921,
        "skein1024-16": 45922,
        "skein1024-24": 45923,
        "skein1024-32": 45924,
        "skein1024-40": 45925,
        "skein1024-48": 45926,
        "skein1024-56": 45927,
        "skein1024-64": 45928,
        "skein1024-72": 45929,
        "skein1024-80": 45930,
        "skein1024-88": 45931,
        "skein1024-96": 45932,
        "skein1024-104": 45933,
        "skein1024-112": 45934,
        "skein1024-120": 45935,
        "skein1024-128": 45936,
        "skein1024-136": 45937,
        "skein1024-144": 45938,
        "skein1024-152": 45939,
        "skein1024-160": 45940,
        "skein1024-168": 45941,
        "skein1024-176": 45942,
        "skein1024-184": 45943,
        "skein1024-192": 45944,
        "skein1024-200": 45945,
        "skein1024-208": 45946,
        "skein1024-216": 45947,
        "skein1024-224": 45948,
        "skein1024-232": 45949,
        "skein1024-240": 45950,
        "skein1024-248": 45951,
        "skein1024-256": 45952,
        "skein1024-264": 45953,
        "skein1024-272": 45954,
        "skein1024-280": 45955,
        "skein1024-288": 45956,
        "skein1024-296": 45957,
        "skein1024-304": 45958,
        "skein1024-312": 45959,
        "skein1024-320": 45960,
        "skein1024-328": 45961,
        "skein1024-336": 45962,
        "skein1024-344": 45963,
        "skein1024-352": 45964,
        "skein1024-360": 45965,
        "skein1024-368": 45966,
        "skein1024-376": 45967,
        "skein1024-384": 45968,
        "skein1024-392": 45969,
        "skein1024-400": 45970,
        "skein1024-408": 45971,
        "skein1024-416": 45972,
        "skein1024-424": 45973,
        "skein1024-432": 45974,
        "skein1024-440": 45975,
        "skein1024-448": 45976,
        "skein1024-456": 45977,
        "skein1024-464": 45978,
        "skein1024-472": 45979,
        "skein1024-480": 45980,
        "skein1024-488": 45981,
        "skein1024-496": 45982,
        "skein1024-504": 45983,
        "skein1024-512": 45984,
        "skein1024-520": 45985,
        "skein1024-528": 45986,
        "skein1024-536": 45987,
        "skein1024-544": 45988,
        "skein1024-552": 45989,
        "skein1024-560": 45990,
        "skein1024-568": 45991,
        "skein1024-576": 45992,
        "skein1024-584": 45993,
        "skein1024-592": 45994,
        "skein1024-600": 45995,
        "skein1024-608": 45996,
        "skein1024-616": 45997,
        "skein1024-624": 45998,
        "skein1024-632": 45999,
        "skein1024-640": 46e3,
        "skein1024-648": 46001,
        "skein1024-656": 46002,
        "skein1024-664": 46003,
        "skein1024-672": 46004,
        "skein1024-680": 46005,
        "skein1024-688": 46006,
        "skein1024-696": 46007,
        "skein1024-704": 46008,
        "skein1024-712": 46009,
        "skein1024-720": 46010,
        "skein1024-728": 46011,
        "skein1024-736": 46012,
        "skein1024-744": 46013,
        "skein1024-752": 46014,
        "skein1024-760": 46015,
        "skein1024-768": 46016,
        "skein1024-776": 46017,
        "skein1024-784": 46018,
        "skein1024-792": 46019,
        "skein1024-800": 46020,
        "skein1024-808": 46021,
        "skein1024-816": 46022,
        "skein1024-824": 46023,
        "skein1024-832": 46024,
        "skein1024-840": 46025,
        "skein1024-848": 46026,
        "skein1024-856": 46027,
        "skein1024-864": 46028,
        "skein1024-872": 46029,
        "skein1024-880": 46030,
        "skein1024-888": 46031,
        "skein1024-896": 46032,
        "skein1024-904": 46033,
        "skein1024-912": 46034,
        "skein1024-920": 46035,
        "skein1024-928": 46036,
        "skein1024-936": 46037,
        "skein1024-944": 46038,
        "skein1024-952": 46039,
        "skein1024-960": 46040,
        "skein1024-968": 46041,
        "skein1024-976": 46042,
        "skein1024-984": 46043,
        "skein1024-992": 46044,
        "skein1024-1000": 46045,
        "skein1024-1008": 46046,
        "skein1024-1016": 46047,
        "skein1024-1024": 46048,
        "poseidon-bls12_381-a2-fc1": 46081,
        "poseidon-bls12_381-a2-fc1-sc": 46082,
        "zeroxcert-imprint-256": 52753,
        "fil-commitment-unsealed": 61697,
        "fil-commitment-sealed": 61698,
        "holochain-adr-v0": 8417572,
        "holochain-adr-v1": 8483108,
        "holochain-key-v0": 9728292,
        "holochain-key-v1": 9793828,
        "holochain-sig-v0": 10645796,
        "holochain-sig-v1": 10711332,
        "skynet-ns": 11639056
      });
      _O.exports = {
        baseTable: h5e
      }
    });
    var xO = y((kgt, SO) => {
      l();
      "use strict";
      var {
        baseTable: bE
      } = EO(), d5e = gE().varintEncode, mE = {}, vE = {}, Fm = {};
      for (let r in bE) {
        let e = r,
          t = bE[e];
        mE[e] = d5e(t);
        let i = e.toUpperCase().replace(/-/g, "_");
        vE[i] = t, Fm[t] || (Fm[t] = e)
      }
      Object.freeze(mE);
      Object.freeze(vE);
      Object.freeze(Fm);
      var p5e = Object.freeze(bE);
      SO.exports = {
        nameToVarint: mE,
        constantToCode: vE,
        nameToCode: p5e,
        codeToName: Fm
      }
    });
    var Jr = y((Pgt, AO) => {
      l();
      "use strict";
      var Um = yE(),
        y5e = xi(),
        IO = gE(),
        {
          nameToVarint: Km,
          constantToCode: g5e,
          nameToCode: TO,
          codeToName: wE
        } = xO();

      function b5e(r, e) {
        let t;
        if (r instanceof Uint8Array) t = IO.varintUint8ArrayEncode(r);
        else if (Km[r]) t = Km[r];
        else throw new Error("multicodec not recognized");
        return y5e([t, e], t.length + e.length)
      }

      function m5e(r) {
        return Um.decode(r), r.slice(Um.decode.bytes)
      }

      function RO(r) {
        let e = Um.decode(r),
          t = wE[e];
        if (t === void 0) throw new Error(`Code "${e}" not found`);
        return t
      }

      function kO(r) {
        return wE[r]
      }

      function PO(r) {
        let e = TO[r];
        if (e === void 0) throw new Error(`Codec "${r}" not found`);
        return e
      }

      function CO(r) {
        return Um.decode(r)
      }

      function OO(r) {
        let e = Km[r];
        if (e === void 0) throw new Error(`Codec "${r}" not found`);
        return e
      }

      function NO(r) {
        return IO.varintEncode(r)
      }

      function v5e(r) {
        return RO(r)
      }

      function w5e(r) {
        return kO(r)
      }

      function _5e(r) {
        return PO(r)
      }

      function E5e(r) {
        return CO(r)
      }

      function S5e(r) {
        return OO(r)
      }

      function x5e(r) {
        return Array.from(NO(r))
      }
      AO.exports = {
        addPrefix: b5e,
        rmPrefix: m5e,
        getNameFromData: RO,
        getNameFromCode: kO,
        getCodeFromName: PO,
        getCodeFromData: CO,
        getVarintFromName: OO,
        getVarintFromCode: NO,
        getCodec: v5e,
        getName: w5e,
        getNumber: _5e,
        getCode: E5e,
        getCodeVarint: S5e,
        getVarint: x5e,
        ...g5e,
        nameToVarint: Km,
        nameToCode: TO,
        codeToName: wE
      }
    });
    var MO = y((Cgt, qO) => {
      l();
      "use strict";
      var A5e = Do(),
        I5e = {
          checkCIDComponents: function (r) {
            if (r == null) return "null values are not valid CIDs";
            if (!(r.version === 0 || r.version === 1)) return "Invalid version, must be a number equal to 1 or 0";
            if (typeof r.codec != "string") return "codec must be string";
            if (r.version === 0) {
              if (r.codec !== "dag-pb") return "codec must be 'dag-pb' for CIDv0";
              if (r.multibaseName !== "base58btc") return "multibaseName must be 'base58btc' for CIDv0"
            }
            if (!(r.multihash instanceof Uint8Array)) return "multihash must be a Uint8Array";
            try {
              A5e.validate(r.multihash)
            } catch (e) {
              let t = e.message;
              return t || (t = "Multihash validation failed"), t
            }
          }
        };
      qO.exports = I5e
    });
    var Lr = y((Ogt, BO) => {
      l();
      "use strict";

      function T5e(r, e) {
        if (r === e) return !0;
        if (r.byteLength !== e.byteLength) return !1;
        for (let t = 0; t < r.byteLength; t++)
          if (r[t] !== e[t]) return !1;
        return !0
      }
      BO.exports = T5e
    });
    var at = y((Ngt, DO) => {
      l();
      "use strict";
      var zm = Do(),
        _E = ln(),
        el = Jr(),
        R5e = MO(),
        LO = xi(),
        k5e = ct(),
        P5e = Lr(),
        jm = el.nameToCode,
        C5e = Object.keys(jm).reduce((r, e) => (r[jm[e]] = e, r), {}),
        FO = Symbol.for("@ipld/js-cid/CID"),
        Lo = class {
          constructor(e, t, i, n) {
            if (this.version, this.codec, this.multihash, Object.defineProperty(this, FO, {
              value: !0
            }), Lo.isCID(e)) {
              let s = e;
              this.version = s.version, this.codec = s.codec, this.multihash = s.multihash, this.multibaseName = s.multibaseName || (s.version === 0 ? "base58btc" : "base32");
              return
            }
            if (typeof e == "string") {
              let s = _E.isEncoded(e);
              if (s) {
                let o = _E.decode(e);
                this.version = parseInt(o[0].toString(), 16), this.codec = el.getCodec(o.slice(1)), this.multihash = el.rmPrefix(o.slice(1)), this.multibaseName = s
              } else this.version = 0, this.codec = "dag-pb", this.multihash = zm.fromB58String(e), this.multibaseName = "base58btc";
              Lo.validateCID(this), Object.defineProperty(this, "string", {
                value: e
              });
              return
            }
            if (e instanceof Uint8Array) {
              let s = parseInt(e[0].toString(), 16);
              if (s === 1) {
                let o = e;
                this.version = s, this.codec = el.getCodec(o.slice(1)), this.multihash = el.rmPrefix(o.slice(1)), this.multibaseName = "base32"
              } else this.version = 0, this.codec = "dag-pb", this.multihash = e, this.multibaseName = "base58btc";
              Lo.validateCID(this);
              return
            }
            this.version = e, typeof t == "number" && (t = C5e[t]), this.codec = t, this.multihash = i, this.multibaseName = n || (e === 0 ? "base58btc" : "base32"), Lo.validateCID(this)
          }
          get bytes() {
            let e = this._bytes;
            if (!e) {
              if (this.version === 0) e = this.multihash;
              else if (this.version === 1) {
                let t = el.getCodeVarint(this.codec);
                e = LO([
                  [1], t, this.multihash
                ], 1 + t.byteLength + this.multihash.byteLength)
              } else throw new Error("unsupported version");
              Object.defineProperty(this, "_bytes", {
                value: e
              })
            }
            return e
          }
          get prefix() {
            let e = el.getCodeVarint(this.codec),
              t = zm.prefix(this.multihash);
            return LO([
              [this.version], e, t
            ], 1 + e.byteLength + t.byteLength)
          }
          get code() {
            return jm[this.codec]
          }
          toV0() {
            if (this.codec !== "dag-pb") throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            let {
              name: e,
              length: t
            } = zm.decode(this.multihash);
            if (e !== "sha2-256") throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            if (t !== 32) throw new Error("Cannot convert non 32 byte multihash CID to CIDv0");
            return new Lo(0, this.codec, this.multihash)
          }
          toV1() {
            return new Lo(1, this.codec, this.multihash)
          }
          toBaseEncodedString(e = this.multibaseName) {
            if (this.string && this.string.length !== 0 && e === this.multibaseName) return this.string;
            let t;
            if (this.version === 0) {
              if (e !== "base58btc") throw new Error("not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()");
              t = zm.toB58String(this.multihash)
            } else if (this.version === 1) t = k5e(_E.encode(e, this.bytes));
            else throw new Error("unsupported version");
            return e === this.multibaseName && Object.defineProperty(this, "string", {
              value: t
            }), t
          } [Symbol.for("nodejs.util.inspect.custom")]() {
            return "CID(" + this.toString() + ")"
          }
          toString(e) {
            return this.toBaseEncodedString(e)
          }
          toJSON() {
            return {
              codec: this.codec,
              version: this.version,
              hash: this.multihash
            }
          }
          equals(e) {
            return this.codec === e.codec && this.version === e.version && P5e(this.multihash, e.multihash)
          }
          static validateCID(e) {
            let t = R5e.checkCIDComponents(e);
            if (t) throw new Error(t)
          }
          static isCID(e) {
            return e instanceof Lo || Boolean(e && e[FO])
          }
        };
      Lo.codecs = jm;
      DO.exports = Lo
    });
    var KO = y((qgt, UO) => {
      l();
      "use strict";
      UO.exports = O5e;

      function O5e(r, e) {
        for (var t = new Array(arguments.length - 1), i = 0, n = 2, s = !0; n < arguments.length;) t[i++] = arguments[n++];
        return new Promise(function (a, c) {
          t[i] = function (f) {
            if (s)
              if (s = !1, f) c(f);
              else {
                for (var h = new Array(arguments.length - 1), d = 0; d < h.length;) h[d++] = arguments[d];
                a.apply(null, h)
              }
          };
          try {
            r.apply(e || null, t)
          } catch (u) {
            s && (s = !1, c(u))
          }
        })
      }
    });
    var HO = y(zO => {
      l();
      "use strict";
      var Vm = zO;
      Vm.length = function (e) {
        var t = e.length;
        if (!t) return 0;
        for (var i = 0; --t % 4 > 1 && e.charAt(t) === "=";) ++i;
        return Math.ceil(e.length * 3) / 4 - i
      };
      var nd = new Array(64),
        jO = new Array(123);
      for (var Ta = 0; Ta < 64;) jO[nd[Ta] = Ta < 26 ? Ta + 65 : Ta < 52 ? Ta + 71 : Ta < 62 ? Ta - 4 : Ta - 59 | 43] = Ta++;
      Vm.encode = function (e, t, i) {
        for (var n = null, s = [], o = 0, a = 0, c; t < i;) {
          var u = e[t++];
          switch (a) {
            case 0:
              s[o++] = nd[u >> 2], c = (u & 3) << 4, a = 1;
              break;
            case 1:
              s[o++] = nd[c | u >> 4], c = (u & 15) << 2, a = 2;
              break;
            case 2:
              s[o++] = nd[c | u >> 6], s[o++] = nd[u & 63], a = 0;
              break
          }
          o > 8191 && ((n || (n = [])).push(String.fromCharCode.apply(String, s)), o = 0)
        }
        return a && (s[o++] = nd[c], s[o++] = 61, a === 1 && (s[o++] = 61)), n ? (o && n.push(String.fromCharCode.apply(String, s.slice(0, o))), n.join("")) : String.fromCharCode.apply(String, s.slice(0, o))
      };
      var VO = "invalid encoding";
      Vm.decode = function (e, t, i) {
        for (var n = i, s = 0, o, a = 0; a < e.length;) {
          var c = e.charCodeAt(a++);
          if (c === 61 && s > 1) break;
          if ((c = jO[c]) === void 0) throw Error(VO);
          switch (s) {
            case 0:
              o = c, s = 1;
              break;
            case 1:
              t[i++] = o << 2 | (c & 48) >> 4, o = c, s = 2;
              break;
            case 2:
              t[i++] = (o & 15) << 4 | (c & 60) >> 2, o = c, s = 3;
              break;
            case 3:
              t[i++] = (o & 3) << 6 | c, s = 0;
              break
          }
        }
        if (s === 1) throw Error(VO);
        return i - n
      };
      Vm.test = function (e) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)
      }
    });
    var $O = y((Bgt, GO) => {
      l();
      "use strict";
      GO.exports = Hm;

      function Hm() {
        this._listeners = {}
      }
      Hm.prototype.on = function (e, t, i) {
        return (this._listeners[e] || (this._listeners[e] = [])).push({
          fn: t,
          ctx: i || this
        }), this
      };
      Hm.prototype.off = function (e, t) {
        if (e === void 0) this._listeners = {};
        else if (t === void 0) this._listeners[e] = [];
        else
          for (var i = this._listeners[e], n = 0; n < i.length;) i[n].fn === t ? i.splice(n, 1) : ++n;
        return this
      };
      Hm.prototype.emit = function (e) {
        var t = this._listeners[e];
        if (t) {
          for (var i = [], n = 1; n < arguments.length;) i.push(arguments[n++]);
          for (n = 0; n < t.length;) t[n].fn.apply(t[n++].ctx, i)
        }
        return this
      }
    });
    var eN = y((Dgt, WO) => {
      l();
      "use strict";
      WO.exports = YO(YO);

      function YO(r) {
        return typeof Float32Array != "undefined" ? function () {
          var e = new Float32Array([-0]),
            t = new Uint8Array(e.buffer),
            i = t[3] === 128;

          function n(c, u, f) {
            e[0] = c, u[f] = t[0], u[f + 1] = t[1], u[f + 2] = t[2], u[f + 3] = t[3]
          }

          function s(c, u, f) {
            e[0] = c, u[f] = t[3], u[f + 1] = t[2], u[f + 2] = t[1], u[f + 3] = t[0]
          }
          r.writeFloatLE = i ? n : s, r.writeFloatBE = i ? s : n;

          function o(c, u) {
            return t[0] = c[u], t[1] = c[u + 1], t[2] = c[u + 2], t[3] = c[u + 3], e[0]
          }

          function a(c, u) {
            return t[3] = c[u], t[2] = c[u + 1], t[1] = c[u + 2], t[0] = c[u + 3], e[0]
          }
          r.readFloatLE = i ? o : a, r.readFloatBE = i ? a : o
        }() : function () {
          function e(i, n, s, o) {
            var a = n < 0 ? 1 : 0;
            if (a && (n = -n), n === 0) i(1 / n > 0 ? 0 : 2147483648, s, o);
            else if (isNaN(n)) i(2143289344, s, o);
            else if (n > 34028234663852886e22) i((a << 31 | 2139095040) >>> 0, s, o);
            else if (n < 11754943508222875e-54) i((a << 31 | Math.round(n / 1401298464324817e-60)) >>> 0, s, o);
            else {
              var c = Math.floor(Math.log(n) / Math.LN2),
                u = Math.round(n * Math.pow(2, -c) * 8388608) & 8388607;
              i((a << 31 | c + 127 << 23 | u) >>> 0, s, o)
            }
          }
          r.writeFloatLE = e.bind(null, JO), r.writeFloatBE = e.bind(null, XO);

          function t(i, n, s) {
            var o = i(n, s),
              a = (o >> 31) * 2 + 1,
              c = o >>> 23 & 255,
              u = o & 8388607;
            return c === 255 ? u ? NaN : a * Infinity : c === 0 ? a * 1401298464324817e-60 * u : a * Math.pow(2, c - 150) * (u + 8388608)
          }
          r.readFloatLE = t.bind(null, ZO), r.readFloatBE = t.bind(null, QO)
        }(), typeof Float64Array != "undefined" ? function () {
          var e = new Float64Array([-0]),
            t = new Uint8Array(e.buffer),
            i = t[7] === 128;

          function n(c, u, f) {
            e[0] = c, u[f] = t[0], u[f + 1] = t[1], u[f + 2] = t[2], u[f + 3] = t[3], u[f + 4] = t[4], u[f + 5] = t[5], u[f + 6] = t[6], u[f + 7] = t[7]
          }

          function s(c, u, f) {
            e[0] = c, u[f] = t[7], u[f + 1] = t[6], u[f + 2] = t[5], u[f + 3] = t[4], u[f + 4] = t[3], u[f + 5] = t[2], u[f + 6] = t[1], u[f + 7] = t[0]
          }
          r.writeDoubleLE = i ? n : s, r.writeDoubleBE = i ? s : n;

          function o(c, u) {
            return t[0] = c[u], t[1] = c[u + 1], t[2] = c[u + 2], t[3] = c[u + 3], t[4] = c[u + 4], t[5] = c[u + 5], t[6] = c[u + 6], t[7] = c[u + 7], e[0]
          }

          function a(c, u) {
            return t[7] = c[u], t[6] = c[u + 1], t[5] = c[u + 2], t[4] = c[u + 3], t[3] = c[u + 4], t[2] = c[u + 5], t[1] = c[u + 6], t[0] = c[u + 7], e[0]
          }
          r.readDoubleLE = i ? o : a, r.readDoubleBE = i ? a : o
        }() : function () {
          function e(i, n, s, o, a, c) {
            var u = o < 0 ? 1 : 0;
            if (u && (o = -o), o === 0) i(0, a, c + n), i(1 / o > 0 ? 0 : 2147483648, a, c + s);
            else if (isNaN(o)) i(0, a, c + n), i(2146959360, a, c + s);
            else if (o > 17976931348623157e292) i(0, a, c + n), i((u << 31 | 2146435072) >>> 0, a, c + s);
            else {
              var f;
              if (o < 22250738585072014e-324) f = o / 5e-324, i(f >>> 0, a, c + n), i((u << 31 | f / 4294967296) >>> 0, a, c + s);
              else {
                var h = Math.floor(Math.log(o) / Math.LN2);
                h === 1024 && (h = 1023), f = o * Math.pow(2, -h), i(f * 4503599627370496 >>> 0, a, c + n), i((u << 31 | h + 1023 << 20 | f * 1048576 & 1048575) >>> 0, a, c + s)
              }
            }
          }
          r.writeDoubleLE = e.bind(null, JO, 0, 4), r.writeDoubleBE = e.bind(null, XO, 4, 0);

          function t(i, n, s, o, a) {
            var c = i(o, a + n),
              u = i(o, a + s),
              f = (u >> 31) * 2 + 1,
              h = u >>> 20 & 2047,
              d = 4294967296 * (u & 1048575) + c;
            return h === 2047 ? d ? NaN : f * Infinity : h === 0 ? f * 5e-324 * d : f * Math.pow(2, h - 1075) * (d + 4503599627370496)
          }
          r.readDoubleLE = t.bind(null, ZO, 0, 4), r.readDoubleBE = t.bind(null, QO, 4, 0)
        }(), r
      }

      function JO(r, e, t) {
        e[t] = r & 255, e[t + 1] = r >>> 8 & 255, e[t + 2] = r >>> 16 & 255, e[t + 3] = r >>> 24
      }

      function XO(r, e, t) {
        e[t] = r >>> 24, e[t + 1] = r >>> 16 & 255, e[t + 2] = r >>> 8 & 255, e[t + 3] = r & 255
      }

      function ZO(r, e) {
        return (r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24) >>> 0
      }

      function QO(r, e) {
        return (r[e] << 24 | r[e + 1] << 16 | r[e + 2] << 8 | r[e + 3]) >>> 0
      }
    });
    var tN = y((exports, module) => {
      l();
      "use strict";
      module.exports = inquire;

      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length)) return mod
        } catch (r) { }
        return null
      }
    });
    var iN = y(rN => {
      l();
      "use strict";
      var EE = rN;
      EE.length = function (e) {
        for (var t = 0, i = 0, n = 0; n < e.length; ++n) i = e.charCodeAt(n), i < 128 ? t += 1 : i < 2048 ? t += 2 : (i & 64512) == 55296 && (e.charCodeAt(n + 1) & 64512) == 56320 ? (++n, t += 4) : t += 3;
        return t
      };
      EE.read = function (e, t, i) {
        var n = i - t;
        if (n < 1) return "";
        for (var s = null, o = [], a = 0, c; t < i;) c = e[t++], c < 128 ? o[a++] = c : c > 191 && c < 224 ? o[a++] = (c & 31) << 6 | e[t++] & 63 : c > 239 && c < 365 ? (c = ((c & 7) << 18 | (e[t++] & 63) << 12 | (e[t++] & 63) << 6 | e[t++] & 63) - 65536, o[a++] = 55296 + (c >> 10), o[a++] = 56320 + (c & 1023)) : o[a++] = (c & 15) << 12 | (e[t++] & 63) << 6 | e[t++] & 63, a > 8191 && ((s || (s = [])).push(String.fromCharCode.apply(String, o)), a = 0);
        return s ? (a && s.push(String.fromCharCode.apply(String, o.slice(0, a))), s.join("")) : String.fromCharCode.apply(String, o.slice(0, a))
      };
      EE.write = function (e, t, i) {
        for (var n = i, s, o, a = 0; a < e.length; ++a) s = e.charCodeAt(a), s < 128 ? t[i++] = s : s < 2048 ? (t[i++] = s >> 6 | 192, t[i++] = s & 63 | 128) : (s & 64512) == 55296 && ((o = e.charCodeAt(a + 1)) & 64512) == 56320 ? (s = 65536 + ((s & 1023) << 10) + (o & 1023), ++a, t[i++] = s >> 18 | 240, t[i++] = s >> 12 & 63 | 128, t[i++] = s >> 6 & 63 | 128, t[i++] = s & 63 | 128) : (t[i++] = s >> 12 | 224, t[i++] = s >> 6 & 63 | 128, t[i++] = s & 63 | 128);
        return i - n
      }
    });
    var sN = y((Fgt, nN) => {
      l();
      "use strict";
      nN.exports = N5e;

      function N5e(r, e, t) {
        var i = t || 8192,
          n = i >>> 1,
          s = null,
          o = i;
        return function (c) {
          if (c < 1 || c > n) return r(c);
          o + c > i && (s = r(i), o = 0);
          var u = e.call(s, o, o += c);
          return o & 7 && (o = (o | 7) + 1), u
        }
      }
    });
    var aN = y((Ugt, oN) => {
      l();
      "use strict";
      oN.exports = Ki;
      var O1 = Nu();

      function Ki(r, e) {
        this.lo = r >>> 0, this.hi = e >>> 0
      }
      var tl = Ki.zero = new Ki(0, 0);
      tl.toNumber = function () {
        return 0
      };
      tl.zzEncode = tl.zzDecode = function () {
        return this
      };
      tl.length = function () {
        return 1
      };
      var q5e = Ki.zeroHash = "\0\0\0\0\0\0\0\0";
      Ki.fromNumber = function (e) {
        if (e === 0) return tl;
        var t = e < 0;
        t && (e = -e);
        var i = e >>> 0,
          n = (e - i) / 4294967296 >>> 0;
        return t && (n = ~n >>> 0, i = ~i >>> 0, ++i > 4294967295 && (i = 0, ++n > 4294967295 && (n = 0))), new Ki(i, n)
      };
      Ki.from = function (e) {
        if (typeof e == "number") return Ki.fromNumber(e);
        if (O1.isString(e))
          if (O1.Long) e = O1.Long.fromString(e);
          else return Ki.fromNumber(parseInt(e, 10));
        return e.low || e.high ? new Ki(e.low >>> 0, e.high >>> 0) : tl
      };
      Ki.prototype.toNumber = function (e) {
        if (!e && this.hi >>> 31) {
          var t = ~this.lo + 1 >>> 0,
            i = ~this.hi >>> 0;
          return t || (i = i + 1 >>> 0), -(t + i * 4294967296)
        }
        return this.lo + this.hi * 4294967296
      };
      Ki.prototype.toLong = function (e) {
        return O1.Long ? new O1.Long(this.lo | 0, this.hi | 0, Boolean(e)) : {
          low: this.lo | 0,
          high: this.hi | 0,
          unsigned: Boolean(e)
        }
      };
      var qu = String.prototype.charCodeAt;
      Ki.fromHash = function (e) {
        return e === q5e ? tl : new Ki((qu.call(e, 0) | qu.call(e, 1) << 8 | qu.call(e, 2) << 16 | qu.call(e, 3) << 24) >>> 0, (qu.call(e, 4) | qu.call(e, 5) << 8 | qu.call(e, 6) << 16 | qu.call(e, 7) << 24) >>> 0)
      };
      Ki.prototype.toHash = function () {
        return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24)
      };
      Ki.prototype.zzEncode = function () {
        var e = this.hi >> 31;
        return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this
      };
      Ki.prototype.zzDecode = function () {
        var e = -(this.lo & 1);
        return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this
      };
      Ki.prototype.length = function () {
        var e = this.lo,
          t = (this.lo >>> 28 | this.hi << 4) >>> 0,
          i = this.hi >>> 24;
        return i === 0 ? t === 0 ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : i < 128 ? 9 : 10
      }
    });
    var Nu = y(SE => {
      l();
      "use strict";
      var ot = SE;
      ot.asPromise = KO();
      ot.base64 = HO();
      ot.EventEmitter = $O();
      ot.float = eN();
      ot.inquire = tN();
      ot.utf8 = iN();
      ot.pool = sN();
      ot.LongBits = aN();
      ot.isNode = Boolean(typeof globalThis != "undefined" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
      ot.global = ot.isNode && globalThis || typeof window != "undefined" && window || typeof self != "undefined" && self || SE;
      ot.emptyArray = Object.freeze ? Object.freeze([]) : [];
      ot.emptyObject = Object.freeze ? Object.freeze({}) : {};
      ot.isInteger = Number.isInteger || function (e) {
        return typeof e == "number" && isFinite(e) && Math.floor(e) === e
      };
      ot.isString = function (e) {
        return typeof e == "string" || e instanceof String
      };
      ot.isObject = function (e) {
        return e && typeof e == "object"
      };
      ot.isset = ot.isSet = function (e, t) {
        var i = e[t];
        return i != null && e.hasOwnProperty(t) ? typeof i != "object" || (Array.isArray(i) ? i.length : Object.keys(i).length) > 0 : !1
      };
      ot.Buffer = function () {
        try {
          var r = ot.inquire("buffer").Buffer;
          return r.prototype.utf8Write ? r : null
        } catch (e) {
          return null
        }
      }();
      ot._Buffer_from = null;
      ot._Buffer_allocUnsafe = null;
      ot.newBuffer = function (e) {
        return typeof e == "number" ? ot.Buffer ? ot._Buffer_allocUnsafe(e) : new ot.Array(e) : ot.Buffer ? ot._Buffer_from(e) : typeof Uint8Array == "undefined" ? e : new Uint8Array(e)
      };
      ot.Array = typeof Uint8Array != "undefined" ? Uint8Array : Array;
      ot.Long = ot.global.dcodeIO && ot.global.dcodeIO.Long || ot.global.Long || ot.inquire("long");
      ot.key2Re = /^true|false|0|1$/;
      ot.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
      ot.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
      ot.longToHash = function (e) {
        return e ? ot.LongBits.from(e).toHash() : ot.LongBits.zeroHash
      };
      ot.longFromHash = function (e, t) {
        var i = ot.LongBits.fromHash(e);
        return ot.Long ? ot.Long.fromBits(i.lo, i.hi, t) : i.toNumber(Boolean(t))
      };

      function cN(r, e, t) {
        for (var i = Object.keys(e), n = 0; n < i.length; ++n)(r[i[n]] === void 0 || !t) && (r[i[n]] = e[i[n]]);
        return r
      }
      ot.merge = cN;
      ot.lcFirst = function (e) {
        return e.charAt(0).toLowerCase() + e.substring(1)
      };

      function uN(r) {
        function e(t, i) {
          if (!(this instanceof e)) return new e(t, i);
          Object.defineProperty(this, "message", {
            get: function () {
              return t
            }
          }), Error.captureStackTrace ? Error.captureStackTrace(this, e) : Object.defineProperty(this, "stack", {
            value: new Error().stack || ""
          }), i && cN(this, i)
        }
        return (e.prototype = Object.create(Error.prototype)).constructor = e, Object.defineProperty(e.prototype, "name", {
          get: function () {
            return r
          }
        }), e.prototype.toString = function () {
          return this.name + ": " + this.message
        }, e
      }
      ot.newError = uN;
      ot.ProtocolError = uN("ProtocolError");
      ot.oneOfGetter = function (e) {
        for (var t = {}, i = 0; i < e.length; ++i) t[e[i]] = 1;
        return function () {
          for (var n = Object.keys(this), s = n.length - 1; s > -1; --s)
            if (t[n[s]] === 1 && this[n[s]] !== void 0 && this[n[s]] !== null) return n[s]
        }
      };
      ot.oneOfSetter = function (e) {
        return function (t) {
          for (var i = 0; i < e.length; ++i) e[i] !== t && delete this[e[i]]
        }
      };
      ot.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: !0
      };
      ot._configure = function () {
        var r = ot.Buffer;
        if (!r) {
          ot._Buffer_from = ot._Buffer_allocUnsafe = null;
          return
        }
        ot._Buffer_from = r.from !== Uint8Array.from && r.from || function (t, i) {
          return new r(t, i)
        }, ot._Buffer_allocUnsafe = r.allocUnsafe || function (t) {
          return new r(t)
        }
      }
    });
    var PE = y((zgt, fN) => {
      l();
      "use strict";
      fN.exports = Yt;
      var Ys = Nu(),
        xE, Gm = Ys.LongBits,
        lN = Ys.base64,
        hN = Ys.utf8;

      function N1(r, e, t) {
        this.fn = r, this.len = e, this.next = void 0, this.val = t
      }

      function AE() { }

      function M5e(r) {
        this.head = r.head, this.tail = r.tail, this.len = r.len, this.next = r.states
      }

      function Yt() {
        this.len = 0, this.head = new N1(AE, 0, 0), this.tail = this.head, this.states = null
      }
      var dN = function () {
        return Ys.Buffer ? function () {
          return (Yt.create = function () {
            return new xE
          })()
        } : function () {
          return new Yt
        }
      };
      Yt.create = dN();
      Yt.alloc = function (e) {
        return new Ys.Array(e)
      };
      Ys.Array !== Array && (Yt.alloc = Ys.pool(Yt.alloc, Ys.Array.prototype.subarray));
      Yt.prototype._push = function (e, t, i) {
        return this.tail = this.tail.next = new N1(e, t, i), this.len += t, this
      };

      function IE(r, e, t) {
        e[t] = r & 255
      }

      function B5e(r, e, t) {
        for (; r > 127;) e[t++] = r & 127 | 128, r >>>= 7;
        e[t] = r
      }

      function TE(r, e) {
        this.len = r, this.next = void 0, this.val = e
      }
      TE.prototype = Object.create(N1.prototype);
      TE.prototype.fn = B5e;
      Yt.prototype.uint32 = function (e) {
        return this.len += (this.tail = this.tail.next = new TE((e = e >>> 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this
      };
      Yt.prototype.int32 = function (e) {
        return e < 0 ? this._push(RE, 10, Gm.fromNumber(e)) : this.uint32(e)
      };
      Yt.prototype.sint32 = function (e) {
        return this.uint32((e << 1 ^ e >> 31) >>> 0)
      };

      function RE(r, e, t) {
        for (; r.hi;) e[t++] = r.lo & 127 | 128, r.lo = (r.lo >>> 7 | r.hi << 25) >>> 0, r.hi >>>= 7;
        for (; r.lo > 127;) e[t++] = r.lo & 127 | 128, r.lo = r.lo >>> 7;
        e[t++] = r.lo
      }
      Yt.prototype.uint64 = function (e) {
        var t = Gm.from(e);
        return this._push(RE, t.length(), t)
      };
      Yt.prototype.int64 = Yt.prototype.uint64;
      Yt.prototype.sint64 = function (e) {
        var t = Gm.from(e).zzEncode();
        return this._push(RE, t.length(), t)
      };
      Yt.prototype.bool = function (e) {
        return this._push(IE, 1, e ? 1 : 0)
      };

      function kE(r, e, t) {
        e[t] = r & 255, e[t + 1] = r >>> 8 & 255, e[t + 2] = r >>> 16 & 255, e[t + 3] = r >>> 24
      }
      Yt.prototype.fixed32 = function (e) {
        return this._push(kE, 4, e >>> 0)
      };
      Yt.prototype.sfixed32 = Yt.prototype.fixed32;
      Yt.prototype.fixed64 = function (e) {
        var t = Gm.from(e);
        return this._push(kE, 4, t.lo)._push(kE, 4, t.hi)
      };
      Yt.prototype.sfixed64 = Yt.prototype.fixed64;
      Yt.prototype.float = function (e) {
        return this._push(Ys.float.writeFloatLE, 4, e)
      };
      Yt.prototype.double = function (e) {
        return this._push(Ys.float.writeDoubleLE, 8, e)
      };
      var D5e = Ys.Array.prototype.set ? function (e, t, i) {
        t.set(e, i)
      } : function (e, t, i) {
        for (var n = 0; n < e.length; ++n) t[i + n] = e[n]
      };
      Yt.prototype.bytes = function (e) {
        var t = e.length >>> 0;
        if (!t) return this._push(IE, 1, 0);
        if (Ys.isString(e)) {
          var i = Yt.alloc(t = lN.length(e));
          lN.decode(e, i, 0), e = i
        }
        return this.uint32(t)._push(D5e, t, e)
      };
      Yt.prototype.string = function (e) {
        var t = hN.length(e);
        return t ? this.uint32(t)._push(hN.write, t, e) : this._push(IE, 1, 0)
      };
      Yt.prototype.fork = function () {
        return this.states = new M5e(this), this.head = this.tail = new N1(AE, 0, 0), this.len = 0, this
      };
      Yt.prototype.reset = function () {
        return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new N1(AE, 0, 0), this.len = 0), this
      };
      Yt.prototype.ldelim = function () {
        var e = this.head,
          t = this.tail,
          i = this.len;
        return this.reset().uint32(i), i && (this.tail.next = e.next, this.tail = t, this.len += i), this
      };
      Yt.prototype.finish = function () {
        for (var e = this.head.next, t = this.constructor.alloc(this.len), i = 0; e;) e.fn(e.val, t, i), i += e.len, e = e.next;
        return t
      };
      Yt._configure = function (r) {
        xE = r, Yt.create = dN(), xE._configure()
      }
    });
    var gN = y((jgt, pN) => {
      l();
      "use strict";
      pN.exports = Ra;
      var yN = PE();
      (Ra.prototype = Object.create(yN.prototype)).constructor = Ra;
      var Mu = Nu();

      function Ra() {
        yN.call(this)
      }
      Ra._configure = function () {
        Ra.alloc = Mu._Buffer_allocUnsafe, Ra.writeBytesBuffer = Mu.Buffer && Mu.Buffer.prototype instanceof Uint8Array && Mu.Buffer.prototype.set.name === "set" ? function (e, t, i) {
          t.set(e, i)
        } : function (e, t, i) {
          if (e.copy) e.copy(t, i, 0, e.length);
          else
            for (var n = 0; n < e.length;) t[i++] = e[n++]
        }
      };
      Ra.prototype.bytes = function (e) {
        Mu.isString(e) && (e = Mu._Buffer_from(e, "base64"));
        var t = e.length >>> 0;
        return this.uint32(t), t && this._push(Ra.writeBytesBuffer, t, e), this
      };

      function L5e(r, e, t) {
        r.length < 40 ? Mu.utf8.write(r, e, t) : e.utf8Write ? e.utf8Write(r, t) : e.write(r, t)
      }
      Ra.prototype.string = function (e) {
        var t = Mu.Buffer.byteLength(e);
        return this.uint32(t), t && this._push(L5e, t, e), this
      };
      Ra._configure()
    });
    var NE = y((Vgt, bN) => {
      l();
      "use strict";
      bN.exports = ui;
      var ka = Nu(),
        CE, mN = ka.LongBits,
        F5e = ka.utf8;

      function Fo(r, e) {
        return RangeError("index out of range: " + r.pos + " + " + (e || 1) + " > " + r.len)
      }

      function ui(r) {
        this.buf = r, this.pos = 0, this.len = r.length
      }
      var vN = typeof Uint8Array != "undefined" ? function (e) {
        if (e instanceof Uint8Array || Array.isArray(e)) return new ui(e);
        throw Error("illegal buffer")
      } : function (e) {
        if (Array.isArray(e)) return new ui(e);
        throw Error("illegal buffer")
      },
        wN = function () {
          return ka.Buffer ? function (t) {
            return (ui.create = function (n) {
              return ka.Buffer.isBuffer(n) ? new CE(n) : vN(n)
            })(t)
          } : vN
        };
      ui.create = wN();
      ui.prototype._slice = ka.Array.prototype.subarray || ka.Array.prototype.slice;
      ui.prototype.uint32 = function () {
        var e = 4294967295;
        return function () {
          if (e = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (e = (e | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return e;
          if ((this.pos += 5) > this.len) throw this.pos = this.len, Fo(this, 10);
          return e
        }
      }();
      ui.prototype.int32 = function () {
        return this.uint32() | 0
      };
      ui.prototype.sint32 = function () {
        var e = this.uint32();
        return e >>> 1 ^ -(e & 1) | 0
      };

      function OE() {
        var r = new mN(0, 0),
          e = 0;
        if (this.len - this.pos > 4) {
          for (; e < 4; ++e)
            if (r.lo = (r.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128) return r;
          if (r.lo = (r.lo | (this.buf[this.pos] & 127) << 28) >>> 0, r.hi = (r.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128) return r;
          e = 0
        } else {
          for (; e < 3; ++e) {
            if (this.pos >= this.len) throw Fo(this);
            if (r.lo = (r.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128) return r
          }
          return r.lo = (r.lo | (this.buf[this.pos++] & 127) << e * 7) >>> 0, r
        }
        if (this.len - this.pos > 4) {
          for (; e < 5; ++e)
            if (r.hi = (r.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return r
        } else
          for (; e < 5; ++e) {
            if (this.pos >= this.len) throw Fo(this);
            if (r.hi = (r.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return r
          }
        throw Error("invalid varint encoding")
      }
      ui.prototype.bool = function () {
        return this.uint32() !== 0
      };

      function $m(r, e) {
        return (r[e - 4] | r[e - 3] << 8 | r[e - 2] << 16 | r[e - 1] << 24) >>> 0
      }
      ui.prototype.fixed32 = function () {
        if (this.pos + 4 > this.len) throw Fo(this, 4);
        return $m(this.buf, this.pos += 4)
      };
      ui.prototype.sfixed32 = function () {
        if (this.pos + 4 > this.len) throw Fo(this, 4);
        return $m(this.buf, this.pos += 4) | 0
      };

      function _N() {
        if (this.pos + 8 > this.len) throw Fo(this, 8);
        return new mN($m(this.buf, this.pos += 4), $m(this.buf, this.pos += 4))
      }
      ui.prototype.float = function () {
        if (this.pos + 4 > this.len) throw Fo(this, 4);
        var e = ka.float.readFloatLE(this.buf, this.pos);
        return this.pos += 4, e
      };
      ui.prototype.double = function () {
        if (this.pos + 8 > this.len) throw Fo(this, 4);
        var e = ka.float.readDoubleLE(this.buf, this.pos);
        return this.pos += 8, e
      };
      ui.prototype.bytes = function () {
        var e = this.uint32(),
          t = this.pos,
          i = this.pos + e;
        if (i > this.len) throw Fo(this, e);
        return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t, i) : t === i ? new this.buf.constructor(0) : this._slice.call(this.buf, t, i)
      };
      ui.prototype.string = function () {
        var e = this.bytes();
        return F5e.read(e, 0, e.length)
      };
      ui.prototype.skip = function (e) {
        if (typeof e == "number") {
          if (this.pos + e > this.len) throw Fo(this, e);
          this.pos += e
        } else
          do
            if (this.pos >= this.len) throw Fo(this); while (this.buf[this.pos++] & 128);
        return this
      };
      ui.prototype.skipType = function (r) {
        switch (r) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            for (;
              (r = this.uint32() & 7) != 4;) this.skipType(r);
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + r + " at offset " + this.pos)
        }
        return this
      };
      ui._configure = function (r) {
        CE = r, ui.create = wN(), CE._configure();
        var e = ka.Long ? "toLong" : "toNumber";
        ka.merge(ui.prototype, {
          int64: function () {
            return OE.call(this)[e](!1)
          },
          uint64: function () {
            return OE.call(this)[e](!0)
          },
          sint64: function () {
            return OE.call(this).zzDecode()[e](!1)
          },
          fixed64: function () {
            return _N.call(this)[e](!0)
          },
          sfixed64: function () {
            return _N.call(this)[e](!1)
          }
        })
      }
    });
    var AN = y((Hgt, EN) => {
      l();
      "use strict";
      EN.exports = rl;
      var SN = NE();
      (rl.prototype = Object.create(SN.prototype)).constructor = rl;
      var xN = Nu();

      function rl(r) {
        SN.call(this, r)
      }
      rl._configure = function () {
        xN.Buffer && (rl.prototype._slice = xN.Buffer.prototype.slice)
      };
      rl.prototype.string = function () {
        var e = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e, this.len))
      };
      rl._configure()
    });
    var TN = y((Ggt, IN) => {
      l();
      "use strict";
      IN.exports = q1;
      var qE = Nu();
      (q1.prototype = Object.create(qE.EventEmitter.prototype)).constructor = q1;

      function q1(r, e, t) {
        if (typeof r != "function") throw TypeError("rpcImpl must be a function");
        qE.EventEmitter.call(this), this.rpcImpl = r, this.requestDelimited = Boolean(e), this.responseDelimited = Boolean(t)
      }
      q1.prototype.rpcCall = function r(e, t, i, n, s) {
        if (!n) throw TypeError("request must be specified");
        var o = this;
        if (!s) return qE.asPromise(r, o, e, t, i, n);
        if (!o.rpcImpl) {
          setTimeout(function () {
            s(Error("already ended"))
          }, 0);
          return
        }
        try {
          return o.rpcImpl(e, t[o.requestDelimited ? "encodeDelimited" : "encode"](n).finish(), function (c, u) {
            if (c) return o.emit("error", c, e), s(c);
            if (u === null) {
              o.end(!0);
              return
            }
            if (!(u instanceof i)) try {
              u = i[o.responseDelimited ? "decodeDelimited" : "decode"](u)
            } catch (f) {
              return o.emit("error", f, e), s(f)
            }
            return o.emit("data", u, e), s(null, u)
          })
        } catch (a) {
          o.emit("error", a, e), setTimeout(function () {
            s(a)
          }, 0);
          return
        }
      };
      q1.prototype.end = function (e) {
        return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this
      }
    });
    var kN = y(RN => {
      l();
      "use strict";
      var U5e = RN;
      U5e.Service = TN()
    });
    var CN = y((Wgt, PN) => {
      l();
      "use strict";
      PN.exports = {}
    });
    var qN = y(ON => {
      l();
      "use strict";
      var ls = ON;
      ls.build = "minimal";
      ls.Writer = PE();
      ls.BufferWriter = gN();
      ls.Reader = NE();
      ls.BufferReader = AN();
      ls.util = Nu();
      ls.rpc = kN();
      ls.roots = CN();
      ls.configure = NN;

      function NN() {
        ls.util._configure(), ls.Writer._configure(ls.BufferWriter), ls.Reader._configure(ls.BufferReader)
      }
      NN()
    });
    var bi = y((Jgt, MN) => {
      l();
      "use strict";
      MN.exports = qN()
    });
    var Ym = y((Xgt, BN) => {
      l();
      "use strict";
      var il = bi(),
        Wm = il.Reader,
        DN = il.Writer,
        En = il.util,
        Js = il.roots["libp2p-crypto-keys"] || (il.roots["libp2p-crypto-keys"] = {});
      Js.KeyType = function () {
        var r = {},
          e = Object.create(r);
        return e[r[0] = "RSA"] = 0, e[r[1] = "Ed25519"] = 1, e[r[2] = "Secp256k1"] = 2, e
      }();
      Js.PublicKey = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.Type = 0, r.prototype.Data = En.newBuffer([]), r.encode = function (t, i) {
          return i || (i = DN.create()), i.uint32(8).int32(t.Type), i.uint32(18).bytes(t.Data), i
        }, r.decode = function (t, i) {
          t instanceof Wm || (t = Wm.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Js.PublicKey; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.Type = t.int32();
                break;
              case 2:
                s.Data = t.bytes();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          if (!s.hasOwnProperty("Type")) throw En.ProtocolError("missing required 'Type'", {
            instance: s
          });
          if (!s.hasOwnProperty("Data")) throw En.ProtocolError("missing required 'Data'", {
            instance: s
          });
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Js.PublicKey) return t;
          var i = new Js.PublicKey;
          switch (t.Type) {
            case "RSA":
            case 0:
              i.Type = 0;
              break;
            case "Ed25519":
            case 1:
              i.Type = 1;
              break;
            case "Secp256k1":
            case 2:
              i.Type = 2;
              break
          }
          return t.Data != null && (typeof t.Data == "string" ? En.base64.decode(t.Data, i.Data = En.newBuffer(En.base64.length(t.Data)), 0) : t.Data.length && (i.Data = t.Data)), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          return i.defaults && (n.Type = i.enums === String ? "RSA" : 0, i.bytes === String ? n.Data = "" : (n.Data = [], i.bytes !== Array && (n.Data = En.newBuffer(n.Data)))), t.Type != null && t.hasOwnProperty("Type") && (n.Type = i.enums === String ? Js.KeyType[t.Type] : t.Type), t.Data != null && t.hasOwnProperty("Data") && (n.Data = i.bytes === String ? En.base64.encode(t.Data, 0, t.Data.length) : i.bytes === Array ? Array.prototype.slice.call(t.Data) : t.Data), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, il.util.toJSONOptions)
        }, r
      }();
      Js.PrivateKey = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.Type = 0, r.prototype.Data = En.newBuffer([]), r.encode = function (t, i) {
          return i || (i = DN.create()), i.uint32(8).int32(t.Type), i.uint32(18).bytes(t.Data), i
        }, r.decode = function (t, i) {
          t instanceof Wm || (t = Wm.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Js.PrivateKey; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.Type = t.int32();
                break;
              case 2:
                s.Data = t.bytes();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          if (!s.hasOwnProperty("Type")) throw En.ProtocolError("missing required 'Type'", {
            instance: s
          });
          if (!s.hasOwnProperty("Data")) throw En.ProtocolError("missing required 'Data'", {
            instance: s
          });
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Js.PrivateKey) return t;
          var i = new Js.PrivateKey;
          switch (t.Type) {
            case "RSA":
            case 0:
              i.Type = 0;
              break;
            case "Ed25519":
            case 1:
              i.Type = 1;
              break;
            case "Secp256k1":
            case 2:
              i.Type = 2;
              break
          }
          return t.Data != null && (typeof t.Data == "string" ? En.base64.decode(t.Data, i.Data = En.newBuffer(En.base64.length(t.Data)), 0) : t.Data.length && (i.Data = t.Data)), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          return i.defaults && (n.Type = i.enums === String ? "RSA" : 0, i.bytes === String ? n.Data = "" : (n.Data = [], i.bytes !== Array && (n.Data = En.newBuffer(n.Data)))), t.Type != null && t.hasOwnProperty("Type") && (n.Type = i.enums === String ? Js.KeyType[t.Type] : t.Type), t.Data != null && t.hasOwnProperty("Data") && (n.Data = i.bytes === String ? En.base64.encode(t.Data, 0, t.Data.length) : i.bytes === Array ? Array.prototype.slice.call(t.Data) : t.Data), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, il.util.toJSONOptions)
        }, r
      }();
      BN.exports = Js
    });
    var At = y((Zgt, LN) => {
      l();
      LN.exports = {
        options: {
          usePureJavaScript: !1
        }
      }
    });
    var KN = y((Qgt, FN) => {
      l();
      var ME = {};
      FN.exports = ME;
      var UN = {};
      ME.encode = function (r, e, t) {
        if (typeof e != "string") throw new TypeError('"alphabet" must be a string.');
        if (t !== void 0 && typeof t != "number") throw new TypeError('"maxline" must be a number.');
        var i = "";
        if (!(r instanceof Uint8Array)) i = K5e(r, e);
        else {
          var n = 0,
            s = e.length,
            o = e.charAt(0),
            a = [0];
          for (n = 0; n < r.length; ++n) {
            for (var c = 0, u = r[n]; c < a.length; ++c) u += a[c] << 8, a[c] = u % s, u = u / s | 0;
            for (; u > 0;) a.push(u % s), u = u / s | 0
          }
          for (n = 0; r[n] === 0 && n < r.length - 1; ++n) i += o;
          for (n = a.length - 1; n >= 0; --n) i += e[a[n]]
        }
        if (t) {
          var f = new RegExp(".{1," + t + "}", "g");
          i = i.match(f).join(`\r
`)
        }
        return i
      };
      ME.decode = function (r, e) {
        if (typeof r != "string") throw new TypeError('"input" must be a string.');
        if (typeof e != "string") throw new TypeError('"alphabet" must be a string.');
        var t = UN[e];
        if (!t) {
          t = UN[e] = [];
          for (var i = 0; i < e.length; ++i) t[e.charCodeAt(i)] = i
        }
        r = r.replace(/\s/g, "");
        for (var n = e.length, s = e.charAt(0), o = [0], i = 0; i < r.length; i++) {
          var a = t[r.charCodeAt(i)];
          if (a === void 0) return;
          for (var c = 0, u = a; c < o.length; ++c) u += o[c] * n, o[c] = u & 255, u >>= 8;
          for (; u > 0;) o.push(u & 255), u >>= 8
        }
        for (var f = 0; r[f] === s && f < r.length - 1; ++f) o.push(0);
        return typeof Buffer != "undefined" ? Buffer.from(o.reverse()) : new Uint8Array(o.reverse())
      };

      function K5e(r, e) {
        var t = 0,
          i = e.length,
          n = e.charAt(0),
          s = [0];
        for (t = 0; t < r.length(); ++t) {
          for (var o = 0, a = r.at(t); o < s.length; ++o) a += s[o] << 8, s[o] = a % i, a = a / i | 0;
          for (; a > 0;) s.push(a % i), a = a / i | 0
        }
        var c = "";
        for (t = 0; r.at(t) === 0 && t < r.length() - 1; ++t) c += n;
        for (t = s.length - 1; t >= 0; --t) c += e[s[t]];
        return c
      }
    });
    var wr = y((ebt, zN) => {
      l();
      var jN = At(),
        VN = KN(),
        ue = zN.exports = jN.util = jN.util || {};
      (function () {
        if (typeof process != "undefined" && process.nextTick && !process.browser) {
          ue.nextTick = process.nextTick, typeof setImmediate == "function" ? ue.setImmediate = setImmediate : ue.setImmediate = ue.nextTick;
          return
        }
        if (typeof setImmediate == "function") {
          ue.setImmediate = function () {
            return setImmediate.apply(void 0, arguments)
          }, ue.nextTick = function (a) {
            return setImmediate(a)
          };
          return
        }
        if (ue.setImmediate = function (a) {
          setTimeout(a, 0)
        }, typeof window != "undefined" && typeof window.postMessage == "function") {
          let a = function (c) {
            if (c.source === window && c.data === r) {
              c.stopPropagation();
              var u = e.slice();
              e.length = 0, u.forEach(function (f) {
                f()
              })
            }
          };
          var o = a,
            r = "forge.setImmediate",
            e = [];
          ue.setImmediate = function (c) {
            e.push(c), e.length === 1 && window.postMessage(r, "*")
          }, window.addEventListener("message", a, !0)
        }
        if (typeof MutationObserver != "undefined") {
          var t = Date.now(),
            i = !0,
            n = document.createElement("div"),
            e = [];
          new MutationObserver(function () {
            var c = e.slice();
            e.length = 0, c.forEach(function (u) {
              u()
            })
          }).observe(n, {
            attributes: !0
          });
          var s = ue.setImmediate;
          ue.setImmediate = function (c) {
            Date.now() - t > 15 ? (t = Date.now(), s(c)) : (e.push(c), e.length === 1 && n.setAttribute("a", i = !i))
          }
        }
        ue.nextTick = ue.setImmediate
      })();
      ue.isNodejs = typeof process != "undefined" && process.versions && process.versions.node;
      ue.globalScope = function () {
        return ue.isNodejs ? globalThis : typeof self == "undefined" ? window : self
      }();
      ue.isArray = Array.isArray || function (r) {
        return Object.prototype.toString.call(r) === "[object Array]"
      };
      ue.isArrayBuffer = function (r) {
        return typeof ArrayBuffer != "undefined" && r instanceof ArrayBuffer
      };
      ue.isArrayBufferView = function (r) {
        return r && ue.isArrayBuffer(r.buffer) && r.byteLength !== void 0
      };

      function M1(r) {
        if (!(r === 8 || r === 16 || r === 24 || r === 32)) throw new Error("Only 8, 16, 24, or 32 bits supported: " + r)
      }
      ue.ByteBuffer = BE;

      function BE(r) {
        if (this.data = "", this.read = 0, typeof r == "string") this.data = r;
        else if (ue.isArrayBuffer(r) || ue.isArrayBufferView(r))
          if (typeof Buffer != "undefined" && r instanceof Buffer) this.data = r.toString("binary");
          else {
            var e = new Uint8Array(r);
            try {
              this.data = String.fromCharCode.apply(null, e)
            } catch (i) {
              for (var t = 0; t < e.length; ++t) this.putByte(e[t])
            }
          }
        else (r instanceof BE || typeof r == "object" && typeof r.data == "string" && typeof r.read == "number") && (this.data = r.data, this.read = r.read);
        this._constructedStringLength = 0
      }
      ue.ByteStringBuffer = BE;
      var z5e = 4096;
      ue.ByteStringBuffer.prototype._optimizeConstructedString = function (r) {
        this._constructedStringLength += r, this._constructedStringLength > z5e && (this.data.substr(0, 1), this._constructedStringLength = 0)
      };
      ue.ByteStringBuffer.prototype.length = function () {
        return this.data.length - this.read
      };
      ue.ByteStringBuffer.prototype.isEmpty = function () {
        return this.length() <= 0
      };
      ue.ByteStringBuffer.prototype.putByte = function (r) {
        return this.putBytes(String.fromCharCode(r))
      };
      ue.ByteStringBuffer.prototype.fillWithByte = function (r, e) {
        r = String.fromCharCode(r);
        for (var t = this.data; e > 0;) e & 1 && (t += r), e >>>= 1, e > 0 && (r += r);
        return this.data = t, this._optimizeConstructedString(e), this
      };
      ue.ByteStringBuffer.prototype.putBytes = function (r) {
        return this.data += r, this._optimizeConstructedString(r.length), this
      };
      ue.ByteStringBuffer.prototype.putString = function (r) {
        return this.putBytes(ue.encodeUtf8(r))
      };
      ue.ByteStringBuffer.prototype.putInt16 = function (r) {
        return this.putBytes(String.fromCharCode(r >> 8 & 255) + String.fromCharCode(r & 255))
      };
      ue.ByteStringBuffer.prototype.putInt24 = function (r) {
        return this.putBytes(String.fromCharCode(r >> 16 & 255) + String.fromCharCode(r >> 8 & 255) + String.fromCharCode(r & 255))
      };
      ue.ByteStringBuffer.prototype.putInt32 = function (r) {
        return this.putBytes(String.fromCharCode(r >> 24 & 255) + String.fromCharCode(r >> 16 & 255) + String.fromCharCode(r >> 8 & 255) + String.fromCharCode(r & 255))
      };
      ue.ByteStringBuffer.prototype.putInt16Le = function (r) {
        return this.putBytes(String.fromCharCode(r & 255) + String.fromCharCode(r >> 8 & 255))
      };
      ue.ByteStringBuffer.prototype.putInt24Le = function (r) {
        return this.putBytes(String.fromCharCode(r & 255) + String.fromCharCode(r >> 8 & 255) + String.fromCharCode(r >> 16 & 255))
      };
      ue.ByteStringBuffer.prototype.putInt32Le = function (r) {
        return this.putBytes(String.fromCharCode(r & 255) + String.fromCharCode(r >> 8 & 255) + String.fromCharCode(r >> 16 & 255) + String.fromCharCode(r >> 24 & 255))
      };
      ue.ByteStringBuffer.prototype.putInt = function (r, e) {
        M1(e);
        var t = "";
        do e -= 8, t += String.fromCharCode(r >> e & 255); while (e > 0);
        return this.putBytes(t)
      };
      ue.ByteStringBuffer.prototype.putSignedInt = function (r, e) {
        return r < 0 && (r += 2 << e - 1), this.putInt(r, e)
      };
      ue.ByteStringBuffer.prototype.putBuffer = function (r) {
        return this.putBytes(r.getBytes())
      };
      ue.ByteStringBuffer.prototype.getByte = function () {
        return this.data.charCodeAt(this.read++)
      };
      ue.ByteStringBuffer.prototype.getInt16 = function () {
        var r = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
        return this.read += 2, r
      };
      ue.ByteStringBuffer.prototype.getInt24 = function () {
        var r = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
        return this.read += 3, r
      };
      ue.ByteStringBuffer.prototype.getInt32 = function () {
        var r = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
        return this.read += 4, r
      };
      ue.ByteStringBuffer.prototype.getInt16Le = function () {
        var r = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
        return this.read += 2, r
      };
      ue.ByteStringBuffer.prototype.getInt24Le = function () {
        var r = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
        return this.read += 3, r
      };
      ue.ByteStringBuffer.prototype.getInt32Le = function () {
        var r = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
        return this.read += 4, r
      };
      ue.ByteStringBuffer.prototype.getInt = function (r) {
        M1(r);
        var e = 0;
        do e = (e << 8) + this.data.charCodeAt(this.read++), r -= 8; while (r > 0);
        return e
      };
      ue.ByteStringBuffer.prototype.getSignedInt = function (r) {
        var e = this.getInt(r),
          t = 2 << r - 2;
        return e >= t && (e -= t << 1), e
      };
      ue.ByteStringBuffer.prototype.getBytes = function (r) {
        var e;
        return r ? (r = Math.min(this.length(), r), e = this.data.slice(this.read, this.read + r), this.read += r) : r === 0 ? e = "" : (e = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), e
      };
      ue.ByteStringBuffer.prototype.bytes = function (r) {
        return typeof r == "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + r)
      };
      ue.ByteStringBuffer.prototype.at = function (r) {
        return this.data.charCodeAt(this.read + r)
      };
      ue.ByteStringBuffer.prototype.setAt = function (r, e) {
        return this.data = this.data.substr(0, this.read + r) + String.fromCharCode(e) + this.data.substr(this.read + r + 1), this
      };
      ue.ByteStringBuffer.prototype.last = function () {
        return this.data.charCodeAt(this.data.length - 1)
      };
      ue.ByteStringBuffer.prototype.copy = function () {
        var r = ue.createBuffer(this.data);
        return r.read = this.read, r
      };
      ue.ByteStringBuffer.prototype.compact = function () {
        return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this
      };
      ue.ByteStringBuffer.prototype.clear = function () {
        return this.data = "", this.read = 0, this
      };
      ue.ByteStringBuffer.prototype.truncate = function (r) {
        var e = Math.max(0, this.length() - r);
        return this.data = this.data.substr(this.read, e), this.read = 0, this
      };
      ue.ByteStringBuffer.prototype.toHex = function () {
        for (var r = "", e = this.read; e < this.data.length; ++e) {
          var t = this.data.charCodeAt(e);
          t < 16 && (r += "0"), r += t.toString(16)
        }
        return r
      };
      ue.ByteStringBuffer.prototype.toString = function () {
        return ue.decodeUtf8(this.bytes())
      };

      function j5e(r, e) {
        e = e || {}, this.read = e.readOffset || 0, this.growSize = e.growSize || 1024;
        var t = ue.isArrayBuffer(r),
          i = ue.isArrayBufferView(r);
        if (t || i) {
          t ? this.data = new DataView(r) : this.data = new DataView(r.buffer, r.byteOffset, r.byteLength), this.write = "writeOffset" in e ? e.writeOffset : this.data.byteLength;
          return
        }
        this.data = new DataView(new ArrayBuffer(0)), this.write = 0, r != null && this.putBytes(r), "writeOffset" in e && (this.write = e.writeOffset)
      }
      ue.DataBuffer = j5e;
      ue.DataBuffer.prototype.length = function () {
        return this.write - this.read
      };
      ue.DataBuffer.prototype.isEmpty = function () {
        return this.length() <= 0
      };
      ue.DataBuffer.prototype.accommodate = function (r, e) {
        if (this.length() >= r) return this;
        e = Math.max(e || this.growSize, r);
        var t = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength),
          i = new Uint8Array(this.length() + e);
        return i.set(t), this.data = new DataView(i.buffer), this
      };
      ue.DataBuffer.prototype.putByte = function (r) {
        return this.accommodate(1), this.data.setUint8(this.write++, r), this
      };
      ue.DataBuffer.prototype.fillWithByte = function (r, e) {
        this.accommodate(e);
        for (var t = 0; t < e; ++t) this.data.setUint8(r);
        return this
      };
      ue.DataBuffer.prototype.putBytes = function (r, e) {
        if (ue.isArrayBufferView(r)) {
          var t = new Uint8Array(r.buffer, r.byteOffset, r.byteLength),
            i = t.byteLength - t.byteOffset;
          this.accommodate(i);
          var n = new Uint8Array(this.data.buffer, this.write);
          return n.set(t), this.write += i, this
        }
        if (ue.isArrayBuffer(r)) {
          var t = new Uint8Array(r);
          this.accommodate(t.byteLength);
          var n = new Uint8Array(this.data.buffer);
          return n.set(t, this.write), this.write += t.byteLength, this
        }
        if (r instanceof ue.DataBuffer || typeof r == "object" && typeof r.read == "number" && typeof r.write == "number" && ue.isArrayBufferView(r.data)) {
          var t = new Uint8Array(r.data.byteLength, r.read, r.length());
          this.accommodate(t.byteLength);
          var n = new Uint8Array(r.data.byteLength, this.write);
          return n.set(t), this.write += t.byteLength, this
        }
        if (r instanceof ue.ByteStringBuffer && (r = r.data, e = "binary"), e = e || "binary", typeof r == "string") {
          var s;
          if (e === "hex") return this.accommodate(Math.ceil(r.length / 2)), s = new Uint8Array(this.data.buffer, this.write), this.write += ue.binary.hex.decode(r, s, this.write), this;
          if (e === "base64") return this.accommodate(Math.ceil(r.length / 4) * 3), s = new Uint8Array(this.data.buffer, this.write), this.write += ue.binary.base64.decode(r, s, this.write), this;
          if (e === "utf8" && (r = ue.encodeUtf8(r), e = "binary"), e === "binary" || e === "raw") return this.accommodate(r.length), s = new Uint8Array(this.data.buffer, this.write), this.write += ue.binary.raw.decode(s), this;
          if (e === "utf16") return this.accommodate(r.length * 2), s = new Uint16Array(this.data.buffer, this.write), this.write += ue.text.utf16.encode(s), this;
          throw new Error("Invalid encoding: " + e)
        }
        throw Error("Invalid parameter: " + r)
      };
      ue.DataBuffer.prototype.putBuffer = function (r) {
        return this.putBytes(r), r.clear(), this
      };
      ue.DataBuffer.prototype.putString = function (r) {
        return this.putBytes(r, "utf16")
      };
      ue.DataBuffer.prototype.putInt16 = function (r) {
        return this.accommodate(2), this.data.setInt16(this.write, r), this.write += 2, this
      };
      ue.DataBuffer.prototype.putInt24 = function (r) {
        return this.accommodate(3), this.data.setInt16(this.write, r >> 8 & 65535), this.data.setInt8(this.write, r >> 16 & 255), this.write += 3, this
      };
      ue.DataBuffer.prototype.putInt32 = function (r) {
        return this.accommodate(4), this.data.setInt32(this.write, r), this.write += 4, this
      };
      ue.DataBuffer.prototype.putInt16Le = function (r) {
        return this.accommodate(2), this.data.setInt16(this.write, r, !0), this.write += 2, this
      };
      ue.DataBuffer.prototype.putInt24Le = function (r) {
        return this.accommodate(3), this.data.setInt8(this.write, r >> 16 & 255), this.data.setInt16(this.write, r >> 8 & 65535, !0), this.write += 3, this
      };
      ue.DataBuffer.prototype.putInt32Le = function (r) {
        return this.accommodate(4), this.data.setInt32(this.write, r, !0), this.write += 4, this
      };
      ue.DataBuffer.prototype.putInt = function (r, e) {
        M1(e), this.accommodate(e / 8);
        do e -= 8, this.data.setInt8(this.write++, r >> e & 255); while (e > 0);
        return this
      };
      ue.DataBuffer.prototype.putSignedInt = function (r, e) {
        return M1(e), this.accommodate(e / 8), r < 0 && (r += 2 << e - 1), this.putInt(r, e)
      };
      ue.DataBuffer.prototype.getByte = function () {
        return this.data.getInt8(this.read++)
      };
      ue.DataBuffer.prototype.getInt16 = function () {
        var r = this.data.getInt16(this.read);
        return this.read += 2, r
      };
      ue.DataBuffer.prototype.getInt24 = function () {
        var r = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
        return this.read += 3, r
      };
      ue.DataBuffer.prototype.getInt32 = function () {
        var r = this.data.getInt32(this.read);
        return this.read += 4, r
      };
      ue.DataBuffer.prototype.getInt16Le = function () {
        var r = this.data.getInt16(this.read, !0);
        return this.read += 2, r
      };
      ue.DataBuffer.prototype.getInt24Le = function () {
        var r = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, !0) << 8;
        return this.read += 3, r
      };
      ue.DataBuffer.prototype.getInt32Le = function () {
        var r = this.data.getInt32(this.read, !0);
        return this.read += 4, r
      };
      ue.DataBuffer.prototype.getInt = function (r) {
        M1(r);
        var e = 0;
        do e = (e << 8) + this.data.getInt8(this.read++), r -= 8; while (r > 0);
        return e
      };
      ue.DataBuffer.prototype.getSignedInt = function (r) {
        var e = this.getInt(r),
          t = 2 << r - 2;
        return e >= t && (e -= t << 1), e
      };
      ue.DataBuffer.prototype.getBytes = function (r) {
        var e;
        return r ? (r = Math.min(this.length(), r), e = this.data.slice(this.read, this.read + r), this.read += r) : r === 0 ? e = "" : (e = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), e
      };
      ue.DataBuffer.prototype.bytes = function (r) {
        return typeof r == "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + r)
      };
      ue.DataBuffer.prototype.at = function (r) {
        return this.data.getUint8(this.read + r)
      };
      ue.DataBuffer.prototype.setAt = function (r, e) {
        return this.data.setUint8(r, e), this
      };
      ue.DataBuffer.prototype.last = function () {
        return this.data.getUint8(this.write - 1)
      };
      ue.DataBuffer.prototype.copy = function () {
        return new ue.DataBuffer(this)
      };
      ue.DataBuffer.prototype.compact = function () {
        if (this.read > 0) {
          var r = new Uint8Array(this.data.buffer, this.read),
            e = new Uint8Array(r.byteLength);
          e.set(r), this.data = new DataView(e), this.write -= this.read, this.read = 0
        }
        return this
      };
      ue.DataBuffer.prototype.clear = function () {
        return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this
      };
      ue.DataBuffer.prototype.truncate = function (r) {
        return this.write = Math.max(0, this.length() - r), this.read = Math.min(this.read, this.write), this
      };
      ue.DataBuffer.prototype.toHex = function () {
        for (var r = "", e = this.read; e < this.data.byteLength; ++e) {
          var t = this.data.getUint8(e);
          t < 16 && (r += "0"), r += t.toString(16)
        }
        return r
      };
      ue.DataBuffer.prototype.toString = function (r) {
        var e = new Uint8Array(this.data, this.read, this.length());
        if (r = r || "utf8", r === "binary" || r === "raw") return ue.binary.raw.encode(e);
        if (r === "hex") return ue.binary.hex.encode(e);
        if (r === "base64") return ue.binary.base64.encode(e);
        if (r === "utf8") return ue.text.utf8.decode(e);
        if (r === "utf16") return ue.text.utf16.decode(e);
        throw new Error("Invalid encoding: " + r)
      };
      ue.createBuffer = function (r, e) {
        return e = e || "raw", r !== void 0 && e === "utf8" && (r = ue.encodeUtf8(r)), new ue.ByteBuffer(r)
      };
      ue.fillString = function (r, e) {
        for (var t = ""; e > 0;) e & 1 && (t += r), e >>>= 1, e > 0 && (r += r);
        return t
      };
      ue.xorBytes = function (r, e, t) {
        for (var i = "", n = "", s = "", o = 0, a = 0; t > 0; --t, ++o) n = r.charCodeAt(o) ^ e.charCodeAt(o), a >= 10 && (i += s, s = "", a = 0), s += String.fromCharCode(n), ++a;
        return i += s, i
      };
      ue.hexToBytes = function (r) {
        var e = "",
          t = 0;
        for (r.length & !0 && (t = 1, e += String.fromCharCode(parseInt(r[0], 16))); t < r.length; t += 2) e += String.fromCharCode(parseInt(r.substr(t, 2), 16));
        return e
      };
      ue.bytesToHex = function (r) {
        return ue.createBuffer(r).toHex()
      };
      ue.int32ToBytes = function (r) {
        return String.fromCharCode(r >> 24 & 255) + String.fromCharCode(r >> 16 & 255) + String.fromCharCode(r >> 8 & 255) + String.fromCharCode(r & 255)
      };
      var Bu = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        Du = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51],
        HN = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      ue.encode64 = function (r, e) {
        for (var t = "", i = "", n, s, o, a = 0; a < r.length;) n = r.charCodeAt(a++), s = r.charCodeAt(a++), o = r.charCodeAt(a++), t += Bu.charAt(n >> 2), t += Bu.charAt((n & 3) << 4 | s >> 4), isNaN(s) ? t += "==" : (t += Bu.charAt((s & 15) << 2 | o >> 6), t += isNaN(o) ? "=" : Bu.charAt(o & 63)), e && t.length > e && (i += t.substr(0, e) + `\r
`, t = t.substr(e));
        return i += t, i
      };
      ue.decode64 = function (r) {
        r = r.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        for (var e = "", t, i, n, s, o = 0; o < r.length;) t = Du[r.charCodeAt(o++) - 43], i = Du[r.charCodeAt(o++) - 43], n = Du[r.charCodeAt(o++) - 43], s = Du[r.charCodeAt(o++) - 43], e += String.fromCharCode(t << 2 | i >> 4), n !== 64 && (e += String.fromCharCode((i & 15) << 4 | n >> 2), s !== 64 && (e += String.fromCharCode((n & 3) << 6 | s)));
        return e
      };
      ue.encodeUtf8 = function (r) {
        return unescape(encodeURIComponent(r))
      };
      ue.decodeUtf8 = function (r) {
        return decodeURIComponent(escape(r))
      };
      ue.binary = {
        raw: {},
        hex: {},
        base64: {},
        base58: {},
        baseN: {
          encode: VN.encode,
          decode: VN.decode
        }
      };
      ue.binary.raw.encode = function (r) {
        return String.fromCharCode.apply(null, r)
      };
      ue.binary.raw.decode = function (r, e, t) {
        var i = e;
        i || (i = new Uint8Array(r.length)), t = t || 0;
        for (var n = t, s = 0; s < r.length; ++s) i[n++] = r.charCodeAt(s);
        return e ? n - t : i
      };
      ue.binary.hex.encode = ue.bytesToHex;
      ue.binary.hex.decode = function (r, e, t) {
        var i = e;
        i || (i = new Uint8Array(Math.ceil(r.length / 2))), t = t || 0;
        var n = 0,
          s = t;
        for (r.length & 1 && (n = 1, i[s++] = parseInt(r[0], 16)); n < r.length; n += 2) i[s++] = parseInt(r.substr(n, 2), 16);
        return e ? s - t : i
      };
      ue.binary.base64.encode = function (r, e) {
        for (var t = "", i = "", n, s, o, a = 0; a < r.byteLength;) n = r[a++], s = r[a++], o = r[a++], t += Bu.charAt(n >> 2), t += Bu.charAt((n & 3) << 4 | s >> 4), isNaN(s) ? t += "==" : (t += Bu.charAt((s & 15) << 2 | o >> 6), t += isNaN(o) ? "=" : Bu.charAt(o & 63)), e && t.length > e && (i += t.substr(0, e) + `\r
`, t = t.substr(e));
        return i += t, i
      };
      ue.binary.base64.decode = function (r, e, t) {
        var i = e;
        i || (i = new Uint8Array(Math.ceil(r.length / 4) * 3)), r = r.replace(/[^A-Za-z0-9\+\/\=]/g, ""), t = t || 0;
        for (var n, s, o, a, c = 0, u = t; c < r.length;) n = Du[r.charCodeAt(c++) - 43], s = Du[r.charCodeAt(c++) - 43], o = Du[r.charCodeAt(c++) - 43], a = Du[r.charCodeAt(c++) - 43], i[u++] = n << 2 | s >> 4, o !== 64 && (i[u++] = (s & 15) << 4 | o >> 2, a !== 64 && (i[u++] = (o & 3) << 6 | a));
        return e ? u - t : i.subarray(0, u)
      };
      ue.binary.base58.encode = function (r, e) {
        return ue.binary.baseN.encode(r, HN, e)
      };
      ue.binary.base58.decode = function (r, e) {
        return ue.binary.baseN.decode(r, HN, e)
      };
      ue.text = {
        utf8: {},
        utf16: {}
      };
      ue.text.utf8.encode = function (r, e, t) {
        r = ue.encodeUtf8(r);
        var i = e;
        i || (i = new Uint8Array(r.length)), t = t || 0;
        for (var n = t, s = 0; s < r.length; ++s) i[n++] = r.charCodeAt(s);
        return e ? n - t : i
      };
      ue.text.utf8.decode = function (r) {
        return ue.decodeUtf8(String.fromCharCode.apply(null, r))
      };
      ue.text.utf16.encode = function (r, e, t) {
        var i = e;
        i || (i = new Uint8Array(r.length * 2));
        var n = new Uint16Array(i.buffer);
        t = t || 0;
        for (var s = t, o = t, a = 0; a < r.length; ++a) n[o++] = r.charCodeAt(a), s += 2;
        return e ? s - t : i
      };
      ue.text.utf16.decode = function (r) {
        return String.fromCharCode.apply(null, new Uint16Array(r.buffer))
      };
      ue.deflate = function (r, e, t) {
        if (e = ue.decode64(r.deflate(ue.encode64(e)).rval), t) {
          var i = 2,
            n = e.charCodeAt(1);
          n & 32 && (i = 6), e = e.substring(i, e.length - 4)
        }
        return e
      };
      ue.inflate = function (r, e, t) {
        var i = r.inflate(ue.encode64(e)).rval;
        return i === null ? null : ue.decode64(i)
      };
      var DE = function (r, e, t) {
        if (!r) throw new Error("WebStorage not available.");
        var i;
        if (t === null ? i = r.removeItem(e) : (t = ue.encode64(JSON.stringify(t)), i = r.setItem(e, t)), typeof i != "undefined" && i.rval !== !0) {
          var n = new Error(i.error.message);
          throw n.id = i.error.id, n.name = i.error.name, n
        }
      },
        LE = function (r, e) {
          if (!r) throw new Error("WebStorage not available.");
          var t = r.getItem(e);
          if (r.init)
            if (t.rval === null) {
              if (t.error) {
                var i = new Error(t.error.message);
                throw i.id = t.error.id, i.name = t.error.name, i
              }
              t = null
            } else t = t.rval;
          return t !== null && (t = JSON.parse(ue.decode64(t))), t
        },
        V5e = function (r, e, t, i) {
          var n = LE(r, e);
          n === null && (n = {}), n[t] = i, DE(r, e, n)
        },
        H5e = function (r, e, t) {
          var i = LE(r, e);
          return i !== null && (i = t in i ? i[t] : null), i
        },
        G5e = function (r, e, t) {
          var i = LE(r, e);
          if (i !== null && t in i) {
            delete i[t];
            var n = !0;
            for (var s in i) {
              n = !1;
              break
            }
            n && (i = null), DE(r, e, i)
          }
        },
        $5e = function (r, e) {
          DE(r, e, null)
        },
        Jm = function (r, e, t) {
          var i = null;
          typeof t == "undefined" && (t = ["web", "flash"]);
          var n, s = !1,
            o = null;
          for (var a in t) {
            n = t[a];
            try {
              if (n === "flash" || n === "both") {
                if (e[0] === null) throw new Error("Flash local storage not available.");
                i = r.apply(this, e), s = n === "flash"
              } (n === "web" || n === "both") && (e[0] = localStorage, i = r.apply(this, e), s = !0)
            } catch (c) {
              o = c
            }
            if (s) break
          }
          if (!s) throw o;
          return i
        };
      ue.setItem = function (r, e, t, i, n) {
        Jm(V5e, arguments, n)
      };
      ue.getItem = function (r, e, t, i) {
        return Jm(H5e, arguments, i)
      };
      ue.removeItem = function (r, e, t, i) {
        Jm(G5e, arguments, i)
      };
      ue.clearItems = function (r, e, t) {
        Jm($5e, arguments, t)
      };
      ue.parseUrl = function (r) {
        var e = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
        e.lastIndex = 0;
        var t = e.exec(r),
          i = t === null ? null : {
            full: r,
            scheme: t[1],
            host: t[2],
            port: t[3],
            path: t[4]
          };
        return i && (i.fullHost = i.host, i.port ? (i.port !== 80 && i.scheme === "http" || i.port !== 443 && i.scheme === "https") && (i.fullHost += ":" + i.port) : i.scheme === "http" ? i.port = 80 : i.scheme === "https" && (i.port = 443), i.full = i.scheme + "://" + i.fullHost), i
      };
      var Xm = null;
      ue.getQueryVariables = function (r) {
        var e = function (i) {
          for (var n = {}, s = i.split("&"), o = 0; o < s.length; o++) {
            var a = s[o].indexOf("="),
              c, u;
            a > 0 ? (c = s[o].substring(0, a), u = s[o].substring(a + 1)) : (c = s[o], u = null), c in n || (n[c] = []), !(c in Object.prototype) && u !== null && n[c].push(unescape(u))
          }
          return n
        },
          t;
        return typeof r == "undefined" ? (Xm === null && (typeof window != "undefined" && window.location && window.location.search ? Xm = e(window.location.search.substring(1)) : Xm = {}), t = Xm) : t = e(r), t
      };
      ue.parseFragment = function (r) {
        var e = r,
          t = "",
          i = r.indexOf("?");
        i > 0 && (e = r.substring(0, i), t = r.substring(i + 1));
        var n = e.split("/");
        n.length > 0 && n[0] === "" && n.shift();
        var s = t === "" ? {} : ue.getQueryVariables(t);
        return {
          pathString: e,
          queryString: t,
          path: n,
          query: s
        }
      };
      ue.makeRequest = function (r) {
        var e = ue.parseFragment(r),
          t = {
            path: e.pathString,
            query: e.queryString,
            getPath: function (i) {
              return typeof i == "undefined" ? e.path : e.path[i]
            },
            getQuery: function (i, n) {
              var s;
              return typeof i == "undefined" ? s = e.query : (s = e.query[i], s && typeof n != "undefined" && (s = s[n])), s
            },
            getQueryLast: function (i, n) {
              var s, o = t.getQuery(i);
              return o ? s = o[o.length - 1] : s = n, s
            }
          };
        return t
      };
      ue.makeLink = function (r, e, t) {
        r = jQuery.isArray(r) ? r.join("/") : r;
        var i = jQuery.param(e || {});
        return t = t || "", r + (i.length > 0 ? "?" + i : "") + (t.length > 0 ? "#" + t : "")
      };
      ue.isEmpty = function (r) {
        for (var e in r)
          if (r.hasOwnProperty(e)) return !1;
        return !0
      };
      ue.format = function (r) {
        for (var e = /%./g, t, i, n = 0, s = [], o = 0; t = e.exec(r);) {
          i = r.substring(o, e.lastIndex - 2), i.length > 0 && s.push(i), o = e.lastIndex;
          var a = t[0][1];
          switch (a) {
            case "s":
            case "o":
              n < arguments.length ? s.push(arguments[n++ + 1]) : s.push("<?>");
              break;
            case "%":
              s.push("%");
              break;
            default:
              s.push("<%" + a + "?>")
          }
        }
        return s.push(r.substring(o)), s.join("")
      };
      ue.formatNumber = function (r, e, t, i) {
        var n = r,
          s = isNaN(e = Math.abs(e)) ? 2 : e,
          o = t === void 0 ? "," : t,
          a = i === void 0 ? "." : i,
          c = n < 0 ? "-" : "",
          u = parseInt(n = Math.abs(+n || 0).toFixed(s), 10) + "",
          f = u.length > 3 ? u.length % 3 : 0;
        return c + (f ? u.substr(0, f) + a : "") + u.substr(f).replace(/(\d{3})(?=\d)/g, "$1" + a) + (s ? o + Math.abs(n - u).toFixed(s).slice(2) : "")
      };
      ue.formatSize = function (r) {
        return r >= 1073741824 ? r = ue.formatNumber(r / 1073741824, 2, ".", "") + " GiB" : r >= 1048576 ? r = ue.formatNumber(r / 1048576, 2, ".", "") + " MiB" : r >= 1024 ? r = ue.formatNumber(r / 1024, 0) + " KiB" : r = ue.formatNumber(r, 0) + " bytes", r
      };
      ue.bytesFromIP = function (r) {
        return r.indexOf(".") !== -1 ? ue.bytesFromIPv4(r) : r.indexOf(":") !== -1 ? ue.bytesFromIPv6(r) : null
      };
      ue.bytesFromIPv4 = function (r) {
        if (r = r.split("."), r.length !== 4) return null;
        for (var e = ue.createBuffer(), t = 0; t < r.length; ++t) {
          var i = parseInt(r[t], 10);
          if (isNaN(i)) return null;
          e.putByte(i)
        }
        return e.getBytes()
      };
      ue.bytesFromIPv6 = function (r) {
        var e = 0;
        r = r.split(":").filter(function (o) {
          return o.length === 0 && ++e, !0
        });
        for (var t = (8 - r.length + e) * 2, i = ue.createBuffer(), n = 0; n < 8; ++n) {
          if (!r[n] || r[n].length === 0) {
            i.fillWithByte(0, t), t = 0;
            continue
          }
          var s = ue.hexToBytes(r[n]);
          s.length < 2 && i.putByte(0), i.putBytes(s)
        }
        return i.getBytes()
      };
      ue.bytesToIP = function (r) {
        return r.length === 4 ? ue.bytesToIPv4(r) : r.length === 16 ? ue.bytesToIPv6(r) : null
      };
      ue.bytesToIPv4 = function (r) {
        if (r.length !== 4) return null;
        for (var e = [], t = 0; t < r.length; ++t) e.push(r.charCodeAt(t));
        return e.join(".")
      };
      ue.bytesToIPv6 = function (r) {
        if (r.length !== 16) return null;
        for (var e = [], t = [], i = 0, n = 0; n < r.length; n += 2) {
          for (var s = ue.bytesToHex(r[n] + r[n + 1]); s[0] === "0" && s !== "0";) s = s.substr(1);
          if (s === "0") {
            var o = t[t.length - 1],
              a = e.length;
            !o || a !== o.end + 1 ? t.push({
              start: a,
              end: a
            }) : (o.end = a, o.end - o.start > t[i].end - t[i].start && (i = t.length - 1))
          }
          e.push(s)
        }
        if (t.length > 0) {
          var c = t[i];
          c.end - c.start > 0 && (e.splice(c.start, c.end - c.start + 1, ""), c.start === 0 && e.unshift(""), c.end === 7 && e.push(""))
        }
        return e.join(":")
      };
      ue.estimateCores = function (r, e) {
        if (typeof r == "function" && (e = r, r = {}), r = r || {}, "cores" in ue && !r.update) return e(null, ue.cores);
        if (typeof navigator != "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) return ue.cores = navigator.hardwareConcurrency, e(null, ue.cores);
        if (typeof Worker == "undefined") return ue.cores = 1, e(null, ue.cores);
        if (typeof Blob == "undefined") return ue.cores = 2, e(null, ue.cores);
        var t = URL.createObjectURL(new Blob(["(", function () {
          self.addEventListener("message", function (o) {
            for (var a = Date.now(), c = a + 4; Date.now() < c;);
            self.postMessage({
              st: a,
              et: c
            })
          })
        }.toString(), ")()"], {
          type: "application/javascript"
        }));
        i([], 5, 16);

        function i(o, a, c) {
          if (a === 0) {
            var u = Math.floor(o.reduce(function (f, h) {
              return f + h
            }, 0) / o.length);
            return ue.cores = Math.max(1, u), URL.revokeObjectURL(t), e(null, ue.cores)
          }
          n(c, function (f, h) {
            o.push(s(c, h)), i(o, a - 1, c)
          })
        }

        function n(o, a) {
          for (var c = [], u = [], f = 0; f < o; ++f) {
            var h = new Worker(t);
            h.addEventListener("message", function (d) {
              if (u.push(d.data), u.length === o) {
                for (var p = 0; p < o; ++p) c[p].terminate();
                a(null, u)
              }
            }), c.push(h)
          }
          for (var f = 0; f < o; ++f) c[f].postMessage(f)
        }

        function s(o, a) {
          for (var c = [], u = 0; u < o; ++u)
            for (var f = a[u], h = c[u] = [], d = 0; d < o; ++d)
              if (u !== d) {
                var p = a[d];
                (f.st > p.st && f.st < p.et || p.st > f.st && p.st < f.et) && h.push(d)
              } return c.reduce(function (g, m) {
                return Math.max(g, m.length)
              }, 0)
        }
      }
    });
    var sd = y((tbt, GN) => {
      l();
      var B1 = At();
      B1.pki = B1.pki || {};
      var FE = GN.exports = B1.pki.oids = B1.oids = B1.oids || {};

      function qe(r, e) {
        FE[r] = e, FE[e] = r
      }

      function ur(r, e) {
        FE[r] = e
      }
      qe("1.2.840.113549.1.1.1", "rsaEncryption");
      qe("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
      qe("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
      qe("1.2.840.113549.1.1.7", "RSAES-OAEP");
      qe("1.2.840.113549.1.1.8", "mgf1");
      qe("1.2.840.113549.1.1.9", "pSpecified");
      qe("1.2.840.113549.1.1.10", "RSASSA-PSS");
      qe("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
      qe("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
      qe("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
      qe("1.3.101.112", "EdDSA25519");
      qe("1.2.840.10040.4.3", "dsa-with-sha1");
      qe("1.3.14.3.2.7", "desCBC");
      qe("1.3.14.3.2.26", "sha1");
      qe("2.16.840.1.101.3.4.2.1", "sha256");
      qe("2.16.840.1.101.3.4.2.2", "sha384");
      qe("2.16.840.1.101.3.4.2.3", "sha512");
      qe("1.2.840.113549.2.5", "md5");
      qe("1.2.840.113549.1.7.1", "data");
      qe("1.2.840.113549.1.7.2", "signedData");
      qe("1.2.840.113549.1.7.3", "envelopedData");
      qe("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
      qe("1.2.840.113549.1.7.5", "digestedData");
      qe("1.2.840.113549.1.7.6", "encryptedData");
      qe("1.2.840.113549.1.9.1", "emailAddress");
      qe("1.2.840.113549.1.9.2", "unstructuredName");
      qe("1.2.840.113549.1.9.3", "contentType");
      qe("1.2.840.113549.1.9.4", "messageDigest");
      qe("1.2.840.113549.1.9.5", "signingTime");
      qe("1.2.840.113549.1.9.6", "counterSignature");
      qe("1.2.840.113549.1.9.7", "challengePassword");
      qe("1.2.840.113549.1.9.8", "unstructuredAddress");
      qe("1.2.840.113549.1.9.14", "extensionRequest");
      qe("1.2.840.113549.1.9.20", "friendlyName");
      qe("1.2.840.113549.1.9.21", "localKeyId");
      qe("1.2.840.113549.1.9.22.1", "x509Certificate");
      qe("1.2.840.113549.1.12.10.1.1", "keyBag");
      qe("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
      qe("1.2.840.113549.1.12.10.1.3", "certBag");
      qe("1.2.840.113549.1.12.10.1.4", "crlBag");
      qe("1.2.840.113549.1.12.10.1.5", "secretBag");
      qe("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
      qe("1.2.840.113549.1.5.13", "pkcs5PBES2");
      qe("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
      qe("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
      qe("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
      qe("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
      qe("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
      qe("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
      qe("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
      qe("1.2.840.113549.2.7", "hmacWithSHA1");
      qe("1.2.840.113549.2.8", "hmacWithSHA224");
      qe("1.2.840.113549.2.9", "hmacWithSHA256");
      qe("1.2.840.113549.2.10", "hmacWithSHA384");
      qe("1.2.840.113549.2.11", "hmacWithSHA512");
      qe("1.2.840.113549.3.7", "des-EDE3-CBC");
      qe("2.16.840.1.101.3.4.1.2", "aes128-CBC");
      qe("2.16.840.1.101.3.4.1.22", "aes192-CBC");
      qe("2.16.840.1.101.3.4.1.42", "aes256-CBC");
      qe("2.5.4.3", "commonName");
      qe("2.5.4.5", "serialName");
      qe("2.5.4.6", "countryName");
      qe("2.5.4.7", "localityName");
      qe("2.5.4.8", "stateOrProvinceName");
      qe("2.5.4.9", "streetAddress");
      qe("2.5.4.10", "organizationName");
      qe("2.5.4.11", "organizationalUnitName");
      qe("2.5.4.13", "description");
      qe("2.5.4.15", "businessCategory");
      qe("2.5.4.17", "postalCode");
      qe("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
      qe("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
      qe("2.16.840.1.113730.1.1", "nsCertType");
      qe("2.16.840.1.113730.1.13", "nsComment");
      ur("2.5.29.1", "authorityKeyIdentifier");
      ur("2.5.29.2", "keyAttributes");
      ur("2.5.29.3", "certificatePolicies");
      ur("2.5.29.4", "keyUsageRestriction");
      ur("2.5.29.5", "policyMapping");
      ur("2.5.29.6", "subtreesConstraint");
      ur("2.5.29.7", "subjectAltName");
      ur("2.5.29.8", "issuerAltName");
      ur("2.5.29.9", "subjectDirectoryAttributes");
      ur("2.5.29.10", "basicConstraints");
      ur("2.5.29.11", "nameConstraints");
      ur("2.5.29.12", "policyConstraints");
      ur("2.5.29.13", "basicConstraints");
      qe("2.5.29.14", "subjectKeyIdentifier");
      qe("2.5.29.15", "keyUsage");
      ur("2.5.29.16", "privateKeyUsagePeriod");
      qe("2.5.29.17", "subjectAltName");
      qe("2.5.29.18", "issuerAltName");
      qe("2.5.29.19", "basicConstraints");
      ur("2.5.29.20", "cRLNumber");
      ur("2.5.29.21", "cRLReason");
      ur("2.5.29.22", "expirationDate");
      ur("2.5.29.23", "instructionCode");
      ur("2.5.29.24", "invalidityDate");
      ur("2.5.29.25", "cRLDistributionPoints");
      ur("2.5.29.26", "issuingDistributionPoint");
      ur("2.5.29.27", "deltaCRLIndicator");
      ur("2.5.29.28", "issuingDistributionPoint");
      ur("2.5.29.29", "certificateIssuer");
      ur("2.5.29.30", "nameConstraints");
      qe("2.5.29.31", "cRLDistributionPoints");
      qe("2.5.29.32", "certificatePolicies");
      ur("2.5.29.33", "policyMappings");
      ur("2.5.29.34", "policyConstraints");
      qe("2.5.29.35", "authorityKeyIdentifier");
      ur("2.5.29.36", "policyConstraints");
      qe("2.5.29.37", "extKeyUsage");
      ur("2.5.29.46", "freshestCRL");
      ur("2.5.29.54", "inhibitAnyPolicy");
      qe("1.3.6.1.4.1.11129.2.4.2", "timestampList");
      qe("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
      qe("1.3.6.1.5.5.7.3.1", "serverAuth");
      qe("1.3.6.1.5.5.7.3.2", "clientAuth");
      qe("1.3.6.1.5.5.7.3.3", "codeSigning");
      qe("1.3.6.1.5.5.7.3.4", "emailProtection");
      qe("1.3.6.1.5.5.7.3.8", "timeStamping")
    });
    var Bc = y((rbt, $N) => {
      l();
      var Fr = At();
      wr();
      sd();
      var Je = $N.exports = Fr.asn1 = Fr.asn1 || {};
      Je.Class = {
        UNIVERSAL: 0,
        APPLICATION: 64,
        CONTEXT_SPECIFIC: 128,
        PRIVATE: 192
      };
      Je.Type = {
        NONE: 0,
        BOOLEAN: 1,
        INTEGER: 2,
        BITSTRING: 3,
        OCTETSTRING: 4,
        NULL: 5,
        OID: 6,
        ODESC: 7,
        EXTERNAL: 8,
        REAL: 9,
        ENUMERATED: 10,
        EMBEDDED: 11,
        UTF8: 12,
        ROID: 13,
        SEQUENCE: 16,
        SET: 17,
        PRINTABLESTRING: 19,
        IA5STRING: 22,
        UTCTIME: 23,
        GENERALIZEDTIME: 24,
        BMPSTRING: 30
      };
      Je.create = function (r, e, t, i, n) {
        if (Fr.util.isArray(i)) {
          for (var s = [], o = 0; o < i.length; ++o) i[o] !== void 0 && s.push(i[o]);
          i = s
        }
        var a = {
          tagClass: r,
          type: e,
          constructed: t,
          composed: t || Fr.util.isArray(i),
          value: i
        };
        return n && "bitStringContents" in n && (a.bitStringContents = n.bitStringContents, a.original = Je.copy(a)), a
      };
      Je.copy = function (r, e) {
        var t;
        if (Fr.util.isArray(r)) {
          t = [];
          for (var i = 0; i < r.length; ++i) t.push(Je.copy(r[i], e));
          return t
        }
        return typeof r == "string" ? r : (t = {
          tagClass: r.tagClass,
          type: r.type,
          constructed: r.constructed,
          composed: r.composed,
          value: Je.copy(r.value, e)
        }, e && !e.excludeBitStringContents && (t.bitStringContents = r.bitStringContents), t)
      };
      Je.equals = function (r, e, t) {
        if (Fr.util.isArray(r)) {
          if (!Fr.util.isArray(e) || r.length !== e.length) return !1;
          for (var i = 0; i < r.length; ++i)
            if (!Je.equals(r[i], e[i])) return !1;
          return !0
        }
        if (typeof r != typeof e) return !1;
        if (typeof r == "string") return r === e;
        var n = r.tagClass === e.tagClass && r.type === e.type && r.constructed === e.constructed && r.composed === e.composed && Je.equals(r.value, e.value);
        return t && t.includeBitStringContents && (n = n && r.bitStringContents === e.bitStringContents), n
      };
      Je.getBerValueLength = function (r) {
        var e = r.getByte();
        if (e !== 128) {
          var t, i = e & 128;
          return i ? t = r.getInt((e & 127) << 3) : t = e, t
        }
      };

      function D1(r, e, t) {
        if (t > e) {
          var i = new Error("Too few bytes to parse DER.");
          throw i.available = r.length(), i.remaining = e, i.requested = t, i
        }
      }
      var W5e = function (r, e) {
        var t = r.getByte();
        if (e--, t !== 128) {
          var i, n = t & 128;
          if (!n) i = t;
          else {
            var s = t & 127;
            D1(r, e, s), i = r.getInt(s << 3)
          }
          if (i < 0) throw new Error("Negative length: " + i);
          return i
        }
      };
      Je.fromDer = function (r, e) {
        return e === void 0 && (e = {
          strict: !0,
          decodeBitStrings: !0
        }), typeof e == "boolean" && (e = {
          strict: e,
          decodeBitStrings: !0
        }), "strict" in e || (e.strict = !0), "decodeBitStrings" in e || (e.decodeBitStrings = !0), typeof r == "string" && (r = Fr.util.createBuffer(r)), Zm(r, r.length(), 0, e)
      };

      function Zm(r, e, t, i) {
        var n;
        D1(r, e, 2);
        var s = r.getByte();
        e--;
        var o = s & 192,
          a = s & 31;
        n = r.length();
        var c = W5e(r, e);
        if (e -= n - r.length(), c !== void 0 && c > e) {
          if (i.strict) {
            var u = new Error("Too few bytes to read ASN.1 value.");
            throw u.available = r.length(), u.remaining = e, u.requested = c, u
          }
          c = e
        }
        var f, h, d = (s & 32) == 32;
        if (d)
          if (f = [], c === void 0)
            for (; ;) {
              if (D1(r, e, 2), r.bytes(2) === String.fromCharCode(0, 0)) {
                r.getBytes(2), e -= 2;
                break
              }
              n = r.length(), f.push(Zm(r, e, t + 1, i)), e -= n - r.length()
            } else
            for (; c > 0;) n = r.length(), f.push(Zm(r, c, t + 1, i)), e -= n - r.length(), c -= n - r.length();
        if (f === void 0 && o === Je.Class.UNIVERSAL && a === Je.Type.BITSTRING && (h = r.bytes(c)), f === void 0 && i.decodeBitStrings && o === Je.Class.UNIVERSAL && a === Je.Type.BITSTRING && c > 1) {
          var p = r.read,
            g = e,
            m = 0;
          if (a === Je.Type.BITSTRING && (D1(r, e, 1), m = r.getByte(), e--), m === 0) try {
            n = r.length();
            var E = {
              verbose: i.verbose,
              strict: !0,
              decodeBitStrings: !0
            },
              w = Zm(r, e, t + 1, E),
              O = n - r.length();
            e -= O, a == Je.Type.BITSTRING && O++;
            var q = w.tagClass;
            O === c && (q === Je.Class.UNIVERSAL || q === Je.Class.CONTEXT_SPECIFIC) && (f = [w])
          } catch (Z) { }
          f === void 0 && (r.read = p, e = g)
        }
        if (f === void 0) {
          if (c === void 0) {
            if (i.strict) throw new Error("Non-constructed ASN.1 object of indefinite length.");
            c = e
          }
          if (a === Je.Type.BMPSTRING)
            for (f = ""; c > 0; c -= 2) D1(r, e, 2), f += String.fromCharCode(r.getInt16()), e -= 2;
          else f = r.getBytes(c)
        }
        var J = h === void 0 ? null : {
          bitStringContents: h
        };
        return Je.create(o, a, d, f, J)
      }
      Je.toDer = function (r) {
        var e = Fr.util.createBuffer(),
          t = r.tagClass | r.type,
          i = Fr.util.createBuffer(),
          n = !1;
        if ("bitStringContents" in r && (n = !0, r.original && (n = Je.equals(r, r.original))), n) i.putBytes(r.bitStringContents);
        else if (r.composed) {
          r.constructed ? t |= 32 : i.putByte(0);
          for (var s = 0; s < r.value.length; ++s) r.value[s] !== void 0 && i.putBuffer(Je.toDer(r.value[s]))
        } else if (r.type === Je.Type.BMPSTRING)
          for (var s = 0; s < r.value.length; ++s) i.putInt16(r.value.charCodeAt(s));
        else r.type === Je.Type.INTEGER && r.value.length > 1 && (r.value.charCodeAt(0) === 0 && (r.value.charCodeAt(1) & 128) == 0 || r.value.charCodeAt(0) === 255 && (r.value.charCodeAt(1) & 128) == 128) ? i.putBytes(r.value.substr(1)) : i.putBytes(r.value);
        if (e.putByte(t), i.length() <= 127) e.putByte(i.length() & 127);
        else {
          var o = i.length(),
            a = "";
          do a += String.fromCharCode(o & 255), o = o >>> 8; while (o > 0);
          e.putByte(a.length | 128);
          for (var s = a.length - 1; s >= 0; --s) e.putByte(a.charCodeAt(s))
        }
        return e.putBuffer(i), e
      };
      Je.oidToDer = function (r) {
        var e = r.split("."),
          t = Fr.util.createBuffer();
        t.putByte(40 * parseInt(e[0], 10) + parseInt(e[1], 10));
        for (var i, n, s, o, a = 2; a < e.length; ++a) {
          i = !0, n = [], s = parseInt(e[a], 10);
          do o = s & 127, s = s >>> 7, i || (o |= 128), n.push(o), i = !1; while (s > 0);
          for (var c = n.length - 1; c >= 0; --c) t.putByte(n[c])
        }
        return t
      };
      Je.derToOid = function (r) {
        var e;
        typeof r == "string" && (r = Fr.util.createBuffer(r));
        var t = r.getByte();
        e = Math.floor(t / 40) + "." + t % 40;
        for (var i = 0; r.length() > 0;) t = r.getByte(), i = i << 7, t & 128 ? i += t & 127 : (e += "." + (i + t), i = 0);
        return e
      };
      Je.utcTimeToDate = function (r) {
        var e = new Date,
          t = parseInt(r.substr(0, 2), 10);
        t = t >= 50 ? 1900 + t : 2e3 + t;
        var i = parseInt(r.substr(2, 2), 10) - 1,
          n = parseInt(r.substr(4, 2), 10),
          s = parseInt(r.substr(6, 2), 10),
          o = parseInt(r.substr(8, 2), 10),
          a = 0;
        if (r.length > 11) {
          var c = r.charAt(10),
            u = 10;
          c !== "+" && c !== "-" && (a = parseInt(r.substr(10, 2), 10), u += 2)
        }
        if (e.setUTCFullYear(t, i, n), e.setUTCHours(s, o, a, 0), u && (c = r.charAt(u), c === "+" || c === "-")) {
          var f = parseInt(r.substr(u + 1, 2), 10),
            h = parseInt(r.substr(u + 4, 2), 10),
            d = f * 60 + h;
          d *= 6e4, c === "+" ? e.setTime(+e - d) : e.setTime(+e + d)
        }
        return e
      };
      Je.generalizedTimeToDate = function (r) {
        var e = new Date,
          t = parseInt(r.substr(0, 4), 10),
          i = parseInt(r.substr(4, 2), 10) - 1,
          n = parseInt(r.substr(6, 2), 10),
          s = parseInt(r.substr(8, 2), 10),
          o = parseInt(r.substr(10, 2), 10),
          a = parseInt(r.substr(12, 2), 10),
          c = 0,
          u = 0,
          f = !1;
        r.charAt(r.length - 1) === "Z" && (f = !0);
        var h = r.length - 5,
          d = r.charAt(h);
        if (d === "+" || d === "-") {
          var p = parseInt(r.substr(h + 1, 2), 10),
            g = parseInt(r.substr(h + 4, 2), 10);
          u = p * 60 + g, u *= 6e4, d === "+" && (u *= -1), f = !0
        }
        return r.charAt(14) === "." && (c = parseFloat(r.substr(14), 10) * 1e3), f ? (e.setUTCFullYear(t, i, n), e.setUTCHours(s, o, a, c), e.setTime(+e + u)) : (e.setFullYear(t, i, n), e.setHours(s, o, a, c)), e
      };
      Je.dateToUtcTime = function (r) {
        if (typeof r == "string") return r;
        var e = "",
          t = [];
        t.push(("" + r.getUTCFullYear()).substr(2)), t.push("" + (r.getUTCMonth() + 1)), t.push("" + r.getUTCDate()), t.push("" + r.getUTCHours()), t.push("" + r.getUTCMinutes()), t.push("" + r.getUTCSeconds());
        for (var i = 0; i < t.length; ++i) t[i].length < 2 && (e += "0"), e += t[i];
        return e += "Z", e
      };
      Je.dateToGeneralizedTime = function (r) {
        if (typeof r == "string") return r;
        var e = "",
          t = [];
        t.push("" + r.getUTCFullYear()), t.push("" + (r.getUTCMonth() + 1)), t.push("" + r.getUTCDate()), t.push("" + r.getUTCHours()), t.push("" + r.getUTCMinutes()), t.push("" + r.getUTCSeconds());
        for (var i = 0; i < t.length; ++i) t[i].length < 2 && (e += "0"), e += t[i];
        return e += "Z", e
      };
      Je.integerToDer = function (r) {
        var e = Fr.util.createBuffer();
        if (r >= -128 && r < 128) return e.putSignedInt(r, 8);
        if (r >= -32768 && r < 32768) return e.putSignedInt(r, 16);
        if (r >= -8388608 && r < 8388608) return e.putSignedInt(r, 24);
        if (r >= -2147483648 && r < 2147483648) return e.putSignedInt(r, 32);
        var t = new Error("Integer too large; max is 32-bits.");
        throw t.integer = r, t
      };
      Je.derToInteger = function (r) {
        typeof r == "string" && (r = Fr.util.createBuffer(r));
        var e = r.length() * 8;
        if (e > 32) throw new Error("Integer too large; max is 32-bits.");
        return r.getSignedInt(e)
      };
      Je.validate = function (r, e, t, i) {
        var n = !1;
        if ((r.tagClass === e.tagClass || typeof e.tagClass == "undefined") && (r.type === e.type || typeof e.type == "undefined"))
          if (r.constructed === e.constructed || typeof e.constructed == "undefined") {
            if (n = !0, e.value && Fr.util.isArray(e.value))
              for (var s = 0, o = 0; n && o < e.value.length; ++o) n = e.value[o].optional || !1, r.value[s] && (n = Je.validate(r.value[s], e.value[o], t, i), n ? ++s : e.value[o].optional && (n = !0)), !n && i && i.push("[" + e.name + '] Tag class "' + e.tagClass + '", type "' + e.type + '" expected value length "' + e.value.length + '", got "' + r.value.length + '"');
            if (n && t && (e.capture && (t[e.capture] = r.value), e.captureAsn1 && (t[e.captureAsn1] = r), e.captureBitStringContents && "bitStringContents" in r && (t[e.captureBitStringContents] = r.bitStringContents), e.captureBitStringValue && "bitStringContents" in r)) {
              var a;
              if (r.bitStringContents.length < 2) t[e.captureBitStringValue] = "";
              else {
                var c = r.bitStringContents.charCodeAt(0);
                if (c !== 0) throw new Error("captureBitStringValue only supported for zero unused bits");
                t[e.captureBitStringValue] = r.bitStringContents.slice(1)
              }
            }
          } else i && i.push("[" + e.name + '] Expected constructed "' + e.constructed + '", got "' + r.constructed + '"');
        else i && (r.tagClass !== e.tagClass && i.push("[" + e.name + '] Expected tag class "' + e.tagClass + '", got "' + r.tagClass + '"'), r.type !== e.type && i.push("[" + e.name + '] Expected type "' + e.type + '", got "' + r.type + '"'));
        return n
      };
      var WN = /[^\\u0000-\\u00ff]/;
      Je.prettyPrint = function (r, e, t) {
        var i = "";
        e = e || 0, t = t || 2, e > 0 && (i += `
`);
        for (var n = "", s = 0; s < e * t; ++s) n += " ";
        switch (i += n + "Tag: ", r.tagClass) {
          case Je.Class.UNIVERSAL:
            i += "Universal:";
            break;
          case Je.Class.APPLICATION:
            i += "Application:";
            break;
          case Je.Class.CONTEXT_SPECIFIC:
            i += "Context-Specific:";
            break;
          case Je.Class.PRIVATE:
            i += "Private:";
            break
        }
        if (r.tagClass === Je.Class.UNIVERSAL) switch (i += r.type, r.type) {
          case Je.Type.NONE:
            i += " (None)";
            break;
          case Je.Type.BOOLEAN:
            i += " (Boolean)";
            break;
          case Je.Type.INTEGER:
            i += " (Integer)";
            break;
          case Je.Type.BITSTRING:
            i += " (Bit string)";
            break;
          case Je.Type.OCTETSTRING:
            i += " (Octet string)";
            break;
          case Je.Type.NULL:
            i += " (Null)";
            break;
          case Je.Type.OID:
            i += " (Object Identifier)";
            break;
          case Je.Type.ODESC:
            i += " (Object Descriptor)";
            break;
          case Je.Type.EXTERNAL:
            i += " (External or Instance of)";
            break;
          case Je.Type.REAL:
            i += " (Real)";
            break;
          case Je.Type.ENUMERATED:
            i += " (Enumerated)";
            break;
          case Je.Type.EMBEDDED:
            i += " (Embedded PDV)";
            break;
          case Je.Type.UTF8:
            i += " (UTF8)";
            break;
          case Je.Type.ROID:
            i += " (Relative Object Identifier)";
            break;
          case Je.Type.SEQUENCE:
            i += " (Sequence)";
            break;
          case Je.Type.SET:
            i += " (Set)";
            break;
          case Je.Type.PRINTABLESTRING:
            i += " (Printable String)";
            break;
          case Je.Type.IA5String:
            i += " (IA5String (ASCII))";
            break;
          case Je.Type.UTCTIME:
            i += " (UTC time)";
            break;
          case Je.Type.GENERALIZEDTIME:
            i += " (Generalized time)";
            break;
          case Je.Type.BMPSTRING:
            i += " (BMP String)";
            break
        } else i += r.type;
        if (i += `
`, i += n + "Constructed: " + r.constructed + `
`, r.composed) {
          for (var o = 0, a = "", s = 0; s < r.value.length; ++s) r.value[s] !== void 0 && (o += 1, a += Je.prettyPrint(r.value[s], e + 1, t), s + 1 < r.value.length && (a += ","));
          i += n + "Sub values: " + o + a
        } else {
          if (i += n + "Value: ", r.type === Je.Type.OID) {
            var c = Je.derToOid(r.value);
            i += c, Fr.pki && Fr.pki.oids && c in Fr.pki.oids && (i += " (" + Fr.pki.oids[c] + ") ")
          }
          if (r.type === Je.Type.INTEGER) try {
            i += Je.derToInteger(r.value)
          } catch (f) {
            i += "0x" + Fr.util.bytesToHex(r.value)
          } else if (r.type === Je.Type.BITSTRING) {
            if (r.value.length > 1 ? i += "0x" + Fr.util.bytesToHex(r.value.slice(1)) : i += "(none)", r.value.length > 0) {
              var u = r.value.charCodeAt(0);
              u == 1 ? i += " (1 unused bit shown)" : u > 1 && (i += " (" + u + " unused bits shown)")
            }
          } else r.type === Je.Type.OCTETSTRING ? (WN.test(r.value) || (i += "(" + r.value + ") "), i += "0x" + Fr.util.bytesToHex(r.value)) : r.type === Je.Type.UTF8 ? i += Fr.util.decodeUtf8(r.value) : r.type === Je.Type.PRINTABLESTRING || r.type === Je.Type.IA5String ? i += r.value : WN.test(r.value) ? i += "0x" + Fr.util.bytesToHex(r.value) : r.value.length === 0 ? i += "[null]" : i += r.value
        }
        return i
      }
    });
    var KE = y((ibt, YN) => {
      l();
      var zi = At();
      wr();
      YN.exports = zi.cipher = zi.cipher || {};
      zi.cipher.algorithms = zi.cipher.algorithms || {};
      zi.cipher.createCipher = function (r, e) {
        var t = r;
        if (typeof t == "string" && (t = zi.cipher.getAlgorithm(t), t && (t = t())), !t) throw new Error("Unsupported algorithm: " + r);
        return new zi.cipher.BlockCipher({
          algorithm: t,
          key: e,
          decrypt: !1
        })
      };
      zi.cipher.createDecipher = function (r, e) {
        var t = r;
        if (typeof t == "string" && (t = zi.cipher.getAlgorithm(t), t && (t = t())), !t) throw new Error("Unsupported algorithm: " + r);
        return new zi.cipher.BlockCipher({
          algorithm: t,
          key: e,
          decrypt: !0
        })
      };
      zi.cipher.registerAlgorithm = function (r, e) {
        r = r.toUpperCase(), zi.cipher.algorithms[r] = e
      };
      zi.cipher.getAlgorithm = function (r) {
        return r = r.toUpperCase(), r in zi.cipher.algorithms ? zi.cipher.algorithms[r] : null
      };
      var UE = zi.cipher.BlockCipher = function (r) {
        this.algorithm = r.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = r.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = r.decrypt, this.algorithm.initialize(r)
      };
      UE.prototype.start = function (r) {
        r = r || {};
        var e = {};
        for (var t in r) e[t] = r[t];
        e.decrypt = this._decrypt, this._finish = !1, this._input = zi.util.createBuffer(), this.output = r.output || zi.util.createBuffer(), this.mode.start(e)
      };
      UE.prototype.update = function (r) {
        for (r && this._input.putBuffer(r); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish;);
        this._input.compact()
      };
      UE.prototype.finish = function (r) {
        r && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function (t) {
          return r(this.blockSize, t, !1)
        }, this.mode.unpad = function (t) {
          return r(this.blockSize, t, !0)
        });
        var e = {};
        return e.decrypt = this._decrypt, e.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, e) || (this._finish = !0, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, e)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, e))
      }
    });
    var jE = y((nbt, JN) => {
      l();
      var ji = At();
      wr();
      ji.cipher = ji.cipher || {};
      var kt = JN.exports = ji.cipher.modes = ji.cipher.modes || {};
      kt.ecb = function (r) {
        r = r || {}, this.name = "ECB", this.cipher = r.cipher, this.blockSize = r.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints)
      };
      kt.ecb.prototype.start = function (r) { };
      kt.ecb.prototype.encrypt = function (r, e, t) {
        if (r.length() < this.blockSize && !(t && r.length() > 0)) return !0;
        for (var i = 0; i < this._ints; ++i) this._inBlock[i] = r.getInt32();
        this.cipher.encrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) e.putInt32(this._outBlock[i])
      };
      kt.ecb.prototype.decrypt = function (r, e, t) {
        if (r.length() < this.blockSize && !(t && r.length() > 0)) return !0;
        for (var i = 0; i < this._ints; ++i) this._inBlock[i] = r.getInt32();
        this.cipher.decrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) e.putInt32(this._outBlock[i])
      };
      kt.ecb.prototype.pad = function (r, e) {
        var t = r.length() === this.blockSize ? this.blockSize : this.blockSize - r.length();
        return r.fillWithByte(t, t), !0
      };
      kt.ecb.prototype.unpad = function (r, e) {
        if (e.overflow > 0) return !1;
        var t = r.length(),
          i = r.at(t - 1);
        return i > this.blockSize << 2 ? !1 : (r.truncate(i), !0)
      };
      kt.cbc = function (r) {
        r = r || {}, this.name = "CBC", this.cipher = r.cipher, this.blockSize = r.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints)
      };
      kt.cbc.prototype.start = function (r) {
        if (r.iv === null) {
          if (!this._prev) throw new Error("Invalid IV parameter.");
          this._iv = this._prev.slice(0)
        } else if ("iv" in r) this._iv = Qm(r.iv, this.blockSize), this._prev = this._iv.slice(0);
        else throw new Error("Invalid IV parameter.")
      };
      kt.cbc.prototype.encrypt = function (r, e, t) {
        if (r.length() < this.blockSize && !(t && r.length() > 0)) return !0;
        for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._prev[i] ^ r.getInt32();
        this.cipher.encrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) e.putInt32(this._outBlock[i]);
        this._prev = this._outBlock
      };
      kt.cbc.prototype.decrypt = function (r, e, t) {
        if (r.length() < this.blockSize && !(t && r.length() > 0)) return !0;
        for (var i = 0; i < this._ints; ++i) this._inBlock[i] = r.getInt32();
        this.cipher.decrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) e.putInt32(this._prev[i] ^ this._outBlock[i]);
        this._prev = this._inBlock.slice(0)
      };
      kt.cbc.prototype.pad = function (r, e) {
        var t = r.length() === this.blockSize ? this.blockSize : this.blockSize - r.length();
        return r.fillWithByte(t, t), !0
      };
      kt.cbc.prototype.unpad = function (r, e) {
        if (e.overflow > 0) return !1;
        var t = r.length(),
          i = r.at(t - 1);
        return i > this.blockSize << 2 ? !1 : (r.truncate(i), !0)
      };
      kt.cfb = function (r) {
        r = r || {}, this.name = "CFB", this.cipher = r.cipher, this.blockSize = r.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = ji.util.createBuffer(), this._partialBytes = 0
      };
      kt.cfb.prototype.start = function (r) {
        if (!("iv" in r)) throw new Error("Invalid IV parameter.");
        this._iv = Qm(r.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0
      };
      kt.cfb.prototype.encrypt = function (r, e, t) {
        var i = r.length();
        if (i === 0) return !0;
        if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i >= this.blockSize) {
          for (var n = 0; n < this._ints; ++n) this._inBlock[n] = r.getInt32() ^ this._outBlock[n], e.putInt32(this._inBlock[n]);
          return
        }
        var s = (this.blockSize - i) % this.blockSize;
        s > 0 && (s = this.blockSize - s), this._partialOutput.clear();
        for (var n = 0; n < this._ints; ++n) this._partialBlock[n] = r.getInt32() ^ this._outBlock[n], this._partialOutput.putInt32(this._partialBlock[n]);
        if (s > 0) r.read -= this.blockSize;
        else
          for (var n = 0; n < this._ints; ++n) this._inBlock[n] = this._partialBlock[n];
        if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !t) return e.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
        e.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = 0
      };
      kt.cfb.prototype.decrypt = function (r, e, t) {
        var i = r.length();
        if (i === 0) return !0;
        if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i >= this.blockSize) {
          for (var n = 0; n < this._ints; ++n) this._inBlock[n] = r.getInt32(), e.putInt32(this._inBlock[n] ^ this._outBlock[n]);
          return
        }
        var s = (this.blockSize - i) % this.blockSize;
        s > 0 && (s = this.blockSize - s), this._partialOutput.clear();
        for (var n = 0; n < this._ints; ++n) this._partialBlock[n] = r.getInt32(), this._partialOutput.putInt32(this._partialBlock[n] ^ this._outBlock[n]);
        if (s > 0) r.read -= this.blockSize;
        else
          for (var n = 0; n < this._ints; ++n) this._inBlock[n] = this._partialBlock[n];
        if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !t) return e.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
        e.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = 0
      };
      kt.ofb = function (r) {
        r = r || {}, this.name = "OFB", this.cipher = r.cipher, this.blockSize = r.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = ji.util.createBuffer(), this._partialBytes = 0
      };
      kt.ofb.prototype.start = function (r) {
        if (!("iv" in r)) throw new Error("Invalid IV parameter.");
        this._iv = Qm(r.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0
      };
      kt.ofb.prototype.encrypt = function (r, e, t) {
        var i = r.length();
        if (r.length() === 0) return !0;
        if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i >= this.blockSize) {
          for (var n = 0; n < this._ints; ++n) e.putInt32(r.getInt32() ^ this._outBlock[n]), this._inBlock[n] = this._outBlock[n];
          return
        }
        var s = (this.blockSize - i) % this.blockSize;
        s > 0 && (s = this.blockSize - s), this._partialOutput.clear();
        for (var n = 0; n < this._ints; ++n) this._partialOutput.putInt32(r.getInt32() ^ this._outBlock[n]);
        if (s > 0) r.read -= this.blockSize;
        else
          for (var n = 0; n < this._ints; ++n) this._inBlock[n] = this._outBlock[n];
        if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !t) return e.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
        e.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = 0
      };
      kt.ofb.prototype.decrypt = kt.ofb.prototype.encrypt;
      kt.ctr = function (r) {
        r = r || {}, this.name = "CTR", this.cipher = r.cipher, this.blockSize = r.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = ji.util.createBuffer(), this._partialBytes = 0
      };
      kt.ctr.prototype.start = function (r) {
        if (!("iv" in r)) throw new Error("Invalid IV parameter.");
        this._iv = Qm(r.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0
      };
      kt.ctr.prototype.encrypt = function (r, e, t) {
        var i = r.length();
        if (i === 0) return !0;
        if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i >= this.blockSize)
          for (var n = 0; n < this._ints; ++n) e.putInt32(r.getInt32() ^ this._outBlock[n]);
        else {
          var s = (this.blockSize - i) % this.blockSize;
          s > 0 && (s = this.blockSize - s), this._partialOutput.clear();
          for (var n = 0; n < this._ints; ++n) this._partialOutput.putInt32(r.getInt32() ^ this._outBlock[n]);
          if (s > 0 && (r.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !t) return e.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
          e.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = 0
        }
        e2(this._inBlock)
      };
      kt.ctr.prototype.decrypt = kt.ctr.prototype.encrypt;
      kt.gcm = function (r) {
        r = r || {}, this.name = "GCM", this.cipher = r.cipher, this.blockSize = r.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = ji.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600
      };
      kt.gcm.prototype.start = function (r) {
        if (!("iv" in r)) throw new Error("Invalid IV parameter.");
        var e = ji.util.createBuffer(r.iv);
        this._cipherLength = 0;
        var t;
        if ("additionalData" in r ? t = ji.util.createBuffer(r.additionalData) : t = ji.util.createBuffer(), "tagLength" in r ? this._tagLength = r.tagLength : this._tagLength = 128, this._tag = null, r.decrypt && (this._tag = ji.util.createBuffer(r.tag).getBytes(), this._tag.length !== this._tagLength / 8)) throw new Error("Authentication tag does not match tag length.");
        this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
        var i = e.length();
        if (i === 12) this._j0 = [e.getInt32(), e.getInt32(), e.getInt32(), 1];
        else {
          for (this._j0 = [0, 0, 0, 0]; e.length() > 0;) this._j0 = this.ghash(this._hashSubkey, this._j0, [e.getInt32(), e.getInt32(), e.getInt32(), e.getInt32()]);
          this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(zE(i * 8)))
        }
        this._inBlock = this._j0.slice(0), e2(this._inBlock), this._partialBytes = 0, t = ji.util.createBuffer(t), this._aDataLength = zE(t.length() * 8);
        var n = t.length() % this.blockSize;
        for (n && t.fillWithByte(0, this.blockSize - n), this._s = [0, 0, 0, 0]; t.length() > 0;) this._s = this.ghash(this._hashSubkey, this._s, [t.getInt32(), t.getInt32(), t.getInt32(), t.getInt32()])
      };
      kt.gcm.prototype.encrypt = function (r, e, t) {
        var i = r.length();
        if (i === 0) return !0;
        if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i >= this.blockSize) {
          for (var n = 0; n < this._ints; ++n) e.putInt32(this._outBlock[n] ^= r.getInt32());
          this._cipherLength += this.blockSize
        } else {
          var s = (this.blockSize - i) % this.blockSize;
          s > 0 && (s = this.blockSize - s), this._partialOutput.clear();
          for (var n = 0; n < this._ints; ++n) this._partialOutput.putInt32(r.getInt32() ^ this._outBlock[n]);
          if (s <= 0 || t) {
            if (t) {
              var o = i % this.blockSize;
              this._cipherLength += o, this._partialOutput.truncate(this.blockSize - o)
            } else this._cipherLength += this.blockSize;
            for (var n = 0; n < this._ints; ++n) this._outBlock[n] = this._partialOutput.getInt32();
            this._partialOutput.read -= this.blockSize
          }
          if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !t) return r.read -= this.blockSize, e.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
          e.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = 0
        }
        this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), e2(this._inBlock)
      };
      kt.gcm.prototype.decrypt = function (r, e, t) {
        var i = r.length();
        if (i < this.blockSize && !(t && i > 0)) return !0;
        this.cipher.encrypt(this._inBlock, this._outBlock), e2(this._inBlock), this._hashBlock[0] = r.getInt32(), this._hashBlock[1] = r.getInt32(), this._hashBlock[2] = r.getInt32(), this._hashBlock[3] = r.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
        for (var n = 0; n < this._ints; ++n) e.putInt32(this._outBlock[n] ^ this._hashBlock[n]);
        i < this.blockSize ? this._cipherLength += i % this.blockSize : this._cipherLength += this.blockSize
      };
      kt.gcm.prototype.afterFinish = function (r, e) {
        var t = !0;
        e.decrypt && e.overflow && r.truncate(this.blockSize - e.overflow), this.tag = ji.util.createBuffer();
        var i = this._aDataLength.concat(zE(this._cipherLength * 8));
        this._s = this.ghash(this._hashSubkey, this._s, i);
        var n = [];
        this.cipher.encrypt(this._j0, n);
        for (var s = 0; s < this._ints; ++s) this.tag.putInt32(this._s[s] ^ n[s]);
        return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), e.decrypt && this.tag.bytes() !== this._tag && (t = !1), t
      };
      kt.gcm.prototype.multiply = function (r, e) {
        for (var t = [0, 0, 0, 0], i = e.slice(0), n = 0; n < 128; ++n) {
          var s = r[n / 32 | 0] & 1 << 31 - n % 32;
          s && (t[0] ^= i[0], t[1] ^= i[1], t[2] ^= i[2], t[3] ^= i[3]), this.pow(i, i)
        }
        return t
      };
      kt.gcm.prototype.pow = function (r, e) {
        for (var t = r[3] & 1, i = 3; i > 0; --i) e[i] = r[i] >>> 1 | (r[i - 1] & 1) << 31;
        e[0] = r[0] >>> 1, t && (e[0] ^= this._R)
      };
      kt.gcm.prototype.tableMultiply = function (r) {
        for (var e = [0, 0, 0, 0], t = 0; t < 32; ++t) {
          var i = t / 8 | 0,
            n = r[i] >>> (7 - t % 8) * 4 & 15,
            s = this._m[t][n];
          e[0] ^= s[0], e[1] ^= s[1], e[2] ^= s[2], e[3] ^= s[3]
        }
        return e
      };
      kt.gcm.prototype.ghash = function (r, e, t) {
        return e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3], this.tableMultiply(e)
      };
      kt.gcm.prototype.generateHashTable = function (r, e) {
        for (var t = 8 / e, i = 4 * t, n = 16 * t, s = new Array(n), o = 0; o < n; ++o) {
          var a = [0, 0, 0, 0],
            c = o / i | 0,
            u = (i - 1 - o % i) * e;
          a[c] = 1 << e - 1 << u, s[o] = this.generateSubHashTable(this.multiply(a, r), e)
        }
        return s
      };
      kt.gcm.prototype.generateSubHashTable = function (r, e) {
        var t = 1 << e,
          i = t >>> 1,
          n = new Array(t);
        n[i] = r.slice(0);
        for (var s = i >>> 1; s > 0;) this.pow(n[2 * s], n[s] = []), s >>= 1;
        for (s = 2; s < i;) {
          for (var o = 1; o < s; ++o) {
            var a = n[s],
              c = n[o];
            n[s + o] = [a[0] ^ c[0], a[1] ^ c[1], a[2] ^ c[2], a[3] ^ c[3]]
          }
          s *= 2
        }
        for (n[0] = [0, 0, 0, 0], s = i + 1; s < t; ++s) {
          var u = n[s ^ i];
          n[s] = [r[0] ^ u[0], r[1] ^ u[1], r[2] ^ u[2], r[3] ^ u[3]]
        }
        return n
      };

      function Qm(r, e) {
        if (typeof r == "string" && (r = ji.util.createBuffer(r)), ji.util.isArray(r) && r.length > 4) {
          var t = r;
          r = ji.util.createBuffer();
          for (var i = 0; i < t.length; ++i) r.putByte(t[i])
        }
        if (r.length() < e) throw new Error("Invalid IV length; got " + r.length() + " bytes and expected " + e + " bytes.");
        if (!ji.util.isArray(r)) {
          for (var n = [], s = e / 4, i = 0; i < s; ++i) n.push(r.getInt32());
          r = n
        }
        return r
      }

      function e2(r) {
        r[r.length - 1] = r[r.length - 1] + 1 & 4294967295
      }

      function zE(r) {
        return [r / 4294967296 | 0, r & 4294967295]
      }
    });
    var cd = y((sbt, XN) => {
      l();
      var Tr = At();
      KE();
      jE();
      wr();
      XN.exports = Tr.aes = Tr.aes || {};
      Tr.aes.startEncrypting = function (r, e, t, i) {
        var n = t2({
          key: r,
          output: t,
          decrypt: !1,
          mode: i
        });
        return n.start(e), n
      };
      Tr.aes.createEncryptionCipher = function (r, e) {
        return t2({
          key: r,
          output: null,
          decrypt: !1,
          mode: e
        })
      };
      Tr.aes.startDecrypting = function (r, e, t, i) {
        var n = t2({
          key: r,
          output: t,
          decrypt: !0,
          mode: i
        });
        return n.start(e), n
      };
      Tr.aes.createDecryptionCipher = function (r, e) {
        return t2({
          key: r,
          output: null,
          decrypt: !0,
          mode: e
        })
      };
      Tr.aes.Algorithm = function (r, e) {
        VE || ZN();
        var t = this;
        t.name = r, t.mode = new e({
          blockSize: 16,
          cipher: {
            encrypt: function (i, n) {
              return HE(t._w, i, n, !1)
            },
            decrypt: function (i, n) {
              return HE(t._w, i, n, !0)
            }
          }
        }), t._init = !1
      };
      Tr.aes.Algorithm.prototype.initialize = function (r) {
        if (!this._init) {
          var e = r.key,
            t;
          if (typeof e == "string" && (e.length === 16 || e.length === 24 || e.length === 32)) e = Tr.util.createBuffer(e);
          else if (Tr.util.isArray(e) && (e.length === 16 || e.length === 24 || e.length === 32)) {
            t = e, e = Tr.util.createBuffer();
            for (var i = 0; i < t.length; ++i) e.putByte(t[i])
          }
          if (!Tr.util.isArray(e)) {
            t = e, e = [];
            var n = t.length();
            if (n === 16 || n === 24 || n === 32) {
              n = n >>> 2;
              for (var i = 0; i < n; ++i) e.push(t.getInt32())
            }
          }
          if (!Tr.util.isArray(e) || !(e.length === 4 || e.length === 6 || e.length === 8)) throw new Error("Invalid key parameter.");
          var s = this.mode.name,
            o = ["CFB", "OFB", "CTR", "GCM"].indexOf(s) !== -1;
          this._w = QN(e, r.decrypt && !o), this._init = !0
        }
      };
      Tr.aes._expandKey = function (r, e) {
        return VE || ZN(), QN(r, e)
      };
      Tr.aes._updateBlock = HE;
      od("AES-ECB", Tr.cipher.modes.ecb);
      od("AES-CBC", Tr.cipher.modes.cbc);
      od("AES-CFB", Tr.cipher.modes.cfb);
      od("AES-OFB", Tr.cipher.modes.ofb);
      od("AES-CTR", Tr.cipher.modes.ctr);
      od("AES-GCM", Tr.cipher.modes.gcm);

      function od(r, e) {
        var t = function () {
          return new Tr.aes.Algorithm(r, e)
        };
        Tr.cipher.registerAlgorithm(r, t)
      }
      var VE = !1,
        ad = 4,
        zn, GE, eq, nl, Uo;

      function ZN() {
        VE = !0, eq = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        for (var r = new Array(256), e = 0; e < 128; ++e) r[e] = e << 1, r[e + 128] = e + 128 << 1 ^ 283;
        zn = new Array(256), GE = new Array(256), nl = new Array(4), Uo = new Array(4);
        for (var e = 0; e < 4; ++e) nl[e] = new Array(256), Uo[e] = new Array(256);
        for (var t = 0, i = 0, n, s, o, a, c, u, f, e = 0; e < 256; ++e) {
          a = i ^ i << 1 ^ i << 2 ^ i << 3 ^ i << 4, a = a >> 8 ^ a & 255 ^ 99, zn[t] = a, GE[a] = t, c = r[a], n = r[t], s = r[n], o = r[s], u = c << 24 ^ a << 16 ^ a << 8 ^ (a ^ c), f = (n ^ s ^ o) << 24 ^ (t ^ o) << 16 ^ (t ^ s ^ o) << 8 ^ (t ^ n ^ o);
          for (var h = 0; h < 4; ++h) nl[h][t] = u, Uo[h][a] = f, u = u << 24 | u >>> 8, f = f << 24 | f >>> 8;
          t === 0 ? t = i = 1 : (t = n ^ r[r[r[n ^ o]]], i ^= r[r[i]])
        }
      }

      function QN(r, e) {
        for (var t = r.slice(0), i, n = 1, s = t.length, o = s + 6 + 1, a = ad * o, c = s; c < a; ++c) i = t[c - 1], c % s == 0 ? (i = zn[i >>> 16 & 255] << 24 ^ zn[i >>> 8 & 255] << 16 ^ zn[i & 255] << 8 ^ zn[i >>> 24] ^ eq[n] << 24, n++) : s > 6 && c % s == 4 && (i = zn[i >>> 24] << 24 ^ zn[i >>> 16 & 255] << 16 ^ zn[i >>> 8 & 255] << 8 ^ zn[i & 255]), t[c] = t[c - s] ^ i;
        if (e) {
          var u, f = Uo[0],
            h = Uo[1],
            d = Uo[2],
            p = Uo[3],
            g = t.slice(0);
          a = t.length;
          for (var c = 0, m = a - ad; c < a; c += ad, m -= ad)
            if (c === 0 || c === a - ad) g[c] = t[m], g[c + 1] = t[m + 3], g[c + 2] = t[m + 2], g[c + 3] = t[m + 1];
            else
              for (var E = 0; E < ad; ++E) u = t[m + E], g[c + (3 & -E)] = f[zn[u >>> 24]] ^ h[zn[u >>> 16 & 255]] ^ d[zn[u >>> 8 & 255]] ^ p[zn[u & 255]];
          t = g
        }
        return t
      }

      function HE(r, e, t, i) {
        var n = r.length / 4 - 1,
          s, o, a, c, u;
        i ? (s = Uo[0], o = Uo[1], a = Uo[2], c = Uo[3], u = GE) : (s = nl[0], o = nl[1], a = nl[2], c = nl[3], u = zn);
        var f, h, d, p, g, m, E;
        f = e[0] ^ r[0], h = e[i ? 3 : 1] ^ r[1], d = e[2] ^ r[2], p = e[i ? 1 : 3] ^ r[3];
        for (var w = 3, O = 1; O < n; ++O) g = s[f >>> 24] ^ o[h >>> 16 & 255] ^ a[d >>> 8 & 255] ^ c[p & 255] ^ r[++w], m = s[h >>> 24] ^ o[d >>> 16 & 255] ^ a[p >>> 8 & 255] ^ c[f & 255] ^ r[++w], E = s[d >>> 24] ^ o[p >>> 16 & 255] ^ a[f >>> 8 & 255] ^ c[h & 255] ^ r[++w], p = s[p >>> 24] ^ o[f >>> 16 & 255] ^ a[h >>> 8 & 255] ^ c[d & 255] ^ r[++w], f = g, h = m, d = E;
        t[0] = u[f >>> 24] << 24 ^ u[h >>> 16 & 255] << 16 ^ u[d >>> 8 & 255] << 8 ^ u[p & 255] ^ r[++w], t[i ? 3 : 1] = u[h >>> 24] << 24 ^ u[d >>> 16 & 255] << 16 ^ u[p >>> 8 & 255] << 8 ^ u[f & 255] ^ r[++w], t[2] = u[d >>> 24] << 24 ^ u[p >>> 16 & 255] << 16 ^ u[f >>> 8 & 255] << 8 ^ u[h & 255] ^ r[++w], t[i ? 1 : 3] = u[p >>> 24] << 24 ^ u[f >>> 16 & 255] << 16 ^ u[h >>> 8 & 255] << 8 ^ u[d & 255] ^ r[++w]
      }

      function t2(r) {
        r = r || {};
        var e = (r.mode || "CBC").toUpperCase(),
          t = "AES-" + e,
          i;
        r.decrypt ? i = Tr.cipher.createDecipher(t, r.key) : i = Tr.cipher.createCipher(t, r.key);
        var n = i.start;
        return i.start = function (s, o) {
          var a = null;
          o instanceof Tr.util.ByteBuffer && (a = o, o = {}), o = o || {}, o.output = a, o.iv = s, n.call(i, o)
        }, i
      }
    });
    var i2 = y((obt, tq) => {
      l();
      var Ur = At();
      KE();
      jE();
      wr();
      tq.exports = Ur.des = Ur.des || {};
      Ur.des.startEncrypting = function (r, e, t, i) {
        var n = r2({
          key: r,
          output: t,
          decrypt: !1,
          mode: i || (e === null ? "ECB" : "CBC")
        });
        return n.start(e), n
      };
      Ur.des.createEncryptionCipher = function (r, e) {
        return r2({
          key: r,
          output: null,
          decrypt: !1,
          mode: e
        })
      };
      Ur.des.startDecrypting = function (r, e, t, i) {
        var n = r2({
          key: r,
          output: t,
          decrypt: !0,
          mode: i || (e === null ? "ECB" : "CBC")
        });
        return n.start(e), n
      };
      Ur.des.createDecryptionCipher = function (r, e) {
        return r2({
          key: r,
          output: null,
          decrypt: !0,
          mode: e
        })
      };
      Ur.des.Algorithm = function (r, e) {
        var t = this;
        t.name = r, t.mode = new e({
          blockSize: 8,
          cipher: {
            encrypt: function (i, n) {
              return rq(t._keys, i, n, !1)
            },
            decrypt: function (i, n) {
              return rq(t._keys, i, n, !0)
            }
          }
        }), t._init = !1
      };
      Ur.des.Algorithm.prototype.initialize = function (r) {
        if (!this._init) {
          var e = Ur.util.createBuffer(r.key);
          if (this.name.indexOf("3DES") === 0 && e.length() !== 24) throw new Error("Invalid Triple-DES key size: " + e.length() * 8);
          this._keys = Y5e(e), this._init = !0
        }
      };
      Pa("DES-ECB", Ur.cipher.modes.ecb);
      Pa("DES-CBC", Ur.cipher.modes.cbc);
      Pa("DES-CFB", Ur.cipher.modes.cfb);
      Pa("DES-OFB", Ur.cipher.modes.ofb);
      Pa("DES-CTR", Ur.cipher.modes.ctr);
      Pa("3DES-ECB", Ur.cipher.modes.ecb);
      Pa("3DES-CBC", Ur.cipher.modes.cbc);
      Pa("3DES-CFB", Ur.cipher.modes.cfb);
      Pa("3DES-OFB", Ur.cipher.modes.ofb);
      Pa("3DES-CTR", Ur.cipher.modes.ctr);

      function Pa(r, e) {
        var t = function () {
          return new Ur.des.Algorithm(r, e)
        };
        Ur.cipher.registerAlgorithm(r, t)
      }
      var J5e = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756],
        X5e = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344],
        Z5e = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584],
        Q5e = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928],
        e8e = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080],
        t8e = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312],
        r8e = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154],
        i8e = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];

      function Y5e(r) {
        for (var e = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], t = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], i = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], n = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], s = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], o = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], a = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], c = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], u = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], f = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], h = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], d = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], p = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], g = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], m = r.length() > 8 ? 3 : 1, E = [], w = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], O = 0, q, J = 0; J < m; J++) {
          var Z = r.getInt32(),
            H = r.getInt32();
          q = (Z >>> 4 ^ H) & 252645135, H ^= q, Z ^= q << 4, q = (H >>> -16 ^ Z) & 65535, Z ^= q, H ^= q << -16, q = (Z >>> 2 ^ H) & 858993459, H ^= q, Z ^= q << 2, q = (H >>> -16 ^ Z) & 65535, Z ^= q, H ^= q << -16, q = (Z >>> 1 ^ H) & 1431655765, H ^= q, Z ^= q << 1, q = (H >>> 8 ^ Z) & 16711935, Z ^= q, H ^= q << 8, q = (Z >>> 1 ^ H) & 1431655765, H ^= q, Z ^= q << 1, q = Z << 8 | H >>> 20 & 240, Z = H << 24 | H << 8 & 16711680 | H >>> 8 & 65280 | H >>> 24 & 240, H = q;
          for (var te = 0; te < w.length; ++te) {
            w[te] ? (Z = Z << 2 | Z >>> 26, H = H << 2 | H >>> 26) : (Z = Z << 1 | Z >>> 27, H = H << 1 | H >>> 27), Z &= -15, H &= -15;
            var ae = e[Z >>> 28] | t[Z >>> 24 & 15] | i[Z >>> 20 & 15] | n[Z >>> 16 & 15] | s[Z >>> 12 & 15] | o[Z >>> 8 & 15] | a[Z >>> 4 & 15],
              oe = c[H >>> 28] | u[H >>> 24 & 15] | f[H >>> 20 & 15] | h[H >>> 16 & 15] | d[H >>> 12 & 15] | p[H >>> 8 & 15] | g[H >>> 4 & 15];
            q = (oe >>> 16 ^ ae) & 65535, E[O++] = ae ^ q, E[O++] = oe ^ q << 16
          }
        }
        return E
      }

      function rq(r, e, t, i) {
        var n = r.length === 32 ? 3 : 9,
          s;
        n === 3 ? s = i ? [30, -2, -2] : [0, 32, 2] : s = i ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
        var o, a = e[0],
          c = e[1];
        o = (a >>> 4 ^ c) & 252645135, c ^= o, a ^= o << 4, o = (a >>> 16 ^ c) & 65535, c ^= o, a ^= o << 16, o = (c >>> 2 ^ a) & 858993459, a ^= o, c ^= o << 2, o = (c >>> 8 ^ a) & 16711935, a ^= o, c ^= o << 8, o = (a >>> 1 ^ c) & 1431655765, c ^= o, a ^= o << 1, a = a << 1 | a >>> 31, c = c << 1 | c >>> 31;
        for (var u = 0; u < n; u += 3) {
          for (var f = s[u + 1], h = s[u + 2], d = s[u]; d != f; d += h) {
            var p = c ^ r[d],
              g = (c >>> 4 | c << 28) ^ r[d + 1];
            o = a, a = c, c = o ^ (X5e[p >>> 24 & 63] | Q5e[p >>> 16 & 63] | t8e[p >>> 8 & 63] | i8e[p & 63] | J5e[g >>> 24 & 63] | Z5e[g >>> 16 & 63] | e8e[g >>> 8 & 63] | r8e[g & 63])
          }
          o = a, a = c, c = o
        }
        a = a >>> 1 | a << 31, c = c >>> 1 | c << 31, o = (a >>> 1 ^ c) & 1431655765, c ^= o, a ^= o << 1, o = (c >>> 8 ^ a) & 16711935, a ^= o, c ^= o << 8, o = (c >>> 2 ^ a) & 858993459, a ^= o, c ^= o << 2, o = (a >>> 16 ^ c) & 65535, c ^= o, a ^= o << 16, o = (a >>> 4 ^ c) & 252645135, c ^= o, a ^= o << 4, t[0] = a, t[1] = c
      }

      function r2(r) {
        r = r || {};
        var e = (r.mode || "CBC").toUpperCase(),
          t = "DES-" + e,
          i;
        r.decrypt ? i = Ur.cipher.createDecipher(t, r.key) : i = Ur.cipher.createCipher(t, r.key);
        var n = i.start;
        return i.start = function (s, o) {
          var a = null;
          o instanceof Ur.util.ByteBuffer && (a = o, o = {}), o = o || {}, o.output = a, o.iv = s, n.call(i, o)
        }, i
      }
    });
    var Lu = y((abt, iq) => {
      l();
      var n2 = At();
      iq.exports = n2.md = n2.md || {};
      n2.md.algorithms = n2.md.algorithms || {}
    });
    var sq = y((cbt, nq) => {
      l();
      var Dc = At();
      Lu();
      wr();
      var n8e = nq.exports = Dc.hmac = Dc.hmac || {};
      n8e.create = function () {
        var r = null,
          e = null,
          t = null,
          i = null,
          n = {};
        return n.start = function (s, o) {
          if (s !== null)
            if (typeof s == "string")
              if (s = s.toLowerCase(), s in Dc.md.algorithms) e = Dc.md.algorithms[s].create();
              else throw new Error('Unknown hash algorithm "' + s + '"');
            else e = s;
          if (o === null) o = r;
          else {
            if (typeof o == "string") o = Dc.util.createBuffer(o);
            else if (Dc.util.isArray(o)) {
              var a = o;
              o = Dc.util.createBuffer();
              for (var c = 0; c < a.length; ++c) o.putByte(a[c])
            }
            var u = o.length();
            u > e.blockLength && (e.start(), e.update(o.bytes()), o = e.digest()), t = Dc.util.createBuffer(), i = Dc.util.createBuffer(), u = o.length();
            for (var c = 0; c < u; ++c) {
              var a = o.at(c);
              t.putByte(54 ^ a), i.putByte(92 ^ a)
            }
            if (u < e.blockLength)
              for (var a = e.blockLength - u, c = 0; c < a; ++c) t.putByte(54), i.putByte(92);
            r = o, t = t.bytes(), i = i.bytes()
          }
          e.start(), e.update(t)
        }, n.update = function (s) {
          e.update(s)
        }, n.getMac = function () {
          var s = e.digest().bytes();
          return e.start(), e.update(i), e.update(s), e.digest()
        }, n.digest = n.getMac, n
      }
    });
    var L1 = y(() => {
      l()
    });
    var $E = y((lbt, oq) => {
      l();
      var jn = At();
      sq();
      Lu();
      wr();
      var s8e = jn.pkcs5 = jn.pkcs5 || {},
        Lc;
      jn.util.isNodejs && !jn.options.usePureJavaScript && (Lc = L1());
      oq.exports = jn.pbkdf2 = s8e.pbkdf2 = function (r, e, t, i, n, s) {
        if (typeof n == "function" && (s = n, n = null), jn.util.isNodejs && !jn.options.usePureJavaScript && Lc.pbkdf2 && (n === null || typeof n != "object") && (Lc.pbkdf2Sync.length > 4 || !n || n === "sha1")) return typeof n != "string" && (n = "sha1"), r = Buffer.from(r, "binary"), e = Buffer.from(e, "binary"), s ? Lc.pbkdf2Sync.length === 4 ? Lc.pbkdf2(r, e, t, i, function (q, J) {
          if (q) return s(q);
          s(null, J.toString("binary"))
        }) : Lc.pbkdf2(r, e, t, i, n, function (q, J) {
          if (q) return s(q);
          s(null, J.toString("binary"))
        }) : Lc.pbkdf2Sync.length === 4 ? Lc.pbkdf2Sync(r, e, t, i).toString("binary") : Lc.pbkdf2Sync(r, e, t, i, n).toString("binary");
        if ((typeof n == "undefined" || n === null) && (n = "sha1"), typeof n == "string") {
          if (!(n in jn.md.algorithms)) throw new Error("Unknown hash algorithm: " + n);
          n = jn.md[n].create()
        }
        var o = n.digestLength;
        if (i > 4294967295 * o) {
          var a = new Error("Derived key is too long.");
          if (s) return s(a);
          throw a
        }
        var c = Math.ceil(i / o),
          u = i - (c - 1) * o,
          f = jn.hmac.create();
        f.start(n, r);
        var h = "",
          d, p, g;
        if (!s) {
          for (var m = 1; m <= c; ++m) {
            f.start(null, null), f.update(e), f.update(jn.util.int32ToBytes(m)), d = g = f.digest().getBytes();
            for (var E = 2; E <= t; ++E) f.start(null, null), f.update(g), p = f.digest().getBytes(), d = jn.util.xorBytes(d, p, o), g = p;
            h += m < c ? d : d.substr(0, u)
          }
          return h
        }
        var m = 1,
          E;

        function w() {
          if (m > c) return s(null, h);
          f.start(null, null), f.update(e), f.update(jn.util.int32ToBytes(m)), d = g = f.digest().getBytes(), E = 2, O()
        }

        function O() {
          if (E <= t) return f.start(null, null), f.update(g), p = f.digest().getBytes(), d = jn.util.xorBytes(d, p, o), g = p, ++E, jn.util.setImmediate(O);
          h += m < c ? d : d.substr(0, u), ++m, w()
        }
        w()
      }
    });
    var a2 = y((hbt, aq) => {
      l();
      var s2 = At();
      wr();
      var cq = aq.exports = s2.pem = s2.pem || {};
      cq.encode = function (r, e) {
        e = e || {};
        var t = "-----BEGIN " + r.type + `-----\r
`,
          i;
        if (r.procType && (i = {
          name: "Proc-Type",
          values: [String(r.procType.version), r.procType.type]
        }, t += o2(i)), r.contentDomain && (i = {
          name: "Content-Domain",
          values: [r.contentDomain]
        }, t += o2(i)), r.dekInfo && (i = {
          name: "DEK-Info",
          values: [r.dekInfo.algorithm]
        }, r.dekInfo.parameters && i.values.push(r.dekInfo.parameters), t += o2(i)), r.headers)
          for (var n = 0; n < r.headers.length; ++n) t += o2(r.headers[n]);
        return r.procType && (t += `\r
`), t += s2.util.encode64(r.body, e.maxline || 64) + `\r
`, t += "-----END " + r.type + `-----\r
`, t
      };
      cq.decode = function (r) {
        for (var e = [], t = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, i = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, n = /\r?\n/, s; s = t.exec(r), !!s;) {
          var o = {
            type: s[1],
            procType: null,
            contentDomain: null,
            dekInfo: null,
            headers: [],
            body: s2.util.decode64(s[3])
          };
          if (e.push(o), !!s[2]) {
            for (var a = s[2].split(n), c = 0; s && c < a.length;) {
              for (var u = a[c].replace(/\s+$/, ""), f = c + 1; f < a.length; ++f) {
                var h = a[f];
                if (!/\s/.test(h[0])) break;
                u += h, c = f
              }
              if (s = u.match(i), s) {
                for (var d = {
                  name: s[1],
                  values: []
                }, p = s[2].split(","), g = 0; g < p.length; ++g) d.values.push(o8e(p[g]));
                if (o.procType)
                  if (!o.contentDomain && d.name === "Content-Domain") o.contentDomain = p[0] || "";
                  else if (!o.dekInfo && d.name === "DEK-Info") {
                    if (d.values.length === 0) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                    o.dekInfo = {
                      algorithm: p[0],
                      parameters: p[1] || null
                    }
                  } else o.headers.push(d);
                else {
                  if (d.name !== "Proc-Type") throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                  if (d.values.length !== 2) throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                  o.procType = {
                    version: p[0],
                    type: p[1]
                  }
                }
              } ++c
            }
            if (o.procType === "ENCRYPTED" && !o.dekInfo) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".')
          }
        }
        if (e.length === 0) throw new Error("Invalid PEM formatted message.");
        return e
      };

      function o2(r) {
        for (var e = r.name + ": ", t = [], i = function (c, u) {
          return " " + u
        }, n = 0; n < r.values.length; ++n) t.push(r.values[n].replace(/^(\S+\r\n)/, i));
        e += t.join(",") + `\r
`;
        for (var s = 0, o = -1, n = 0; n < e.length; ++n, ++s)
          if (s > 65 && o !== -1) {
            var a = e[o];
            a === "," ? (++o, e = e.substr(0, o) + `\r
` + e.substr(o)) : e = e.substr(0, o) + `\r
` + a + e.substr(o + 1), s = n - o - 1, o = -1, ++n
          } else (e[n] === " " || e[n] === "	" || e[n] === ",") && (o = n);
        return e
      }

      function o8e(r) {
        return r.replace(/^\s+/, "")
      }
    });
    var pq = y((dbt, uq) => {
      l();
      var Ca = At();
      Lu();
      wr();
      var fq = uq.exports = Ca.sha256 = Ca.sha256 || {};
      Ca.md.sha256 = Ca.md.algorithms.sha256 = fq;
      fq.create = function () {
        lq || a8e();
        var r = null,
          e = Ca.util.createBuffer(),
          t = new Array(64),
          i = {
            algorithm: "sha256",
            blockLength: 64,
            digestLength: 32,
            messageLength: 0,
            fullMessageLength: null,
            messageLengthSize: 8
          };
        return i.start = function () {
          i.messageLength = 0, i.fullMessageLength = i.messageLength64 = [];
          for (var n = i.messageLengthSize / 4, s = 0; s < n; ++s) i.fullMessageLength.push(0);
          return e = Ca.util.createBuffer(), r = {
            h0: 1779033703,
            h1: 3144134277,
            h2: 1013904242,
            h3: 2773480762,
            h4: 1359893119,
            h5: 2600822924,
            h6: 528734635,
            h7: 1541459225
          }, i
        }, i.start(), i.update = function (n, s) {
          s === "utf8" && (n = Ca.util.encodeUtf8(n));
          var o = n.length;
          i.messageLength += o, o = [o / 4294967296 >>> 0, o >>> 0];
          for (var a = i.fullMessageLength.length - 1; a >= 0; --a) i.fullMessageLength[a] += o[1], o[1] = o[0] + (i.fullMessageLength[a] / 4294967296 >>> 0), i.fullMessageLength[a] = i.fullMessageLength[a] >>> 0, o[0] = o[1] / 4294967296 >>> 0;
          return e.putBytes(n), hq(r, t, e), (e.read > 2048 || e.length() === 0) && e.compact(), i
        }, i.digest = function () {
          var n = Ca.util.createBuffer();
          n.putBytes(e.bytes());
          var s = i.fullMessageLength[i.fullMessageLength.length - 1] + i.messageLengthSize,
            o = s & i.blockLength - 1;
          n.putBytes(WE.substr(0, i.blockLength - o));
          for (var a, c, u = i.fullMessageLength[0] * 8, f = 0; f < i.fullMessageLength.length - 1; ++f) a = i.fullMessageLength[f + 1] * 8, c = a / 4294967296 >>> 0, u += c, n.putInt32(u >>> 0), u = a >>> 0;
          n.putInt32(u);
          var h = {
            h0: r.h0,
            h1: r.h1,
            h2: r.h2,
            h3: r.h3,
            h4: r.h4,
            h5: r.h5,
            h6: r.h6,
            h7: r.h7
          };
          hq(h, t, n);
          var d = Ca.util.createBuffer();
          return d.putInt32(h.h0), d.putInt32(h.h1), d.putInt32(h.h2), d.putInt32(h.h3), d.putInt32(h.h4), d.putInt32(h.h5), d.putInt32(h.h6), d.putInt32(h.h7), d
        }, i
      };
      var WE = null,
        lq = !1,
        dq = null;

      function a8e() {
        WE = String.fromCharCode(128), WE += Ca.util.fillString(String.fromCharCode(0), 64), dq = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], lq = !0
      }

      function hq(r, e, t) {
        for (var i, n, s, o, a, c, u, f, h, d, p, g, m, E, w, O = t.length(); O >= 64;) {
          for (u = 0; u < 16; ++u) e[u] = t.getInt32();
          for (; u < 64; ++u) i = e[u - 2], i = (i >>> 17 | i << 15) ^ (i >>> 19 | i << 13) ^ i >>> 10, n = e[u - 15], n = (n >>> 7 | n << 25) ^ (n >>> 18 | n << 14) ^ n >>> 3, e[u] = i + e[u - 7] + n + e[u - 16] | 0;
          for (f = r.h0, h = r.h1, d = r.h2, p = r.h3, g = r.h4, m = r.h5, E = r.h6, w = r.h7, u = 0; u < 64; ++u) o = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7), a = E ^ g & (m ^ E), s = (f >>> 2 | f << 30) ^ (f >>> 13 | f << 19) ^ (f >>> 22 | f << 10), c = f & h | d & (f ^ h), i = w + o + a + dq[u] + e[u], n = s + c, w = E, E = m, m = g, g = p + i >>> 0, p = d, d = h, h = f, f = i + n >>> 0;
          r.h0 = r.h0 + f | 0, r.h1 = r.h1 + h | 0, r.h2 = r.h2 + d | 0, r.h3 = r.h3 + p | 0, r.h4 = r.h4 + g | 0, r.h5 = r.h5 + m | 0, r.h6 = r.h6 + E | 0, r.h7 = r.h7 + w | 0, O -= 64
        }
      }
    });
    var gq = y((pbt, yq) => {
      l();
      var Oa = At();
      wr();
      var c2 = null;
      Oa.util.isNodejs && !Oa.options.usePureJavaScript && !process.versions["node-webkit"] && (c2 = L1());
      var c8e = yq.exports = Oa.prng = Oa.prng || {};
      c8e.create = function (r) {
        for (var e = {
          plugin: r,
          key: null,
          seed: null,
          time: null,
          reseeds: 0,
          generated: 0,
          keyBytes: ""
        }, t = r.md, i = new Array(32), n = 0; n < 32; ++n) i[n] = t.create();
        e.pools = i, e.pool = 0, e.generate = function (u, f) {
          if (!f) return e.generateSync(u);
          var h = e.plugin.cipher,
            d = e.plugin.increment,
            p = e.plugin.formatKey,
            g = e.plugin.formatSeed,
            m = Oa.util.createBuffer();
          e.key = null, E();

          function E(w) {
            if (w) return f(w);
            if (m.length() >= u) return f(null, m.getBytes(u));
            if (e.generated > 1048575 && (e.key = null), e.key === null) return Oa.util.nextTick(function () {
              s(E)
            });
            var O = h(e.key, e.seed);
            e.generated += O.length, m.putBytes(O), e.key = p(h(e.key, d(e.seed))), e.seed = g(h(e.key, e.seed)), Oa.util.setImmediate(E)
          }
        }, e.generateSync = function (u) {
          var f = e.plugin.cipher,
            h = e.plugin.increment,
            d = e.plugin.formatKey,
            p = e.plugin.formatSeed;
          e.key = null;
          for (var g = Oa.util.createBuffer(); g.length() < u;) {
            e.generated > 1048575 && (e.key = null), e.key === null && o();
            var m = f(e.key, e.seed);
            e.generated += m.length, g.putBytes(m), e.key = d(f(e.key, h(e.seed))), e.seed = p(f(e.key, e.seed))
          }
          return g.getBytes(u)
        };

        function s(u) {
          if (e.pools[0].messageLength >= 32) return a(), u();
          var f = 32 - e.pools[0].messageLength << 5;
          e.seedFile(f, function (h, d) {
            if (h) return u(h);
            e.collect(d), a(), u()
          })
        }

        function o() {
          if (e.pools[0].messageLength >= 32) return a();
          var u = 32 - e.pools[0].messageLength << 5;
          e.collect(e.seedFileSync(u)), a()
        }

        function a() {
          e.reseeds = e.reseeds === 4294967295 ? 0 : e.reseeds + 1;
          var u = e.plugin.md.create();
          u.update(e.keyBytes);
          for (var f = 1, h = 0; h < 32; ++h) e.reseeds % f == 0 && (u.update(e.pools[h].digest().getBytes()), e.pools[h].start()), f = f << 1;
          e.keyBytes = u.digest().getBytes(), u.start(), u.update(e.keyBytes);
          var d = u.digest().getBytes();
          e.key = e.plugin.formatKey(e.keyBytes), e.seed = e.plugin.formatSeed(d), e.generated = 0
        }

        function c(u) {
          var f = null,
            h = Oa.util.globalScope,
            d = h.crypto || h.msCrypto;
          d && d.getRandomValues && (f = function (Z) {
            return d.getRandomValues(Z)
          });
          var p = Oa.util.createBuffer();
          if (f)
            for (; p.length() < u;) {
              var g = Math.max(1, Math.min(u - p.length(), 65536) / 4),
                m = new Uint32Array(Math.floor(g));
              try {
                f(m);
                for (var E = 0; E < m.length; ++E) p.putInt32(m[E])
              } catch (Z) {
                if (!(typeof QuotaExceededError != "undefined" && Z instanceof QuotaExceededError)) throw Z
              }
            }
          if (p.length() < u)
            for (var w, O, q, J = Math.floor(Math.random() * 65536); p.length() < u;) {
              O = 16807 * (J & 65535), w = 16807 * (J >> 16), O += (w & 32767) << 16, O += w >> 15, O = (O & 2147483647) + (O >> 31), J = O & 4294967295;
              for (var E = 0; E < 3; ++E) q = J >>> (E << 3), q ^= Math.floor(Math.random() * 256), p.putByte(String.fromCharCode(q & 255))
            }
          return p.getBytes(u)
        }
        return c2 ? (e.seedFile = function (u, f) {
          c2.randomBytes(u, function (h, d) {
            if (h) return f(h);
            f(null, d.toString())
          })
        }, e.seedFileSync = function (u) {
          return c2.randomBytes(u).toString()
        }) : (e.seedFile = function (u, f) {
          try {
            f(null, c(u))
          } catch (h) {
            f(h)
          }
        }, e.seedFileSync = c), e.collect = function (u) {
          for (var f = u.length, h = 0; h < f; ++h) e.pools[e.pool].update(u.substr(h, 1)), e.pool = e.pool === 31 ? 0 : e.pool + 1
        }, e.collectInt = function (u, f) {
          for (var h = "", d = 0; d < f; d += 8) h += String.fromCharCode(u >> d & 255);
          e.collect(h)
        }, e.registerWorker = function (u) {
          if (u === self) e.seedFile = function (h, d) {
            function p(g) {
              var m = g.data;
              m.forge && m.forge.prng && (self.removeEventListener("message", p), d(m.forge.prng.err, m.forge.prng.bytes))
            }
            self.addEventListener("message", p), self.postMessage({
              forge: {
                prng: {
                  needed: h
                }
              }
            })
          };
          else {
            var f = function (h) {
              var d = h.data;
              d.forge && d.forge.prng && e.seedFile(d.forge.prng.needed, function (p, g) {
                u.postMessage({
                  forge: {
                    prng: {
                      err: p,
                      bytes: g
                    }
                  }
                })
              })
            };
            u.addEventListener("message", f)
          }
        }, e
      }
    });
    var Fu = y((ybt, YE) => {
      l();
      var Vi = At();
      cd();
      pq();
      gq();
      wr();
      (function () {
        if (Vi.random && Vi.random.getBytes) {
          YE.exports = Vi.random;
          return
        } (function (r) {
          var e = {},
            t = new Array(4),
            i = Vi.util.createBuffer();
          e.formatKey = function (h) {
            var d = Vi.util.createBuffer(h);
            return h = new Array(4), h[0] = d.getInt32(), h[1] = d.getInt32(), h[2] = d.getInt32(), h[3] = d.getInt32(), Vi.aes._expandKey(h, !1)
          }, e.formatSeed = function (h) {
            var d = Vi.util.createBuffer(h);
            return h = new Array(4), h[0] = d.getInt32(), h[1] = d.getInt32(), h[2] = d.getInt32(), h[3] = d.getInt32(), h
          }, e.cipher = function (h, d) {
            return Vi.aes._updateBlock(h, d, t, !1), i.putInt32(t[0]), i.putInt32(t[1]), i.putInt32(t[2]), i.putInt32(t[3]), i.getBytes()
          }, e.increment = function (h) {
            return ++h[3], h
          }, e.md = Vi.md.sha256;

          function n() {
            var h = Vi.prng.create(e);
            return h.getBytes = function (d, p) {
              return h.generate(d, p)
            }, h.getBytesSync = function (d) {
              return h.generate(d)
            }, h
          }
          var s = n(),
            o = null,
            a = Vi.util.globalScope,
            c = a.crypto || a.msCrypto;
          if (c && c.getRandomValues && (o = function (h) {
            return c.getRandomValues(h)
          }), Vi.options.usePureJavaScript || !Vi.util.isNodejs && !o) {
            if (typeof window == "undefined" || window.document === void 0, s.collectInt(+new Date, 32), typeof navigator != "undefined") {
              var u = "";
              for (var f in navigator) try {
                typeof navigator[f] == "string" && (u += navigator[f])
              } catch (h) { }
              s.collect(u), u = null
            }
            r && (r().mousemove(function (h) {
              s.collectInt(h.clientX, 16), s.collectInt(h.clientY, 16)
            }), r().keypress(function (h) {
              s.collectInt(h.charCode, 8)
            }))
          }
          if (!Vi.random) Vi.random = s;
          else
            for (var f in s) Vi.random[f] = s[f];
          Vi.random.createInstance = n, YE.exports = Vi.random
        })(typeof jQuery != "undefined" ? jQuery : null)
      })()
    });
    var wq = y((gbt, bq) => {
      l();
      var hs = At();
      wr();
      var JE = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173],
        mq = [1, 2, 3, 5],
        u8e = function (r, e) {
          return r << e & 65535 | (r & 65535) >> 16 - e
        },
        f8e = function (r, e) {
          return (r & 65535) >> e | r << 16 - e & 65535
        };
      bq.exports = hs.rc2 = hs.rc2 || {};
      hs.rc2.expandKey = function (r, e) {
        typeof r == "string" && (r = hs.util.createBuffer(r)), e = e || 128;
        var t = r,
          i = r.length(),
          n = e,
          s = Math.ceil(n / 8),
          o = 255 >> (n & 7),
          a;
        for (a = i; a < 128; a++) t.putByte(JE[t.at(a - 1) + t.at(a - i) & 255]);
        for (t.setAt(128 - s, JE[t.at(128 - s) & o]), a = 127 - s; a >= 0; a--) t.setAt(a, JE[t.at(a + 1) ^ t.at(a + s)]);
        return t
      };
      var vq = function (r, e, t) {
        var i = !1,
          n = null,
          s = null,
          o = null,
          a, c, u, f, h = [];
        for (r = hs.rc2.expandKey(r, e), u = 0; u < 64; u++) h.push(r.getInt16Le());
        t ? (a = function (g) {
          for (u = 0; u < 4; u++) g[u] += h[f] + (g[(u + 3) % 4] & g[(u + 2) % 4]) + (~g[(u + 3) % 4] & g[(u + 1) % 4]), g[u] = u8e(g[u], mq[u]), f++
        }, c = function (g) {
          for (u = 0; u < 4; u++) g[u] += h[g[(u + 3) % 4] & 63]
        }) : (a = function (g) {
          for (u = 3; u >= 0; u--) g[u] = f8e(g[u], mq[u]), g[u] -= h[f] + (g[(u + 3) % 4] & g[(u + 2) % 4]) + (~g[(u + 3) % 4] & g[(u + 1) % 4]), f--
        }, c = function (g) {
          for (u = 3; u >= 0; u--) g[u] -= h[g[(u + 3) % 4] & 63]
        });
        var d = function (g) {
          var m = [];
          for (u = 0; u < 4; u++) {
            var E = n.getInt16Le();
            o !== null && (t ? E ^= o.getInt16Le() : o.putInt16Le(E)), m.push(E & 65535)
          }
          f = t ? 0 : 63;
          for (var w = 0; w < g.length; w++)
            for (var O = 0; O < g[w][0]; O++) g[w][1](m);
          for (u = 0; u < 4; u++) o !== null && (t ? o.putInt16Le(m[u]) : m[u] ^= o.getInt16Le()), s.putInt16Le(m[u])
        },
          p = null;
        return p = {
          start: function (g, m) {
            g && typeof g == "string" && (g = hs.util.createBuffer(g)), i = !1, n = hs.util.createBuffer(), s = m || new hs.util.createBuffer, o = g, p.output = s
          },
          update: function (g) {
            for (i || n.putBuffer(g); n.length() >= 8;) d([
              [5, a],
              [1, c],
              [6, a],
              [1, c],
              [5, a]
            ])
          },
          finish: function (g) {
            var m = !0;
            if (t)
              if (g) m = g(8, n, !t);
              else {
                var E = n.length() === 8 ? 8 : 8 - n.length();
                n.fillWithByte(E, E)
              } if (m && (i = !0, p.update()), !t && (m = n.length() === 0, m))
              if (g) m = g(8, s, !t);
              else {
                var w = s.length(),
                  O = s.at(w - 1);
                O > w ? m = !1 : s.truncate(O)
              } return m
          }
        }, p
      };
      hs.rc2.startEncrypting = function (r, e, t) {
        var i = hs.rc2.createEncryptionCipher(r, 128);
        return i.start(e, t), i
      };
      hs.rc2.createEncryptionCipher = function (r, e) {
        return vq(r, e, !0)
      };
      hs.rc2.startDecrypting = function (r, e, t) {
        var i = hs.rc2.createDecryptionCipher(r, 128);
        return i.start(e, t), i
      };
      hs.rc2.createDecryptionCipher = function (r, e) {
        return vq(r, e, !1)
      }
    });
    var U1 = y((bbt, _q) => {
      l();
      var XE = At();
      _q.exports = XE.jsbn = XE.jsbn || {};
      var Fc, l8e = 244837814094590,
        Eq = (l8e & 16777215) == 15715070;

      function Pe(r, e, t) {
        this.data = [], r != null && (typeof r == "number" ? this.fromNumber(r, e, t) : e == null && typeof r != "string" ? this.fromString(r, 256) : this.fromString(r, e))
      }
      XE.jsbn.BigInteger = Pe;

      function Jt() {
        return new Pe(null)
      }

      function h8e(r, e, t, i, n, s) {
        for (; --s >= 0;) {
          var o = e * this.data[r++] + t.data[i] + n;
          n = Math.floor(o / 67108864), t.data[i++] = o & 67108863
        }
        return n
      }

      function d8e(r, e, t, i, n, s) {
        for (var o = e & 32767, a = e >> 15; --s >= 0;) {
          var c = this.data[r] & 32767,
            u = this.data[r++] >> 15,
            f = a * c + u * o;
          c = o * c + ((f & 32767) << 15) + t.data[i] + (n & 1073741823), n = (c >>> 30) + (f >>> 15) + a * u + (n >>> 30), t.data[i++] = c & 1073741823
        }
        return n
      }

      function Sq(r, e, t, i, n, s) {
        for (var o = e & 16383, a = e >> 14; --s >= 0;) {
          var c = this.data[r] & 16383,
            u = this.data[r++] >> 14,
            f = a * c + u * o;
          c = o * c + ((f & 16383) << 14) + t.data[i] + n, n = (c >> 28) + (f >> 14) + a * u, t.data[i++] = c & 268435455
        }
        return n
      }
      typeof navigator == "undefined" ? (Pe.prototype.am = Sq, Fc = 28) : Eq && navigator.appName == "Microsoft Internet Explorer" ? (Pe.prototype.am = d8e, Fc = 30) : Eq && navigator.appName != "Netscape" ? (Pe.prototype.am = h8e, Fc = 26) : (Pe.prototype.am = Sq, Fc = 28);
      Pe.prototype.DB = Fc;
      Pe.prototype.DM = (1 << Fc) - 1;
      Pe.prototype.DV = 1 << Fc;
      var ZE = 52;
      Pe.prototype.FV = Math.pow(2, ZE);
      Pe.prototype.F1 = ZE - Fc;
      Pe.prototype.F2 = 2 * Fc - ZE;
      var p8e = "0123456789abcdefghijklmnopqrstuvwxyz",
        u2 = new Array,
        ud, Xs;
      ud = "0".charCodeAt(0);
      for (Xs = 0; Xs <= 9; ++Xs) u2[ud++] = Xs;
      ud = "a".charCodeAt(0);
      for (Xs = 10; Xs < 36; ++Xs) u2[ud++] = Xs;
      ud = "A".charCodeAt(0);
      for (Xs = 10; Xs < 36; ++Xs) u2[ud++] = Xs;

      function xq(r) {
        return p8e.charAt(r)
      }

      function Aq(r, e) {
        var t = u2[r.charCodeAt(e)];
        return t ?? -1
      }

      function y8e(r) {
        for (var e = this.t - 1; e >= 0; --e) r.data[e] = this.data[e];
        r.t = this.t, r.s = this.s
      }

      function g8e(r) {
        this.t = 1, this.s = r < 0 ? -1 : 0, r > 0 ? this.data[0] = r : r < -1 ? this.data[0] = r + this.DV : this.t = 0
      }

      function Uu(r) {
        var e = Jt();
        return e.fromInt(r), e
      }

      function b8e(r, e) {
        var t;
        if (e == 16) t = 4;
        else if (e == 8) t = 3;
        else if (e == 256) t = 8;
        else if (e == 2) t = 1;
        else if (e == 32) t = 5;
        else if (e == 4) t = 2;
        else {
          this.fromRadix(r, e);
          return
        }
        this.t = 0, this.s = 0;
        for (var i = r.length, n = !1, s = 0; --i >= 0;) {
          var o = t == 8 ? r[i] & 255 : Aq(r, i);
          if (o < 0) {
            r.charAt(i) == "-" && (n = !0);
            continue
          }
          n = !1, s == 0 ? this.data[this.t++] = o : s + t > this.DB ? (this.data[this.t - 1] |= (o & (1 << this.DB - s) - 1) << s, this.data[this.t++] = o >> this.DB - s) : this.data[this.t - 1] |= o << s, s += t, s >= this.DB && (s -= this.DB)
        }
        t == 8 && (r[0] & 128) != 0 && (this.s = -1, s > 0 && (this.data[this.t - 1] |= (1 << this.DB - s) - 1 << s)), this.clamp(), n && Pe.ZERO.subTo(this, this)
      }

      function m8e() {
        for (var r = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == r;) --this.t
      }

      function v8e(r) {
        if (this.s < 0) return "-" + this.negate().toString(r);
        var e;
        if (r == 16) e = 4;
        else if (r == 8) e = 3;
        else if (r == 2) e = 1;
        else if (r == 32) e = 5;
        else if (r == 4) e = 2;
        else return this.toRadix(r);
        var t = (1 << e) - 1,
          i, n = !1,
          s = "",
          o = this.t,
          a = this.DB - o * this.DB % e;
        if (o-- > 0)
          for (a < this.DB && (i = this.data[o] >> a) > 0 && (n = !0, s = xq(i)); o >= 0;) a < e ? (i = (this.data[o] & (1 << a) - 1) << e - a, i |= this.data[--o] >> (a += this.DB - e)) : (i = this.data[o] >> (a -= e) & t, a <= 0 && (a += this.DB, --o)), i > 0 && (n = !0), n && (s += xq(i));
        return n ? s : "0"
      }

      function w8e() {
        var r = Jt();
        return Pe.ZERO.subTo(this, r), r
      }

      function _8e() {
        return this.s < 0 ? this.negate() : this
      }

      function E8e(r) {
        var e = this.s - r.s;
        if (e != 0) return e;
        var t = this.t;
        if (e = t - r.t, e != 0) return this.s < 0 ? -e : e;
        for (; --t >= 0;)
          if ((e = this.data[t] - r.data[t]) != 0) return e;
        return 0
      }

      function f2(r) {
        var e = 1,
          t;
        return (t = r >>> 16) != 0 && (r = t, e += 16), (t = r >> 8) != 0 && (r = t, e += 8), (t = r >> 4) != 0 && (r = t, e += 4), (t = r >> 2) != 0 && (r = t, e += 2), (t = r >> 1) != 0 && (r = t, e += 1), e
      }

      function S8e() {
        return this.t <= 0 ? 0 : this.DB * (this.t - 1) + f2(this.data[this.t - 1] ^ this.s & this.DM)
      }

      function x8e(r, e) {
        var t;
        for (t = this.t - 1; t >= 0; --t) e.data[t + r] = this.data[t];
        for (t = r - 1; t >= 0; --t) e.data[t] = 0;
        e.t = this.t + r, e.s = this.s
      }

      function A8e(r, e) {
        for (var t = r; t < this.t; ++t) e.data[t - r] = this.data[t];
        e.t = Math.max(this.t - r, 0), e.s = this.s
      }

      function I8e(r, e) {
        var t = r % this.DB,
          i = this.DB - t,
          n = (1 << i) - 1,
          s = Math.floor(r / this.DB),
          o = this.s << t & this.DM,
          a;
        for (a = this.t - 1; a >= 0; --a) e.data[a + s + 1] = this.data[a] >> i | o, o = (this.data[a] & n) << t;
        for (a = s - 1; a >= 0; --a) e.data[a] = 0;
        e.data[s] = o, e.t = this.t + s + 1, e.s = this.s, e.clamp()
      }

      function T8e(r, e) {
        e.s = this.s;
        var t = Math.floor(r / this.DB);
        if (t >= this.t) {
          e.t = 0;
          return
        }
        var i = r % this.DB,
          n = this.DB - i,
          s = (1 << i) - 1;
        e.data[0] = this.data[t] >> i;
        for (var o = t + 1; o < this.t; ++o) e.data[o - t - 1] |= (this.data[o] & s) << n, e.data[o - t] = this.data[o] >> i;
        i > 0 && (e.data[this.t - t - 1] |= (this.s & s) << n), e.t = this.t - t, e.clamp()
      }

      function R8e(r, e) {
        for (var t = 0, i = 0, n = Math.min(r.t, this.t); t < n;) i += this.data[t] - r.data[t], e.data[t++] = i & this.DM, i >>= this.DB;
        if (r.t < this.t) {
          for (i -= r.s; t < this.t;) i += this.data[t], e.data[t++] = i & this.DM, i >>= this.DB;
          i += this.s
        } else {
          for (i += this.s; t < r.t;) i -= r.data[t], e.data[t++] = i & this.DM, i >>= this.DB;
          i -= r.s
        }
        e.s = i < 0 ? -1 : 0, i < -1 ? e.data[t++] = this.DV + i : i > 0 && (e.data[t++] = i), e.t = t, e.clamp()
      }

      function k8e(r, e) {
        var t = this.abs(),
          i = r.abs(),
          n = t.t;
        for (e.t = n + i.t; --n >= 0;) e.data[n] = 0;
        for (n = 0; n < i.t; ++n) e.data[n + t.t] = t.am(0, i.data[n], e, n, 0, t.t);
        e.s = 0, e.clamp(), this.s != r.s && Pe.ZERO.subTo(e, e)
      }

      function P8e(r) {
        for (var e = this.abs(), t = r.t = 2 * e.t; --t >= 0;) r.data[t] = 0;
        for (t = 0; t < e.t - 1; ++t) {
          var i = e.am(t, e.data[t], r, 2 * t, 0, 1);
          (r.data[t + e.t] += e.am(t + 1, 2 * e.data[t], r, 2 * t + 1, i, e.t - t - 1)) >= e.DV && (r.data[t + e.t] -= e.DV, r.data[t + e.t + 1] = 1)
        }
        r.t > 0 && (r.data[r.t - 1] += e.am(t, e.data[t], r, 2 * t, 0, 1)), r.s = 0, r.clamp()
      }

      function C8e(r, e, t) {
        var i = r.abs();
        if (!(i.t <= 0)) {
          var n = this.abs();
          if (n.t < i.t) {
            e != null && e.fromInt(0), t != null && this.copyTo(t);
            return
          }
          t == null && (t = Jt());
          var s = Jt(),
            o = this.s,
            a = r.s,
            c = this.DB - f2(i.data[i.t - 1]);
          c > 0 ? (i.lShiftTo(c, s), n.lShiftTo(c, t)) : (i.copyTo(s), n.copyTo(t));
          var u = s.t,
            f = s.data[u - 1];
          if (f != 0) {
            var h = f * (1 << this.F1) + (u > 1 ? s.data[u - 2] >> this.F2 : 0),
              d = this.FV / h,
              p = (1 << this.F1) / h,
              g = 1 << this.F2,
              m = t.t,
              E = m - u,
              w = e ?? Jt();
            for (s.dlShiftTo(E, w), t.compareTo(w) >= 0 && (t.data[t.t++] = 1, t.subTo(w, t)), Pe.ONE.dlShiftTo(u, w), w.subTo(s, s); s.t < u;) s.data[s.t++] = 0;
            for (; --E >= 0;) {
              var O = t.data[--m] == f ? this.DM : Math.floor(t.data[m] * d + (t.data[m - 1] + g) * p);
              if ((t.data[m] += s.am(0, O, t, E, 0, u)) < O)
                for (s.dlShiftTo(E, w), t.subTo(w, t); t.data[m] < --O;) t.subTo(w, t)
            }
            e != null && (t.drShiftTo(u, e), o != a && Pe.ZERO.subTo(e, e)), t.t = u, t.clamp(), c > 0 && t.rShiftTo(c, t), o < 0 && Pe.ZERO.subTo(t, t)
          }
        }
      }

      function O8e(r) {
        var e = Jt();
        return this.abs().divRemTo(r, null, e), this.s < 0 && e.compareTo(Pe.ZERO) > 0 && r.subTo(e, e), e
      }

      function sl(r) {
        this.m = r
      }

      function N8e(r) {
        return r.s < 0 || r.compareTo(this.m) >= 0 ? r.mod(this.m) : r
      }

      function q8e(r) {
        return r
      }

      function M8e(r) {
        r.divRemTo(this.m, null, r)
      }

      function B8e(r, e, t) {
        r.multiplyTo(e, t), this.reduce(t)
      }

      function D8e(r, e) {
        r.squareTo(e), this.reduce(e)
      }
      sl.prototype.convert = N8e;
      sl.prototype.revert = q8e;
      sl.prototype.reduce = M8e;
      sl.prototype.mulTo = B8e;
      sl.prototype.sqrTo = D8e;

      function L8e() {
        if (this.t < 1) return 0;
        var r = this.data[0];
        if ((r & 1) == 0) return 0;
        var e = r & 3;
        return e = e * (2 - (r & 15) * e) & 15, e = e * (2 - (r & 255) * e) & 255, e = e * (2 - ((r & 65535) * e & 65535)) & 65535, e = e * (2 - r * e % this.DV) % this.DV, e > 0 ? this.DV - e : -e
      }

      function ol(r) {
        this.m = r, this.mp = r.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << r.DB - 15) - 1, this.mt2 = 2 * r.t
      }

      function F8e(r) {
        var e = Jt();
        return r.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), r.s < 0 && e.compareTo(Pe.ZERO) > 0 && this.m.subTo(e, e), e
      }

      function U8e(r) {
        var e = Jt();
        return r.copyTo(e), this.reduce(e), e
      }

      function K8e(r) {
        for (; r.t <= this.mt2;) r.data[r.t++] = 0;
        for (var e = 0; e < this.m.t; ++e) {
          var t = r.data[e] & 32767,
            i = t * this.mpl + ((t * this.mph + (r.data[e] >> 15) * this.mpl & this.um) << 15) & r.DM;
          for (t = e + this.m.t, r.data[t] += this.m.am(0, i, r, e, 0, this.m.t); r.data[t] >= r.DV;) r.data[t] -= r.DV, r.data[++t]++
        }
        r.clamp(), r.drShiftTo(this.m.t, r), r.compareTo(this.m) >= 0 && r.subTo(this.m, r)
      }

      function z8e(r, e) {
        r.squareTo(e), this.reduce(e)
      }

      function j8e(r, e, t) {
        r.multiplyTo(e, t), this.reduce(t)
      }
      ol.prototype.convert = F8e;
      ol.prototype.revert = U8e;
      ol.prototype.reduce = K8e;
      ol.prototype.mulTo = j8e;
      ol.prototype.sqrTo = z8e;

      function V8e() {
        return (this.t > 0 ? this.data[0] & 1 : this.s) == 0
      }

      function H8e(r, e) {
        if (r > 4294967295 || r < 1) return Pe.ONE;
        var t = Jt(),
          i = Jt(),
          n = e.convert(this),
          s = f2(r) - 1;
        for (n.copyTo(t); --s >= 0;)
          if (e.sqrTo(t, i), (r & 1 << s) > 0) e.mulTo(i, n, t);
          else {
            var o = t;
            t = i, i = o
          } return e.revert(t)
      }

      function G8e(r, e) {
        var t;
        return r < 256 || e.isEven() ? t = new sl(e) : t = new ol(e), this.exp(r, t)
      }
      Pe.prototype.copyTo = y8e;
      Pe.prototype.fromInt = g8e;
      Pe.prototype.fromString = b8e;
      Pe.prototype.clamp = m8e;
      Pe.prototype.dlShiftTo = x8e;
      Pe.prototype.drShiftTo = A8e;
      Pe.prototype.lShiftTo = I8e;
      Pe.prototype.rShiftTo = T8e;
      Pe.prototype.subTo = R8e;
      Pe.prototype.multiplyTo = k8e;
      Pe.prototype.squareTo = P8e;
      Pe.prototype.divRemTo = C8e;
      Pe.prototype.invDigit = L8e;
      Pe.prototype.isEven = V8e;
      Pe.prototype.exp = H8e;
      Pe.prototype.toString = v8e;
      Pe.prototype.negate = w8e;
      Pe.prototype.abs = _8e;
      Pe.prototype.compareTo = E8e;
      Pe.prototype.bitLength = S8e;
      Pe.prototype.mod = O8e;
      Pe.prototype.modPowInt = G8e;
      Pe.ZERO = Uu(0);
      Pe.ONE = Uu(1);

      function $8e() {
        var r = Jt();
        return this.copyTo(r), r
      }

      function W8e() {
        if (this.s < 0) {
          if (this.t == 1) return this.data[0] - this.DV;
          if (this.t == 0) return -1
        } else {
          if (this.t == 1) return this.data[0];
          if (this.t == 0) return 0
        }
        return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0]
      }

      function Y8e() {
        return this.t == 0 ? this.s : this.data[0] << 24 >> 24
      }

      function J8e() {
        return this.t == 0 ? this.s : this.data[0] << 16 >> 16
      }

      function X8e(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r))
      }

      function Z8e() {
        return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1
      }

      function Q8e(r) {
        if (r == null && (r = 10), this.signum() == 0 || r < 2 || r > 36) return "0";
        var e = this.chunkSize(r),
          t = Math.pow(r, e),
          i = Uu(t),
          n = Jt(),
          s = Jt(),
          o = "";
        for (this.divRemTo(i, n, s); n.signum() > 0;) o = (t + s.intValue()).toString(r).substr(1) + o, n.divRemTo(i, n, s);
        return s.intValue().toString(r) + o
      }

      function exe(r, e) {
        this.fromInt(0), e == null && (e = 10);
        for (var t = this.chunkSize(e), i = Math.pow(e, t), n = !1, s = 0, o = 0, a = 0; a < r.length; ++a) {
          var c = Aq(r, a);
          if (c < 0) {
            r.charAt(a) == "-" && this.signum() == 0 && (n = !0);
            continue
          }
          o = e * o + c, ++s >= t && (this.dMultiply(i), this.dAddOffset(o, 0), s = 0, o = 0)
        }
        s > 0 && (this.dMultiply(Math.pow(e, s)), this.dAddOffset(o, 0)), n && Pe.ZERO.subTo(this, this)
      }

      function txe(r, e, t) {
        if (typeof e == "number")
          if (r < 2) this.fromInt(1);
          else
            for (this.fromNumber(r, t), this.testBit(r - 1) || this.bitwiseTo(Pe.ONE.shiftLeft(r - 1), QE, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e);) this.dAddOffset(2, 0), this.bitLength() > r && this.subTo(Pe.ONE.shiftLeft(r - 1), this);
        else {
          var i = new Array,
            n = r & 7;
          i.length = (r >> 3) + 1, e.nextBytes(i), n > 0 ? i[0] &= (1 << n) - 1 : i[0] = 0, this.fromString(i, 256)
        }
      }

      function rxe() {
        var r = this.t,
          e = new Array;
        e[0] = this.s;
        var t = this.DB - r * this.DB % 8,
          i, n = 0;
        if (r-- > 0)
          for (t < this.DB && (i = this.data[r] >> t) != (this.s & this.DM) >> t && (e[n++] = i | this.s << this.DB - t); r >= 0;) t < 8 ? (i = (this.data[r] & (1 << t) - 1) << 8 - t, i |= this.data[--r] >> (t += this.DB - 8)) : (i = this.data[r] >> (t -= 8) & 255, t <= 0 && (t += this.DB, --r)), (i & 128) != 0 && (i |= -256), n == 0 && (this.s & 128) != (i & 128) && ++n, (n > 0 || i != this.s) && (e[n++] = i);
        return e
      }

      function ixe(r) {
        return this.compareTo(r) == 0
      }

      function nxe(r) {
        return this.compareTo(r) < 0 ? this : r
      }

      function sxe(r) {
        return this.compareTo(r) > 0 ? this : r
      }

      function oxe(r, e, t) {
        var i, n, s = Math.min(r.t, this.t);
        for (i = 0; i < s; ++i) t.data[i] = e(this.data[i], r.data[i]);
        if (r.t < this.t) {
          for (n = r.s & this.DM, i = s; i < this.t; ++i) t.data[i] = e(this.data[i], n);
          t.t = this.t
        } else {
          for (n = this.s & this.DM, i = s; i < r.t; ++i) t.data[i] = e(n, r.data[i]);
          t.t = r.t
        }
        t.s = e(this.s, r.s), t.clamp()
      }

      function axe(r, e) {
        return r & e
      }

      function cxe(r) {
        var e = Jt();
        return this.bitwiseTo(r, axe, e), e
      }

      function QE(r, e) {
        return r | e
      }

      function uxe(r) {
        var e = Jt();
        return this.bitwiseTo(r, QE, e), e
      }

      function Iq(r, e) {
        return r ^ e
      }

      function fxe(r) {
        var e = Jt();
        return this.bitwiseTo(r, Iq, e), e
      }

      function Tq(r, e) {
        return r & ~e
      }

      function lxe(r) {
        var e = Jt();
        return this.bitwiseTo(r, Tq, e), e
      }

      function hxe() {
        for (var r = Jt(), e = 0; e < this.t; ++e) r.data[e] = this.DM & ~this.data[e];
        return r.t = this.t, r.s = ~this.s, r
      }

      function dxe(r) {
        var e = Jt();
        return r < 0 ? this.rShiftTo(-r, e) : this.lShiftTo(r, e), e
      }

      function pxe(r) {
        var e = Jt();
        return r < 0 ? this.lShiftTo(-r, e) : this.rShiftTo(r, e), e
      }

      function yxe(r) {
        if (r == 0) return -1;
        var e = 0;
        return (r & 65535) == 0 && (r >>= 16, e += 16), (r & 255) == 0 && (r >>= 8, e += 8), (r & 15) == 0 && (r >>= 4, e += 4), (r & 3) == 0 && (r >>= 2, e += 2), (r & 1) == 0 && ++e, e
      }

      function gxe() {
        for (var r = 0; r < this.t; ++r)
          if (this.data[r] != 0) return r * this.DB + yxe(this.data[r]);
        return this.s < 0 ? this.t * this.DB : -1
      }

      function bxe(r) {
        for (var e = 0; r != 0;) r &= r - 1, ++e;
        return e
      }

      function mxe() {
        for (var r = 0, e = this.s & this.DM, t = 0; t < this.t; ++t) r += bxe(this.data[t] ^ e);
        return r
      }

      function vxe(r) {
        var e = Math.floor(r / this.DB);
        return e >= this.t ? this.s != 0 : (this.data[e] & 1 << r % this.DB) != 0
      }

      function wxe(r, e) {
        var t = Pe.ONE.shiftLeft(r);
        return this.bitwiseTo(t, e, t), t
      }

      function _xe(r) {
        return this.changeBit(r, QE)
      }

      function Exe(r) {
        return this.changeBit(r, Tq)
      }

      function Sxe(r) {
        return this.changeBit(r, Iq)
      }

      function xxe(r, e) {
        for (var t = 0, i = 0, n = Math.min(r.t, this.t); t < n;) i += this.data[t] + r.data[t], e.data[t++] = i & this.DM, i >>= this.DB;
        if (r.t < this.t) {
          for (i += r.s; t < this.t;) i += this.data[t], e.data[t++] = i & this.DM, i >>= this.DB;
          i += this.s
        } else {
          for (i += this.s; t < r.t;) i += r.data[t], e.data[t++] = i & this.DM, i >>= this.DB;
          i += r.s
        }
        e.s = i < 0 ? -1 : 0, i > 0 ? e.data[t++] = i : i < -1 && (e.data[t++] = this.DV + i), e.t = t, e.clamp()
      }

      function Axe(r) {
        var e = Jt();
        return this.addTo(r, e), e
      }

      function Ixe(r) {
        var e = Jt();
        return this.subTo(r, e), e
      }

      function Txe(r) {
        var e = Jt();
        return this.multiplyTo(r, e), e
      }

      function Rxe(r) {
        var e = Jt();
        return this.divRemTo(r, e, null), e
      }

      function kxe(r) {
        var e = Jt();
        return this.divRemTo(r, null, e), e
      }

      function Pxe(r) {
        var e = Jt(),
          t = Jt();
        return this.divRemTo(r, e, t), new Array(e, t)
      }

      function Cxe(r) {
        this.data[this.t] = this.am(0, r - 1, this, 0, 0, this.t), ++this.t, this.clamp()
      }

      function Oxe(r, e) {
        if (r != 0) {
          for (; this.t <= e;) this.data[this.t++] = 0;
          for (this.data[e] += r; this.data[e] >= this.DV;) this.data[e] -= this.DV, ++e >= this.t && (this.data[this.t++] = 0), ++this.data[e]
        }
      }

      function F1() { }

      function Rq(r) {
        return r
      }

      function Nxe(r, e, t) {
        r.multiplyTo(e, t)
      }

      function qxe(r, e) {
        r.squareTo(e)
      }
      F1.prototype.convert = Rq;
      F1.prototype.revert = Rq;
      F1.prototype.mulTo = Nxe;
      F1.prototype.sqrTo = qxe;

      function Mxe(r) {
        return this.exp(r, new F1)
      }

      function Bxe(r, e, t) {
        var i = Math.min(this.t + r.t, e);
        for (t.s = 0, t.t = i; i > 0;) t.data[--i] = 0;
        var n;
        for (n = t.t - this.t; i < n; ++i) t.data[i + this.t] = this.am(0, r.data[i], t, i, 0, this.t);
        for (n = Math.min(r.t, e); i < n; ++i) this.am(0, r.data[i], t, i, 0, e - i);
        t.clamp()
      }

      function Dxe(r, e, t) {
        --e;
        var i = t.t = this.t + r.t - e;
        for (t.s = 0; --i >= 0;) t.data[i] = 0;
        for (i = Math.max(e - this.t, 0); i < r.t; ++i) t.data[this.t + i - e] = this.am(e - i, r.data[i], t, 0, 0, this.t + i - e);
        t.clamp(), t.drShiftTo(1, t)
      }

      function fd(r) {
        this.r2 = Jt(), this.q3 = Jt(), Pe.ONE.dlShiftTo(2 * r.t, this.r2), this.mu = this.r2.divide(r), this.m = r
      }

      function Lxe(r) {
        if (r.s < 0 || r.t > 2 * this.m.t) return r.mod(this.m);
        if (r.compareTo(this.m) < 0) return r;
        var e = Jt();
        return r.copyTo(e), this.reduce(e), e
      }

      function Fxe(r) {
        return r
      }

      function Uxe(r) {
        for (r.drShiftTo(this.m.t - 1, this.r2), r.t > this.m.t + 1 && (r.t = this.m.t + 1, r.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); r.compareTo(this.r2) < 0;) r.dAddOffset(1, this.m.t + 1);
        for (r.subTo(this.r2, r); r.compareTo(this.m) >= 0;) r.subTo(this.m, r)
      }

      function Kxe(r, e) {
        r.squareTo(e), this.reduce(e)
      }

      function zxe(r, e, t) {
        r.multiplyTo(e, t), this.reduce(t)
      }
      fd.prototype.convert = Lxe;
      fd.prototype.revert = Fxe;
      fd.prototype.reduce = Uxe;
      fd.prototype.mulTo = zxe;
      fd.prototype.sqrTo = Kxe;

      function jxe(r, e) {
        var t = r.bitLength(),
          i, n = Uu(1),
          s;
        if (t <= 0) return n;
        t < 18 ? i = 1 : t < 48 ? i = 3 : t < 144 ? i = 4 : t < 768 ? i = 5 : i = 6, t < 8 ? s = new sl(e) : e.isEven() ? s = new fd(e) : s = new ol(e);
        var o = new Array,
          a = 3,
          c = i - 1,
          u = (1 << i) - 1;
        if (o[1] = s.convert(this), i > 1) {
          var f = Jt();
          for (s.sqrTo(o[1], f); a <= u;) o[a] = Jt(), s.mulTo(f, o[a - 2], o[a]), a += 2
        }
        var h = r.t - 1,
          d, p = !0,
          g = Jt(),
          m;
        for (t = f2(r.data[h]) - 1; h >= 0;) {
          for (t >= c ? d = r.data[h] >> t - c & u : (d = (r.data[h] & (1 << t + 1) - 1) << c - t, h > 0 && (d |= r.data[h - 1] >> this.DB + t - c)), a = i;
            (d & 1) == 0;) d >>= 1, --a;
          if ((t -= a) < 0 && (t += this.DB, --h), p) o[d].copyTo(n), p = !1;
          else {
            for (; a > 1;) s.sqrTo(n, g), s.sqrTo(g, n), a -= 2;
            a > 0 ? s.sqrTo(n, g) : (m = n, n = g, g = m), s.mulTo(g, o[d], n)
          }
          for (; h >= 0 && (r.data[h] & 1 << t) == 0;) s.sqrTo(n, g), m = n, n = g, g = m, --t < 0 && (t = this.DB - 1, --h)
        }
        return s.revert(n)
      }

      function Vxe(r) {
        var e = this.s < 0 ? this.negate() : this.clone(),
          t = r.s < 0 ? r.negate() : r.clone();
        if (e.compareTo(t) < 0) {
          var i = e;
          e = t, t = i
        }
        var n = e.getLowestSetBit(),
          s = t.getLowestSetBit();
        if (s < 0) return e;
        for (n < s && (s = n), s > 0 && (e.rShiftTo(s, e), t.rShiftTo(s, t)); e.signum() > 0;)(n = e.getLowestSetBit()) > 0 && e.rShiftTo(n, e), (n = t.getLowestSetBit()) > 0 && t.rShiftTo(n, t), e.compareTo(t) >= 0 ? (e.subTo(t, e), e.rShiftTo(1, e)) : (t.subTo(e, t), t.rShiftTo(1, t));
        return s > 0 && t.lShiftTo(s, t), t
      }

      function Hxe(r) {
        if (r <= 0) return 0;
        var e = this.DV % r,
          t = this.s < 0 ? r - 1 : 0;
        if (this.t > 0)
          if (e == 0) t = this.data[0] % r;
          else
            for (var i = this.t - 1; i >= 0; --i) t = (e * t + this.data[i]) % r;
        return t
      }

      function Gxe(r) {
        var e = r.isEven();
        if (this.isEven() && e || r.signum() == 0) return Pe.ZERO;
        for (var t = r.clone(), i = this.clone(), n = Uu(1), s = Uu(0), o = Uu(0), a = Uu(1); t.signum() != 0;) {
          for (; t.isEven();) t.rShiftTo(1, t), e ? ((!n.isEven() || !s.isEven()) && (n.addTo(this, n), s.subTo(r, s)), n.rShiftTo(1, n)) : s.isEven() || s.subTo(r, s), s.rShiftTo(1, s);
          for (; i.isEven();) i.rShiftTo(1, i), e ? ((!o.isEven() || !a.isEven()) && (o.addTo(this, o), a.subTo(r, a)), o.rShiftTo(1, o)) : a.isEven() || a.subTo(r, a), a.rShiftTo(1, a);
          t.compareTo(i) >= 0 ? (t.subTo(i, t), e && n.subTo(o, n), s.subTo(a, s)) : (i.subTo(t, i), e && o.subTo(n, o), a.subTo(s, a))
        }
        if (i.compareTo(Pe.ONE) != 0) return Pe.ZERO;
        if (a.compareTo(r) >= 0) return a.subtract(r);
        if (a.signum() < 0) a.addTo(r, a);
        else return a;
        return a.signum() < 0 ? a.add(r) : a
      }
      var Ko = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509],
        $xe = (1 << 26) / Ko[Ko.length - 1];

      function Wxe(r) {
        var e, t = this.abs();
        if (t.t == 1 && t.data[0] <= Ko[Ko.length - 1]) {
          for (e = 0; e < Ko.length; ++e)
            if (t.data[0] == Ko[e]) return !0;
          return !1
        }
        if (t.isEven()) return !1;
        for (e = 1; e < Ko.length;) {
          for (var i = Ko[e], n = e + 1; n < Ko.length && i < $xe;) i *= Ko[n++];
          for (i = t.modInt(i); e < n;)
            if (i % Ko[e++] == 0) return !1
        }
        return t.millerRabin(r)
      }

      function Jxe(r) {
        var e = this.subtract(Pe.ONE),
          t = e.getLowestSetBit();
        if (t <= 0) return !1;
        for (var i = e.shiftRight(t), n = Yxe(), s, o = 0; o < r; ++o) {
          do s = new Pe(this.bitLength(), n); while (s.compareTo(Pe.ONE) <= 0 || s.compareTo(e) >= 0);
          var a = s.modPow(i, this);
          if (a.compareTo(Pe.ONE) != 0 && a.compareTo(e) != 0) {
            for (var c = 1; c++ < t && a.compareTo(e) != 0;)
              if (a = a.modPowInt(2, this), a.compareTo(Pe.ONE) == 0) return !1;
            if (a.compareTo(e) != 0) return !1
          }
        }
        return !0
      }

      function Yxe() {
        return {
          nextBytes: function (r) {
            for (var e = 0; e < r.length; ++e) r[e] = Math.floor(Math.random() * 256)
          }
        }
      }
      Pe.prototype.chunkSize = X8e;
      Pe.prototype.toRadix = Q8e;
      Pe.prototype.fromRadix = exe;
      Pe.prototype.fromNumber = txe;
      Pe.prototype.bitwiseTo = oxe;
      Pe.prototype.changeBit = wxe;
      Pe.prototype.addTo = xxe;
      Pe.prototype.dMultiply = Cxe;
      Pe.prototype.dAddOffset = Oxe;
      Pe.prototype.multiplyLowerTo = Bxe;
      Pe.prototype.multiplyUpperTo = Dxe;
      Pe.prototype.modInt = Hxe;
      Pe.prototype.millerRabin = Jxe;
      Pe.prototype.clone = $8e;
      Pe.prototype.intValue = W8e;
      Pe.prototype.byteValue = Y8e;
      Pe.prototype.shortValue = J8e;
      Pe.prototype.signum = Z8e;
      Pe.prototype.toByteArray = rxe;
      Pe.prototype.equals = ixe;
      Pe.prototype.min = nxe;
      Pe.prototype.max = sxe;
      Pe.prototype.and = cxe;
      Pe.prototype.or = uxe;
      Pe.prototype.xor = fxe;
      Pe.prototype.andNot = lxe;
      Pe.prototype.not = hxe;
      Pe.prototype.shiftLeft = dxe;
      Pe.prototype.shiftRight = pxe;
      Pe.prototype.getLowestSetBit = gxe;
      Pe.prototype.bitCount = mxe;
      Pe.prototype.testBit = vxe;
      Pe.prototype.setBit = _xe;
      Pe.prototype.clearBit = Exe;
      Pe.prototype.flipBit = Sxe;
      Pe.prototype.add = Axe;
      Pe.prototype.subtract = Ixe;
      Pe.prototype.multiply = Txe;
      Pe.prototype.divide = Rxe;
      Pe.prototype.remainder = kxe;
      Pe.prototype.divideAndRemainder = Pxe;
      Pe.prototype.modPow = jxe;
      Pe.prototype.modInverse = Gxe;
      Pe.prototype.pow = Mxe;
      Pe.prototype.gcd = Vxe;
      Pe.prototype.isProbablePrime = Wxe
    });
    var Nq = y((mbt, kq) => {
      l();
      var Na = At();
      Lu();
      wr();
      var Pq = kq.exports = Na.sha1 = Na.sha1 || {};
      Na.md.sha1 = Na.md.algorithms.sha1 = Pq;
      Pq.create = function () {
        Cq || Xxe();
        var r = null,
          e = Na.util.createBuffer(),
          t = new Array(80),
          i = {
            algorithm: "sha1",
            blockLength: 64,
            digestLength: 20,
            messageLength: 0,
            fullMessageLength: null,
            messageLengthSize: 8
          };
        return i.start = function () {
          i.messageLength = 0, i.fullMessageLength = i.messageLength64 = [];
          for (var n = i.messageLengthSize / 4, s = 0; s < n; ++s) i.fullMessageLength.push(0);
          return e = Na.util.createBuffer(), r = {
            h0: 1732584193,
            h1: 4023233417,
            h2: 2562383102,
            h3: 271733878,
            h4: 3285377520
          }, i
        }, i.start(), i.update = function (n, s) {
          s === "utf8" && (n = Na.util.encodeUtf8(n));
          var o = n.length;
          i.messageLength += o, o = [o / 4294967296 >>> 0, o >>> 0];
          for (var a = i.fullMessageLength.length - 1; a >= 0; --a) i.fullMessageLength[a] += o[1], o[1] = o[0] + (i.fullMessageLength[a] / 4294967296 >>> 0), i.fullMessageLength[a] = i.fullMessageLength[a] >>> 0, o[0] = o[1] / 4294967296 >>> 0;
          return e.putBytes(n), Oq(r, t, e), (e.read > 2048 || e.length() === 0) && e.compact(), i
        }, i.digest = function () {
          var n = Na.util.createBuffer();
          n.putBytes(e.bytes());
          var s = i.fullMessageLength[i.fullMessageLength.length - 1] + i.messageLengthSize,
            o = s & i.blockLength - 1;
          n.putBytes(eS.substr(0, i.blockLength - o));
          for (var a, c, u = i.fullMessageLength[0] * 8, f = 0; f < i.fullMessageLength.length - 1; ++f) a = i.fullMessageLength[f + 1] * 8, c = a / 4294967296 >>> 0, u += c, n.putInt32(u >>> 0), u = a >>> 0;
          n.putInt32(u);
          var h = {
            h0: r.h0,
            h1: r.h1,
            h2: r.h2,
            h3: r.h3,
            h4: r.h4
          };
          Oq(h, t, n);
          var d = Na.util.createBuffer();
          return d.putInt32(h.h0), d.putInt32(h.h1), d.putInt32(h.h2), d.putInt32(h.h3), d.putInt32(h.h4), d
        }, i
      };
      var eS = null,
        Cq = !1;

      function Xxe() {
        eS = String.fromCharCode(128), eS += Na.util.fillString(String.fromCharCode(0), 64), Cq = !0
      }

      function Oq(r, e, t) {
        for (var i, n, s, o, a, c, u, f, h = t.length(); h >= 64;) {
          for (n = r.h0, s = r.h1, o = r.h2, a = r.h3, c = r.h4, f = 0; f < 16; ++f) i = t.getInt32(), e[f] = i, u = a ^ s & (o ^ a), i = (n << 5 | n >>> 27) + u + c + 1518500249 + i, c = a, a = o, o = (s << 30 | s >>> 2) >>> 0, s = n, n = i;
          for (; f < 20; ++f) i = e[f - 3] ^ e[f - 8] ^ e[f - 14] ^ e[f - 16], i = i << 1 | i >>> 31, e[f] = i, u = a ^ s & (o ^ a), i = (n << 5 | n >>> 27) + u + c + 1518500249 + i, c = a, a = o, o = (s << 30 | s >>> 2) >>> 0, s = n, n = i;
          for (; f < 32; ++f) i = e[f - 3] ^ e[f - 8] ^ e[f - 14] ^ e[f - 16], i = i << 1 | i >>> 31, e[f] = i, u = s ^ o ^ a, i = (n << 5 | n >>> 27) + u + c + 1859775393 + i, c = a, a = o, o = (s << 30 | s >>> 2) >>> 0, s = n, n = i;
          for (; f < 40; ++f) i = e[f - 6] ^ e[f - 16] ^ e[f - 28] ^ e[f - 32], i = i << 2 | i >>> 30, e[f] = i, u = s ^ o ^ a, i = (n << 5 | n >>> 27) + u + c + 1859775393 + i, c = a, a = o, o = (s << 30 | s >>> 2) >>> 0, s = n, n = i;
          for (; f < 60; ++f) i = e[f - 6] ^ e[f - 16] ^ e[f - 28] ^ e[f - 32], i = i << 2 | i >>> 30, e[f] = i, u = s & o | a & (s ^ o), i = (n << 5 | n >>> 27) + u + c + 2400959708 + i, c = a, a = o, o = (s << 30 | s >>> 2) >>> 0, s = n, n = i;
          for (; f < 80; ++f) i = e[f - 6] ^ e[f - 16] ^ e[f - 28] ^ e[f - 32], i = i << 2 | i >>> 30, e[f] = i, u = s ^ o ^ a, i = (n << 5 | n >>> 27) + u + c + 3395469782 + i, c = a, a = o, o = (s << 30 | s >>> 2) >>> 0, s = n, n = i;
          r.h0 = r.h0 + n | 0, r.h1 = r.h1 + s | 0, r.h2 = r.h2 + o | 0, r.h3 = r.h3 + a | 0, r.h4 = r.h4 + c | 0, h -= 64
        }
      }
    });
    var Bq = y((vbt, qq) => {
      l();
      var qa = At();
      wr();
      Fu();
      Nq();
      var Mq = qq.exports = qa.pkcs1 = qa.pkcs1 || {};
      Mq.encode_rsa_oaep = function (r, e, t) {
        var i, n, s, o;
        typeof t == "string" ? (i = t, n = arguments[3] || void 0, s = arguments[4] || void 0) : t && (i = t.label || void 0, n = t.seed || void 0, s = t.md || void 0, t.mgf1 && t.mgf1.md && (o = t.mgf1.md)), s ? s.start() : s = qa.md.sha1.create(), o || (o = s);
        var a = Math.ceil(r.n.bitLength() / 8),
          c = a - 2 * s.digestLength - 2;
        if (e.length > c) {
          var u = new Error("RSAES-OAEP input message length is too long.");
          throw u.length = e.length, u.maxLength = c, u
        }
        i || (i = ""), s.update(i, "raw");
        for (var f = s.digest(), h = "", d = c - e.length, p = 0; p < d; p++) h += "\0";
        var g = f.getBytes() + h + "" + e;
        if (!n) n = qa.random.getBytes(s.digestLength);
        else if (n.length !== s.digestLength) {
          var u = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
          throw u.seedLength = n.length, u.digestLength = s.digestLength, u
        }
        var m = l2(n, a - s.digestLength - 1, o),
          E = qa.util.xorBytes(g, m, g.length),
          w = l2(E, s.digestLength, o),
          O = qa.util.xorBytes(n, w, n.length);
        return "\0" + O + E
      };
      Mq.decode_rsa_oaep = function (r, e, t) {
        var i, n, s;
        typeof t == "string" ? (i = t, n = arguments[3] || void 0) : t && (i = t.label || void 0, n = t.md || void 0, t.mgf1 && t.mgf1.md && (s = t.mgf1.md));
        var o = Math.ceil(r.n.bitLength() / 8);
        if (e.length !== o) {
          var E = new Error("RSAES-OAEP encoded message length is invalid.");
          throw E.length = e.length, E.expectedLength = o, E
        }
        if (n === void 0 ? n = qa.md.sha1.create() : n.start(), s || (s = n), o < 2 * n.digestLength + 2) throw new Error("RSAES-OAEP key is too short for the hash function.");
        i || (i = ""), n.update(i, "raw");
        for (var a = n.digest().getBytes(), c = e.charAt(0), u = e.substring(1, n.digestLength + 1), f = e.substring(1 + n.digestLength), h = l2(f, n.digestLength, s), d = qa.util.xorBytes(u, h, u.length), p = l2(d, o - n.digestLength - 1, s), g = qa.util.xorBytes(f, p, f.length), m = g.substring(0, n.digestLength), E = c !== "\0", w = 0; w < n.digestLength; ++w) E |= a.charAt(w) !== m.charAt(w);
        for (var O = 1, q = n.digestLength, J = n.digestLength; J < g.length; J++) {
          var Z = g.charCodeAt(J),
            H = Z & 1 ^ 1,
            te = O ? 65534 : 0;
          E |= Z & te, O = O & H, q += O
        }
        if (E || g.charCodeAt(q) !== 1) throw new Error("Invalid RSAES-OAEP padding.");
        return g.substring(q + 1)
      };

      function l2(r, e, t) {
        t || (t = qa.md.sha1.create());
        for (var i = "", n = Math.ceil(e / t.digestLength), s = 0; s < n; ++s) {
          var o = String.fromCharCode(s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, s & 255);
          t.start(), t.update(r + o), i += t.digest().getBytes()
        }
        return i.substring(0, e)
      }
    });
    var Dq = y((wbt, tS) => {
      l();
      var Ku = At();
      wr();
      U1();
      Fu();
      (function () {
        if (Ku.prime) {
          tS.exports = Ku.prime;
          return
        }
        var r = tS.exports = Ku.prime = Ku.prime || {},
          e = Ku.jsbn.BigInteger,
          t = [6, 4, 2, 4, 2, 4, 6, 2],
          i = new e(null);
        i.fromInt(30);
        var n = function (h, d) {
          return h | d
        };
        r.generateProbablePrime = function (h, d, p) {
          typeof d == "function" && (p = d, d = {}), d = d || {};
          var g = d.algorithm || "PRIMEINC";
          typeof g == "string" && (g = {
            name: g
          }), g.options = g.options || {};
          var m = d.prng || Ku.random,
            E = {
              nextBytes: function (w) {
                for (var O = m.getBytesSync(w.length), q = 0; q < w.length; ++q) w[q] = O.charCodeAt(q)
              }
            };
          if (g.name === "PRIMEINC") return s(h, E, g.options, p);
          throw new Error("Invalid prime generation algorithm: " + g.name)
        };

        function s(h, d, p, g) {
          return "workers" in p ? c(h, d, p, g) : o(h, d, p, g)
        }

        function o(h, d, p, g) {
          var m = u(h, d),
            E = 0,
            w = f(m.bitLength());
          "millerRabinTests" in p && (w = p.millerRabinTests);
          var O = 10;
          "maxBlockTime" in p && (O = p.maxBlockTime), a(m, h, d, E, w, O, g)
        }

        function a(h, d, p, g, m, E, w) {
          var O = +new Date;
          do {
            if (h.bitLength() > d && (h = u(d, p)), h.isProbablePrime(m)) return w(null, h);
            h.dAddOffset(t[g++ % 8], 0)
          } while (E < 0 || +new Date - O < E);
          Ku.util.setImmediate(function () {
            a(h, d, p, g, m, E, w)
          })
        }

        function c(h, d, p, g) {
          if (typeof Worker == "undefined") return o(h, d, p, g);
          var m = u(h, d),
            E = p.workers,
            w = p.workLoad || 100,
            O = w * 30 / 8,
            q = p.workerScript || "forge/prime.worker.js";
          if (E === -1) return Ku.util.estimateCores(function (Z, H) {
            Z && (H = 2), E = H - 1, J()
          });
          J();

          function J() {
            E = Math.max(1, E);
            for (var Z = [], H = 0; H < E; ++H) Z[H] = new Worker(q);
            for (var te = E, H = 0; H < E; ++H) Z[H].addEventListener("message", oe);
            var ae = !1;

            function oe(U) {
              if (!ae) {
                --te;
                var b = U.data;
                if (b.found) {
                  for (var _ = 0; _ < Z.length; ++_) Z[_].terminate();
                  return ae = !0, g(null, new e(b.prime, 16))
                }
                m.bitLength() > h && (m = u(h, d));
                var R = m.toString(16);
                U.target.postMessage({
                  hex: R,
                  workLoad: w
                }), m.dAddOffset(O, 0)
              }
            }
          }
        }

        function u(h, d) {
          var p = new e(h, d),
            g = h - 1;
          return p.testBit(g) || p.bitwiseTo(e.ONE.shiftLeft(g), n, p), p.dAddOffset(31 - p.mod(i).byteValue(), 0), p
        }

        function f(h) {
          return h <= 100 ? 27 : h <= 150 ? 18 : h <= 200 ? 15 : h <= 250 ? 12 : h <= 300 ? 9 : h <= 350 ? 8 : h <= 400 ? 7 : h <= 500 ? 6 : h <= 600 ? 5 : h <= 800 ? 4 : h <= 1250 ? 3 : 2
        }
      })()
    });
    var K1 = y((_bt, Lq) => {
      l();
      var wt = At();
      Bc();
      U1();
      sd();
      Bq();
      Dq();
      Fu();
      wr();
      typeof zt == "undefined" && (zt = wt.jsbn.BigInteger);
      var zt, rS = wt.util.isNodejs ? L1() : null,
        ge = wt.asn1,
        Zs = wt.util;
      wt.pki = wt.pki || {};
      Lq.exports = wt.pki.rsa = wt.rsa = wt.rsa || {};
      var _t = wt.pki,
        Zxe = [6, 4, 2, 4, 2, 4, 6, 2],
        Qxe = {
          name: "PrivateKeyInfo",
          tagClass: ge.Class.UNIVERSAL,
          type: ge.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "PrivateKeyInfo.version",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "privateKeyVersion"
          }, {
            name: "PrivateKeyInfo.privateKeyAlgorithm",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: ge.Class.UNIVERSAL,
              type: ge.Type.OID,
              constructed: !1,
              capture: "privateKeyOid"
            }]
          }, {
            name: "PrivateKeyInfo",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.OCTETSTRING,
            constructed: !1,
            capture: "privateKey"
          }]
        },
        eAe = {
          name: "RSAPrivateKey",
          tagClass: ge.Class.UNIVERSAL,
          type: ge.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "RSAPrivateKey.version",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "privateKeyVersion"
          }, {
            name: "RSAPrivateKey.modulus",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "privateKeyModulus"
          }, {
            name: "RSAPrivateKey.publicExponent",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "privateKeyPublicExponent"
          }, {
            name: "RSAPrivateKey.privateExponent",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "privateKeyPrivateExponent"
          }, {
            name: "RSAPrivateKey.prime1",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "privateKeyPrime1"
          }, {
            name: "RSAPrivateKey.prime2",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "privateKeyPrime2"
          }, {
            name: "RSAPrivateKey.exponent1",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "privateKeyExponent1"
          }, {
            name: "RSAPrivateKey.exponent2",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "privateKeyExponent2"
          }, {
            name: "RSAPrivateKey.coefficient",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "privateKeyCoefficient"
          }]
        },
        tAe = {
          name: "RSAPublicKey",
          tagClass: ge.Class.UNIVERSAL,
          type: ge.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "RSAPublicKey.modulus",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "publicKeyModulus"
          }, {
            name: "RSAPublicKey.exponent",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.INTEGER,
            constructed: !1,
            capture: "publicKeyExponent"
          }]
        },
        rAe = wt.pki.rsa.publicKeyValidator = {
          name: "SubjectPublicKeyInfo",
          tagClass: ge.Class.UNIVERSAL,
          type: ge.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "subjectPublicKeyInfo",
          value: [{
            name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: ge.Class.UNIVERSAL,
              type: ge.Type.OID,
              constructed: !1,
              capture: "publicKeyOid"
            }]
          }, {
            name: "SubjectPublicKeyInfo.subjectPublicKey",
            tagClass: ge.Class.UNIVERSAL,
            type: ge.Type.BITSTRING,
            constructed: !1,
            value: [{
              name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
              tagClass: ge.Class.UNIVERSAL,
              type: ge.Type.SEQUENCE,
              constructed: !0,
              optional: !0,
              captureAsn1: "rsaPublicKey"
            }]
          }]
        },
        iAe = function (r) {
          var e;
          if (r.algorithm in _t.oids) e = _t.oids[r.algorithm];
          else {
            var t = new Error("Unknown message digest algorithm.");
            throw t.algorithm = r.algorithm, t
          }
          var i = ge.oidToDer(e).getBytes(),
            n = ge.create(ge.Class.UNIVERSAL, ge.Type.SEQUENCE, !0, []),
            s = ge.create(ge.Class.UNIVERSAL, ge.Type.SEQUENCE, !0, []);
          s.value.push(ge.create(ge.Class.UNIVERSAL, ge.Type.OID, !1, i)), s.value.push(ge.create(ge.Class.UNIVERSAL, ge.Type.NULL, !1, ""));
          var o = ge.create(ge.Class.UNIVERSAL, ge.Type.OCTETSTRING, !1, r.digest().getBytes());
          return n.value.push(s), n.value.push(o), ge.toDer(n).getBytes()
        },
        Fq = function (r, e, t) {
          if (t) return r.modPow(e.e, e.n);
          if (!e.p || !e.q) return r.modPow(e.d, e.n);
          e.dP || (e.dP = e.d.mod(e.p.subtract(zt.ONE))), e.dQ || (e.dQ = e.d.mod(e.q.subtract(zt.ONE))), e.qInv || (e.qInv = e.q.modInverse(e.p));
          var i;
          do i = new zt(wt.util.bytesToHex(wt.random.getBytes(e.n.bitLength() / 8)), 16); while (i.compareTo(e.n) >= 0 || !i.gcd(e.n).equals(zt.ONE));
          r = r.multiply(i.modPow(e.e, e.n)).mod(e.n);
          for (var n = r.mod(e.p).modPow(e.dP, e.p), s = r.mod(e.q).modPow(e.dQ, e.q); n.compareTo(s) < 0;) n = n.add(e.p);
          var o = n.subtract(s).multiply(e.qInv).mod(e.p).multiply(e.q).add(s);
          return o = o.multiply(i.modInverse(e.n)).mod(e.n), o
        };
      _t.rsa.encrypt = function (r, e, t) {
        var i = t,
          n, s = Math.ceil(e.n.bitLength() / 8);
        t !== !1 && t !== !0 ? (i = t === 2, n = Uq(r, e, t)) : (n = wt.util.createBuffer(), n.putBytes(r));
        for (var o = new zt(n.toHex(), 16), a = Fq(o, e, i), c = a.toString(16), u = wt.util.createBuffer(), f = s - Math.ceil(c.length / 2); f > 0;) u.putByte(0), --f;
        return u.putBytes(wt.util.hexToBytes(c)), u.getBytes()
      };
      _t.rsa.decrypt = function (r, e, t, i) {
        var n = Math.ceil(e.n.bitLength() / 8);
        if (r.length !== n) {
          var s = new Error("Encrypted message length is invalid.");
          throw s.length = r.length, s.expected = n, s
        }
        var o = new zt(wt.util.createBuffer(r).toHex(), 16);
        if (o.compareTo(e.n) >= 0) throw new Error("Encrypted message is invalid.");
        for (var a = Fq(o, e, t), c = a.toString(16), u = wt.util.createBuffer(), f = n - Math.ceil(c.length / 2); f > 0;) u.putByte(0), --f;
        return u.putBytes(wt.util.hexToBytes(c)), i !== !1 ? h2(u.getBytes(), e, t) : u.getBytes()
      };
      _t.rsa.createKeyPairGenerationState = function (r, e, t) {
        typeof r == "string" && (r = parseInt(r, 10)), r = r || 2048, t = t || {};
        var i = t.prng || wt.random,
          n = {
            nextBytes: function (a) {
              for (var c = i.getBytesSync(a.length), u = 0; u < a.length; ++u) a[u] = c.charCodeAt(u)
            }
          },
          s = t.algorithm || "PRIMEINC",
          o;
        if (s === "PRIMEINC") o = {
          algorithm: s,
          state: 0,
          bits: r,
          rng: n,
          eInt: e || 65537,
          e: new zt(null),
          p: null,
          q: null,
          qBits: r >> 1,
          pBits: r - (r >> 1),
          pqState: 0,
          num: null,
          keys: null
        }, o.e.fromInt(o.eInt);
        else throw new Error("Invalid key generation algorithm: " + s);
        return o
      };
      _t.rsa.stepKeyPairGenerationState = function (r, e) {
        "algorithm" in r || (r.algorithm = "PRIMEINC");
        var t = new zt(null);
        t.fromInt(30);
        for (var i = 0, n = function (h, d) {
          return h | d
        }, s = +new Date, o, a = 0; r.keys === null && (e <= 0 || a < e);) {
          if (r.state === 0) {
            var c = r.p === null ? r.pBits : r.qBits,
              u = c - 1;
            r.pqState === 0 ? (r.num = new zt(c, r.rng), r.num.testBit(u) || r.num.bitwiseTo(zt.ONE.shiftLeft(u), n, r.num), r.num.dAddOffset(31 - r.num.mod(t).byteValue(), 0), i = 0, ++r.pqState) : r.pqState === 1 ? r.num.bitLength() > c ? r.pqState = 0 : r.num.isProbablePrime(nAe(r.num.bitLength())) ? ++r.pqState : r.num.dAddOffset(Zxe[i++ % 8], 0) : r.pqState === 2 ? r.pqState = r.num.subtract(zt.ONE).gcd(r.e).compareTo(zt.ONE) === 0 ? 3 : 0 : r.pqState === 3 && (r.pqState = 0, r.p === null ? r.p = r.num : r.q = r.num, r.p !== null && r.q !== null && ++r.state, r.num = null)
          } else if (r.state === 1) r.p.compareTo(r.q) < 0 && (r.num = r.p, r.p = r.q, r.q = r.num), ++r.state;
          else if (r.state === 2) r.p1 = r.p.subtract(zt.ONE), r.q1 = r.q.subtract(zt.ONE), r.phi = r.p1.multiply(r.q1), ++r.state;
          else if (r.state === 3) r.phi.gcd(r.e).compareTo(zt.ONE) === 0 ? ++r.state : (r.p = null, r.q = null, r.state = 0);
          else if (r.state === 4) r.n = r.p.multiply(r.q), r.n.bitLength() === r.bits ? ++r.state : (r.q = null, r.state = 0);
          else if (r.state === 5) {
            var f = r.e.modInverse(r.phi);
            r.keys = {
              privateKey: _t.rsa.setPrivateKey(r.n, r.e, f, r.p, r.q, f.mod(r.p1), f.mod(r.q1), r.q.modInverse(r.p)),
              publicKey: _t.rsa.setPublicKey(r.n, r.e)
            }
          }
          o = +new Date, a += o - s, s = o
        }
        return r.keys !== null
      };
      _t.rsa.generateKeyPair = function (r, e, t, i) {
        if (arguments.length === 1 ? typeof r == "object" ? (t = r, r = void 0) : typeof r == "function" && (i = r, r = void 0) : arguments.length === 2 ? typeof r == "number" ? typeof e == "function" ? (i = e, e = void 0) : typeof e != "number" && (t = e, e = void 0) : (t = r, i = e, r = void 0, e = void 0) : arguments.length === 3 && (typeof e == "number" ? typeof t == "function" && (i = t, t = void 0) : (i = t, t = e, e = void 0)), t = t || {}, r === void 0 && (r = t.bits || 2048), e === void 0 && (e = t.e || 65537), !wt.options.usePureJavaScript && !t.prng && r >= 256 && r <= 16384 && (e === 65537 || e === 3)) {
          if (i) {
            if (Kq("generateKeyPair")) return rS.generateKeyPair("rsa", {
              modulusLength: r,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function (a, c, u) {
              if (a) return i(a);
              i(null, {
                privateKey: _t.privateKeyFromPem(u),
                publicKey: _t.publicKeyFromPem(c)
              })
            });
            if (zq("generateKey") && zq("exportKey")) return Zs.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: r,
              publicExponent: Vq(e),
              hash: {
                name: "SHA-256"
              }
            }, !0, ["sign", "verify"]).then(function (a) {
              return Zs.globalScope.crypto.subtle.exportKey("pkcs8", a.privateKey)
            }).then(void 0, function (a) {
              i(a)
            }).then(function (a) {
              if (a) {
                var c = _t.privateKeyFromAsn1(ge.fromDer(wt.util.createBuffer(a)));
                i(null, {
                  privateKey: c,
                  publicKey: _t.setRsaPublicKey(c.n, c.e)
                })
              }
            });
            if (jq("generateKey") && jq("exportKey")) {
              var n = Zs.globalScope.msCrypto.subtle.generateKey({
                name: "RSASSA-PKCS1-v1_5",
                modulusLength: r,
                publicExponent: Vq(e),
                hash: {
                  name: "SHA-256"
                }
              }, !0, ["sign", "verify"]);
              n.oncomplete = function (a) {
                var c = a.target.result,
                  u = Zs.globalScope.msCrypto.subtle.exportKey("pkcs8", c.privateKey);
                u.oncomplete = function (f) {
                  var h = f.target.result,
                    d = _t.privateKeyFromAsn1(ge.fromDer(wt.util.createBuffer(h)));
                  i(null, {
                    privateKey: d,
                    publicKey: _t.setRsaPublicKey(d.n, d.e)
                  })
                }, u.onerror = function (f) {
                  i(f)
                }
              }, n.onerror = function (a) {
                i(a)
              };
              return
            }
          } else if (Kq("generateKeyPairSync")) {
            var s = rS.generateKeyPairSync("rsa", {
              modulusLength: r,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: _t.privateKeyFromPem(s.privateKey),
              publicKey: _t.publicKeyFromPem(s.publicKey)
            }
          }
        }
        var o = _t.rsa.createKeyPairGenerationState(r, e, t);
        if (!i) return _t.rsa.stepKeyPairGenerationState(o, 0), o.keys;
        sAe(o, t, i)
      };
      _t.setRsaPublicKey = _t.rsa.setPublicKey = function (r, e) {
        var t = {
          n: r,
          e
        };
        return t.encrypt = function (i, n, s) {
          if (typeof n == "string" ? n = n.toUpperCase() : n === void 0 && (n = "RSAES-PKCS1-V1_5"), n === "RSAES-PKCS1-V1_5") n = {
            encode: function (a, c, u) {
              return Uq(a, c, 2).getBytes()
            }
          };
          else if (n === "RSA-OAEP" || n === "RSAES-OAEP") n = {
            encode: function (a, c) {
              return wt.pkcs1.encode_rsa_oaep(c, a, s)
            }
          };
          else if (["RAW", "NONE", "NULL", null].indexOf(n) !== -1) n = {
            encode: function (a) {
              return a
            }
          };
          else if (typeof n == "string") throw new Error('Unsupported encryption scheme: "' + n + '".');
          var o = n.encode(i, t, !0);
          return _t.rsa.encrypt(o, t, !0)
        }, t.verify = function (i, n, s) {
          typeof s == "string" ? s = s.toUpperCase() : s === void 0 && (s = "RSASSA-PKCS1-V1_5"), s === "RSASSA-PKCS1-V1_5" ? s = {
            verify: function (a, c) {
              c = h2(c, t, !0);
              var u = ge.fromDer(c);
              return a === u.value[1].value
            }
          } : (s === "NONE" || s === "NULL" || s === null) && (s = {
            verify: function (a, c) {
              return c = h2(c, t, !0), a === c
            }
          });
          var o = _t.rsa.decrypt(n, t, !0, !1);
          return s.verify(i, o, t.n.bitLength())
        }, t
      };
      _t.setRsaPrivateKey = _t.rsa.setPrivateKey = function (r, e, t, i, n, s, o, a) {
        var c = {
          n: r,
          e,
          d: t,
          p: i,
          q: n,
          dP: s,
          dQ: o,
          qInv: a
        };
        return c.decrypt = function (u, f, h) {
          typeof f == "string" ? f = f.toUpperCase() : f === void 0 && (f = "RSAES-PKCS1-V1_5");
          var d = _t.rsa.decrypt(u, c, !1, !1);
          if (f === "RSAES-PKCS1-V1_5") f = {
            decode: h2
          };
          else if (f === "RSA-OAEP" || f === "RSAES-OAEP") f = {
            decode: function (p, g) {
              return wt.pkcs1.decode_rsa_oaep(g, p, h)
            }
          };
          else if (["RAW", "NONE", "NULL", null].indexOf(f) !== -1) f = {
            decode: function (p) {
              return p
            }
          };
          else throw new Error('Unsupported encryption scheme: "' + f + '".');
          return f.decode(d, c, !1)
        }, c.sign = function (u, f) {
          var h = !1;
          typeof f == "string" && (f = f.toUpperCase()), f === void 0 || f === "RSASSA-PKCS1-V1_5" ? (f = {
            encode: iAe
          }, h = 1) : (f === "NONE" || f === "NULL" || f === null) && (f = {
            encode: function () {
              return u
            }
          }, h = 1);
          var d = f.encode(u, c.n.bitLength());
          return _t.rsa.encrypt(d, c, h)
        }, c
      };
      _t.wrapRsaPrivateKey = function (r) {
        return ge.create(ge.Class.UNIVERSAL, ge.Type.SEQUENCE, !0, [ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, ge.integerToDer(0).getBytes()), ge.create(ge.Class.UNIVERSAL, ge.Type.SEQUENCE, !0, [ge.create(ge.Class.UNIVERSAL, ge.Type.OID, !1, ge.oidToDer(_t.oids.rsaEncryption).getBytes()), ge.create(ge.Class.UNIVERSAL, ge.Type.NULL, !1, "")]), ge.create(ge.Class.UNIVERSAL, ge.Type.OCTETSTRING, !1, ge.toDer(r).getBytes())])
      };
      _t.privateKeyFromAsn1 = function (r) {
        var e = {},
          t = [];
        if (ge.validate(r, Qxe, e, t) && (r = ge.fromDer(wt.util.createBuffer(e.privateKey))), e = {}, t = [], !ge.validate(r, eAe, e, t)) {
          var i = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
          throw i.errors = t, i
        }
        var n, s, o, a, c, u, f, h;
        return n = wt.util.createBuffer(e.privateKeyModulus).toHex(), s = wt.util.createBuffer(e.privateKeyPublicExponent).toHex(), o = wt.util.createBuffer(e.privateKeyPrivateExponent).toHex(), a = wt.util.createBuffer(e.privateKeyPrime1).toHex(), c = wt.util.createBuffer(e.privateKeyPrime2).toHex(), u = wt.util.createBuffer(e.privateKeyExponent1).toHex(), f = wt.util.createBuffer(e.privateKeyExponent2).toHex(), h = wt.util.createBuffer(e.privateKeyCoefficient).toHex(), _t.setRsaPrivateKey(new zt(n, 16), new zt(s, 16), new zt(o, 16), new zt(a, 16), new zt(c, 16), new zt(u, 16), new zt(f, 16), new zt(h, 16))
      };
      _t.privateKeyToAsn1 = _t.privateKeyToRSAPrivateKey = function (r) {
        return ge.create(ge.Class.UNIVERSAL, ge.Type.SEQUENCE, !0, [ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, ge.integerToDer(0).getBytes()), ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, Ma(r.n)), ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, Ma(r.e)), ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, Ma(r.d)), ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, Ma(r.p)), ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, Ma(r.q)), ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, Ma(r.dP)), ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, Ma(r.dQ)), ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, Ma(r.qInv))])
      };
      _t.publicKeyFromAsn1 = function (r) {
        var e = {},
          t = [];
        if (ge.validate(r, rAe, e, t)) {
          var i = ge.derToOid(e.publicKeyOid);
          if (i !== _t.oids.rsaEncryption) {
            var n = new Error("Cannot read public key. Unknown OID.");
            throw n.oid = i, n
          }
          r = e.rsaPublicKey
        }
        if (t = [], !ge.validate(r, tAe, e, t)) {
          var n = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
          throw n.errors = t, n
        }
        var s = wt.util.createBuffer(e.publicKeyModulus).toHex(),
          o = wt.util.createBuffer(e.publicKeyExponent).toHex();
        return _t.setRsaPublicKey(new zt(s, 16), new zt(o, 16))
      };
      _t.publicKeyToAsn1 = _t.publicKeyToSubjectPublicKeyInfo = function (r) {
        return ge.create(ge.Class.UNIVERSAL, ge.Type.SEQUENCE, !0, [ge.create(ge.Class.UNIVERSAL, ge.Type.SEQUENCE, !0, [ge.create(ge.Class.UNIVERSAL, ge.Type.OID, !1, ge.oidToDer(_t.oids.rsaEncryption).getBytes()), ge.create(ge.Class.UNIVERSAL, ge.Type.NULL, !1, "")]), ge.create(ge.Class.UNIVERSAL, ge.Type.BITSTRING, !1, [_t.publicKeyToRSAPublicKey(r)])])
      };
      _t.publicKeyToRSAPublicKey = function (r) {
        return ge.create(ge.Class.UNIVERSAL, ge.Type.SEQUENCE, !0, [ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, Ma(r.n)), ge.create(ge.Class.UNIVERSAL, ge.Type.INTEGER, !1, Ma(r.e))])
      };

      function Uq(r, e, t) {
        var i = wt.util.createBuffer(),
          n = Math.ceil(e.n.bitLength() / 8);
        if (r.length > n - 11) {
          var s = new Error("Message is too long for PKCS#1 v1.5 padding.");
          throw s.length = r.length, s.max = n - 11, s
        }
        i.putByte(0), i.putByte(t);
        var o = n - 3 - r.length,
          a;
        if (t === 0 || t === 1) {
          a = t === 0 ? 0 : 255;
          for (var c = 0; c < o; ++c) i.putByte(a)
        } else
          for (; o > 0;) {
            for (var u = 0, f = wt.random.getBytes(o), c = 0; c < o; ++c) a = f.charCodeAt(c), a === 0 ? ++u : i.putByte(a);
            o = u
          }
        return i.putByte(0), i.putBytes(r), i
      }

      function h2(r, e, t, i) {
        var n = Math.ceil(e.n.bitLength() / 8),
          s = wt.util.createBuffer(r),
          o = s.getByte(),
          a = s.getByte();
        if (o !== 0 || t && a !== 0 && a !== 1 || !t && a != 2 || t && a === 0 && typeof i == "undefined") throw new Error("Encryption block is invalid.");
        var c = 0;
        if (a === 0) {
          c = n - 3 - i;
          for (var u = 0; u < c; ++u)
            if (s.getByte() !== 0) throw new Error("Encryption block is invalid.")
        } else if (a === 1)
          for (c = 0; s.length() > 1;) {
            if (s.getByte() !== 255) {
              --s.read;
              break
            } ++c
          } else if (a === 2)
          for (c = 0; s.length() > 1;) {
            if (s.getByte() === 0) {
              --s.read;
              break
            } ++c
          }
        var f = s.getByte();
        if (f !== 0 || c !== n - 3 - s.length()) throw new Error("Encryption block is invalid.");
        return s.getBytes()
      }

      function sAe(r, e, t) {
        typeof e == "function" && (t = e, e = {}), e = e || {};
        var i = {
          algorithm: {
            name: e.algorithm || "PRIMEINC",
            options: {
              workers: e.workers || 2,
              workLoad: e.workLoad || 100,
              workerScript: e.workerScript
            }
          }
        };
        "prng" in e && (i.prng = e.prng), n();

        function n() {
          s(r.pBits, function (a, c) {
            if (a) return t(a);
            if (r.p = c, r.q !== null) return o(a, r.q);
            s(r.qBits, o)
          })
        }

        function s(a, c) {
          wt.prime.generateProbablePrime(a, i, c)
        }

        function o(a, c) {
          if (a) return t(a);
          if (r.q = c, r.p.compareTo(r.q) < 0) {
            var u = r.p;
            r.p = r.q, r.q = u
          }
          if (r.p.subtract(zt.ONE).gcd(r.e).compareTo(zt.ONE) !== 0) {
            r.p = null, n();
            return
          }
          if (r.q.subtract(zt.ONE).gcd(r.e).compareTo(zt.ONE) !== 0) {
            r.q = null, s(r.qBits, o);
            return
          }
          if (r.p1 = r.p.subtract(zt.ONE), r.q1 = r.q.subtract(zt.ONE), r.phi = r.p1.multiply(r.q1), r.phi.gcd(r.e).compareTo(zt.ONE) !== 0) {
            r.p = r.q = null, n();
            return
          }
          if (r.n = r.p.multiply(r.q), r.n.bitLength() !== r.bits) {
            r.q = null, s(r.qBits, o);
            return
          }
          var f = r.e.modInverse(r.phi);
          r.keys = {
            privateKey: _t.rsa.setPrivateKey(r.n, r.e, f, r.p, r.q, f.mod(r.p1), f.mod(r.q1), r.q.modInverse(r.p)),
            publicKey: _t.rsa.setPublicKey(r.n, r.e)
          }, t(null, r.keys)
        }
      }

      function Ma(r) {
        var e = r.toString(16);
        e[0] >= "8" && (e = "00" + e);
        var t = wt.util.hexToBytes(e);
        return t.length > 1 && (t.charCodeAt(0) === 0 && (t.charCodeAt(1) & 128) == 0 || t.charCodeAt(0) === 255 && (t.charCodeAt(1) & 128) == 128) ? t.substr(1) : t
      }

      function nAe(r) {
        return r <= 100 ? 27 : r <= 150 ? 18 : r <= 200 ? 15 : r <= 250 ? 12 : r <= 300 ? 9 : r <= 350 ? 8 : r <= 400 ? 7 : r <= 500 ? 6 : r <= 600 ? 5 : r <= 800 ? 4 : r <= 1250 ? 3 : 2
      }

      function Kq(r) {
        return wt.util.isNodejs && typeof rS[r] == "function"
      }

      function zq(r) {
        return typeof Zs.globalScope != "undefined" && typeof Zs.globalScope.crypto == "object" && typeof Zs.globalScope.crypto.subtle == "object" && typeof Zs.globalScope.crypto.subtle[r] == "function"
      }

      function jq(r) {
        return typeof Zs.globalScope != "undefined" && typeof Zs.globalScope.msCrypto == "object" && typeof Zs.globalScope.msCrypto.subtle == "object" && typeof Zs.globalScope.msCrypto.subtle[r] == "function"
      }

      function Vq(r) {
        for (var e = wt.util.hexToBytes(r.toString(16)), t = new Uint8Array(e.length), i = 0; i < e.length; ++i) t[i] = e.charCodeAt(i);
        return t
      }
    });
    var iS = y((Ebt, Hq) => {
      l();
      var Qe = At();
      cd();
      Bc();
      i2();
      Lu();
      sd();
      $E();
      a2();
      Fu();
      wq();
      K1();
      wr();
      typeof Gq == "undefined" && (Gq = Qe.jsbn.BigInteger);
      var Gq, Ee = Qe.asn1,
        xt = Qe.pki = Qe.pki || {};
      Hq.exports = xt.pbe = Qe.pbe = Qe.pbe || {};
      var al = xt.oids,
        oAe = {
          name: "EncryptedPrivateKeyInfo",
          tagClass: Ee.Class.UNIVERSAL,
          type: Ee.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
            tagClass: Ee.Class.UNIVERSAL,
            type: Ee.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: Ee.Class.UNIVERSAL,
              type: Ee.Type.OID,
              constructed: !1,
              capture: "encryptionOid"
            }, {
              name: "AlgorithmIdentifier.parameters",
              tagClass: Ee.Class.UNIVERSAL,
              type: Ee.Type.SEQUENCE,
              constructed: !0,
              captureAsn1: "encryptionParams"
            }]
          }, {
            name: "EncryptedPrivateKeyInfo.encryptedData",
            tagClass: Ee.Class.UNIVERSAL,
            type: Ee.Type.OCTETSTRING,
            constructed: !1,
            capture: "encryptedData"
          }]
        },
        aAe = {
          name: "PBES2Algorithms",
          tagClass: Ee.Class.UNIVERSAL,
          type: Ee.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "PBES2Algorithms.keyDerivationFunc",
            tagClass: Ee.Class.UNIVERSAL,
            type: Ee.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "PBES2Algorithms.keyDerivationFunc.oid",
              tagClass: Ee.Class.UNIVERSAL,
              type: Ee.Type.OID,
              constructed: !1,
              capture: "kdfOid"
            }, {
              name: "PBES2Algorithms.params",
              tagClass: Ee.Class.UNIVERSAL,
              type: Ee.Type.SEQUENCE,
              constructed: !0,
              value: [{
                name: "PBES2Algorithms.params.salt",
                tagClass: Ee.Class.UNIVERSAL,
                type: Ee.Type.OCTETSTRING,
                constructed: !1,
                capture: "kdfSalt"
              }, {
                name: "PBES2Algorithms.params.iterationCount",
                tagClass: Ee.Class.UNIVERSAL,
                type: Ee.Type.INTEGER,
                constructed: !1,
                capture: "kdfIterationCount"
              }, {
                name: "PBES2Algorithms.params.keyLength",
                tagClass: Ee.Class.UNIVERSAL,
                type: Ee.Type.INTEGER,
                constructed: !1,
                optional: !0,
                capture: "keyLength"
              }, {
                name: "PBES2Algorithms.params.prf",
                tagClass: Ee.Class.UNIVERSAL,
                type: Ee.Type.SEQUENCE,
                constructed: !0,
                optional: !0,
                value: [{
                  name: "PBES2Algorithms.params.prf.algorithm",
                  tagClass: Ee.Class.UNIVERSAL,
                  type: Ee.Type.OID,
                  constructed: !1,
                  capture: "prfOid"
                }]
              }]
            }]
          }, {
            name: "PBES2Algorithms.encryptionScheme",
            tagClass: Ee.Class.UNIVERSAL,
            type: Ee.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "PBES2Algorithms.encryptionScheme.oid",
              tagClass: Ee.Class.UNIVERSAL,
              type: Ee.Type.OID,
              constructed: !1,
              capture: "encOid"
            }, {
              name: "PBES2Algorithms.encryptionScheme.iv",
              tagClass: Ee.Class.UNIVERSAL,
              type: Ee.Type.OCTETSTRING,
              constructed: !1,
              capture: "encIv"
            }]
          }]
        },
        cAe = {
          name: "pkcs-12PbeParams",
          tagClass: Ee.Class.UNIVERSAL,
          type: Ee.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "pkcs-12PbeParams.salt",
            tagClass: Ee.Class.UNIVERSAL,
            type: Ee.Type.OCTETSTRING,
            constructed: !1,
            capture: "salt"
          }, {
            name: "pkcs-12PbeParams.iterations",
            tagClass: Ee.Class.UNIVERSAL,
            type: Ee.Type.INTEGER,
            constructed: !1,
            capture: "iterations"
          }]
        };
      xt.encryptPrivateKeyInfo = function (r, e, t) {
        t = t || {}, t.saltSize = t.saltSize || 8, t.count = t.count || 2048, t.algorithm = t.algorithm || "aes128", t.prfAlgorithm = t.prfAlgorithm || "sha1";
        var i = Qe.random.getBytesSync(t.saltSize),
          n = t.count,
          s = Ee.integerToDer(n),
          o, a, c;
        if (t.algorithm.indexOf("aes") === 0 || t.algorithm === "des") {
          var u, f, h;
          switch (t.algorithm) {
            case "aes128":
              o = 16, u = 16, f = al["aes128-CBC"], h = Qe.aes.createEncryptionCipher;
              break;
            case "aes192":
              o = 24, u = 16, f = al["aes192-CBC"], h = Qe.aes.createEncryptionCipher;
              break;
            case "aes256":
              o = 32, u = 16, f = al["aes256-CBC"], h = Qe.aes.createEncryptionCipher;
              break;
            case "des":
              o = 8, u = 8, f = al.desCBC, h = Qe.des.createEncryptionCipher;
              break;
            default:
              var d = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
              throw d.algorithm = t.algorithm, d
          }
          var p = "hmacWith" + t.prfAlgorithm.toUpperCase(),
            g = $q(p),
            m = Qe.pkcs5.pbkdf2(e, i, n, o, g),
            E = Qe.random.getBytesSync(u),
            w = h(m);
          w.start(E), w.update(Ee.toDer(r)), w.finish(), c = w.output.getBytes();
          var O = uAe(i, s, o, p);
          a = Ee.create(Ee.Class.UNIVERSAL, Ee.Type.SEQUENCE, !0, [Ee.create(Ee.Class.UNIVERSAL, Ee.Type.OID, !1, Ee.oidToDer(al.pkcs5PBES2).getBytes()), Ee.create(Ee.Class.UNIVERSAL, Ee.Type.SEQUENCE, !0, [Ee.create(Ee.Class.UNIVERSAL, Ee.Type.SEQUENCE, !0, [Ee.create(Ee.Class.UNIVERSAL, Ee.Type.OID, !1, Ee.oidToDer(al.pkcs5PBKDF2).getBytes()), O]), Ee.create(Ee.Class.UNIVERSAL, Ee.Type.SEQUENCE, !0, [Ee.create(Ee.Class.UNIVERSAL, Ee.Type.OID, !1, Ee.oidToDer(f).getBytes()), Ee.create(Ee.Class.UNIVERSAL, Ee.Type.OCTETSTRING, !1, E)])])])
        } else if (t.algorithm === "3des") {
          o = 24;
          var q = new Qe.util.ByteBuffer(i),
            m = xt.pbe.generatePkcs12Key(e, q, 1, n, o),
            E = xt.pbe.generatePkcs12Key(e, q, 2, n, o),
            w = Qe.des.createEncryptionCipher(m);
          w.start(E), w.update(Ee.toDer(r)), w.finish(), c = w.output.getBytes(), a = Ee.create(Ee.Class.UNIVERSAL, Ee.Type.SEQUENCE, !0, [Ee.create(Ee.Class.UNIVERSAL, Ee.Type.OID, !1, Ee.oidToDer(al["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), Ee.create(Ee.Class.UNIVERSAL, Ee.Type.SEQUENCE, !0, [Ee.create(Ee.Class.UNIVERSAL, Ee.Type.OCTETSTRING, !1, i), Ee.create(Ee.Class.UNIVERSAL, Ee.Type.INTEGER, !1, s.getBytes())])])
        } else {
          var d = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
          throw d.algorithm = t.algorithm, d
        }
        var J = Ee.create(Ee.Class.UNIVERSAL, Ee.Type.SEQUENCE, !0, [a, Ee.create(Ee.Class.UNIVERSAL, Ee.Type.OCTETSTRING, !1, c)]);
        return J
      };
      xt.decryptPrivateKeyInfo = function (r, e) {
        var t = null,
          i = {},
          n = [];
        if (!Ee.validate(r, oAe, i, n)) {
          var s = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
          throw s.errors = n, s
        }
        var o = Ee.derToOid(i.encryptionOid),
          a = xt.pbe.getCipher(o, i.encryptionParams, e),
          c = Qe.util.createBuffer(i.encryptedData);
        return a.update(c), a.finish() && (t = Ee.fromDer(a.output)), t
      };
      xt.encryptedPrivateKeyToPem = function (r, e) {
        var t = {
          type: "ENCRYPTED PRIVATE KEY",
          body: Ee.toDer(r).getBytes()
        };
        return Qe.pem.encode(t, {
          maxline: e
        })
      };
      xt.encryptedPrivateKeyFromPem = function (r) {
        var e = Qe.pem.decode(r)[0];
        if (e.type !== "ENCRYPTED PRIVATE KEY") {
          var t = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
          throw t.headerType = e.type, t
        }
        if (e.procType && e.procType.type === "ENCRYPTED") throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
        return Ee.fromDer(e.body)
      };
      xt.encryptRsaPrivateKey = function (r, e, t) {
        if (t = t || {}, !t.legacy) {
          var i = xt.wrapRsaPrivateKey(xt.privateKeyToAsn1(r));
          return i = xt.encryptPrivateKeyInfo(i, e, t), xt.encryptedPrivateKeyToPem(i)
        }
        var n, s, o, a;
        switch (t.algorithm) {
          case "aes128":
            n = "AES-128-CBC", o = 16, s = Qe.random.getBytesSync(16), a = Qe.aes.createEncryptionCipher;
            break;
          case "aes192":
            n = "AES-192-CBC", o = 24, s = Qe.random.getBytesSync(16), a = Qe.aes.createEncryptionCipher;
            break;
          case "aes256":
            n = "AES-256-CBC", o = 32, s = Qe.random.getBytesSync(16), a = Qe.aes.createEncryptionCipher;
            break;
          case "3des":
            n = "DES-EDE3-CBC", o = 24, s = Qe.random.getBytesSync(8), a = Qe.des.createEncryptionCipher;
            break;
          case "des":
            n = "DES-CBC", o = 8, s = Qe.random.getBytesSync(8), a = Qe.des.createEncryptionCipher;
            break;
          default:
            var c = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + t.algorithm + '".');
            throw c.algorithm = t.algorithm, c
        }
        var u = Qe.pbe.opensslDeriveBytes(e, s.substr(0, 8), o),
          f = a(u);
        f.start(s), f.update(Ee.toDer(xt.privateKeyToAsn1(r))), f.finish();
        var h = {
          type: "RSA PRIVATE KEY",
          procType: {
            version: "4",
            type: "ENCRYPTED"
          },
          dekInfo: {
            algorithm: n,
            parameters: Qe.util.bytesToHex(s).toUpperCase()
          },
          body: f.output.getBytes()
        };
        return Qe.pem.encode(h)
      };
      xt.decryptRsaPrivateKey = function (r, e) {
        var t = null,
          i = Qe.pem.decode(r)[0];
        if (i.type !== "ENCRYPTED PRIVATE KEY" && i.type !== "PRIVATE KEY" && i.type !== "RSA PRIVATE KEY") {
          var n = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
          throw n.headerType = n, n
        }
        if (i.procType && i.procType.type === "ENCRYPTED") {
          var s, o;
          switch (i.dekInfo.algorithm) {
            case "DES-CBC":
              s = 8, o = Qe.des.createDecryptionCipher;
              break;
            case "DES-EDE3-CBC":
              s = 24, o = Qe.des.createDecryptionCipher;
              break;
            case "AES-128-CBC":
              s = 16, o = Qe.aes.createDecryptionCipher;
              break;
            case "AES-192-CBC":
              s = 24, o = Qe.aes.createDecryptionCipher;
              break;
            case "AES-256-CBC":
              s = 32, o = Qe.aes.createDecryptionCipher;
              break;
            case "RC2-40-CBC":
              s = 5, o = function (h) {
                return Qe.rc2.createDecryptionCipher(h, 40)
              };
              break;
            case "RC2-64-CBC":
              s = 8, o = function (h) {
                return Qe.rc2.createDecryptionCipher(h, 64)
              };
              break;
            case "RC2-128-CBC":
              s = 16, o = function (h) {
                return Qe.rc2.createDecryptionCipher(h, 128)
              };
              break;
            default:
              var n = new Error('Could not decrypt private key; unsupported encryption algorithm "' + i.dekInfo.algorithm + '".');
              throw n.algorithm = i.dekInfo.algorithm, n
          }
          var a = Qe.util.hexToBytes(i.dekInfo.parameters),
            c = Qe.pbe.opensslDeriveBytes(e, a.substr(0, 8), s),
            u = o(c);
          if (u.start(a), u.update(Qe.util.createBuffer(i.body)), u.finish()) t = u.output.getBytes();
          else return t
        } else t = i.body;
        return i.type === "ENCRYPTED PRIVATE KEY" ? t = xt.decryptPrivateKeyInfo(Ee.fromDer(t), e) : t = Ee.fromDer(t), t !== null && (t = xt.privateKeyFromAsn1(t)), t
      };
      xt.pbe.generatePkcs12Key = function (r, e, t, i, n, s) {
        var o, a;
        if (typeof s == "undefined" || s === null) {
          if (!("sha1" in Qe.md)) throw new Error('"sha1" hash algorithm unavailable.');
          s = Qe.md.sha1.create()
        }
        var c = s.digestLength,
          u = s.blockLength,
          f = new Qe.util.ByteBuffer,
          h = new Qe.util.ByteBuffer;
        if (r != null) {
          for (a = 0; a < r.length; a++) h.putInt16(r.charCodeAt(a));
          h.putInt16(0)
        }
        var d = h.length(),
          p = e.length(),
          g = new Qe.util.ByteBuffer;
        g.fillWithByte(t, u);
        var m = u * Math.ceil(p / u),
          E = new Qe.util.ByteBuffer;
        for (a = 0; a < m; a++) E.putByte(e.at(a % p));
        var w = u * Math.ceil(d / u),
          O = new Qe.util.ByteBuffer;
        for (a = 0; a < w; a++) O.putByte(h.at(a % d));
        var q = E;
        q.putBuffer(O);
        for (var J = Math.ceil(n / c), Z = 1; Z <= J; Z++) {
          var H = new Qe.util.ByteBuffer;
          H.putBytes(g.bytes()), H.putBytes(q.bytes());
          for (var te = 0; te < i; te++) s.start(), s.update(H.getBytes()), H = s.digest();
          var ae = new Qe.util.ByteBuffer;
          for (a = 0; a < u; a++) ae.putByte(H.at(a % c));
          var oe = Math.ceil(p / u) + Math.ceil(d / u),
            U = new Qe.util.ByteBuffer;
          for (o = 0; o < oe; o++) {
            var b = new Qe.util.ByteBuffer(q.getBytes(u)),
              _ = 511;
            for (a = ae.length() - 1; a >= 0; a--) _ = _ >> 8, _ += ae.at(a) + b.at(a), b.setAt(a, _ & 255);
            U.putBuffer(b)
          }
          q = U, f.putBuffer(H)
        }
        return f.truncate(f.length() - n), f
      };
      xt.pbe.getCipher = function (r, e, t) {
        switch (r) {
          case xt.oids.pkcs5PBES2:
            return xt.pbe.getCipherForPBES2(r, e, t);
          case xt.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          case xt.oids["pbewithSHAAnd40BitRC2-CBC"]:
            return xt.pbe.getCipherForPKCS12PBE(r, e, t);
          default:
            var i = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
            throw i.oid = r, i.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"], i
        }
      };
      xt.pbe.getCipherForPBES2 = function (r, e, t) {
        var i = {},
          n = [];
        if (!Ee.validate(e, aAe, i, n)) {
          var s = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
          throw s.errors = n, s
        }
        if (r = Ee.derToOid(i.kdfOid), r !== xt.oids.pkcs5PBKDF2) {
          var s = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
          throw s.oid = r, s.supportedOids = ["pkcs5PBKDF2"], s
        }
        if (r = Ee.derToOid(i.encOid), r !== xt.oids["aes128-CBC"] && r !== xt.oids["aes192-CBC"] && r !== xt.oids["aes256-CBC"] && r !== xt.oids["des-EDE3-CBC"] && r !== xt.oids.desCBC) {
          var s = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
          throw s.oid = r, s.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"], s
        }
        var o = i.kdfSalt,
          a = Qe.util.createBuffer(i.kdfIterationCount);
        a = a.getInt(a.length() << 3);
        var c, u;
        switch (xt.oids[r]) {
          case "aes128-CBC":
            c = 16, u = Qe.aes.createDecryptionCipher;
            break;
          case "aes192-CBC":
            c = 24, u = Qe.aes.createDecryptionCipher;
            break;
          case "aes256-CBC":
            c = 32, u = Qe.aes.createDecryptionCipher;
            break;
          case "des-EDE3-CBC":
            c = 24, u = Qe.des.createDecryptionCipher;
            break;
          case "desCBC":
            c = 8, u = Qe.des.createDecryptionCipher;
            break
        }
        var f = Wq(i.prfOid),
          h = Qe.pkcs5.pbkdf2(t, o, a, c, f),
          d = i.encIv,
          p = u(h);
        return p.start(d), p
      };
      xt.pbe.getCipherForPKCS12PBE = function (r, e, t) {
        var i = {},
          n = [];
        if (!Ee.validate(e, cAe, i, n)) {
          var s = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
          throw s.errors = n, s
        }
        var o = Qe.util.createBuffer(i.salt),
          a = Qe.util.createBuffer(i.iterations);
        a = a.getInt(a.length() << 3);
        var c, u, f;
        switch (r) {
          case xt.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
            c = 24, u = 8, f = Qe.des.startDecrypting;
            break;
          case xt.oids["pbewithSHAAnd40BitRC2-CBC"]:
            c = 5, u = 8, f = function (m, E) {
              var w = Qe.rc2.createDecryptionCipher(m, 40);
              return w.start(E, null), w
            };
            break;
          default:
            var s = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
            throw s.oid = r, s
        }
        var h = Wq(i.prfOid),
          d = xt.pbe.generatePkcs12Key(t, o, 1, a, c, h);
        h.start();
        var p = xt.pbe.generatePkcs12Key(t, o, 2, a, u, h);
        return f(d, p)
      };
      xt.pbe.opensslDeriveBytes = function (r, e, t, i) {
        if (typeof i == "undefined" || i === null) {
          if (!("md5" in Qe.md)) throw new Error('"md5" hash algorithm unavailable.');
          i = Qe.md.md5.create()
        }
        e === null && (e = "");
        for (var n = [Yq(i, r + e)], s = 16, o = 1; s < t; ++o, s += 16) n.push(Yq(i, n[o - 1] + r + e));
        return n.join("").substr(0, t)
      };

      function Yq(r, e) {
        return r.start().update(e).digest().getBytes()
      }

      function Wq(r) {
        var e;
        if (!r) e = "hmacWithSHA1";
        else if (e = xt.oids[Ee.derToOid(r)], !e) {
          var t = new Error("Unsupported PRF OID.");
          throw t.oid = r, t.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], t
        }
        return $q(e)
      }

      function $q(r) {
        var e = Qe.md;
        switch (r) {
          case "hmacWithSHA224":
            e = Qe.md.sha512;
          case "hmacWithSHA1":
          case "hmacWithSHA256":
          case "hmacWithSHA384":
          case "hmacWithSHA512":
            r = r.substr(8).toLowerCase();
            break;
          default:
            var t = new Error("Unsupported PRF algorithm.");
            throw t.algorithm = r, t.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], t
        }
        if (!e || !(r in e)) throw new Error("Unknown hash algorithm: " + r);
        return e[r].create()
      }

      function uAe(r, e, t, i) {
        var n = Ee.create(Ee.Class.UNIVERSAL, Ee.Type.SEQUENCE, !0, [Ee.create(Ee.Class.UNIVERSAL, Ee.Type.OCTETSTRING, !1, r), Ee.create(Ee.Class.UNIVERSAL, Ee.Type.INTEGER, !1, e.getBytes())]);
        return i !== "hmacWithSHA1" && n.value.push(Ee.create(Ee.Class.UNIVERSAL, Ee.Type.INTEGER, !1, Qe.util.hexToBytes(t.toString(16))), Ee.create(Ee.Class.UNIVERSAL, Ee.Type.SEQUENCE, !0, [Ee.create(Ee.Class.UNIVERSAL, Ee.Type.OID, !1, Ee.oidToDer(xt.oids[i]).getBytes()), Ee.create(Ee.Class.UNIVERSAL, Ee.Type.NULL, !1, "")])), n
      }
    });
    var xe = y((Sbt, Jq) => {
      l();
      "use strict";

      function Xq(r, e) {
        for (let t in e) Object.defineProperty(r, t, {
          value: e[t],
          enumerable: !0,
          configurable: !0
        });
        return r
      }

      function fAe(r, e, t) {
        if (!r || typeof r == "string") throw new TypeError("Please pass an Error to err-code");
        t || (t = {}), typeof e == "object" && (t = e, e = ""), e && (t.code = e);
        try {
          return Xq(r, t)
        } catch (i) {
          t.message = r.message, t.stack = r.stack;
          let n = function () { };
          return n.prototype = Object.create(Object.getPrototypeOf(r)), Xq(new n, t)
        }
      }
      Jq.exports = fAe
    });
    var z1 = y(Zq => {
      l();
      "use strict";
      Zq.get = (r = self) => {
        let e = r.crypto || r.msCrypto;
        if (!e || !e.subtle) throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), {
          code: "ERR_MISSING_WEB_CRYPTO"
        });
        return e
      }
    });
    var nS = y((Abt, Qq) => {
      l();
      "use strict";
      var lAe = xi(),
        eM = gt(),
        hAe = z1();

      function dAe({
        algorithm: r = "AES-GCM",
        nonceLength: e = 12,
        keyLength: t = 16,
        digest: i = "SHA-256",
        saltLength: n = 16,
        iterations: s = 32767
      } = {}) {
        let o = hAe.get();
        t *= 8;
        async function a(u, f) {
          let h = o.getRandomValues(new Uint8Array(n)),
            d = o.getRandomValues(new Uint8Array(e)),
            p = {
              name: r,
              iv: d
            },
            g = {
              name: "PBKDF2",
              salt: h,
              iterations: s,
              hash: {
                name: i
              }
            },
            m = await o.subtle.importKey("raw", eM(f), {
              name: "PBKDF2"
            }, !1, ["deriveKey", "deriveBits"]),
            E = await o.subtle.deriveKey(g, m, {
              name: r,
              length: t
            }, !0, ["encrypt"]),
            w = await o.subtle.encrypt(p, E, u);
          return lAe([h, p.iv, new Uint8Array(w)])
        }
        async function c(u, f) {
          let h = u.slice(0, n),
            d = u.slice(n, n + e),
            p = u.slice(n + e),
            g = {
              name: r,
              iv: d
            },
            m = {
              name: "PBKDF2",
              salt: h,
              iterations: s,
              hash: {
                name: i
              }
            },
            E = await o.subtle.importKey("raw", eM(f), {
              name: "PBKDF2"
            }, !1, ["deriveKey", "deriveBits"]),
            w = await o.subtle.deriveKey(m, E, {
              name: r,
              length: t
            }, !0, ["decrypt"]),
            O = await o.subtle.decrypt(g, w, p);
          return new Uint8Array(O)
        }
        return {
          encrypt: a,
          decrypt: c
        }
      }
      Qq.exports = {
        create: dAe
      }
    });
    var rM = y((Ibt, tM) => {
      l();
      "use strict";
      var pAe = ln(),
        yAe = nS();
      tM.exports = {
        import: async function (r, e) {
          let i = pAe.names.base64.decode(r);
          return await yAe.create().decrypt(i, e)
        }
      }
    });
    var hd = y((Tbt, iM) => {
      l();
      "use strict";
      var gAe = Do(),
        ld = self.crypto || self.msCrypto,
        sS = async (r, e) => {
          if (typeof self == "undefined" || !ld) throw new Error("Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context");
          switch (e) {
            case "sha1":
              return new Uint8Array(await ld.subtle.digest({
                name: "SHA-1"
              }, r));
            case "sha2-256":
              return new Uint8Array(await ld.subtle.digest({
                name: "SHA-256"
              }, r));
            case "sha2-512":
              return new Uint8Array(await ld.subtle.digest({
                name: "SHA-512"
              }, r));
            case "dbl-sha2-256": {
              let t = await ld.subtle.digest({
                name: "SHA-256"
              }, r);
              return new Uint8Array(await ld.subtle.digest({
                name: "SHA-256"
              }, t))
            }
            default:
              throw new Error(`${e} is not a supported algorithm`)
          }
        };
      iM.exports = {
        factory: r => async e => sS(e, r),
        digest: sS,
        multihashing: async (r, e, t) => {
          let i = await sS(r, e);
          return gAe.encode(i, e, t)
        }
      }
    });
    var d2 = y((Rbt, nM) => {
      l();
      var qr = At();
      Lu();
      wr();
      var j1 = nM.exports = qr.sha512 = qr.sha512 || {};
      qr.md.sha512 = qr.md.algorithms.sha512 = j1;
      var sM = qr.sha384 = qr.sha512.sha384 = qr.sha512.sha384 || {};
      sM.create = function () {
        return j1.create("SHA-384")
      };
      qr.md.sha384 = qr.md.algorithms.sha384 = sM;
      qr.sha512.sha256 = qr.sha512.sha256 || {
        create: function () {
          return j1.create("SHA-512/256")
        }
      };
      qr.md["sha512/256"] = qr.md.algorithms["sha512/256"] = qr.sha512.sha256;
      qr.sha512.sha224 = qr.sha512.sha224 || {
        create: function () {
          return j1.create("SHA-512/224")
        }
      };
      qr.md["sha512/224"] = qr.md.algorithms["sha512/224"] = qr.sha512.sha224;
      j1.create = function (r) {
        if (oM || bAe(), typeof r == "undefined" && (r = "SHA-512"), !(r in cl)) throw new Error("Invalid SHA-512 algorithm: " + r);
        for (var e = cl[r], t = null, i = qr.util.createBuffer(), n = new Array(80), s = 0; s < 80; ++s) n[s] = new Array(2);
        var o = 64;
        switch (r) {
          case "SHA-384":
            o = 48;
            break;
          case "SHA-512/256":
            o = 32;
            break;
          case "SHA-512/224":
            o = 28;
            break
        }
        var a = {
          algorithm: r.replace("-", "").toLowerCase(),
          blockLength: 128,
          digestLength: o,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 16
        };
        return a.start = function () {
          a.messageLength = 0, a.fullMessageLength = a.messageLength128 = [];
          for (var c = a.messageLengthSize / 4, u = 0; u < c; ++u) a.fullMessageLength.push(0);
          i = qr.util.createBuffer(), t = new Array(e.length);
          for (var u = 0; u < e.length; ++u) t[u] = e[u].slice(0);
          return a
        }, a.start(), a.update = function (c, u) {
          u === "utf8" && (c = qr.util.encodeUtf8(c));
          var f = c.length;
          a.messageLength += f, f = [f / 4294967296 >>> 0, f >>> 0];
          for (var h = a.fullMessageLength.length - 1; h >= 0; --h) a.fullMessageLength[h] += f[1], f[1] = f[0] + (a.fullMessageLength[h] / 4294967296 >>> 0), a.fullMessageLength[h] = a.fullMessageLength[h] >>> 0, f[0] = f[1] / 4294967296 >>> 0;
          return i.putBytes(c), aM(t, n, i), (i.read > 2048 || i.length() === 0) && i.compact(), a
        }, a.digest = function () {
          var c = qr.util.createBuffer();
          c.putBytes(i.bytes());
          var u = a.fullMessageLength[a.fullMessageLength.length - 1] + a.messageLengthSize,
            f = u & a.blockLength - 1;
          c.putBytes(oS.substr(0, a.blockLength - f));
          for (var h, d, p = a.fullMessageLength[0] * 8, g = 0; g < a.fullMessageLength.length - 1; ++g) h = a.fullMessageLength[g + 1] * 8, d = h / 4294967296 >>> 0, p += d, c.putInt32(p >>> 0), p = h >>> 0;
          c.putInt32(p);
          for (var m = new Array(t.length), g = 0; g < t.length; ++g) m[g] = t[g].slice(0);
          aM(m, n, c);
          var E = qr.util.createBuffer(),
            w;
          r === "SHA-512" ? w = m.length : r === "SHA-384" ? w = m.length - 2 : w = m.length - 4;
          for (var g = 0; g < w; ++g) E.putInt32(m[g][0]), (g !== w - 1 || r !== "SHA-512/224") && E.putInt32(m[g][1]);
          return E
        }, a
      };
      var oS = null,
        oM = !1,
        aS = null,
        cl = null;

      function bAe() {
        oS = String.fromCharCode(128), oS += qr.util.fillString(String.fromCharCode(0), 128), aS = [
          [1116352408, 3609767458],
          [1899447441, 602891725],
          [3049323471, 3964484399],
          [3921009573, 2173295548],
          [961987163, 4081628472],
          [1508970993, 3053834265],
          [2453635748, 2937671579],
          [2870763221, 3664609560],
          [3624381080, 2734883394],
          [310598401, 1164996542],
          [607225278, 1323610764],
          [1426881987, 3590304994],
          [1925078388, 4068182383],
          [2162078206, 991336113],
          [2614888103, 633803317],
          [3248222580, 3479774868],
          [3835390401, 2666613458],
          [4022224774, 944711139],
          [264347078, 2341262773],
          [604807628, 2007800933],
          [770255983, 1495990901],
          [1249150122, 1856431235],
          [1555081692, 3175218132],
          [1996064986, 2198950837],
          [2554220882, 3999719339],
          [2821834349, 766784016],
          [2952996808, 2566594879],
          [3210313671, 3203337956],
          [3336571891, 1034457026],
          [3584528711, 2466948901],
          [113926993, 3758326383],
          [338241895, 168717936],
          [666307205, 1188179964],
          [773529912, 1546045734],
          [1294757372, 1522805485],
          [1396182291, 2643833823],
          [1695183700, 2343527390],
          [1986661051, 1014477480],
          [2177026350, 1206759142],
          [2456956037, 344077627],
          [2730485921, 1290863460],
          [2820302411, 3158454273],
          [3259730800, 3505952657],
          [3345764771, 106217008],
          [3516065817, 3606008344],
          [3600352804, 1432725776],
          [4094571909, 1467031594],
          [275423344, 851169720],
          [430227734, 3100823752],
          [506948616, 1363258195],
          [659060556, 3750685593],
          [883997877, 3785050280],
          [958139571, 3318307427],
          [1322822218, 3812723403],
          [1537002063, 2003034995],
          [1747873779, 3602036899],
          [1955562222, 1575990012],
          [2024104815, 1125592928],
          [2227730452, 2716904306],
          [2361852424, 442776044],
          [2428436474, 593698344],
          [2756734187, 3733110249],
          [3204031479, 2999351573],
          [3329325298, 3815920427],
          [3391569614, 3928383900],
          [3515267271, 566280711],
          [3940187606, 3454069534],
          [4118630271, 4000239992],
          [116418474, 1914138554],
          [174292421, 2731055270],
          [289380356, 3203993006],
          [460393269, 320620315],
          [685471733, 587496836],
          [852142971, 1086792851],
          [1017036298, 365543100],
          [1126000580, 2618297676],
          [1288033470, 3409855158],
          [1501505948, 4234509866],
          [1607167915, 987167468],
          [1816402316, 1246189591]
        ], cl = {}, cl["SHA-512"] = [
          [1779033703, 4089235720],
          [3144134277, 2227873595],
          [1013904242, 4271175723],
          [2773480762, 1595750129],
          [1359893119, 2917565137],
          [2600822924, 725511199],
          [528734635, 4215389547],
          [1541459225, 327033209]
        ], cl["SHA-384"] = [
          [3418070365, 3238371032],
          [1654270250, 914150663],
          [2438529370, 812702999],
          [355462360, 4144912697],
          [1731405415, 4290775857],
          [2394180231, 1750603025],
          [3675008525, 1694076839],
          [1203062813, 3204075428]
        ], cl["SHA-512/256"] = [
          [573645204, 4230739756],
          [2673172387, 3360449730],
          [596883563, 1867755857],
          [2520282905, 1497426621],
          [2519219938, 2827943907],
          [3193839141, 1401305490],
          [721525244, 746961066],
          [246885852, 2177182882]
        ], cl["SHA-512/224"] = [
          [2352822216, 424955298],
          [1944164710, 2312950998],
          [502970286, 855612546],
          [1738396948, 1479516111],
          [258812777, 2077511080],
          [2011393907, 79989058],
          [1067287976, 1780299464],
          [286451373, 2446758561]
        ], oM = !0
      }

      function aM(r, e, t) {
        for (var i, n, s, o, a, c, u, f, h, d, p, g, m, E, w, O, q, J, Z, H, te, ae, oe, U, b, _, R, D, K, ee, re, V, v, Y, Se, Q = t.length(); Q >= 128;) {
          for (K = 0; K < 16; ++K) e[K][0] = t.getInt32() >>> 0, e[K][1] = t.getInt32() >>> 0;
          for (; K < 80; ++K) V = e[K - 2], ee = V[0], re = V[1], i = ((ee >>> 19 | re << 13) ^ (re >>> 29 | ee << 3) ^ ee >>> 6) >>> 0, n = ((ee << 13 | re >>> 19) ^ (re << 3 | ee >>> 29) ^ (ee << 26 | re >>> 6)) >>> 0, Y = e[K - 15], ee = Y[0], re = Y[1], s = ((ee >>> 1 | re << 31) ^ (ee >>> 8 | re << 24) ^ ee >>> 7) >>> 0, o = ((ee << 31 | re >>> 1) ^ (ee << 24 | re >>> 8) ^ (ee << 25 | re >>> 7)) >>> 0, v = e[K - 7], Se = e[K - 16], re = n + v[1] + o + Se[1], e[K][0] = i + v[0] + s + Se[0] + (re / 4294967296 >>> 0) >>> 0, e[K][1] = re >>> 0;
          for (m = r[0][0], E = r[0][1], w = r[1][0], O = r[1][1], q = r[2][0], J = r[2][1], Z = r[3][0], H = r[3][1], te = r[4][0], ae = r[4][1], oe = r[5][0], U = r[5][1], b = r[6][0], _ = r[6][1], R = r[7][0], D = r[7][1], K = 0; K < 80; ++K) u = ((te >>> 14 | ae << 18) ^ (te >>> 18 | ae << 14) ^ (ae >>> 9 | te << 23)) >>> 0, f = ((te << 18 | ae >>> 14) ^ (te << 14 | ae >>> 18) ^ (ae << 23 | te >>> 9)) >>> 0, h = (b ^ te & (oe ^ b)) >>> 0, d = (_ ^ ae & (U ^ _)) >>> 0, a = ((m >>> 28 | E << 4) ^ (E >>> 2 | m << 30) ^ (E >>> 7 | m << 25)) >>> 0, c = ((m << 4 | E >>> 28) ^ (E << 30 | m >>> 2) ^ (E << 25 | m >>> 7)) >>> 0, p = (m & w | q & (m ^ w)) >>> 0, g = (E & O | J & (E ^ O)) >>> 0, re = D + f + d + aS[K][1] + e[K][1], i = R + u + h + aS[K][0] + e[K][0] + (re / 4294967296 >>> 0) >>> 0, n = re >>> 0, re = c + g, s = a + p + (re / 4294967296 >>> 0) >>> 0, o = re >>> 0, R = b, D = _, b = oe, _ = U, oe = te, U = ae, re = H + n, te = Z + i + (re / 4294967296 >>> 0) >>> 0, ae = re >>> 0, Z = q, H = J, q = w, J = O, w = m, O = E, re = n + o, m = i + s + (re / 4294967296 >>> 0) >>> 0, E = re >>> 0;
          re = r[0][1] + E, r[0][0] = r[0][0] + m + (re / 4294967296 >>> 0) >>> 0, r[0][1] = re >>> 0, re = r[1][1] + O, r[1][0] = r[1][0] + w + (re / 4294967296 >>> 0) >>> 0, r[1][1] = re >>> 0, re = r[2][1] + J, r[2][0] = r[2][0] + q + (re / 4294967296 >>> 0) >>> 0, r[2][1] = re >>> 0, re = r[3][1] + H, r[3][0] = r[3][0] + Z + (re / 4294967296 >>> 0) >>> 0, r[3][1] = re >>> 0, re = r[4][1] + ae, r[4][0] = r[4][0] + te + (re / 4294967296 >>> 0) >>> 0, r[4][1] = re >>> 0, re = r[5][1] + U, r[5][0] = r[5][0] + oe + (re / 4294967296 >>> 0) >>> 0, r[5][1] = re >>> 0, re = r[6][1] + _, r[6][0] = r[6][0] + b + (re / 4294967296 >>> 0) >>> 0, r[6][1] = re >>> 0, re = r[7][1] + D, r[7][0] = r[7][0] + R + (re / 4294967296 >>> 0) >>> 0, r[7][1] = re >>> 0, Q -= 128
        }
      }
    });
    var cM = y(cS => {
      l();
      var mAe = At();
      Bc();
      var Hi = mAe.asn1;
      cS.privateKeyValidator = {
        name: "PrivateKeyInfo",
        tagClass: Hi.Class.UNIVERSAL,
        type: Hi.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "PrivateKeyInfo.version",
          tagClass: Hi.Class.UNIVERSAL,
          type: Hi.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyVersion"
        }, {
          name: "PrivateKeyInfo.privateKeyAlgorithm",
          tagClass: Hi.Class.UNIVERSAL,
          type: Hi.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: Hi.Class.UNIVERSAL,
            type: Hi.Type.OID,
            constructed: !1,
            capture: "privateKeyOid"
          }]
        }, {
          name: "PrivateKeyInfo",
          tagClass: Hi.Class.UNIVERSAL,
          type: Hi.Type.OCTETSTRING,
          constructed: !1,
          capture: "privateKey"
        }]
      };
      cS.publicKeyValidator = {
        name: "SubjectPublicKeyInfo",
        tagClass: Hi.Class.UNIVERSAL,
        type: Hi.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "subjectPublicKeyInfo",
        value: [{
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: Hi.Class.UNIVERSAL,
          type: Hi.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: Hi.Class.UNIVERSAL,
            type: Hi.Type.OID,
            constructed: !1,
            capture: "publicKeyOid"
          }]
        }, {
          tagClass: Hi.Class.UNIVERSAL,
          type: Hi.Type.BITSTRING,
          constructed: !1,
          composed: !0,
          captureBitStringValue: "ed25519PublicKey"
        }]
      }
    });
    var bS = y((Pbt, uM) => {
      l();
      var hn = At();
      U1();
      Fu();
      d2();
      wr();
      var fM = cM(),
        vAe = fM.publicKeyValidator,
        wAe = fM.privateKeyValidator;
      typeof lM == "undefined" && (lM = hn.jsbn.BigInteger);
      var lM, uS = hn.util.ByteBuffer,
        ds = typeof Buffer == "undefined" ? Uint8Array : Buffer;
      hn.pki = hn.pki || {};
      uM.exports = hn.pki.ed25519 = hn.ed25519 = hn.ed25519 || {};
      var Pt = hn.ed25519;
      Pt.constants = {};
      Pt.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
      Pt.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
      Pt.constants.SEED_BYTE_LENGTH = 32;
      Pt.constants.SIGN_BYTE_LENGTH = 64;
      Pt.constants.HASH_BYTE_LENGTH = 64;
      Pt.generateKeyPair = function (r) {
        r = r || {};
        var e = r.seed;
        if (e === void 0) e = hn.random.getBytesSync(Pt.constants.SEED_BYTE_LENGTH);
        else if (typeof e == "string") {
          if (e.length !== Pt.constants.SEED_BYTE_LENGTH) throw new TypeError('"seed" must be ' + Pt.constants.SEED_BYTE_LENGTH + " bytes in length.")
        } else if (!(e instanceof Uint8Array)) throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
        e = Uc({
          message: e,
          encoding: "binary"
        });
        for (var t = new ds(Pt.constants.PUBLIC_KEY_BYTE_LENGTH), i = new ds(Pt.constants.PRIVATE_KEY_BYTE_LENGTH), n = 0; n < 32; ++n) i[n] = e[n];
        return _Ae(t, i), {
          publicKey: t,
          privateKey: i
        }
      };
      Pt.privateKeyFromAsn1 = function (r) {
        var e = {},
          t = [],
          i = hn.asn1.validate(r, wAe, e, t);
        if (!i) {
          var n = new Error("Invalid Key.");
          throw n.errors = t, n
        }
        var s = hn.asn1.derToOid(e.privateKeyOid),
          o = hn.oids.EdDSA25519;
        if (s !== o) throw new Error('Invalid OID "' + s + '"; OID must be "' + o + '".');
        var a = e.privateKey,
          c = Uc({
            message: hn.asn1.fromDer(a).value,
            encoding: "binary"
          });
        return {
          privateKeyBytes: c
        }
      };
      Pt.publicKeyFromAsn1 = function (r) {
        var e = {},
          t = [],
          i = hn.asn1.validate(r, vAe, e, t);
        if (!i) {
          var n = new Error("Invalid Key.");
          throw n.errors = t, n
        }
        var s = hn.asn1.derToOid(e.publicKeyOid),
          o = hn.oids.EdDSA25519;
        if (s !== o) throw new Error('Invalid OID "' + s + '"; OID must be "' + o + '".');
        var a = e.ed25519PublicKey;
        if (a.length !== Pt.constants.PUBLIC_KEY_BYTE_LENGTH) throw new Error("Key length is invalid.");
        return Uc({
          message: a,
          encoding: "binary"
        })
      };
      Pt.publicKeyFromPrivateKey = function (r) {
        r = r || {};
        var e = Uc({
          message: r.privateKey,
          encoding: "binary"
        });
        if (e.length !== Pt.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError('"options.privateKey" must have a byte length of ' + Pt.constants.PRIVATE_KEY_BYTE_LENGTH);
        for (var t = new ds(Pt.constants.PUBLIC_KEY_BYTE_LENGTH), i = 0; i < t.length; ++i) t[i] = e[32 + i];
        return t
      };
      Pt.sign = function (r) {
        r = r || {};
        var e = Uc(r),
          t = Uc({
            message: r.privateKey,
            encoding: "binary"
          });
        if (t.length === Pt.constants.SEED_BYTE_LENGTH) {
          var i = Pt.generateKeyPair({
            seed: t
          });
          t = i.privateKey
        } else if (t.length !== Pt.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError('"options.privateKey" must have a byte length of ' + Pt.constants.SEED_BYTE_LENGTH + " or " + Pt.constants.PRIVATE_KEY_BYTE_LENGTH);
        var n = new ds(Pt.constants.SIGN_BYTE_LENGTH + e.length);
        EAe(n, e, e.length, t);
        for (var s = new ds(Pt.constants.SIGN_BYTE_LENGTH), o = 0; o < s.length; ++o) s[o] = n[o];
        return s
      };
      Pt.verify = function (r) {
        r = r || {};
        var e = Uc(r);
        if (r.signature === void 0) throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
        var t = Uc({
          message: r.signature,
          encoding: "binary"
        });
        if (t.length !== Pt.constants.SIGN_BYTE_LENGTH) throw new TypeError('"options.signature" must have a byte length of ' + Pt.constants.SIGN_BYTE_LENGTH);
        var i = Uc({
          message: r.publicKey,
          encoding: "binary"
        });
        if (i.length !== Pt.constants.PUBLIC_KEY_BYTE_LENGTH) throw new TypeError('"options.publicKey" must have a byte length of ' + Pt.constants.PUBLIC_KEY_BYTE_LENGTH);
        var n = new ds(Pt.constants.SIGN_BYTE_LENGTH + e.length),
          s = new ds(Pt.constants.SIGN_BYTE_LENGTH + e.length),
          o;
        for (o = 0; o < Pt.constants.SIGN_BYTE_LENGTH; ++o) n[o] = t[o];
        for (o = 0; o < e.length; ++o) n[o + Pt.constants.SIGN_BYTE_LENGTH] = e[o];
        return SAe(s, n, n.length, i) >= 0
      };

      function Uc(r) {
        var e = r.message;
        if (e instanceof Uint8Array || e instanceof ds) return e;
        var t = r.encoding;
        if (e === void 0)
          if (r.md) e = r.md.digest().getBytes(), t = "binary";
          else throw new TypeError('"options.message" or "options.md" not specified.');
        if (typeof e == "string" && !t) throw new TypeError('"options.encoding" must be "binary" or "utf8".');
        if (typeof e == "string") {
          if (typeof Buffer != "undefined") return Buffer.from(e, t);
          e = new uS(e, t)
        } else if (!(e instanceof uS)) throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
        for (var i = new ds(e.length()), n = 0; n < i.length; ++n) i[n] = e.at(n);
        return i
      }
      var fS = ft(),
        p2 = ft([1]),
        xAe = ft([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
        AAe = ft([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
        hM = ft([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
        dM = ft([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
        lS = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]),
        IAe = ft([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

      function V1(r, e) {
        var t = hn.md.sha512.create(),
          i = new uS(r);
        t.update(i.getBytes(e), "binary");
        var n = t.digest().getBytes();
        if (typeof Buffer != "undefined") return Buffer.from(n, "binary");
        for (var s = new ds(Pt.constants.HASH_BYTE_LENGTH), o = 0; o < 64; ++o) s[o] = n.charCodeAt(o);
        return s
      }

      function _Ae(r, e) {
        var t = [ft(), ft(), ft(), ft()],
          i, n = V1(e, 32);
        for (n[0] &= 248, n[31] &= 127, n[31] |= 64, dS(t, n), hS(r, t), i = 0; i < 32; ++i) e[i + 32] = r[i];
        return 0
      }

      function EAe(r, e, t, i) {
        var n, s, o = new Float64Array(64),
          a = [ft(), ft(), ft(), ft()],
          c = V1(i, 32);
        c[0] &= 248, c[31] &= 127, c[31] |= 64;
        var u = t + 64;
        for (n = 0; n < t; ++n) r[64 + n] = e[n];
        for (n = 0; n < 32; ++n) r[32 + n] = c[32 + n];
        var f = V1(r.subarray(32), t + 32);
        for (pS(f), dS(a, f), hS(r, a), n = 32; n < 64; ++n) r[n] = i[n];
        var h = V1(r, t + 64);
        for (pS(h), n = 32; n < 64; ++n) o[n] = 0;
        for (n = 0; n < 32; ++n) o[n] = f[n];
        for (n = 0; n < 32; ++n)
          for (s = 0; s < 32; s++) o[n + s] += h[n] * c[s];
        return pM(r.subarray(32), o), u
      }

      function SAe(r, e, t, i) {
        var n, s, o = new ds(32),
          a = [ft(), ft(), ft(), ft()],
          c = [ft(), ft(), ft(), ft()];
        if (s = -1, t < 64 || TAe(c, i)) return -1;
        for (n = 0; n < t; ++n) r[n] = e[n];
        for (n = 0; n < 32; ++n) r[n + 32] = i[n];
        var u = V1(r, t);
        if (pS(u), gM(a, c, u), dS(c, e.subarray(32)), yS(a, c), hS(o, a), t -= 64, yM(e, 0, o, 0)) {
          for (n = 0; n < t; ++n) r[n] = 0;
          return -1
        }
        for (n = 0; n < t; ++n) r[n] = e[n + 64];
        return s = t, s
      }

      function pM(r, e) {
        var t, i, n, s;
        for (i = 63; i >= 32; --i) {
          for (t = 0, n = i - 32, s = i - 12; n < s; ++n) e[n] += t - 16 * e[i] * lS[n - (i - 32)], t = e[n] + 128 >> 8, e[n] -= t * 256;
          e[n] += t, e[i] = 0
        }
        for (t = 0, n = 0; n < 32; ++n) e[n] += t - (e[31] >> 4) * lS[n], t = e[n] >> 8, e[n] &= 255;
        for (n = 0; n < 32; ++n) e[n] -= t * lS[n];
        for (i = 0; i < 32; ++i) e[i + 1] += e[i] >> 8, r[i] = e[i] & 255
      }

      function pS(r) {
        for (var e = new Float64Array(64), t = 0; t < 64; ++t) e[t] = r[t], r[t] = 0;
        pM(r, e)
      }

      function yS(r, e) {
        var t = ft(),
          i = ft(),
          n = ft(),
          s = ft(),
          o = ft(),
          a = ft(),
          c = ft(),
          u = ft(),
          f = ft();
        pd(t, r[1], r[0]), pd(f, e[1], e[0]), _r(t, t, f), dd(i, r[0], r[1]), dd(f, e[0], e[1]), _r(i, i, f), _r(n, r[3], e[3]), _r(n, n, AAe), _r(s, r[2], e[2]), dd(s, s, s), pd(o, i, t), pd(a, s, n), dd(c, s, n), dd(u, i, t), _r(r[0], o, a), _r(r[1], u, c), _r(r[2], c, a), _r(r[3], o, u)
      }

      function mM(r, e, t) {
        for (var i = 0; i < 4; ++i) bM(r[i], e[i], t)
      }

      function hS(r, e) {
        var t = ft(),
          i = ft(),
          n = ft();
        RAe(n, e[2]), _r(t, e[0], n), _r(i, e[1], n), y2(r, i), r[31] ^= vM(t) << 7
      }

      function y2(r, e) {
        var t, i, n, s = ft(),
          o = ft();
        for (t = 0; t < 16; ++t) o[t] = e[t];
        for (gS(o), gS(o), gS(o), i = 0; i < 2; ++i) {
          for (s[0] = o[0] - 65517, t = 1; t < 15; ++t) s[t] = o[t] - 65535 - (s[t - 1] >> 16 & 1), s[t - 1] &= 65535;
          s[15] = o[15] - 32767 - (s[14] >> 16 & 1), n = s[15] >> 16 & 1, s[14] &= 65535, bM(o, s, 1 - n)
        }
        for (t = 0; t < 16; t++) r[2 * t] = o[t] & 255, r[2 * t + 1] = o[t] >> 8
      }

      function TAe(r, e) {
        var t = ft(),
          i = ft(),
          n = ft(),
          s = ft(),
          o = ft(),
          a = ft(),
          c = ft();
        return zu(r[2], p2), kAe(r[1], e), ul(n, r[1]), _r(s, n, xAe), pd(n, n, r[2]), dd(s, r[2], s), ul(o, s), ul(a, o), _r(c, a, o), _r(t, c, n), _r(t, t, s), PAe(t, t), _r(t, t, n), _r(t, t, s), _r(t, t, s), _r(r[0], t, s), ul(i, r[0]), _r(i, i, s), wM(i, n) && _r(r[0], r[0], IAe), ul(i, r[0]), _r(i, i, s), wM(i, n) ? -1 : (vM(r[0]) === e[31] >> 7 && pd(r[0], fS, r[0]), _r(r[3], r[0], r[1]), 0)
      }

      function kAe(r, e) {
        var t;
        for (t = 0; t < 16; ++t) r[t] = e[2 * t] + (e[2 * t + 1] << 8);
        r[15] &= 32767
      }

      function PAe(r, e) {
        var t = ft(),
          i;
        for (i = 0; i < 16; ++i) t[i] = e[i];
        for (i = 250; i >= 0; --i) ul(t, t), i !== 1 && _r(t, t, e);
        for (i = 0; i < 16; ++i) r[i] = t[i]
      }

      function wM(r, e) {
        var t = new ds(32),
          i = new ds(32);
        return y2(t, r), y2(i, e), yM(t, 0, i, 0)
      }

      function yM(r, e, t, i) {
        return CAe(r, e, t, i, 32)
      }

      function CAe(r, e, t, i, n) {
        var s, o = 0;
        for (s = 0; s < n; ++s) o |= r[e + s] ^ t[i + s];
        return (1 & o - 1 >>> 8) - 1
      }

      function vM(r) {
        var e = new ds(32);
        return y2(e, r), e[0] & 1
      }

      function gM(r, e, t) {
        var i, n;
        for (zu(r[0], fS), zu(r[1], p2), zu(r[2], p2), zu(r[3], fS), n = 255; n >= 0; --n) i = t[n / 8 | 0] >> (n & 7) & 1, mM(r, e, i), yS(e, r), yS(r, r), mM(r, e, i)
      }

      function dS(r, e) {
        var t = [ft(), ft(), ft(), ft()];
        zu(t[0], hM), zu(t[1], dM), zu(t[2], p2), _r(t[3], hM, dM), gM(r, t, e)
      }

      function zu(r, e) {
        var t;
        for (t = 0; t < 16; t++) r[t] = e[t] | 0
      }

      function RAe(r, e) {
        var t = ft(),
          i;
        for (i = 0; i < 16; ++i) t[i] = e[i];
        for (i = 253; i >= 0; --i) ul(t, t), i !== 2 && i !== 4 && _r(t, t, e);
        for (i = 0; i < 16; ++i) r[i] = t[i]
      }

      function gS(r) {
        var e, t, i = 1;
        for (e = 0; e < 16; ++e) t = r[e] + i + 65535, i = Math.floor(t / 65536), r[e] = t - i * 65536;
        r[0] += i - 1 + 37 * (i - 1)
      }

      function bM(r, e, t) {
        for (var i, n = ~(t - 1), s = 0; s < 16; ++s) i = n & (r[s] ^ e[s]), r[s] ^= i, e[s] ^= i
      }

      function ft(r) {
        var e, t = new Float64Array(16);
        if (r)
          for (e = 0; e < r.length; ++e) t[e] = r[e];
        return t
      }

      function dd(r, e, t) {
        for (var i = 0; i < 16; ++i) r[i] = e[i] + t[i]
      }

      function pd(r, e, t) {
        for (var i = 0; i < 16; ++i) r[i] = e[i] - t[i]
      }

      function ul(r, e) {
        _r(r, e, e)
      }

      function _r(r, e, t) {
        var i, n, s = 0,
          o = 0,
          a = 0,
          c = 0,
          u = 0,
          f = 0,
          h = 0,
          d = 0,
          p = 0,
          g = 0,
          m = 0,
          E = 0,
          w = 0,
          O = 0,
          q = 0,
          J = 0,
          Z = 0,
          H = 0,
          te = 0,
          ae = 0,
          oe = 0,
          U = 0,
          b = 0,
          _ = 0,
          R = 0,
          D = 0,
          K = 0,
          ee = 0,
          re = 0,
          V = 0,
          v = 0,
          Y = t[0],
          Se = t[1],
          Q = t[2],
          ve = t[3],
          x = t[4],
          I = t[5],
          le = t[6],
          he = t[7],
          S = t[8],
          T = t[9],
          j = t[10],
          G = t[11],
          k = t[12],
          F = t[13],
          B = t[14],
          L = t[15];
        i = e[0], s += i * Y, o += i * Se, a += i * Q, c += i * ve, u += i * x, f += i * I, h += i * le, d += i * he, p += i * S, g += i * T, m += i * j, E += i * G, w += i * k, O += i * F, q += i * B, J += i * L, i = e[1], o += i * Y, a += i * Se, c += i * Q, u += i * ve, f += i * x, h += i * I, d += i * le, p += i * he, g += i * S, m += i * T, E += i * j, w += i * G, O += i * k, q += i * F, J += i * B, Z += i * L, i = e[2], a += i * Y, c += i * Se, u += i * Q, f += i * ve, h += i * x, d += i * I, p += i * le, g += i * he, m += i * S, E += i * T, w += i * j, O += i * G, q += i * k, J += i * F, Z += i * B, H += i * L, i = e[3], c += i * Y, u += i * Se, f += i * Q, h += i * ve, d += i * x, p += i * I, g += i * le, m += i * he, E += i * S, w += i * T, O += i * j, q += i * G, J += i * k, Z += i * F, H += i * B, te += i * L, i = e[4], u += i * Y, f += i * Se, h += i * Q, d += i * ve, p += i * x, g += i * I, m += i * le, E += i * he, w += i * S, O += i * T, q += i * j, J += i * G, Z += i * k, H += i * F, te += i * B, ae += i * L, i = e[5], f += i * Y, h += i * Se, d += i * Q, p += i * ve, g += i * x, m += i * I, E += i * le, w += i * he, O += i * S, q += i * T, J += i * j, Z += i * G, H += i * k, te += i * F, ae += i * B, oe += i * L, i = e[6], h += i * Y, d += i * Se, p += i * Q, g += i * ve, m += i * x, E += i * I, w += i * le, O += i * he, q += i * S, J += i * T, Z += i * j, H += i * G, te += i * k, ae += i * F, oe += i * B, U += i * L, i = e[7], d += i * Y, p += i * Se, g += i * Q, m += i * ve, E += i * x, w += i * I, O += i * le, q += i * he, J += i * S, Z += i * T, H += i * j, te += i * G, ae += i * k, oe += i * F, U += i * B, b += i * L, i = e[8], p += i * Y, g += i * Se, m += i * Q, E += i * ve, w += i * x, O += i * I, q += i * le, J += i * he, Z += i * S, H += i * T, te += i * j, ae += i * G, oe += i * k, U += i * F, b += i * B, _ += i * L, i = e[9], g += i * Y, m += i * Se, E += i * Q, w += i * ve, O += i * x, q += i * I, J += i * le, Z += i * he, H += i * S, te += i * T, ae += i * j, oe += i * G, U += i * k, b += i * F, _ += i * B, R += i * L, i = e[10], m += i * Y, E += i * Se, w += i * Q, O += i * ve, q += i * x, J += i * I, Z += i * le, H += i * he, te += i * S, ae += i * T, oe += i * j, U += i * G, b += i * k, _ += i * F, R += i * B, D += i * L, i = e[11], E += i * Y, w += i * Se, O += i * Q, q += i * ve, J += i * x, Z += i * I, H += i * le, te += i * he, ae += i * S, oe += i * T, U += i * j, b += i * G, _ += i * k, R += i * F, D += i * B, K += i * L, i = e[12], w += i * Y, O += i * Se, q += i * Q, J += i * ve, Z += i * x, H += i * I, te += i * le, ae += i * he, oe += i * S, U += i * T, b += i * j, _ += i * G, R += i * k, D += i * F, K += i * B, ee += i * L, i = e[13], O += i * Y, q += i * Se, J += i * Q, Z += i * ve, H += i * x, te += i * I, ae += i * le, oe += i * he, U += i * S, b += i * T, _ += i * j, R += i * G, D += i * k, K += i * F, ee += i * B, re += i * L, i = e[14], q += i * Y, J += i * Se, Z += i * Q, H += i * ve, te += i * x, ae += i * I, oe += i * le, U += i * he, b += i * S, _ += i * T, R += i * j, D += i * G, K += i * k, ee += i * F, re += i * B, V += i * L, i = e[15], J += i * Y, Z += i * Se, H += i * Q, te += i * ve, ae += i * x, oe += i * I, U += i * le, b += i * he, _ += i * S, R += i * T, D += i * j, K += i * G, ee += i * k, re += i * F, V += i * B, v += i * L, s += 38 * Z, o += 38 * H, a += 38 * te, c += 38 * ae, u += 38 * oe, f += 38 * U, h += 38 * b, d += 38 * _, p += 38 * R, g += 38 * D, m += 38 * K, E += 38 * ee, w += 38 * re, O += 38 * V, q += 38 * v, n = 1, i = s + n + 65535, n = Math.floor(i / 65536), s = i - n * 65536, i = o + n + 65535, n = Math.floor(i / 65536), o = i - n * 65536, i = a + n + 65535, n = Math.floor(i / 65536), a = i - n * 65536, i = c + n + 65535, n = Math.floor(i / 65536), c = i - n * 65536, i = u + n + 65535, n = Math.floor(i / 65536), u = i - n * 65536, i = f + n + 65535, n = Math.floor(i / 65536), f = i - n * 65536, i = h + n + 65535, n = Math.floor(i / 65536), h = i - n * 65536, i = d + n + 65535, n = Math.floor(i / 65536), d = i - n * 65536, i = p + n + 65535, n = Math.floor(i / 65536), p = i - n * 65536, i = g + n + 65535, n = Math.floor(i / 65536), g = i - n * 65536, i = m + n + 65535, n = Math.floor(i / 65536), m = i - n * 65536, i = E + n + 65535, n = Math.floor(i / 65536), E = i - n * 65536, i = w + n + 65535, n = Math.floor(i / 65536), w = i - n * 65536, i = O + n + 65535, n = Math.floor(i / 65536), O = i - n * 65536, i = q + n + 65535, n = Math.floor(i / 65536), q = i - n * 65536, i = J + n + 65535, n = Math.floor(i / 65536), J = i - n * 65536, s += n - 1 + 37 * (n - 1), n = 1, i = s + n + 65535, n = Math.floor(i / 65536), s = i - n * 65536, i = o + n + 65535, n = Math.floor(i / 65536), o = i - n * 65536, i = a + n + 65535, n = Math.floor(i / 65536), a = i - n * 65536, i = c + n + 65535, n = Math.floor(i / 65536), c = i - n * 65536, i = u + n + 65535, n = Math.floor(i / 65536), u = i - n * 65536, i = f + n + 65535, n = Math.floor(i / 65536), f = i - n * 65536, i = h + n + 65535, n = Math.floor(i / 65536), h = i - n * 65536, i = d + n + 65535, n = Math.floor(i / 65536), d = i - n * 65536, i = p + n + 65535, n = Math.floor(i / 65536), p = i - n * 65536, i = g + n + 65535, n = Math.floor(i / 65536), g = i - n * 65536, i = m + n + 65535, n = Math.floor(i / 65536), m = i - n * 65536, i = E + n + 65535, n = Math.floor(i / 65536), E = i - n * 65536, i = w + n + 65535, n = Math.floor(i / 65536), w = i - n * 65536, i = O + n + 65535, n = Math.floor(i / 65536), O = i - n * 65536, i = q + n + 65535, n = Math.floor(i / 65536), q = i - n * 65536, i = J + n + 65535, n = Math.floor(i / 65536), J = i - n * 65536, s += n - 1 + 37 * (n - 1), r[0] = s, r[1] = o, r[2] = a, r[3] = c, r[4] = u, r[5] = f, r[6] = h, r[7] = d, r[8] = p, r[9] = g, r[10] = m, r[11] = E, r[12] = w, r[13] = O, r[14] = q, r[15] = J
      }
    });
    var EM = y((Cbt, _M) => {
      l();
      "use strict";
      var g2 = 65536;

      function OAe(r) {
        let e = new Uint8Array(r),
          t = 0;
        if (r > 0)
          if (r > g2)
            for (; t < r;) t + g2 > r ? (crypto.getRandomValues(e.subarray(t, t + (r - t))), t += r - t) : (crypto.getRandomValues(e.subarray(t, t + g2)), t += g2);
          else crypto.getRandomValues(e);
        return e
      }
      _M.exports = OAe
    });
    var H1 = y((Obt, SM) => {
      l();
      "use strict";
      var NAe = EM(),
        qAe = xe();
      SM.exports = function (r) {
        if (isNaN(r) || r <= 0) throw qAe(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
        return NAe(r)
      }
    });
    var b2 = y(G1 => {
      l();
      "use strict";
      wr();
      U1();
      var MAe = At(),
        BAe = gt(),
        xM = ct(),
        AM = xi();
      G1.bigIntegerToUintBase64url = (r, e) => {
        let t = Uint8Array.from(r.abs().toByteArray());
        if (t = t[0] === 0 ? t.slice(1) : t, e != null) {
          if (t.length > e) throw new Error("byte array longer than desired length");
          t = AM([new Uint8Array(e - t.length), t])
        }
        return xM(t, "base64url")
      };
      G1.base64urlToBigInteger = r => {
        let e = G1.base64urlToBuffer(r);
        return new MAe.jsbn.BigInteger(xM(e, "base16"), 16)
      };
      G1.base64urlToBuffer = (r, e) => {
        let t = BAe(r, "base64urlpad");
        if (e != null) {
          if (t.length > e) throw new Error("byte array longer than desired length");
          t = AM([new Uint8Array(e - t.length), t])
        }
        return t
      }
    });
    var RM = y($1 => {
      l();
      "use strict";
      Bc();
      K1();
      var ju = At(),
        {
          bigIntegerToUintBase64url: Ba,
          base64urlToBigInteger: Da
        } = b2(),
        IM = gt(),
        TM = ct();
      $1.pkcs1ToJwk = function (r) {
        let e = ju.asn1.fromDer(TM(r, "ascii")),
          t = ju.pki.privateKeyFromAsn1(e);
        return {
          kty: "RSA",
          n: Ba(t.n),
          e: Ba(t.e),
          d: Ba(t.d),
          p: Ba(t.p),
          q: Ba(t.q),
          dp: Ba(t.dP),
          dq: Ba(t.dQ),
          qi: Ba(t.qInv),
          alg: "RS256",
          kid: "2011-04-29"
        }
      };
      $1.jwkToPkcs1 = function (r) {
        let e = ju.pki.privateKeyToAsn1({
          n: Da(r.n),
          e: Da(r.e),
          d: Da(r.d),
          p: Da(r.p),
          q: Da(r.q),
          dP: Da(r.dp),
          dQ: Da(r.dq),
          qInv: Da(r.qi)
        });
        return IM(ju.asn1.toDer(e).getBytes(), "ascii")
      };
      $1.pkixToJwk = function (r) {
        let e = ju.asn1.fromDer(TM(r, "ascii")),
          t = ju.pki.publicKeyFromAsn1(e);
        return {
          kty: "RSA",
          n: Ba(t.n),
          e: Ba(t.e),
          alg: "RS256",
          kid: "2011-04-29"
        }
      };
      $1.jwkToPkix = function (r) {
        let e = ju.pki.publicKeyToAsn1({
          n: Da(r.n),
          e: Da(r.e)
        });
        return IM(ju.asn1.toDer(e).getBytes(), "ascii")
      }
    });
    var OM = y((Mbt, kM) => {
      l();
      "use strict";
      K1();
      var PM = At(),
        {
          base64urlToBigInteger: DAe
        } = b2();

      function CM(r, e) {
        return e.map(t => DAe(r[t]))
      }

      function LAe(r) {
        return PM.pki.setRsaPrivateKey(...CM(r, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]))
      }

      function FAe(r) {
        return PM.pki.setRsaPublicKey(...CM(r, ["n", "e"]))
      }
      kM.exports = {
        jwk2pub: FAe,
        jwk2priv: LAe
      }
    });
    var MM = y(Kc => {
      l();
      "use strict";
      var zc = z1(),
        UAe = H1(),
        KAe = ct(),
        zAe = gt();
      Kc.utils = RM();
      Kc.generateKey = async function (r) {
        let e = await zc.get().subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: r,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: {
            name: "SHA-256"
          }
        }, !0, ["sign", "verify"]),
          t = await NM(e);
        return {
          privateKey: t[0],
          publicKey: t[1]
        }
      };
      Kc.unmarshalPrivateKey = async function (r) {
        let t = [await zc.get().subtle.importKey("jwk", r, {
          name: "RSASSA-PKCS1-v1_5",
          hash: {
            name: "SHA-256"
          }
        }, !0, ["sign"]), await jAe(r)],
          i = await NM({
            privateKey: t[0],
            publicKey: t[1]
          });
        return {
          privateKey: i[0],
          publicKey: i[1]
        }
      };
      Kc.getRandomValues = UAe;
      Kc.hashAndSign = async function (r, e) {
        let t = await zc.get().subtle.importKey("jwk", r, {
          name: "RSASSA-PKCS1-v1_5",
          hash: {
            name: "SHA-256"
          }
        }, !1, ["sign"]),
          i = await zc.get().subtle.sign({
            name: "RSASSA-PKCS1-v1_5"
          }, t, Uint8Array.from(e));
        return new Uint8Array(i, i.byteOffset, i.byteLength)
      };
      Kc.hashAndVerify = async function (r, e, t) {
        let i = await zc.get().subtle.importKey("jwk", r, {
          name: "RSASSA-PKCS1-v1_5",
          hash: {
            name: "SHA-256"
          }
        }, !1, ["verify"]);
        return zc.get().subtle.verify({
          name: "RSASSA-PKCS1-v1_5"
        }, i, e, t)
      };

      function NM(r) {
        return Promise.all([zc.get().subtle.exportKey("jwk", r.privateKey), zc.get().subtle.exportKey("jwk", r.publicKey)])
      }

      function jAe(r) {
        return zc.get().subtle.importKey("jwk", {
          kty: r.kty,
          n: r.n,
          e: r.e
        }, {
          name: "RSASSA-PKCS1-v1_5",
          hash: {
            name: "SHA-256"
          }
        }, !0, ["verify"])
      }
      var {
        jwk2pub: VAe,
        jwk2priv: HAe
      } = OM();

      function qM(r, e, t, i) {
        let n = e ? VAe(r) : HAe(r),
          s = KAe(Uint8Array.from(t), "ascii"),
          o = i(s, n);
        return zAe(o, "ascii")
      }
      Kc.encrypt = function (r, e) {
        return qM(r, !0, e, (t, i) => i.encrypt(t))
      };
      Kc.decrypt = function (r, e) {
        return qM(r, !1, e, (t, i) => i.decrypt(t))
      }
    });
    var m2 = y((Dbt, BM) => {
      l();
      "use strict";
      var GAe = ln(),
        $Ae = nS();
      BM.exports = {
        export: async function (r, e) {
          let i = await $Ae.create().encrypt(r, e);
          return GAe.names.base64.encode(i)
        }
      }
    });
    var KM = y((Lbt, DM) => {
      l();
      "use strict";
      var LM = hd(),
        FM = xe(),
        UM = Lr(),
        WAe = ct();
      d2();
      bS();
      var v2 = At(),
        Qs = MM(),
        w2 = Ym(),
        YAe = m2(),
        _2 = class {
          constructor(e) {
            this._key = e
          }
          async verify(e, t) {
            return Qs.hashAndVerify(this._key, t, e)
          }
          marshal() {
            return Qs.utils.jwkToPkix(this._key)
          }
          get bytes() {
            return w2.PublicKey.encode({
              Type: w2.KeyType.RSA,
              Data: this.marshal()
            }).finish()
          }
          encrypt(e) {
            return Qs.encrypt(this._key, e)
          }
          equals(e) {
            return UM(this.bytes, e.bytes)
          }
          async hash() {
            return LM.multihashing(this.bytes, "sha2-256")
          }
        },
        W1 = class {
          constructor(e, t) {
            this._key = e, this._publicKey = t
          }
          genSecret() {
            return Qs.getRandomValues(16)
          }
          async sign(e) {
            return Qs.hashAndSign(this._key, e)
          }
          get public() {
            if (!this._publicKey) throw FM(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
            return new _2(this._publicKey)
          }
          decrypt(e) {
            return Qs.decrypt(this._key, e)
          }
          marshal() {
            return Qs.utils.jwkToPkcs1(this._key)
          }
          get bytes() {
            return w2.PrivateKey.encode({
              Type: w2.KeyType.RSA,
              Data: this.marshal()
            }).finish()
          }
          equals(e) {
            return UM(this.bytes, e.bytes)
          }
          async hash() {
            return LM.multihashing(this.bytes, "sha2-256")
          }
          async id() {
            let e = await this.public.hash();
            return WAe(e, "base58btc")
          }
          async export(e, t = "pkcs-8") {
            if (t === "pkcs-8") {
              let i = new v2.util.ByteBuffer(this.marshal()),
                n = v2.asn1.fromDer(i),
                s = v2.pki.privateKeyFromAsn1(n),
                o = {
                  algorithm: "aes256",
                  count: 1e4,
                  saltSize: 128 / 8,
                  prfAlgorithm: "sha512"
                };
              return v2.pki.encryptRsaPrivateKey(s, e, o)
            } else {
              if (t === "libp2p-key") return YAe.export(this.bytes, e);
              throw FM(new Error(`export format '${t}' is not supported`), "ERR_INVALID_EXPORT_FORMAT")
            }
          }
        };
      async function JAe(r) {
        let e = Qs.utils.pkcs1ToJwk(r),
          t = await Qs.unmarshalPrivateKey(e);
        return new W1(t.privateKey, t.publicKey)
      }

      function XAe(r) {
        let e = Qs.utils.pkixToJwk(r);
        return new _2(e)
      }
      async function ZAe(r) {
        let e = await Qs.unmarshalPrivateKey(r);
        return new W1(e.privateKey, e.publicKey)
      }
      async function QAe(r) {
        let e = await Qs.generateKey(r);
        return new W1(e.privateKey, e.publicKey)
      }
      DM.exports = {
        RsaPublicKey: _2,
        RsaPrivateKey: W1,
        unmarshalRsaPublicKey: XAe,
        unmarshalRsaPrivateKey: JAe,
        generateKeyPair: QAe,
        fromJwk: ZAe
      }
    });
    var zM = y(fl => {
      l();
      "use strict";
      bS();
      var yd = At();
      fl.publicKeyLength = yd.pki.ed25519.constants.PUBLIC_KEY_BYTE_LENGTH;
      fl.privateKeyLength = yd.pki.ed25519.constants.PRIVATE_KEY_BYTE_LENGTH;
      fl.generateKey = async function () {
        return yd.pki.ed25519.generateKeyPair()
      };
      fl.generateKeyFromSeed = async function (r) {
        return yd.pki.ed25519.generateKeyPair({
          seed: r
        })
      };
      fl.hashAndSign = async function (r, e) {
        return yd.pki.ed25519.sign({
          message: e,
          privateKey: r
        })
      };
      fl.hashAndVerify = async function (r, e, t) {
        return yd.pki.ed25519.verify({
          signature: e,
          message: t,
          publicKey: r
        })
      }
    });
    var WM = y((Ubt, jM) => {
      l();
      "use strict";
      var VM = hd(),
        HM = xe(),
        GM = Lr(),
        $M = Do(),
        Sn = zM(),
        E2 = Ym(),
        eIe = m2(),
        S2 = class {
          constructor(e) {
            this._key = gd(e, Sn.publicKeyLength)
          }
          async verify(e, t) {
            return Sn.hashAndVerify(this._key, t, e)
          }
          marshal() {
            return this._key
          }
          get bytes() {
            return E2.PublicKey.encode({
              Type: E2.KeyType.Ed25519,
              Data: this.marshal()
            }).finish()
          }
          equals(e) {
            return GM(this.bytes, e.bytes)
          }
          async hash() {
            return VM.multihashing(this.bytes, "sha2-256")
          }
        },
        bd = class {
          constructor(e, t) {
            this._key = gd(e, Sn.privateKeyLength), this._publicKey = gd(t, Sn.publicKeyLength)
          }
          async sign(e) {
            return Sn.hashAndSign(this._key, e)
          }
          get public() {
            return new S2(this._publicKey)
          }
          marshal() {
            return this._key
          }
          get bytes() {
            return E2.PrivateKey.encode({
              Type: E2.KeyType.Ed25519,
              Data: this.marshal()
            }).finish()
          }
          equals(e) {
            return GM(this.bytes, e.bytes)
          }
          async hash() {
            return VM.multihashing(this.bytes, "sha2-256")
          }
          async id() {
            let e = $M.encode(this.public.bytes, "identity");
            return await $M.toB58String(e)
          }
          async export(e, t = "libp2p-key") {
            if (t === "libp2p-key") return eIe.export(this.bytes, e);
            throw HM(new Error(`export format '${t}' is not supported`), "ERR_INVALID_EXPORT_FORMAT")
          }
        };

      function tIe(r) {
        if (r.length > Sn.privateKeyLength) {
          r = gd(r, Sn.privateKeyLength + Sn.publicKeyLength);
          let i = r.slice(0, Sn.privateKeyLength),
            n = r.slice(Sn.privateKeyLength, r.length);
          return new bd(i, n)
        }
        r = gd(r, Sn.privateKeyLength);
        let e = r.slice(0, Sn.privateKeyLength),
          t = r.slice(Sn.publicKeyLength);
        return new bd(e, t)
      }

      function rIe(r) {
        return r = gd(r, Sn.publicKeyLength), new S2(r)
      }
      async function iIe() {
        let {
          privateKey: r,
          publicKey: e
        } = await Sn.generateKey();
        return new bd(r, e)
      }
      async function nIe(r) {
        let {
          privateKey: e,
          publicKey: t
        } = await Sn.generateKeyFromSeed(r);
        return new bd(e, t)
      }

      function gd(r, e) {
        if (r = Uint8Array.from(r || []), r.length !== e) throw HM(new Error(`Key must be a Uint8Array of length ${e}, got ${r.length}`), "ERR_INVALID_KEY_TYPE");
        return r
      }
      jM.exports = {
        Ed25519PublicKey: S2,
        Ed25519PrivateKey: bd,
        unmarshalEd25519PrivateKey: tIe,
        unmarshalEd25519PublicKey: rIe,
        generateKeyPair: iIe,
        generateKeyPairFromSeed: nIe
      }
    });
    var JM = y((Kbt, YM) => {
      l();
      var er = {
        IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
        TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
        TWEAK_MUL: "The tweak was out of range or equal to zero",
        CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
        SECKEY_INVALID: "Private Key is invalid",
        PUBKEY_PARSE: "Public Key could not be parsed",
        PUBKEY_SERIALIZE: "Public Key serialization error",
        PUBKEY_COMBINE: "The sum of the public keys is not valid",
        SIG_PARSE: "Signature could not be parsed",
        SIGN: "The nonce generation function failed, or the private key was invalid",
        RECOVER: "Public key could not be recover",
        ECDH: "Scalar was invalid (zero or overflow)"
      };

      function eo(r, e) {
        if (!r) throw new Error(e)
      }

      function jt(r, e, t) {
        if (eo(e instanceof Uint8Array, `Expected ${r} to be an Uint8Array`), t !== void 0)
          if (Array.isArray(t)) {
            let i = t.join(", "),
              n = `Expected ${r} to be an Uint8Array with length [${i}]`;
            eo(t.includes(e.length), n)
          } else {
            let i = `Expected ${r} to be an Uint8Array with length ${t}`;
            eo(e.length === t, i)
          }
      }

      function ll(r) {
        eo(md(r) === "Boolean", "Expected compressed to be a Boolean")
      }

      function zo(r = t => new Uint8Array(t), e) {
        return typeof r == "function" && (r = r(e)), jt("output", r, e), r
      }

      function md(r) {
        return Object.prototype.toString.call(r).slice(8, -1)
      }
      YM.exports = r => ({
        contextRandomize(e) {
          switch (eo(e === null || e instanceof Uint8Array, "Expected seed to be an Uint8Array or null"), e !== null && jt("seed", e, 32), r.contextRandomize(e)) {
            case 1:
              throw new Error(er.CONTEXT_RANDOMIZE_UNKNOW)
          }
        },
        privateKeyVerify(e) {
          return jt("private key", e, 32), r.privateKeyVerify(e) === 0
        },
        privateKeyNegate(e) {
          switch (jt("private key", e, 32), r.privateKeyNegate(e)) {
            case 0:
              return e;
            case 1:
              throw new Error(er.IMPOSSIBLE_CASE)
          }
        },
        privateKeyTweakAdd(e, t) {
          switch (jt("private key", e, 32), jt("tweak", t, 32), r.privateKeyTweakAdd(e, t)) {
            case 0:
              return e;
            case 1:
              throw new Error(er.TWEAK_ADD)
          }
        },
        privateKeyTweakMul(e, t) {
          switch (jt("private key", e, 32), jt("tweak", t, 32), r.privateKeyTweakMul(e, t)) {
            case 0:
              return e;
            case 1:
              throw new Error(er.TWEAK_MUL)
          }
        },
        publicKeyVerify(e) {
          return jt("public key", e, [33, 65]), r.publicKeyVerify(e) === 0
        },
        publicKeyCreate(e, t = !0, i) {
          switch (jt("private key", e, 32), ll(t), i = zo(i, t ? 33 : 65), r.publicKeyCreate(i, e)) {
            case 0:
              return i;
            case 1:
              throw new Error(er.SECKEY_INVALID);
            case 2:
              throw new Error(er.PUBKEY_SERIALIZE)
          }
        },
        publicKeyConvert(e, t = !0, i) {
          switch (jt("public key", e, [33, 65]), ll(t), i = zo(i, t ? 33 : 65), r.publicKeyConvert(i, e)) {
            case 0:
              return i;
            case 1:
              throw new Error(er.PUBKEY_PARSE);
            case 2:
              throw new Error(er.PUBKEY_SERIALIZE)
          }
        },
        publicKeyNegate(e, t = !0, i) {
          switch (jt("public key", e, [33, 65]), ll(t), i = zo(i, t ? 33 : 65), r.publicKeyNegate(i, e)) {
            case 0:
              return i;
            case 1:
              throw new Error(er.PUBKEY_PARSE);
            case 2:
              throw new Error(er.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(er.PUBKEY_SERIALIZE)
          }
        },
        publicKeyCombine(e, t = !0, i) {
          eo(Array.isArray(e), "Expected public keys to be an Array"), eo(e.length > 0, "Expected public keys array will have more than zero items");
          for (let n of e) jt("public key", n, [33, 65]);
          switch (ll(t), i = zo(i, t ? 33 : 65), r.publicKeyCombine(i, e)) {
            case 0:
              return i;
            case 1:
              throw new Error(er.PUBKEY_PARSE);
            case 2:
              throw new Error(er.PUBKEY_COMBINE);
            case 3:
              throw new Error(er.PUBKEY_SERIALIZE)
          }
        },
        publicKeyTweakAdd(e, t, i = !0, n) {
          switch (jt("public key", e, [33, 65]), jt("tweak", t, 32), ll(i), n = zo(n, i ? 33 : 65), r.publicKeyTweakAdd(n, e, t)) {
            case 0:
              return n;
            case 1:
              throw new Error(er.PUBKEY_PARSE);
            case 2:
              throw new Error(er.TWEAK_ADD)
          }
        },
        publicKeyTweakMul(e, t, i = !0, n) {
          switch (jt("public key", e, [33, 65]), jt("tweak", t, 32), ll(i), n = zo(n, i ? 33 : 65), r.publicKeyTweakMul(n, e, t)) {
            case 0:
              return n;
            case 1:
              throw new Error(er.PUBKEY_PARSE);
            case 2:
              throw new Error(er.TWEAK_MUL)
          }
        },
        signatureNormalize(e) {
          switch (jt("signature", e, 64), r.signatureNormalize(e)) {
            case 0:
              return e;
            case 1:
              throw new Error(er.SIG_PARSE)
          }
        },
        signatureExport(e, t) {
          jt("signature", e, 64), t = zo(t, 72);
          let i = {
            output: t,
            outputlen: 72
          };
          switch (r.signatureExport(i, e)) {
            case 0:
              return t.slice(0, i.outputlen);
            case 1:
              throw new Error(er.SIG_PARSE);
            case 2:
              throw new Error(er.IMPOSSIBLE_CASE)
          }
        },
        signatureImport(e, t) {
          switch (jt("signature", e), t = zo(t, 64), r.signatureImport(t, e)) {
            case 0:
              return t;
            case 1:
              throw new Error(er.SIG_PARSE);
            case 2:
              throw new Error(er.IMPOSSIBLE_CASE)
          }
        },
        ecdsaSign(e, t, i = {}, n) {
          jt("message", e, 32), jt("private key", t, 32), eo(md(i) === "Object", "Expected options to be an Object"), i.data !== void 0 && jt("options.data", i.data), i.noncefn !== void 0 && eo(md(i.noncefn) === "Function", "Expected options.noncefn to be a Function"), n = zo(n, 64);
          let s = {
            signature: n,
            recid: null
          };
          switch (r.ecdsaSign(s, e, t, i.data, i.noncefn)) {
            case 0:
              return s;
            case 1:
              throw new Error(er.SIGN);
            case 2:
              throw new Error(er.IMPOSSIBLE_CASE)
          }
        },
        ecdsaVerify(e, t, i) {
          switch (jt("signature", e, 64), jt("message", t, 32), jt("public key", i, [33, 65]), r.ecdsaVerify(e, t, i)) {
            case 0:
              return !0;
            case 3:
              return !1;
            case 1:
              throw new Error(er.SIG_PARSE);
            case 2:
              throw new Error(er.PUBKEY_PARSE)
          }
        },
        ecdsaRecover(e, t, i, n = !0, s) {
          switch (jt("signature", e, 64), eo(md(t) === "Number" && t >= 0 && t <= 3, "Expected recovery id to be a Number within interval [0, 3]"), jt("message", i, 32), ll(n), s = zo(s, n ? 33 : 65), r.ecdsaRecover(s, e, t, i)) {
            case 0:
              return s;
            case 1:
              throw new Error(er.SIG_PARSE);
            case 2:
              throw new Error(er.RECOVER);
            case 3:
              throw new Error(er.IMPOSSIBLE_CASE)
          }
        },
        ecdh(e, t, i = {}, n) {
          switch (jt("public key", e, [33, 65]), jt("private key", t, 32), eo(md(i) === "Object", "Expected options to be an Object"), i.data !== void 0 && jt("options.data", i.data), i.hashfn !== void 0 ? (eo(md(i.hashfn) === "Function", "Expected options.hashfn to be a Function"), i.xbuf !== void 0 && jt("options.xbuf", i.xbuf, 32), i.ybuf !== void 0 && jt("options.ybuf", i.ybuf, 32), jt("output", n)) : n = zo(n, 32), r.ecdh(n, e, t, i.data, i.hashfn, i.xbuf, i.ybuf)) {
            case 0:
              return n;
            case 1:
              throw new Error(er.PUBKEY_PARSE);
            case 2:
              throw new Error(er.ECDH)
          }
        }
      })
    });
    var ZM = y((zbt, XM) => {
      XM.exports = {
        _args: [
          ["elliptic@6.5.4", "/Users/alex/Documents/Workspaces/ipfs/js-ipfs"]
        ],
        _from: "elliptic@6.5.4",
        _id: "elliptic@6.5.4",
        _inBundle: !1,
        _integrity: "sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==",
        _location: "/elliptic",
        _phantomChildren: {},
        _requested: {
          type: "version",
          registry: !0,
          raw: "elliptic@6.5.4",
          name: "elliptic",
          escapedName: "elliptic",
          rawSpec: "6.5.4",
          saveSpec: null,
          fetchSpec: "6.5.4"
        },
        _requiredBy: ["/secp256k1"],
        _resolved: "https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz",
        _spec: "6.5.4",
        _where: "/Users/alex/Documents/Workspaces/ipfs/js-ipfs",
        author: {
          name: "Fedor Indutny",
          email: "fedor@indutny.com"
        },
        bugs: {
          url: "https://github.com/indutny/elliptic/issues"
        },
        dependencies: {
          "bn.js": "^4.11.9",
          brorand: "^1.1.0",
          "hash.js": "^1.0.0",
          "hmac-drbg": "^1.0.1",
          inherits: "^2.0.4",
          "minimalistic-assert": "^1.0.1",
          "minimalistic-crypto-utils": "^1.0.1"
        },
        description: "EC cryptography",
        devDependencies: {
          brfs: "^2.0.2",
          coveralls: "^3.1.0",
          eslint: "^7.6.0",
          grunt: "^1.2.1",
          "grunt-browserify": "^5.3.0",
          "grunt-cli": "^1.3.2",
          "grunt-contrib-connect": "^3.0.0",
          "grunt-contrib-copy": "^1.0.0",
          "grunt-contrib-uglify": "^5.0.0",
          "grunt-mocha-istanbul": "^5.0.2",
          "grunt-saucelabs": "^9.0.1",
          istanbul: "^0.4.5",
          mocha: "^8.0.1"
        },
        files: ["lib"],
        homepage: "https://github.com/indutny/elliptic",
        keywords: ["EC", "Elliptic", "curve", "Cryptography"],
        license: "MIT",
        main: "lib/elliptic.js",
        name: "elliptic",
        repository: {
          type: "git",
          url: "git+ssh://git@github.com/indutny/elliptic.git"
        },
        scripts: {
          lint: "eslint lib test",
          "lint:fix": "npm run lint -- --fix",
          test: "npm run lint && npm run unit",
          unit: "istanbul test _mocha --reporter=spec test/index.js",
          version: "grunt dist && git add dist/"
        },
        version: "6.5.4"
      }
    });
    var QM = y(() => {
      l()
    });
    var La = y((eB, mS) => {
      l();
      (function (r, e) {
        "use strict";

        function t(U, b) {
          if (!U) throw new Error(b || "Assertion failed")
        }

        function i(U, b) {
          U.super_ = b;
          var _ = function () { };
          _.prototype = b.prototype, U.prototype = new _, U.prototype.constructor = U
        }

        function n(U, b, _) {
          if (n.isBN(U)) return U;
          this.negative = 0, this.words = null, this.length = 0, this.red = null, U !== null && ((b === "le" || b === "be") && (_ = b, b = 10), this._init(U || 0, b || 10, _ || "be"))
        }
        typeof r == "object" ? r.exports = n : e.BN = n, n.BN = n, n.wordSize = 26;
        var s;
        try {
          typeof window != "undefined" && typeof window.Buffer != "undefined" ? s = window.Buffer : s = QM().Buffer
        } catch (U) { }
        n.isBN = function (b) {
          return b instanceof n ? !0 : b !== null && typeof b == "object" && b.constructor.wordSize === n.wordSize && Array.isArray(b.words)
        }, n.max = function (b, _) {
          return b.cmp(_) > 0 ? b : _
        }, n.min = function (b, _) {
          return b.cmp(_) < 0 ? b : _
        }, n.prototype._init = function (b, _, R) {
          if (typeof b == "number") return this._initNumber(b, _, R);
          if (typeof b == "object") return this._initArray(b, _, R);
          _ === "hex" && (_ = 16), t(_ === (_ | 0) && _ >= 2 && _ <= 36), b = b.toString().replace(/\s+/g, "");
          var D = 0;
          b[0] === "-" && (D++, this.negative = 1), D < b.length && (_ === 16 ? this._parseHex(b, D, R) : (this._parseBase(b, _, D), R === "le" && this._initArray(this.toArray(), _, R)))
        }, n.prototype._initNumber = function (b, _, R) {
          b < 0 && (this.negative = 1, b = -b), b < 67108864 ? (this.words = [b & 67108863], this.length = 1) : b < 4503599627370496 ? (this.words = [b & 67108863, b / 67108864 & 67108863], this.length = 2) : (t(b < 9007199254740992), this.words = [b & 67108863, b / 67108864 & 67108863, 1], this.length = 3), R === "le" && this._initArray(this.toArray(), _, R)
        }, n.prototype._initArray = function (b, _, R) {
          if (t(typeof b.length == "number"), b.length <= 0) return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(b.length / 3), this.words = new Array(this.length);
          for (var D = 0; D < this.length; D++) this.words[D] = 0;
          var K, ee, re = 0;
          if (R === "be")
            for (D = b.length - 1, K = 0; D >= 0; D -= 3) ee = b[D] | b[D - 1] << 8 | b[D - 2] << 16, this.words[K] |= ee << re & 67108863, this.words[K + 1] = ee >>> 26 - re & 67108863, re += 24, re >= 26 && (re -= 26, K++);
          else if (R === "le")
            for (D = 0, K = 0; D < b.length; D += 3) ee = b[D] | b[D + 1] << 8 | b[D + 2] << 16, this.words[K] |= ee << re & 67108863, this.words[K + 1] = ee >>> 26 - re & 67108863, re += 24, re >= 26 && (re -= 26, K++);
          return this.strip()
        };

        function o(U, b) {
          var _ = U.charCodeAt(b);
          return _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : _ - 48 & 15
        }

        function a(U, b, _) {
          var R = o(U, _);
          return _ - 1 >= b && (R |= o(U, _ - 1) << 4), R
        }
        n.prototype._parseHex = function (b, _, R) {
          this.length = Math.ceil((b.length - _) / 6), this.words = new Array(this.length);
          for (var D = 0; D < this.length; D++) this.words[D] = 0;
          var K = 0,
            ee = 0,
            re;
          if (R === "be")
            for (D = b.length - 1; D >= _; D -= 2) re = a(b, _, D) << K, this.words[ee] |= re & 67108863, K >= 18 ? (K -= 18, ee += 1, this.words[ee] |= re >>> 26) : K += 8;
          else {
            var V = b.length - _;
            for (D = V % 2 == 0 ? _ + 1 : _; D < b.length; D += 2) re = a(b, _, D) << K, this.words[ee] |= re & 67108863, K >= 18 ? (K -= 18, ee += 1, this.words[ee] |= re >>> 26) : K += 8
          }
          this.strip()
        };

        function c(U, b, _, R) {
          for (var D = 0, K = Math.min(U.length, _), ee = b; ee < K; ee++) {
            var re = U.charCodeAt(ee) - 48;
            D *= R, re >= 49 ? D += re - 49 + 10 : re >= 17 ? D += re - 17 + 10 : D += re
          }
          return D
        }
        n.prototype._parseBase = function (b, _, R) {
          this.words = [0], this.length = 1;
          for (var D = 0, K = 1; K <= 67108863; K *= _) D++;
          D--, K = K / _ | 0;
          for (var ee = b.length - R, re = ee % D, V = Math.min(ee, ee - re) + R, v = 0, Y = R; Y < V; Y += D) v = c(b, Y, Y + D, _), this.imuln(K), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
          if (re !== 0) {
            var Se = 1;
            for (v = c(b, Y, b.length, _), Y = 0; Y < re; Y++) Se *= _;
            this.imuln(Se), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v)
          }
          this.strip()
        }, n.prototype.copy = function (b) {
          b.words = new Array(this.length);
          for (var _ = 0; _ < this.length; _++) b.words[_] = this.words[_];
          b.length = this.length, b.negative = this.negative, b.red = this.red
        }, n.prototype.clone = function () {
          var b = new n(null);
          return this.copy(b), b
        }, n.prototype._expand = function (b) {
          for (; this.length < b;) this.words[this.length++] = 0;
          return this
        }, n.prototype.strip = function () {
          for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
          return this._normSign()
        }, n.prototype._normSign = function () {
          return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        }, n.prototype.inspect = function () {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        };
        var u = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
          f = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
          h = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        n.prototype.toString = function (b, _) {
          b = b || 10, _ = _ | 0 || 1;
          var R;
          if (b === 16 || b === "hex") {
            R = "";
            for (var D = 0, K = 0, ee = 0; ee < this.length; ee++) {
              var re = this.words[ee],
                V = ((re << D | K) & 16777215).toString(16);
              K = re >>> 24 - D & 16777215, K !== 0 || ee !== this.length - 1 ? R = u[6 - V.length] + V + R : R = V + R, D += 2, D >= 26 && (D -= 26, ee--)
            }
            for (K !== 0 && (R = K.toString(16) + R); R.length % _ != 0;) R = "0" + R;
            return this.negative !== 0 && (R = "-" + R), R
          }
          if (b === (b | 0) && b >= 2 && b <= 36) {
            var v = f[b],
              Y = h[b];
            R = "";
            var Se = this.clone();
            for (Se.negative = 0; !Se.isZero();) {
              var Q = Se.modn(Y).toString(b);
              Se = Se.idivn(Y), Se.isZero() ? R = Q + R : R = u[v - Q.length] + Q + R
            }
            for (this.isZero() && (R = "0" + R); R.length % _ != 0;) R = "0" + R;
            return this.negative !== 0 && (R = "-" + R), R
          }
          t(!1, "Base should be between 2 and 36")
        }, n.prototype.toNumber = function () {
          var b = this.words[0];
          return this.length === 2 ? b += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? b += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && t(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -b : b
        }, n.prototype.toJSON = function () {
          return this.toString(16)
        }, n.prototype.toBuffer = function (b, _) {
          return t(typeof s != "undefined"), this.toArrayLike(s, b, _)
        }, n.prototype.toArray = function (b, _) {
          return this.toArrayLike(Array, b, _)
        }, n.prototype.toArrayLike = function (b, _, R) {
          var D = this.byteLength(),
            K = R || Math.max(1, D);
          t(D <= K, "byte array longer than desired length"), t(K > 0, "Requested array length <= 0"), this.strip();
          var ee = _ === "le",
            re = new b(K),
            V, v, Y = this.clone();
          if (ee) {
            for (v = 0; !Y.isZero(); v++) V = Y.andln(255), Y.iushrn(8), re[v] = V;
            for (; v < K; v++) re[v] = 0
          } else {
            for (v = 0; v < K - D; v++) re[v] = 0;
            for (v = 0; !Y.isZero(); v++) V = Y.andln(255), Y.iushrn(8), re[K - v - 1] = V
          }
          return re
        }, Math.clz32 ? n.prototype._countBits = function (b) {
          return 32 - Math.clz32(b)
        } : n.prototype._countBits = function (b) {
          var _ = b,
            R = 0;
          return _ >= 4096 && (R += 13, _ >>>= 13), _ >= 64 && (R += 7, _ >>>= 7), _ >= 8 && (R += 4, _ >>>= 4), _ >= 2 && (R += 2, _ >>>= 2), R + _
        }, n.prototype._zeroBits = function (b) {
          if (b === 0) return 26;
          var _ = b,
            R = 0;
          return (_ & 8191) == 0 && (R += 13, _ >>>= 13), (_ & 127) == 0 && (R += 7, _ >>>= 7), (_ & 15) == 0 && (R += 4, _ >>>= 4), (_ & 3) == 0 && (R += 2, _ >>>= 2), (_ & 1) == 0 && R++, R
        }, n.prototype.bitLength = function () {
          var b = this.words[this.length - 1],
            _ = this._countBits(b);
          return (this.length - 1) * 26 + _
        };

        function d(U) {
          for (var b = new Array(U.bitLength()), _ = 0; _ < b.length; _++) {
            var R = _ / 26 | 0,
              D = _ % 26;
            b[_] = (U.words[R] & 1 << D) >>> D
          }
          return b
        }
        n.prototype.zeroBits = function () {
          if (this.isZero()) return 0;
          for (var b = 0, _ = 0; _ < this.length; _++) {
            var R = this._zeroBits(this.words[_]);
            if (b += R, R !== 26) break
          }
          return b
        }, n.prototype.byteLength = function () {
          return Math.ceil(this.bitLength() / 8)
        }, n.prototype.toTwos = function (b) {
          return this.negative !== 0 ? this.abs().inotn(b).iaddn(1) : this.clone()
        }, n.prototype.fromTwos = function (b) {
          return this.testn(b - 1) ? this.notn(b).iaddn(1).ineg() : this.clone()
        }, n.prototype.isNeg = function () {
          return this.negative !== 0
        }, n.prototype.neg = function () {
          return this.clone().ineg()
        }, n.prototype.ineg = function () {
          return this.isZero() || (this.negative ^= 1), this
        }, n.prototype.iuor = function (b) {
          for (; this.length < b.length;) this.words[this.length++] = 0;
          for (var _ = 0; _ < b.length; _++) this.words[_] = this.words[_] | b.words[_];
          return this.strip()
        }, n.prototype.ior = function (b) {
          return t((this.negative | b.negative) == 0), this.iuor(b)
        }, n.prototype.or = function (b) {
          return this.length > b.length ? this.clone().ior(b) : b.clone().ior(this)
        }, n.prototype.uor = function (b) {
          return this.length > b.length ? this.clone().iuor(b) : b.clone().iuor(this)
        }, n.prototype.iuand = function (b) {
          var _;
          this.length > b.length ? _ = b : _ = this;
          for (var R = 0; R < _.length; R++) this.words[R] = this.words[R] & b.words[R];
          return this.length = _.length, this.strip()
        }, n.prototype.iand = function (b) {
          return t((this.negative | b.negative) == 0), this.iuand(b)
        }, n.prototype.and = function (b) {
          return this.length > b.length ? this.clone().iand(b) : b.clone().iand(this)
        }, n.prototype.uand = function (b) {
          return this.length > b.length ? this.clone().iuand(b) : b.clone().iuand(this)
        }, n.prototype.iuxor = function (b) {
          var _, R;
          this.length > b.length ? (_ = this, R = b) : (_ = b, R = this);
          for (var D = 0; D < R.length; D++) this.words[D] = _.words[D] ^ R.words[D];
          if (this !== _)
            for (; D < _.length; D++) this.words[D] = _.words[D];
          return this.length = _.length, this.strip()
        }, n.prototype.ixor = function (b) {
          return t((this.negative | b.negative) == 0), this.iuxor(b)
        }, n.prototype.xor = function (b) {
          return this.length > b.length ? this.clone().ixor(b) : b.clone().ixor(this)
        }, n.prototype.uxor = function (b) {
          return this.length > b.length ? this.clone().iuxor(b) : b.clone().iuxor(this)
        }, n.prototype.inotn = function (b) {
          t(typeof b == "number" && b >= 0);
          var _ = Math.ceil(b / 26) | 0,
            R = b % 26;
          this._expand(_), R > 0 && _--;
          for (var D = 0; D < _; D++) this.words[D] = ~this.words[D] & 67108863;
          return R > 0 && (this.words[D] = ~this.words[D] & 67108863 >> 26 - R), this.strip()
        }, n.prototype.notn = function (b) {
          return this.clone().inotn(b)
        }, n.prototype.setn = function (b, _) {
          t(typeof b == "number" && b >= 0);
          var R = b / 26 | 0,
            D = b % 26;
          return this._expand(R + 1), _ ? this.words[R] = this.words[R] | 1 << D : this.words[R] = this.words[R] & ~(1 << D), this.strip()
        }, n.prototype.iadd = function (b) {
          var _;
          if (this.negative !== 0 && b.negative === 0) return this.negative = 0, _ = this.isub(b), this.negative ^= 1, this._normSign();
          if (this.negative === 0 && b.negative !== 0) return b.negative = 0, _ = this.isub(b), b.negative = 1, _._normSign();
          var R, D;
          this.length > b.length ? (R = this, D = b) : (R = b, D = this);
          for (var K = 0, ee = 0; ee < D.length; ee++) _ = (R.words[ee] | 0) + (D.words[ee] | 0) + K, this.words[ee] = _ & 67108863, K = _ >>> 26;
          for (; K !== 0 && ee < R.length; ee++) _ = (R.words[ee] | 0) + K, this.words[ee] = _ & 67108863, K = _ >>> 26;
          if (this.length = R.length, K !== 0) this.words[this.length] = K, this.length++;
          else if (R !== this)
            for (; ee < R.length; ee++) this.words[ee] = R.words[ee];
          return this
        }, n.prototype.add = function (b) {
          var _;
          return b.negative !== 0 && this.negative === 0 ? (b.negative = 0, _ = this.sub(b), b.negative ^= 1, _) : b.negative === 0 && this.negative !== 0 ? (this.negative = 0, _ = b.sub(this), this.negative = 1, _) : this.length > b.length ? this.clone().iadd(b) : b.clone().iadd(this)
        }, n.prototype.isub = function (b) {
          if (b.negative !== 0) {
            b.negative = 0;
            var _ = this.iadd(b);
            return b.negative = 1, _._normSign()
          } else if (this.negative !== 0) return this.negative = 0, this.iadd(b), this.negative = 1, this._normSign();
          var R = this.cmp(b);
          if (R === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          var D, K;
          R > 0 ? (D = this, K = b) : (D = b, K = this);
          for (var ee = 0, re = 0; re < K.length; re++) _ = (D.words[re] | 0) - (K.words[re] | 0) + ee, ee = _ >> 26, this.words[re] = _ & 67108863;
          for (; ee !== 0 && re < D.length; re++) _ = (D.words[re] | 0) + ee, ee = _ >> 26, this.words[re] = _ & 67108863;
          if (ee === 0 && re < D.length && D !== this)
            for (; re < D.length; re++) this.words[re] = D.words[re];
          return this.length = Math.max(this.length, re), D !== this && (this.negative = 1), this.strip()
        }, n.prototype.sub = function (b) {
          return this.clone().isub(b)
        };

        function p(U, b, _) {
          _.negative = b.negative ^ U.negative;
          var R = U.length + b.length | 0;
          _.length = R, R = R - 1 | 0;
          var D = U.words[0] | 0,
            K = b.words[0] | 0,
            ee = D * K,
            re = ee & 67108863,
            V = ee / 67108864 | 0;
          _.words[0] = re;
          for (var v = 1; v < R; v++) {
            for (var Y = V >>> 26, Se = V & 67108863, Q = Math.min(v, b.length - 1), ve = Math.max(0, v - U.length + 1); ve <= Q; ve++) {
              var x = v - ve | 0;
              D = U.words[x] | 0, K = b.words[ve] | 0, ee = D * K + Se, Y += ee / 67108864 | 0, Se = ee & 67108863
            }
            _.words[v] = Se | 0, V = Y | 0
          }
          return V !== 0 ? _.words[v] = V | 0 : _.length--, _.strip()
        }
        var g = function (b, _, R) {
          var D = b.words,
            K = _.words,
            ee = R.words,
            re = 0,
            V, v, Y, Se = D[0] | 0,
            Q = Se & 8191,
            ve = Se >>> 13,
            x = D[1] | 0,
            I = x & 8191,
            le = x >>> 13,
            he = D[2] | 0,
            S = he & 8191,
            T = he >>> 13,
            j = D[3] | 0,
            G = j & 8191,
            k = j >>> 13,
            F = D[4] | 0,
            B = F & 8191,
            L = F >>> 13,
            $ = D[5] | 0,
            ie = $ & 8191,
            ne = $ >>> 13,
            pe = D[6] | 0,
            be = pe & 8191,
            de = pe >>> 13,
            Ne = D[7] | 0,
            Re = Ne & 8191,
            $e = Ne >>> 13,
            Ke = D[8] | 0,
            Me = Ke & 8191,
            Ie = Ke >>> 13,
            tt = D[9] | 0,
            nt = tt & 8191,
            Ge = tt >>> 13,
            se = K[0] | 0,
            A = se & 8191,
            X = se >>> 13,
            Kt = K[1] | 0,
            st = Kt & 8191,
            Nt = Kt >>> 13,
            on = K[2] | 0,
            qt = on & 8191,
            De = on >>> 13,
            an = K[3] | 0,
            Mt = an & 8191,
            Bt = an >>> 13,
            cn = K[4] | 0,
            Dt = cn & 8191,
            yt = cn >>> 13,
            Bn = K[5] | 0,
            Ht = Bn & 8191,
            Gt = Bn >>> 13,
            Dn = K[6] | 0,
            et = Dn & 8191,
            $t = Dn >>> 13,
            Ln = K[7] | 0,
            dr = Ln & 8191,
            nr = Ln >>> 13,
            Ss = K[8] | 0,
            sr = Ss & 8191,
            or = Ss >>> 13,
            ut = K[9] | 0,
            ar = ut & 8191,
            Lt = ut >>> 13;
          R.negative = b.negative ^ _.negative, R.length = 19, V = Math.imul(Q, A), v = Math.imul(Q, X), v = v + Math.imul(ve, A) | 0, Y = Math.imul(ve, X);
          var Fn = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (Fn >>> 26) | 0, Fn &= 67108863, V = Math.imul(I, A), v = Math.imul(I, X), v = v + Math.imul(le, A) | 0, Y = Math.imul(le, X), V = V + Math.imul(Q, st) | 0, v = v + Math.imul(Q, Nt) | 0, v = v + Math.imul(ve, st) | 0, Y = Y + Math.imul(ve, Nt) | 0;
          var ns = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (ns >>> 26) | 0, ns &= 67108863, V = Math.imul(S, A), v = Math.imul(S, X), v = v + Math.imul(T, A) | 0, Y = Math.imul(T, X), V = V + Math.imul(I, st) | 0, v = v + Math.imul(I, Nt) | 0, v = v + Math.imul(le, st) | 0, Y = Y + Math.imul(le, Nt) | 0, V = V + Math.imul(Q, qt) | 0, v = v + Math.imul(Q, De) | 0, v = v + Math.imul(ve, qt) | 0, Y = Y + Math.imul(ve, De) | 0;
          var ss = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (ss >>> 26) | 0, ss &= 67108863, V = Math.imul(G, A), v = Math.imul(G, X), v = v + Math.imul(k, A) | 0, Y = Math.imul(k, X), V = V + Math.imul(S, st) | 0, v = v + Math.imul(S, Nt) | 0, v = v + Math.imul(T, st) | 0, Y = Y + Math.imul(T, Nt) | 0, V = V + Math.imul(I, qt) | 0, v = v + Math.imul(I, De) | 0, v = v + Math.imul(le, qt) | 0, Y = Y + Math.imul(le, De) | 0, V = V + Math.imul(Q, Mt) | 0, v = v + Math.imul(Q, Bt) | 0, v = v + Math.imul(ve, Mt) | 0, Y = Y + Math.imul(ve, Bt) | 0;
          var os = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (os >>> 26) | 0, os &= 67108863, V = Math.imul(B, A), v = Math.imul(B, X), v = v + Math.imul(L, A) | 0, Y = Math.imul(L, X), V = V + Math.imul(G, st) | 0, v = v + Math.imul(G, Nt) | 0, v = v + Math.imul(k, st) | 0, Y = Y + Math.imul(k, Nt) | 0, V = V + Math.imul(S, qt) | 0, v = v + Math.imul(S, De) | 0, v = v + Math.imul(T, qt) | 0, Y = Y + Math.imul(T, De) | 0, V = V + Math.imul(I, Mt) | 0, v = v + Math.imul(I, Bt) | 0, v = v + Math.imul(le, Mt) | 0, Y = Y + Math.imul(le, Bt) | 0, V = V + Math.imul(Q, Dt) | 0, v = v + Math.imul(Q, yt) | 0, v = v + Math.imul(ve, Dt) | 0, Y = Y + Math.imul(ve, yt) | 0;
          var as = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (as >>> 26) | 0, as &= 67108863, V = Math.imul(ie, A), v = Math.imul(ie, X), v = v + Math.imul(ne, A) | 0, Y = Math.imul(ne, X), V = V + Math.imul(B, st) | 0, v = v + Math.imul(B, Nt) | 0, v = v + Math.imul(L, st) | 0, Y = Y + Math.imul(L, Nt) | 0, V = V + Math.imul(G, qt) | 0, v = v + Math.imul(G, De) | 0, v = v + Math.imul(k, qt) | 0, Y = Y + Math.imul(k, De) | 0, V = V + Math.imul(S, Mt) | 0, v = v + Math.imul(S, Bt) | 0, v = v + Math.imul(T, Mt) | 0, Y = Y + Math.imul(T, Bt) | 0, V = V + Math.imul(I, Dt) | 0, v = v + Math.imul(I, yt) | 0, v = v + Math.imul(le, Dt) | 0, Y = Y + Math.imul(le, yt) | 0, V = V + Math.imul(Q, Ht) | 0, v = v + Math.imul(Q, Gt) | 0, v = v + Math.imul(ve, Ht) | 0, Y = Y + Math.imul(ve, Gt) | 0;
          var cs = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (cs >>> 26) | 0, cs &= 67108863, V = Math.imul(be, A), v = Math.imul(be, X), v = v + Math.imul(de, A) | 0, Y = Math.imul(de, X), V = V + Math.imul(ie, st) | 0, v = v + Math.imul(ie, Nt) | 0, v = v + Math.imul(ne, st) | 0, Y = Y + Math.imul(ne, Nt) | 0, V = V + Math.imul(B, qt) | 0, v = v + Math.imul(B, De) | 0, v = v + Math.imul(L, qt) | 0, Y = Y + Math.imul(L, De) | 0, V = V + Math.imul(G, Mt) | 0, v = v + Math.imul(G, Bt) | 0, v = v + Math.imul(k, Mt) | 0, Y = Y + Math.imul(k, Bt) | 0, V = V + Math.imul(S, Dt) | 0, v = v + Math.imul(S, yt) | 0, v = v + Math.imul(T, Dt) | 0, Y = Y + Math.imul(T, yt) | 0, V = V + Math.imul(I, Ht) | 0, v = v + Math.imul(I, Gt) | 0, v = v + Math.imul(le, Ht) | 0, Y = Y + Math.imul(le, Gt) | 0, V = V + Math.imul(Q, et) | 0, v = v + Math.imul(Q, $t) | 0, v = v + Math.imul(ve, et) | 0, Y = Y + Math.imul(ve, $t) | 0;
          var Ze = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, V = Math.imul(Re, A), v = Math.imul(Re, X), v = v + Math.imul($e, A) | 0, Y = Math.imul($e, X), V = V + Math.imul(be, st) | 0, v = v + Math.imul(be, Nt) | 0, v = v + Math.imul(de, st) | 0, Y = Y + Math.imul(de, Nt) | 0, V = V + Math.imul(ie, qt) | 0, v = v + Math.imul(ie, De) | 0, v = v + Math.imul(ne, qt) | 0, Y = Y + Math.imul(ne, De) | 0, V = V + Math.imul(B, Mt) | 0, v = v + Math.imul(B, Bt) | 0, v = v + Math.imul(L, Mt) | 0, Y = Y + Math.imul(L, Bt) | 0, V = V + Math.imul(G, Dt) | 0, v = v + Math.imul(G, yt) | 0, v = v + Math.imul(k, Dt) | 0, Y = Y + Math.imul(k, yt) | 0, V = V + Math.imul(S, Ht) | 0, v = v + Math.imul(S, Gt) | 0, v = v + Math.imul(T, Ht) | 0, Y = Y + Math.imul(T, Gt) | 0, V = V + Math.imul(I, et) | 0, v = v + Math.imul(I, $t) | 0, v = v + Math.imul(le, et) | 0, Y = Y + Math.imul(le, $t) | 0, V = V + Math.imul(Q, dr) | 0, v = v + Math.imul(Q, nr) | 0, v = v + Math.imul(ve, dr) | 0, Y = Y + Math.imul(ve, nr) | 0;
          var us = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (us >>> 26) | 0, us &= 67108863, V = Math.imul(Me, A), v = Math.imul(Me, X), v = v + Math.imul(Ie, A) | 0, Y = Math.imul(Ie, X), V = V + Math.imul(Re, st) | 0, v = v + Math.imul(Re, Nt) | 0, v = v + Math.imul($e, st) | 0, Y = Y + Math.imul($e, Nt) | 0, V = V + Math.imul(be, qt) | 0, v = v + Math.imul(be, De) | 0, v = v + Math.imul(de, qt) | 0, Y = Y + Math.imul(de, De) | 0, V = V + Math.imul(ie, Mt) | 0, v = v + Math.imul(ie, Bt) | 0, v = v + Math.imul(ne, Mt) | 0, Y = Y + Math.imul(ne, Bt) | 0, V = V + Math.imul(B, Dt) | 0, v = v + Math.imul(B, yt) | 0, v = v + Math.imul(L, Dt) | 0, Y = Y + Math.imul(L, yt) | 0, V = V + Math.imul(G, Ht) | 0, v = v + Math.imul(G, Gt) | 0, v = v + Math.imul(k, Ht) | 0, Y = Y + Math.imul(k, Gt) | 0, V = V + Math.imul(S, et) | 0, v = v + Math.imul(S, $t) | 0, v = v + Math.imul(T, et) | 0, Y = Y + Math.imul(T, $t) | 0, V = V + Math.imul(I, dr) | 0, v = v + Math.imul(I, nr) | 0, v = v + Math.imul(le, dr) | 0, Y = Y + Math.imul(le, nr) | 0, V = V + Math.imul(Q, sr) | 0, v = v + Math.imul(Q, or) | 0, v = v + Math.imul(ve, sr) | 0, Y = Y + Math.imul(ve, or) | 0;
          var kc = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (kc >>> 26) | 0, kc &= 67108863, V = Math.imul(nt, A), v = Math.imul(nt, X), v = v + Math.imul(Ge, A) | 0, Y = Math.imul(Ge, X), V = V + Math.imul(Me, st) | 0, v = v + Math.imul(Me, Nt) | 0, v = v + Math.imul(Ie, st) | 0, Y = Y + Math.imul(Ie, Nt) | 0, V = V + Math.imul(Re, qt) | 0, v = v + Math.imul(Re, De) | 0, v = v + Math.imul($e, qt) | 0, Y = Y + Math.imul($e, De) | 0, V = V + Math.imul(be, Mt) | 0, v = v + Math.imul(be, Bt) | 0, v = v + Math.imul(de, Mt) | 0, Y = Y + Math.imul(de, Bt) | 0, V = V + Math.imul(ie, Dt) | 0, v = v + Math.imul(ie, yt) | 0, v = v + Math.imul(ne, Dt) | 0, Y = Y + Math.imul(ne, yt) | 0, V = V + Math.imul(B, Ht) | 0, v = v + Math.imul(B, Gt) | 0, v = v + Math.imul(L, Ht) | 0, Y = Y + Math.imul(L, Gt) | 0, V = V + Math.imul(G, et) | 0, v = v + Math.imul(G, $t) | 0, v = v + Math.imul(k, et) | 0, Y = Y + Math.imul(k, $t) | 0, V = V + Math.imul(S, dr) | 0, v = v + Math.imul(S, nr) | 0, v = v + Math.imul(T, dr) | 0, Y = Y + Math.imul(T, nr) | 0, V = V + Math.imul(I, sr) | 0, v = v + Math.imul(I, or) | 0, v = v + Math.imul(le, sr) | 0, Y = Y + Math.imul(le, or) | 0, V = V + Math.imul(Q, ar) | 0, v = v + Math.imul(Q, Lt) | 0, v = v + Math.imul(ve, ar) | 0, Y = Y + Math.imul(ve, Lt) | 0;
          var P = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (P >>> 26) | 0, P &= 67108863, V = Math.imul(nt, st), v = Math.imul(nt, Nt), v = v + Math.imul(Ge, st) | 0, Y = Math.imul(Ge, Nt), V = V + Math.imul(Me, qt) | 0, v = v + Math.imul(Me, De) | 0, v = v + Math.imul(Ie, qt) | 0, Y = Y + Math.imul(Ie, De) | 0, V = V + Math.imul(Re, Mt) | 0, v = v + Math.imul(Re, Bt) | 0, v = v + Math.imul($e, Mt) | 0, Y = Y + Math.imul($e, Bt) | 0, V = V + Math.imul(be, Dt) | 0, v = v + Math.imul(be, yt) | 0, v = v + Math.imul(de, Dt) | 0, Y = Y + Math.imul(de, yt) | 0, V = V + Math.imul(ie, Ht) | 0, v = v + Math.imul(ie, Gt) | 0, v = v + Math.imul(ne, Ht) | 0, Y = Y + Math.imul(ne, Gt) | 0, V = V + Math.imul(B, et) | 0, v = v + Math.imul(B, $t) | 0, v = v + Math.imul(L, et) | 0, Y = Y + Math.imul(L, $t) | 0, V = V + Math.imul(G, dr) | 0, v = v + Math.imul(G, nr) | 0, v = v + Math.imul(k, dr) | 0, Y = Y + Math.imul(k, nr) | 0, V = V + Math.imul(S, sr) | 0, v = v + Math.imul(S, or) | 0, v = v + Math.imul(T, sr) | 0, Y = Y + Math.imul(T, or) | 0, V = V + Math.imul(I, ar) | 0, v = v + Math.imul(I, Lt) | 0, v = v + Math.imul(le, ar) | 0, Y = Y + Math.imul(le, Lt) | 0;
          var Ve = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, V = Math.imul(nt, qt), v = Math.imul(nt, De), v = v + Math.imul(Ge, qt) | 0, Y = Math.imul(Ge, De), V = V + Math.imul(Me, Mt) | 0, v = v + Math.imul(Me, Bt) | 0, v = v + Math.imul(Ie, Mt) | 0, Y = Y + Math.imul(Ie, Bt) | 0, V = V + Math.imul(Re, Dt) | 0, v = v + Math.imul(Re, yt) | 0, v = v + Math.imul($e, Dt) | 0, Y = Y + Math.imul($e, yt) | 0, V = V + Math.imul(be, Ht) | 0, v = v + Math.imul(be, Gt) | 0, v = v + Math.imul(de, Ht) | 0, Y = Y + Math.imul(de, Gt) | 0, V = V + Math.imul(ie, et) | 0, v = v + Math.imul(ie, $t) | 0, v = v + Math.imul(ne, et) | 0, Y = Y + Math.imul(ne, $t) | 0, V = V + Math.imul(B, dr) | 0, v = v + Math.imul(B, nr) | 0, v = v + Math.imul(L, dr) | 0, Y = Y + Math.imul(L, nr) | 0, V = V + Math.imul(G, sr) | 0, v = v + Math.imul(G, or) | 0, v = v + Math.imul(k, sr) | 0, Y = Y + Math.imul(k, or) | 0, V = V + Math.imul(S, ar) | 0, v = v + Math.imul(S, Lt) | 0, v = v + Math.imul(T, ar) | 0, Y = Y + Math.imul(T, Lt) | 0;
          var We = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, V = Math.imul(nt, Mt), v = Math.imul(nt, Bt), v = v + Math.imul(Ge, Mt) | 0, Y = Math.imul(Ge, Bt), V = V + Math.imul(Me, Dt) | 0, v = v + Math.imul(Me, yt) | 0, v = v + Math.imul(Ie, Dt) | 0, Y = Y + Math.imul(Ie, yt) | 0, V = V + Math.imul(Re, Ht) | 0, v = v + Math.imul(Re, Gt) | 0, v = v + Math.imul($e, Ht) | 0, Y = Y + Math.imul($e, Gt) | 0, V = V + Math.imul(be, et) | 0, v = v + Math.imul(be, $t) | 0, v = v + Math.imul(de, et) | 0, Y = Y + Math.imul(de, $t) | 0, V = V + Math.imul(ie, dr) | 0, v = v + Math.imul(ie, nr) | 0, v = v + Math.imul(ne, dr) | 0, Y = Y + Math.imul(ne, nr) | 0, V = V + Math.imul(B, sr) | 0, v = v + Math.imul(B, or) | 0, v = v + Math.imul(L, sr) | 0, Y = Y + Math.imul(L, or) | 0, V = V + Math.imul(G, ar) | 0, v = v + Math.imul(G, Lt) | 0, v = v + Math.imul(k, ar) | 0, Y = Y + Math.imul(k, Lt) | 0;
          var Fe = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, V = Math.imul(nt, Dt), v = Math.imul(nt, yt), v = v + Math.imul(Ge, Dt) | 0, Y = Math.imul(Ge, yt), V = V + Math.imul(Me, Ht) | 0, v = v + Math.imul(Me, Gt) | 0, v = v + Math.imul(Ie, Ht) | 0, Y = Y + Math.imul(Ie, Gt) | 0, V = V + Math.imul(Re, et) | 0, v = v + Math.imul(Re, $t) | 0, v = v + Math.imul($e, et) | 0, Y = Y + Math.imul($e, $t) | 0, V = V + Math.imul(be, dr) | 0, v = v + Math.imul(be, nr) | 0, v = v + Math.imul(de, dr) | 0, Y = Y + Math.imul(de, nr) | 0, V = V + Math.imul(ie, sr) | 0, v = v + Math.imul(ie, or) | 0, v = v + Math.imul(ne, sr) | 0, Y = Y + Math.imul(ne, or) | 0, V = V + Math.imul(B, ar) | 0, v = v + Math.imul(B, Lt) | 0, v = v + Math.imul(L, ar) | 0, Y = Y + Math.imul(L, Lt) | 0;
          var Un = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (Un >>> 26) | 0, Un &= 67108863, V = Math.imul(nt, Ht), v = Math.imul(nt, Gt), v = v + Math.imul(Ge, Ht) | 0, Y = Math.imul(Ge, Gt), V = V + Math.imul(Me, et) | 0, v = v + Math.imul(Me, $t) | 0, v = v + Math.imul(Ie, et) | 0, Y = Y + Math.imul(Ie, $t) | 0, V = V + Math.imul(Re, dr) | 0, v = v + Math.imul(Re, nr) | 0, v = v + Math.imul($e, dr) | 0, Y = Y + Math.imul($e, nr) | 0, V = V + Math.imul(be, sr) | 0, v = v + Math.imul(be, or) | 0, v = v + Math.imul(de, sr) | 0, Y = Y + Math.imul(de, or) | 0, V = V + Math.imul(ie, ar) | 0, v = v + Math.imul(ie, Lt) | 0, v = v + Math.imul(ne, ar) | 0, Y = Y + Math.imul(ne, Lt) | 0;
          var un = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, V = Math.imul(nt, et), v = Math.imul(nt, $t), v = v + Math.imul(Ge, et) | 0, Y = Math.imul(Ge, $t), V = V + Math.imul(Me, dr) | 0, v = v + Math.imul(Me, nr) | 0, v = v + Math.imul(Ie, dr) | 0, Y = Y + Math.imul(Ie, nr) | 0, V = V + Math.imul(Re, sr) | 0, v = v + Math.imul(Re, or) | 0, v = v + Math.imul($e, sr) | 0, Y = Y + Math.imul($e, or) | 0, V = V + Math.imul(be, ar) | 0, v = v + Math.imul(be, Lt) | 0, v = v + Math.imul(de, ar) | 0, Y = Y + Math.imul(de, Lt) | 0;
          var Yf = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (Yf >>> 26) | 0, Yf &= 67108863, V = Math.imul(nt, dr), v = Math.imul(nt, nr), v = v + Math.imul(Ge, dr) | 0, Y = Math.imul(Ge, nr), V = V + Math.imul(Me, sr) | 0, v = v + Math.imul(Me, or) | 0, v = v + Math.imul(Ie, sr) | 0, Y = Y + Math.imul(Ie, or) | 0, V = V + Math.imul(Re, ar) | 0, v = v + Math.imul(Re, Lt) | 0, v = v + Math.imul($e, ar) | 0, Y = Y + Math.imul($e, Lt) | 0;
          var Si = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (Si >>> 26) | 0, Si &= 67108863, V = Math.imul(nt, sr), v = Math.imul(nt, or), v = v + Math.imul(Ge, sr) | 0, Y = Math.imul(Ge, or), V = V + Math.imul(Me, ar) | 0, v = v + Math.imul(Me, Lt) | 0, v = v + Math.imul(Ie, ar) | 0, Y = Y + Math.imul(Ie, Lt) | 0;
          var E1 = (re + V | 0) + ((v & 8191) << 13) | 0;
          re = (Y + (v >>> 13) | 0) + (E1 >>> 26) | 0, E1 &= 67108863, V = Math.imul(nt, ar), v = Math.imul(nt, Lt), v = v + Math.imul(Ge, ar) | 0, Y = Math.imul(Ge, Lt);
          var S1 = (re + V | 0) + ((v & 8191) << 13) | 0;
          return re = (Y + (v >>> 13) | 0) + (S1 >>> 26) | 0, S1 &= 67108863, ee[0] = Fn, ee[1] = ns, ee[2] = ss, ee[3] = os, ee[4] = as, ee[5] = cs, ee[6] = Ze, ee[7] = us, ee[8] = kc, ee[9] = P, ee[10] = Ve, ee[11] = We, ee[12] = Fe, ee[13] = Un, ee[14] = un, ee[15] = Yf, ee[16] = Si, ee[17] = E1, ee[18] = S1, re !== 0 && (ee[19] = re, R.length++), R
        };
        Math.imul || (g = p);

        function m(U, b, _) {
          _.negative = b.negative ^ U.negative, _.length = U.length + b.length;
          for (var R = 0, D = 0, K = 0; K < _.length - 1; K++) {
            var ee = D;
            D = 0;
            for (var re = R & 67108863, V = Math.min(K, b.length - 1), v = Math.max(0, K - U.length + 1); v <= V; v++) {
              var Y = K - v,
                Se = U.words[Y] | 0,
                Q = b.words[v] | 0,
                ve = Se * Q,
                x = ve & 67108863;
              ee = ee + (ve / 67108864 | 0) | 0, x = x + re | 0, re = x & 67108863, ee = ee + (x >>> 26) | 0, D += ee >>> 26, ee &= 67108863
            }
            _.words[K] = re, R = ee, ee = D
          }
          return R !== 0 ? _.words[K] = R : _.length--, _.strip()
        }

        function E(U, b, _) {
          var R = new w;
          return R.mulp(U, b, _)
        }
        n.prototype.mulTo = function (b, _) {
          var R, D = this.length + b.length;
          return this.length === 10 && b.length === 10 ? R = g(this, b, _) : D < 63 ? R = p(this, b, _) : D < 1024 ? R = m(this, b, _) : R = E(this, b, _), R
        };

        function w(U, b) {
          this.x = U, this.y = b
        }
        w.prototype.makeRBT = function (b) {
          for (var _ = new Array(b), R = n.prototype._countBits(b) - 1, D = 0; D < b; D++) _[D] = this.revBin(D, R, b);
          return _
        }, w.prototype.revBin = function (b, _, R) {
          if (b === 0 || b === R - 1) return b;
          for (var D = 0, K = 0; K < _; K++) D |= (b & 1) << _ - K - 1, b >>= 1;
          return D
        }, w.prototype.permute = function (b, _, R, D, K, ee) {
          for (var re = 0; re < ee; re++) D[re] = _[b[re]], K[re] = R[b[re]]
        }, w.prototype.transform = function (b, _, R, D, K, ee) {
          this.permute(ee, b, _, R, D, K);
          for (var re = 1; re < K; re <<= 1)
            for (var V = re << 1, v = Math.cos(2 * Math.PI / V), Y = Math.sin(2 * Math.PI / V), Se = 0; Se < K; Se += V)
              for (var Q = v, ve = Y, x = 0; x < re; x++) {
                var I = R[Se + x],
                  le = D[Se + x],
                  he = R[Se + x + re],
                  S = D[Se + x + re],
                  T = Q * he - ve * S;
                S = Q * S + ve * he, he = T, R[Se + x] = I + he, D[Se + x] = le + S, R[Se + x + re] = I - he, D[Se + x + re] = le - S, x !== V && (T = v * Q - Y * ve, ve = v * ve + Y * Q, Q = T)
              }
        }, w.prototype.guessLen13b = function (b, _) {
          var R = Math.max(_, b) | 1,
            D = R & 1,
            K = 0;
          for (R = R / 2 | 0; R; R = R >>> 1) K++;
          return 1 << K + 1 + D
        }, w.prototype.conjugate = function (b, _, R) {
          if (!(R <= 1))
            for (var D = 0; D < R / 2; D++) {
              var K = b[D];
              b[D] = b[R - D - 1], b[R - D - 1] = K, K = _[D], _[D] = -_[R - D - 1], _[R - D - 1] = -K
            }
        }, w.prototype.normalize13b = function (b, _) {
          for (var R = 0, D = 0; D < _ / 2; D++) {
            var K = Math.round(b[2 * D + 1] / _) * 8192 + Math.round(b[2 * D] / _) + R;
            b[D] = K & 67108863, K < 67108864 ? R = 0 : R = K / 67108864 | 0
          }
          return b
        }, w.prototype.convert13b = function (b, _, R, D) {
          for (var K = 0, ee = 0; ee < _; ee++) K = K + (b[ee] | 0), R[2 * ee] = K & 8191, K = K >>> 13, R[2 * ee + 1] = K & 8191, K = K >>> 13;
          for (ee = 2 * _; ee < D; ++ee) R[ee] = 0;
          t(K === 0), t((K & ~8191) == 0)
        }, w.prototype.stub = function (b) {
          for (var _ = new Array(b), R = 0; R < b; R++) _[R] = 0;
          return _
        }, w.prototype.mulp = function (b, _, R) {
          var D = 2 * this.guessLen13b(b.length, _.length),
            K = this.makeRBT(D),
            ee = this.stub(D),
            re = new Array(D),
            V = new Array(D),
            v = new Array(D),
            Y = new Array(D),
            Se = new Array(D),
            Q = new Array(D),
            ve = R.words;
          ve.length = D, this.convert13b(b.words, b.length, re, D), this.convert13b(_.words, _.length, Y, D), this.transform(re, ee, V, v, D, K), this.transform(Y, ee, Se, Q, D, K);
          for (var x = 0; x < D; x++) {
            var I = V[x] * Se[x] - v[x] * Q[x];
            v[x] = V[x] * Q[x] + v[x] * Se[x], V[x] = I
          }
          return this.conjugate(V, v, D), this.transform(V, v, ve, ee, D, K), this.conjugate(ve, ee, D), this.normalize13b(ve, D), R.negative = b.negative ^ _.negative, R.length = b.length + _.length, R.strip()
        }, n.prototype.mul = function (b) {
          var _ = new n(null);
          return _.words = new Array(this.length + b.length), this.mulTo(b, _)
        }, n.prototype.mulf = function (b) {
          var _ = new n(null);
          return _.words = new Array(this.length + b.length), E(this, b, _)
        }, n.prototype.imul = function (b) {
          return this.clone().mulTo(b, this)
        }, n.prototype.imuln = function (b) {
          t(typeof b == "number"), t(b < 67108864);
          for (var _ = 0, R = 0; R < this.length; R++) {
            var D = (this.words[R] | 0) * b,
              K = (D & 67108863) + (_ & 67108863);
            _ >>= 26, _ += D / 67108864 | 0, _ += K >>> 26, this.words[R] = K & 67108863
          }
          return _ !== 0 && (this.words[R] = _, this.length++), this
        }, n.prototype.muln = function (b) {
          return this.clone().imuln(b)
        }, n.prototype.sqr = function () {
          return this.mul(this)
        }, n.prototype.isqr = function () {
          return this.imul(this.clone())
        }, n.prototype.pow = function (b) {
          var _ = d(b);
          if (_.length === 0) return new n(1);
          for (var R = this, D = 0; D < _.length && _[D] === 0; D++, R = R.sqr());
          if (++D < _.length)
            for (var K = R.sqr(); D < _.length; D++, K = K.sqr()) _[D] !== 0 && (R = R.mul(K));
          return R
        }, n.prototype.iushln = function (b) {
          t(typeof b == "number" && b >= 0);
          var _ = b % 26,
            R = (b - _) / 26,
            D = 67108863 >>> 26 - _ << 26 - _,
            K;
          if (_ !== 0) {
            var ee = 0;
            for (K = 0; K < this.length; K++) {
              var re = this.words[K] & D,
                V = (this.words[K] | 0) - re << _;
              this.words[K] = V | ee, ee = re >>> 26 - _
            }
            ee && (this.words[K] = ee, this.length++)
          }
          if (R !== 0) {
            for (K = this.length - 1; K >= 0; K--) this.words[K + R] = this.words[K];
            for (K = 0; K < R; K++) this.words[K] = 0;
            this.length += R
          }
          return this.strip()
        }, n.prototype.ishln = function (b) {
          return t(this.negative === 0), this.iushln(b)
        }, n.prototype.iushrn = function (b, _, R) {
          t(typeof b == "number" && b >= 0);
          var D;
          _ ? D = (_ - _ % 26) / 26 : D = 0;
          var K = b % 26,
            ee = Math.min((b - K) / 26, this.length),
            re = 67108863 ^ 67108863 >>> K << K,
            V = R;
          if (D -= ee, D = Math.max(0, D), V) {
            for (var v = 0; v < ee; v++) V.words[v] = this.words[v];
            V.length = ee
          }
          if (ee !== 0)
            if (this.length > ee)
              for (this.length -= ee, v = 0; v < this.length; v++) this.words[v] = this.words[v + ee];
            else this.words[0] = 0, this.length = 1;
          var Y = 0;
          for (v = this.length - 1; v >= 0 && (Y !== 0 || v >= D); v--) {
            var Se = this.words[v] | 0;
            this.words[v] = Y << 26 - K | Se >>> K, Y = Se & re
          }
          return V && Y !== 0 && (V.words[V.length++] = Y), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip()
        }, n.prototype.ishrn = function (b, _, R) {
          return t(this.negative === 0), this.iushrn(b, _, R)
        }, n.prototype.shln = function (b) {
          return this.clone().ishln(b)
        }, n.prototype.ushln = function (b) {
          return this.clone().iushln(b)
        }, n.prototype.shrn = function (b) {
          return this.clone().ishrn(b)
        }, n.prototype.ushrn = function (b) {
          return this.clone().iushrn(b)
        }, n.prototype.testn = function (b) {
          t(typeof b == "number" && b >= 0);
          var _ = b % 26,
            R = (b - _) / 26,
            D = 1 << _;
          if (this.length <= R) return !1;
          var K = this.words[R];
          return !!(K & D)
        }, n.prototype.imaskn = function (b) {
          t(typeof b == "number" && b >= 0);
          var _ = b % 26,
            R = (b - _) / 26;
          if (t(this.negative === 0, "imaskn works only with positive numbers"), this.length <= R) return this;
          if (_ !== 0 && R++, this.length = Math.min(R, this.length), _ !== 0) {
            var D = 67108863 ^ 67108863 >>> _ << _;
            this.words[this.length - 1] &= D
          }
          return this.strip()
        }, n.prototype.maskn = function (b) {
          return this.clone().imaskn(b)
        }, n.prototype.iaddn = function (b) {
          return t(typeof b == "number"), t(b < 67108864), b < 0 ? this.isubn(-b) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < b ? (this.words[0] = b - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(b), this.negative = 1, this) : this._iaddn(b)
        }, n.prototype._iaddn = function (b) {
          this.words[0] += b;
          for (var _ = 0; _ < this.length && this.words[_] >= 67108864; _++) this.words[_] -= 67108864, _ === this.length - 1 ? this.words[_ + 1] = 1 : this.words[_ + 1]++;
          return this.length = Math.max(this.length, _ + 1), this
        }, n.prototype.isubn = function (b) {
          if (t(typeof b == "number"), t(b < 67108864), b < 0) return this.iaddn(-b);
          if (this.negative !== 0) return this.negative = 0, this.iaddn(b), this.negative = 1, this;
          if (this.words[0] -= b, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var _ = 0; _ < this.length && this.words[_] < 0; _++) this.words[_] += 67108864, this.words[_ + 1] -= 1;
          return this.strip()
        }, n.prototype.addn = function (b) {
          return this.clone().iaddn(b)
        }, n.prototype.subn = function (b) {
          return this.clone().isubn(b)
        }, n.prototype.iabs = function () {
          return this.negative = 0, this
        }, n.prototype.abs = function () {
          return this.clone().iabs()
        }, n.prototype._ishlnsubmul = function (b, _, R) {
          var D = b.length + R,
            K;
          this._expand(D);
          var ee, re = 0;
          for (K = 0; K < b.length; K++) {
            ee = (this.words[K + R] | 0) + re;
            var V = (b.words[K] | 0) * _;
            ee -= V & 67108863, re = (ee >> 26) - (V / 67108864 | 0), this.words[K + R] = ee & 67108863
          }
          for (; K < this.length - R; K++) ee = (this.words[K + R] | 0) + re, re = ee >> 26, this.words[K + R] = ee & 67108863;
          if (re === 0) return this.strip();
          for (t(re === -1), re = 0, K = 0; K < this.length; K++) ee = -(this.words[K] | 0) + re, re = ee >> 26, this.words[K] = ee & 67108863;
          return this.negative = 1, this.strip()
        }, n.prototype._wordDiv = function (b, _) {
          var R = this.length - b.length,
            D = this.clone(),
            K = b,
            ee = K.words[K.length - 1] | 0,
            re = this._countBits(ee);
          R = 26 - re, R !== 0 && (K = K.ushln(R), D.iushln(R), ee = K.words[K.length - 1] | 0);
          var V = D.length - K.length,
            v;
          if (_ !== "mod") {
            v = new n(null), v.length = V + 1, v.words = new Array(v.length);
            for (var Y = 0; Y < v.length; Y++) v.words[Y] = 0
          }
          var Se = D.clone()._ishlnsubmul(K, 1, V);
          Se.negative === 0 && (D = Se, v && (v.words[V] = 1));
          for (var Q = V - 1; Q >= 0; Q--) {
            var ve = (D.words[K.length + Q] | 0) * 67108864 + (D.words[K.length + Q - 1] | 0);
            for (ve = Math.min(ve / ee | 0, 67108863), D._ishlnsubmul(K, ve, Q); D.negative !== 0;) ve--, D.negative = 0, D._ishlnsubmul(K, 1, Q), D.isZero() || (D.negative ^= 1);
            v && (v.words[Q] = ve)
          }
          return v && v.strip(), D.strip(), _ !== "div" && R !== 0 && D.iushrn(R), {
            div: v || null,
            mod: D
          }
        }, n.prototype.divmod = function (b, _, R) {
          if (t(!b.isZero()), this.isZero()) return {
            div: new n(0),
            mod: new n(0)
          };
          var D, K, ee;
          return this.negative !== 0 && b.negative === 0 ? (ee = this.neg().divmod(b, _), _ !== "mod" && (D = ee.div.neg()), _ !== "div" && (K = ee.mod.neg(), R && K.negative !== 0 && K.iadd(b)), {
            div: D,
            mod: K
          }) : this.negative === 0 && b.negative !== 0 ? (ee = this.divmod(b.neg(), _), _ !== "mod" && (D = ee.div.neg()), {
            div: D,
            mod: ee.mod
          }) : (this.negative & b.negative) != 0 ? (ee = this.neg().divmod(b.neg(), _), _ !== "div" && (K = ee.mod.neg(), R && K.negative !== 0 && K.isub(b)), {
            div: ee.div,
            mod: K
          }) : b.length > this.length || this.cmp(b) < 0 ? {
            div: new n(0),
            mod: this
          } : b.length === 1 ? _ === "div" ? {
            div: this.divn(b.words[0]),
            mod: null
          } : _ === "mod" ? {
            div: null,
            mod: new n(this.modn(b.words[0]))
          } : {
            div: this.divn(b.words[0]),
            mod: new n(this.modn(b.words[0]))
          } : this._wordDiv(b, _)
        }, n.prototype.div = function (b) {
          return this.divmod(b, "div", !1).div
        }, n.prototype.mod = function (b) {
          return this.divmod(b, "mod", !1).mod
        }, n.prototype.umod = function (b) {
          return this.divmod(b, "mod", !0).mod
        }, n.prototype.divRound = function (b) {
          var _ = this.divmod(b);
          if (_.mod.isZero()) return _.div;
          var R = _.div.negative !== 0 ? _.mod.isub(b) : _.mod,
            D = b.ushrn(1),
            K = b.andln(1),
            ee = R.cmp(D);
          return ee < 0 || K === 1 && ee === 0 ? _.div : _.div.negative !== 0 ? _.div.isubn(1) : _.div.iaddn(1)
        }, n.prototype.modn = function (b) {
          t(b <= 67108863);
          for (var _ = (1 << 26) % b, R = 0, D = this.length - 1; D >= 0; D--) R = (_ * R + (this.words[D] | 0)) % b;
          return R
        }, n.prototype.idivn = function (b) {
          t(b <= 67108863);
          for (var _ = 0, R = this.length - 1; R >= 0; R--) {
            var D = (this.words[R] | 0) + _ * 67108864;
            this.words[R] = D / b | 0, _ = D % b
          }
          return this.strip()
        }, n.prototype.divn = function (b) {
          return this.clone().idivn(b)
        }, n.prototype.egcd = function (b) {
          t(b.negative === 0), t(!b.isZero());
          var _ = this,
            R = b.clone();
          _.negative !== 0 ? _ = _.umod(b) : _ = _.clone();
          for (var D = new n(1), K = new n(0), ee = new n(0), re = new n(1), V = 0; _.isEven() && R.isEven();) _.iushrn(1), R.iushrn(1), ++V;
          for (var v = R.clone(), Y = _.clone(); !_.isZero();) {
            for (var Se = 0, Q = 1;
              (_.words[0] & Q) == 0 && Se < 26; ++Se, Q <<= 1);
            if (Se > 0)
              for (_.iushrn(Se); Se-- > 0;)(D.isOdd() || K.isOdd()) && (D.iadd(v), K.isub(Y)), D.iushrn(1), K.iushrn(1);
            for (var ve = 0, x = 1;
              (R.words[0] & x) == 0 && ve < 26; ++ve, x <<= 1);
            if (ve > 0)
              for (R.iushrn(ve); ve-- > 0;)(ee.isOdd() || re.isOdd()) && (ee.iadd(v), re.isub(Y)), ee.iushrn(1), re.iushrn(1);
            _.cmp(R) >= 0 ? (_.isub(R), D.isub(ee), K.isub(re)) : (R.isub(_), ee.isub(D), re.isub(K))
          }
          return {
            a: ee,
            b: re,
            gcd: R.iushln(V)
          }
        }, n.prototype._invmp = function (b) {
          t(b.negative === 0), t(!b.isZero());
          var _ = this,
            R = b.clone();
          _.negative !== 0 ? _ = _.umod(b) : _ = _.clone();
          for (var D = new n(1), K = new n(0), ee = R.clone(); _.cmpn(1) > 0 && R.cmpn(1) > 0;) {
            for (var re = 0, V = 1;
              (_.words[0] & V) == 0 && re < 26; ++re, V <<= 1);
            if (re > 0)
              for (_.iushrn(re); re-- > 0;) D.isOdd() && D.iadd(ee), D.iushrn(1);
            for (var v = 0, Y = 1;
              (R.words[0] & Y) == 0 && v < 26; ++v, Y <<= 1);
            if (v > 0)
              for (R.iushrn(v); v-- > 0;) K.isOdd() && K.iadd(ee), K.iushrn(1);
            _.cmp(R) >= 0 ? (_.isub(R), D.isub(K)) : (R.isub(_), K.isub(D))
          }
          var Se;
          return _.cmpn(1) === 0 ? Se = D : Se = K, Se.cmpn(0) < 0 && Se.iadd(b), Se
        }, n.prototype.gcd = function (b) {
          if (this.isZero()) return b.abs();
          if (b.isZero()) return this.abs();
          var _ = this.clone(),
            R = b.clone();
          _.negative = 0, R.negative = 0;
          for (var D = 0; _.isEven() && R.isEven(); D++) _.iushrn(1), R.iushrn(1);
          do {
            for (; _.isEven();) _.iushrn(1);
            for (; R.isEven();) R.iushrn(1);
            var K = _.cmp(R);
            if (K < 0) {
              var ee = _;
              _ = R, R = ee
            } else if (K === 0 || R.cmpn(1) === 0) break;
            _.isub(R)
          } while (!0);
          return R.iushln(D)
        }, n.prototype.invm = function (b) {
          return this.egcd(b).a.umod(b)
        }, n.prototype.isEven = function () {
          return (this.words[0] & 1) == 0
        }, n.prototype.isOdd = function () {
          return (this.words[0] & 1) == 1
        }, n.prototype.andln = function (b) {
          return this.words[0] & b
        }, n.prototype.bincn = function (b) {
          t(typeof b == "number");
          var _ = b % 26,
            R = (b - _) / 26,
            D = 1 << _;
          if (this.length <= R) return this._expand(R + 1), this.words[R] |= D, this;
          for (var K = D, ee = R; K !== 0 && ee < this.length; ee++) {
            var re = this.words[ee] | 0;
            re += K, K = re >>> 26, re &= 67108863, this.words[ee] = re
          }
          return K !== 0 && (this.words[ee] = K, this.length++), this
        }, n.prototype.isZero = function () {
          return this.length === 1 && this.words[0] === 0
        }, n.prototype.cmpn = function (b) {
          var _ = b < 0;
          if (this.negative !== 0 && !_) return -1;
          if (this.negative === 0 && _) return 1;
          this.strip();
          var R;
          if (this.length > 1) R = 1;
          else {
            _ && (b = -b), t(b <= 67108863, "Number is too big");
            var D = this.words[0] | 0;
            R = D === b ? 0 : D < b ? -1 : 1
          }
          return this.negative !== 0 ? -R | 0 : R
        }, n.prototype.cmp = function (b) {
          if (this.negative !== 0 && b.negative === 0) return -1;
          if (this.negative === 0 && b.negative !== 0) return 1;
          var _ = this.ucmp(b);
          return this.negative !== 0 ? -_ | 0 : _
        }, n.prototype.ucmp = function (b) {
          if (this.length > b.length) return 1;
          if (this.length < b.length) return -1;
          for (var _ = 0, R = this.length - 1; R >= 0; R--) {
            var D = this.words[R] | 0,
              K = b.words[R] | 0;
            if (D !== K) {
              D < K ? _ = -1 : D > K && (_ = 1);
              break
            }
          }
          return _
        }, n.prototype.gtn = function (b) {
          return this.cmpn(b) === 1
        }, n.prototype.gt = function (b) {
          return this.cmp(b) === 1
        }, n.prototype.gten = function (b) {
          return this.cmpn(b) >= 0
        }, n.prototype.gte = function (b) {
          return this.cmp(b) >= 0
        }, n.prototype.ltn = function (b) {
          return this.cmpn(b) === -1
        }, n.prototype.lt = function (b) {
          return this.cmp(b) === -1
        }, n.prototype.lten = function (b) {
          return this.cmpn(b) <= 0
        }, n.prototype.lte = function (b) {
          return this.cmp(b) <= 0
        }, n.prototype.eqn = function (b) {
          return this.cmpn(b) === 0
        }, n.prototype.eq = function (b) {
          return this.cmp(b) === 0
        }, n.red = function (b) {
          return new ae(b)
        }, n.prototype.toRed = function (b) {
          return t(!this.red, "Already a number in reduction context"), t(this.negative === 0, "red works only with positives"), b.convertTo(this)._forceRed(b)
        }, n.prototype.fromRed = function () {
          return t(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, n.prototype._forceRed = function (b) {
          return this.red = b, this
        }, n.prototype.forceRed = function (b) {
          return t(!this.red, "Already a number in reduction context"), this._forceRed(b)
        }, n.prototype.redAdd = function (b) {
          return t(this.red, "redAdd works only with red numbers"), this.red.add(this, b)
        }, n.prototype.redIAdd = function (b) {
          return t(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, b)
        }, n.prototype.redSub = function (b) {
          return t(this.red, "redSub works only with red numbers"), this.red.sub(this, b)
        }, n.prototype.redISub = function (b) {
          return t(this.red, "redISub works only with red numbers"), this.red.isub(this, b)
        }, n.prototype.redShl = function (b) {
          return t(this.red, "redShl works only with red numbers"), this.red.shl(this, b)
        }, n.prototype.redMul = function (b) {
          return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.mul(this, b)
        }, n.prototype.redIMul = function (b) {
          return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.imul(this, b)
        }, n.prototype.redSqr = function () {
          return t(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, n.prototype.redISqr = function () {
          return t(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, n.prototype.redSqrt = function () {
          return t(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, n.prototype.redInvm = function () {
          return t(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, n.prototype.redNeg = function () {
          return t(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, n.prototype.redPow = function (b) {
          return t(this.red && !b.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, b)
        };
        var O = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };

        function q(U, b) {
          this.name = U, this.p = new n(b, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }
        q.prototype._tmp = function () {
          var b = new n(null);
          return b.words = new Array(Math.ceil(this.n / 13)), b
        }, q.prototype.ireduce = function (b) {
          var _ = b,
            R;
          do this.split(_, this.tmp), _ = this.imulK(_), _ = _.iadd(this.tmp), R = _.bitLength(); while (R > this.n);
          var D = R < this.n ? -1 : _.ucmp(this.p);
          return D === 0 ? (_.words[0] = 0, _.length = 1) : D > 0 ? _.isub(this.p) : _.strip !== void 0 ? _.strip() : _._strip(), _
        }, q.prototype.split = function (b, _) {
          b.iushrn(this.n, 0, _)
        }, q.prototype.imulK = function (b) {
          return b.imul(this.k)
        };

        function J() {
          q.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(J, q), J.prototype.split = function (b, _) {
          for (var R = 4194303, D = Math.min(b.length, 9), K = 0; K < D; K++) _.words[K] = b.words[K];
          if (_.length = D, b.length <= 9) {
            b.words[0] = 0, b.length = 1;
            return
          }
          var ee = b.words[9];
          for (_.words[_.length++] = ee & R, K = 10; K < b.length; K++) {
            var re = b.words[K] | 0;
            b.words[K - 10] = (re & R) << 4 | ee >>> 22, ee = re
          }
          ee >>>= 22, b.words[K - 10] = ee, ee === 0 && b.length > 10 ? b.length -= 10 : b.length -= 9
        }, J.prototype.imulK = function (b) {
          b.words[b.length] = 0, b.words[b.length + 1] = 0, b.length += 2;
          for (var _ = 0, R = 0; R < b.length; R++) {
            var D = b.words[R] | 0;
            _ += D * 977, b.words[R] = _ & 67108863, _ = D * 64 + (_ / 67108864 | 0)
          }
          return b.words[b.length - 1] === 0 && (b.length--, b.words[b.length - 1] === 0 && b.length--), b
        };

        function Z() {
          q.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(Z, q);

        function H() {
          q.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(H, q);

        function te() {
          q.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(te, q), te.prototype.imulK = function (b) {
          for (var _ = 0, R = 0; R < b.length; R++) {
            var D = (b.words[R] | 0) * 19 + _,
              K = D & 67108863;
            D >>>= 26, b.words[R] = K, _ = D
          }
          return _ !== 0 && (b.words[b.length++] = _), b
        }, n._prime = function (b) {
          if (O[b]) return O[b];
          var _;
          if (b === "k256") _ = new J;
          else if (b === "p224") _ = new Z;
          else if (b === "p192") _ = new H;
          else if (b === "p25519") _ = new te;
          else throw new Error("Unknown prime " + b);
          return O[b] = _, _
        };

        function ae(U) {
          if (typeof U == "string") {
            var b = n._prime(U);
            this.m = b.p, this.prime = b
          } else t(U.gtn(1), "modulus must be greater than 1"), this.m = U, this.prime = null
        }
        ae.prototype._verify1 = function (b) {
          t(b.negative === 0, "red works only with positives"), t(b.red, "red works only with red numbers")
        }, ae.prototype._verify2 = function (b, _) {
          t((b.negative | _.negative) == 0, "red works only with positives"), t(b.red && b.red === _.red, "red works only with red numbers")
        }, ae.prototype.imod = function (b) {
          return this.prime ? this.prime.ireduce(b)._forceRed(this) : b.umod(this.m)._forceRed(this)
        }, ae.prototype.neg = function (b) {
          return b.isZero() ? b.clone() : this.m.sub(b)._forceRed(this)
        }, ae.prototype.add = function (b, _) {
          this._verify2(b, _);
          var R = b.add(_);
          return R.cmp(this.m) >= 0 && R.isub(this.m), R._forceRed(this)
        }, ae.prototype.iadd = function (b, _) {
          this._verify2(b, _);
          var R = b.iadd(_);
          return R.cmp(this.m) >= 0 && R.isub(this.m), R
        }, ae.prototype.sub = function (b, _) {
          this._verify2(b, _);
          var R = b.sub(_);
          return R.cmpn(0) < 0 && R.iadd(this.m), R._forceRed(this)
        }, ae.prototype.isub = function (b, _) {
          this._verify2(b, _);
          var R = b.isub(_);
          return R.cmpn(0) < 0 && R.iadd(this.m), R
        }, ae.prototype.shl = function (b, _) {
          return this._verify1(b), this.imod(b.ushln(_))
        }, ae.prototype.imul = function (b, _) {
          return this._verify2(b, _), this.imod(b.imul(_))
        }, ae.prototype.mul = function (b, _) {
          return this._verify2(b, _), this.imod(b.mul(_))
        }, ae.prototype.isqr = function (b) {
          return this.imul(b, b.clone())
        }, ae.prototype.sqr = function (b) {
          return this.mul(b, b)
        }, ae.prototype.sqrt = function (b) {
          if (b.isZero()) return b.clone();
          var _ = this.m.andln(3);
          if (t(_ % 2 == 1), _ === 3) {
            var R = this.m.add(new n(1)).iushrn(2);
            return this.pow(b, R)
          }
          for (var D = this.m.subn(1), K = 0; !D.isZero() && D.andln(1) === 0;) K++, D.iushrn(1);
          t(!D.isZero());
          var ee = new n(1).toRed(this),
            re = ee.redNeg(),
            V = this.m.subn(1).iushrn(1),
            v = this.m.bitLength();
          for (v = new n(2 * v * v).toRed(this); this.pow(v, V).cmp(re) !== 0;) v.redIAdd(re);
          for (var Y = this.pow(v, D), Se = this.pow(b, D.addn(1).iushrn(1)), Q = this.pow(b, D), ve = K; Q.cmp(ee) !== 0;) {
            for (var x = Q, I = 0; x.cmp(ee) !== 0; I++) x = x.redSqr();
            t(I < ve);
            var le = this.pow(Y, new n(1).iushln(ve - I - 1));
            Se = Se.redMul(le), Y = le.redSqr(), Q = Q.redMul(Y), ve = I
          }
          return Se
        }, ae.prototype.invm = function (b) {
          var _ = b._invmp(this.m);
          return _.negative !== 0 ? (_.negative = 0, this.imod(_).redNeg()) : this.imod(_)
        }, ae.prototype.pow = function (b, _) {
          if (_.isZero()) return new n(1).toRed(this);
          if (_.cmpn(1) === 0) return b.clone();
          var R = 4,
            D = new Array(1 << R);
          D[0] = new n(1).toRed(this), D[1] = b;
          for (var K = 2; K < D.length; K++) D[K] = this.mul(D[K - 1], b);
          var ee = D[0],
            re = 0,
            V = 0,
            v = _.bitLength() % 26;
          for (v === 0 && (v = 26), K = _.length - 1; K >= 0; K--) {
            for (var Y = _.words[K], Se = v - 1; Se >= 0; Se--) {
              var Q = Y >> Se & 1;
              if (ee !== D[0] && (ee = this.sqr(ee)), Q === 0 && re === 0) {
                V = 0;
                continue
              }
              re <<= 1, re |= Q, V++, !(V !== R && (K !== 0 || Se !== 0)) && (ee = this.mul(ee, D[re]), V = 0, re = 0)
            }
            v = 26
          }
          return ee
        }, ae.prototype.convertTo = function (b) {
          var _ = b.umod(this.m);
          return _ === b ? _.clone() : _
        }, ae.prototype.convertFrom = function (b) {
          var _ = b.clone();
          return _.red = null, _
        }, n.mont = function (b) {
          return new oe(b)
        };

        function oe(U) {
          ae.call(this, U), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }
        i(oe, ae), oe.prototype.convertTo = function (b) {
          return this.imod(b.ushln(this.shift))
        }, oe.prototype.convertFrom = function (b) {
          var _ = this.imod(b.mul(this.rinv));
          return _.red = null, _
        }, oe.prototype.imul = function (b, _) {
          if (b.isZero() || _.isZero()) return b.words[0] = 0, b.length = 1, b;
          var R = b.imul(_),
            D = R.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
            K = R.isub(D).iushrn(this.shift),
            ee = K;
          return K.cmp(this.m) >= 0 ? ee = K.isub(this.m) : K.cmpn(0) < 0 && (ee = K.iadd(this.m)), ee._forceRed(this)
        }, oe.prototype.mul = function (b, _) {
          if (b.isZero() || _.isZero()) return new n(0)._forceRed(this);
          var R = b.mul(_),
            D = R.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
            K = R.isub(D).iushrn(this.shift),
            ee = K;
          return K.cmp(this.m) >= 0 ? ee = K.isub(this.m) : K.cmpn(0) < 0 && (ee = K.iadd(this.m)), ee._forceRed(this)
        }, oe.prototype.invm = function (b) {
          var _ = this.imod(b._invmp(this.m).mul(this.r2));
          return _._forceRed(this)
        }
      })(typeof mS == "undefined" || mS, eB)
    });
    var Vu = y((Hbt, tB) => {
      l();
      tB.exports = rB;

      function rB(r, e) {
        if (!r) throw new Error(e || "Assertion failed")
      }
      rB.equal = function (e, t, i) {
        if (e != t) throw new Error(i || "Assertion failed: " + e + " != " + t)
      }
    });
    var vS = y(iB => {
      l();
      "use strict";
      var x2 = iB;

      function sIe(r, e) {
        if (Array.isArray(r)) return r.slice();
        if (!r) return [];
        var t = [];
        if (typeof r != "string") {
          for (var i = 0; i < r.length; i++) t[i] = r[i] | 0;
          return t
        }
        if (e === "hex") {
          r = r.replace(/[^a-z0-9]+/ig, ""), r.length % 2 != 0 && (r = "0" + r);
          for (var i = 0; i < r.length; i += 2) t.push(parseInt(r[i] + r[i + 1], 16))
        } else
          for (var i = 0; i < r.length; i++) {
            var n = r.charCodeAt(i),
              s = n >> 8,
              o = n & 255;
            s ? t.push(s, o) : t.push(o)
          }
        return t
      }
      x2.toArray = sIe;

      function nB(r) {
        return r.length === 1 ? "0" + r : r
      }
      x2.zero2 = nB;

      function sB(r) {
        for (var e = "", t = 0; t < r.length; t++) e += nB(r[t].toString(16));
        return e
      }
      x2.toHex = sB;
      x2.encode = function (e, t) {
        return t === "hex" ? sB(e) : e
      }
    });
    var Is = y(oB => {
      l();
      "use strict";
      var jo = oB,
        oIe = La(),
        aIe = Vu(),
        A2 = vS();
      jo.assert = aIe;
      jo.toArray = A2.toArray;
      jo.zero2 = A2.zero2;
      jo.toHex = A2.toHex;
      jo.encode = A2.encode;

      function cIe(r, e, t) {
        var i = new Array(Math.max(r.bitLength(), t) + 1);
        i.fill(0);
        for (var n = 1 << e + 1, s = r.clone(), o = 0; o < i.length; o++) {
          var a, c = s.andln(n - 1);
          s.isOdd() ? (c > (n >> 1) - 1 ? a = (n >> 1) - c : a = c, s.isubn(a)) : a = 0, i[o] = a, s.iushrn(1)
        }
        return i
      }
      jo.getNAF = cIe;

      function uIe(r, e) {
        var t = [
          [],
          []
        ];
        r = r.clone(), e = e.clone();
        for (var i = 0, n = 0, s; r.cmpn(-i) > 0 || e.cmpn(-n) > 0;) {
          var o = r.andln(3) + i & 3,
            a = e.andln(3) + n & 3;
          o === 3 && (o = -1), a === 3 && (a = -1);
          var c;
          (o & 1) == 0 ? c = 0 : (s = r.andln(7) + i & 7, (s === 3 || s === 5) && a === 2 ? c = -o : c = o), t[0].push(c);
          var u;
          (a & 1) == 0 ? u = 0 : (s = e.andln(7) + n & 7, (s === 3 || s === 5) && o === 2 ? u = -a : u = a), t[1].push(u), 2 * i === c + 1 && (i = 1 - i), 2 * n === u + 1 && (n = 1 - n), r.iushrn(1), e.iushrn(1)
        }
        return t
      }
      jo.getJSF = uIe;

      function fIe(r, e, t) {
        var i = "_" + e;
        r.prototype[e] = function () {
          return this[i] !== void 0 ? this[i] : this[i] = t.call(this)
        }
      }
      jo.cachedProperty = fIe;

      function lIe(r) {
        return typeof r == "string" ? jo.toArray(r, "hex") : r
      }
      jo.parseBytes = lIe;

      function hIe(r) {
        return new oIe(r, "hex", "le")
      }
      jo.intFromLE = hIe
    });
    var SS = y((Wbt, wS) => {
      l();
      var _S;
      wS.exports = function (e) {
        return _S || (_S = new Hu(null)), _S.generate(e)
      };

      function Hu(r) {
        this.rand = r
      }
      wS.exports.Rand = Hu;
      Hu.prototype.generate = function (e) {
        return this._rand(e)
      };
      Hu.prototype._rand = function (e) {
        if (this.rand.getBytes) return this.rand.getBytes(e);
        for (var t = new Uint8Array(e), i = 0; i < t.length; i++) t[i] = this.rand.getByte();
        return t
      };
      if (typeof self == "object") self.crypto && self.crypto.getRandomValues ? Hu.prototype._rand = function (e) {
        var t = new Uint8Array(e);
        return self.crypto.getRandomValues(t), t
      } : self.msCrypto && self.msCrypto.getRandomValues ? Hu.prototype._rand = function (e) {
        var t = new Uint8Array(e);
        return self.msCrypto.getRandomValues(t), t
      } : typeof window == "object" && (Hu.prototype._rand = function () {
        throw new Error("Not implemented yet")
      });
      else try {
        if (ES = L1(), typeof ES.randomBytes != "function") throw new Error("Not supported");
        Hu.prototype._rand = function (e) {
          return ES.randomBytes(e)
        }
      } catch (r) { }
      var ES
    });
    var J1 = y((Ybt, aB) => {
      l();
      "use strict";
      var hl = La(),
        Y1 = Is(),
        I2 = Y1.getNAF,
        dIe = Y1.getJSF,
        T2 = Y1.assert;

      function Gu(r, e) {
        this.type = r, this.p = new hl(e.p, 16), this.red = e.prime ? hl.red(e.prime) : hl.mont(this.p), this.zero = new hl(0).toRed(this.red), this.one = new hl(1).toRed(this.red), this.two = new hl(2).toRed(this.red), this.n = e.n && new hl(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
        var t = this.n && this.p.div(this.n);
        !t || t.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
      }
      aB.exports = Gu;
      Gu.prototype.point = function () {
        throw new Error("Not implemented")
      };
      Gu.prototype.validate = function () {
        throw new Error("Not implemented")
      };
      Gu.prototype._fixedNafMul = function (e, t) {
        T2(e.precomputed);
        var i = e._getDoubles(),
          n = I2(t, 1, this._bitLength),
          s = (1 << i.step + 1) - (i.step % 2 == 0 ? 2 : 1);
        s /= 3;
        var o = [],
          a, c;
        for (a = 0; a < n.length; a += i.step) {
          c = 0;
          for (var u = a + i.step - 1; u >= a; u--) c = (c << 1) + n[u];
          o.push(c)
        }
        for (var f = this.jpoint(null, null, null), h = this.jpoint(null, null, null), d = s; d > 0; d--) {
          for (a = 0; a < o.length; a++) c = o[a], c === d ? h = h.mixedAdd(i.points[a]) : c === -d && (h = h.mixedAdd(i.points[a].neg()));
          f = f.add(h)
        }
        return f.toP()
      };
      Gu.prototype._wnafMul = function (e, t) {
        var i = 4,
          n = e._getNAFPoints(i);
        i = n.wnd;
        for (var s = n.points, o = I2(t, i, this._bitLength), a = this.jpoint(null, null, null), c = o.length - 1; c >= 0; c--) {
          for (var u = 0; c >= 0 && o[c] === 0; c--) u++;
          if (c >= 0 && u++, a = a.dblp(u), c < 0) break;
          var f = o[c];
          T2(f !== 0), e.type === "affine" ? f > 0 ? a = a.mixedAdd(s[f - 1 >> 1]) : a = a.mixedAdd(s[-f - 1 >> 1].neg()) : f > 0 ? a = a.add(s[f - 1 >> 1]) : a = a.add(s[-f - 1 >> 1].neg())
        }
        return e.type === "affine" ? a.toP() : a
      };
      Gu.prototype._wnafMulAdd = function (e, t, i, n, s) {
        var o = this._wnafT1,
          a = this._wnafT2,
          c = this._wnafT3,
          u = 0,
          f, h, d;
        for (f = 0; f < n; f++) {
          d = t[f];
          var p = d._getNAFPoints(e);
          o[f] = p.wnd, a[f] = p.points
        }
        for (f = n - 1; f >= 1; f -= 2) {
          var g = f - 1,
            m = f;
          if (o[g] !== 1 || o[m] !== 1) {
            c[g] = I2(i[g], o[g], this._bitLength), c[m] = I2(i[m], o[m], this._bitLength), u = Math.max(c[g].length, u), u = Math.max(c[m].length, u);
            continue
          }
          var E = [t[g], null, null, t[m]];
          t[g].y.cmp(t[m].y) === 0 ? (E[1] = t[g].add(t[m]), E[2] = t[g].toJ().mixedAdd(t[m].neg())) : t[g].y.cmp(t[m].y.redNeg()) === 0 ? (E[1] = t[g].toJ().mixedAdd(t[m]), E[2] = t[g].add(t[m].neg())) : (E[1] = t[g].toJ().mixedAdd(t[m]), E[2] = t[g].toJ().mixedAdd(t[m].neg()));
          var w = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
            O = dIe(i[g], i[m]);
          for (u = Math.max(O[0].length, u), c[g] = new Array(u), c[m] = new Array(u), h = 0; h < u; h++) {
            var q = O[0][h] | 0,
              J = O[1][h] | 0;
            c[g][h] = w[(q + 1) * 3 + (J + 1)], c[m][h] = 0, a[g] = E
          }
        }
        var Z = this.jpoint(null, null, null),
          H = this._wnafT4;
        for (f = u; f >= 0; f--) {
          for (var te = 0; f >= 0;) {
            var ae = !0;
            for (h = 0; h < n; h++) H[h] = c[h][f] | 0, H[h] !== 0 && (ae = !1);
            if (!ae) break;
            te++, f--
          }
          if (f >= 0 && te++, Z = Z.dblp(te), f < 0) break;
          for (h = 0; h < n; h++) {
            var oe = H[h];
            oe !== 0 && (oe > 0 ? d = a[h][oe - 1 >> 1] : oe < 0 && (d = a[h][-oe - 1 >> 1].neg()), d.type === "affine" ? Z = Z.mixedAdd(d) : Z = Z.add(d))
          }
        }
        for (f = 0; f < n; f++) a[f] = null;
        return s ? Z : Z.toP()
      };

      function to(r, e) {
        this.curve = r, this.type = e, this.precomputed = null
      }
      Gu.BasePoint = to;
      to.prototype.eq = function () {
        throw new Error("Not implemented")
      };
      to.prototype.validate = function () {
        return this.curve.validate(this)
      };
      Gu.prototype.decodePoint = function (e, t) {
        e = Y1.toArray(e, t);
        var i = this.p.byteLength();
        if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 == 2 * i) {
          e[0] === 6 ? T2(e[e.length - 1] % 2 == 0) : e[0] === 7 && T2(e[e.length - 1] % 2 == 1);
          var n = this.point(e.slice(1, 1 + i), e.slice(1 + i, 1 + 2 * i));
          return n
        } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === i) return this.pointFromX(e.slice(1, 1 + i), e[0] === 3);
        throw new Error("Unknown point format")
      };
      to.prototype.encodeCompressed = function (e) {
        return this.encode(e, !0)
      };
      to.prototype._encode = function (e) {
        var t = this.curve.p.byteLength(),
          i = this.getX().toArray("be", t);
        return e ? [this.getY().isEven() ? 2 : 3].concat(i) : [4].concat(i, this.getY().toArray("be", t))
      };
      to.prototype.encode = function (e, t) {
        return Y1.encode(this._encode(t), e)
      };
      to.prototype.precompute = function (e) {
        if (this.precomputed) return this;
        var t = {
          doubles: null,
          naf: null,
          beta: null
        };
        return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this
      };
      to.prototype._hasDoubles = function (e) {
        if (!this.precomputed) return !1;
        var t = this.precomputed.doubles;
        return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1
      };
      to.prototype._getDoubles = function (e, t) {
        if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
        for (var i = [this], n = this, s = 0; s < t; s += e) {
          for (var o = 0; o < e; o++) n = n.dbl();
          i.push(n)
        }
        return {
          step: e,
          points: i
        }
      };
      to.prototype._getNAFPoints = function (e) {
        if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
        for (var t = [this], i = (1 << e) - 1, n = i === 1 ? null : this.dbl(), s = 1; s < i; s++) t[s] = t[s - 1].add(n);
        return {
          wnd: e,
          points: t
        }
      };
      to.prototype._getBeta = function () {
        return null
      };
      to.prototype.dblp = function (e) {
        for (var t = this, i = 0; i < e; i++) t = t.dbl();
        return t
      }
    });
    var dn = y((Jbt, xS) => {
      l();
      typeof Object.create == "function" ? xS.exports = function (e, t) {
        t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
          constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }))
      } : xS.exports = function (e, t) {
        if (t) {
          e.super_ = t;
          var i = function () { };
          i.prototype = t.prototype, e.prototype = new i, e.prototype.constructor = e
        }
      }
    });
    var uB = y((Xbt, cB) => {
      l();
      "use strict";
      var pIe = Is(),
        Qr = La(),
        AS = dn(),
        vd = J1(),
        yIe = pIe.assert;

      function ro(r) {
        vd.call(this, "short", r), this.a = new Qr(r.a, 16).toRed(this.red), this.b = new Qr(r.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(r), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
      }
      AS(ro, vd);
      cB.exports = ro;
      ro.prototype._getEndomorphism = function (e) {
        if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
          var t, i;
          if (e.beta) t = new Qr(e.beta, 16).toRed(this.red);
          else {
            var n = this._getEndoRoots(this.p);
            t = n[0].cmp(n[1]) < 0 ? n[0] : n[1], t = t.toRed(this.red)
          }
          if (e.lambda) i = new Qr(e.lambda, 16);
          else {
            var s = this._getEndoRoots(this.n);
            this.g.mul(s[0]).x.cmp(this.g.x.redMul(t)) === 0 ? i = s[0] : (i = s[1], yIe(this.g.mul(i).x.cmp(this.g.x.redMul(t)) === 0))
          }
          var o;
          return e.basis ? o = e.basis.map(function (a) {
            return {
              a: new Qr(a.a, 16),
              b: new Qr(a.b, 16)
            }
          }) : o = this._getEndoBasis(i), {
            beta: t,
            lambda: i,
            basis: o
          }
        }
      };
      ro.prototype._getEndoRoots = function (e) {
        var t = e === this.p ? this.red : Qr.mont(e),
          i = new Qr(2).toRed(t).redInvm(),
          n = i.redNeg(),
          s = new Qr(3).toRed(t).redNeg().redSqrt().redMul(i),
          o = n.redAdd(s).fromRed(),
          a = n.redSub(s).fromRed();
        return [o, a]
      };
      ro.prototype._getEndoBasis = function (e) {
        for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i = e, n = this.n.clone(), s = new Qr(1), o = new Qr(0), a = new Qr(0), c = new Qr(1), u, f, h, d, p, g, m, E = 0, w, O; i.cmpn(0) !== 0;) {
          var q = n.div(i);
          w = n.sub(q.mul(i)), O = a.sub(q.mul(s));
          var J = c.sub(q.mul(o));
          if (!h && w.cmp(t) < 0) u = m.neg(), f = s, h = w.neg(), d = O;
          else if (h && ++E == 2) break;
          m = w, n = i, i = w, a = s, s = O, c = o, o = J
        }
        p = w.neg(), g = O;
        var Z = h.sqr().add(d.sqr()),
          H = p.sqr().add(g.sqr());
        return H.cmp(Z) >= 0 && (p = u, g = f), h.negative && (h = h.neg(), d = d.neg()), p.negative && (p = p.neg(), g = g.neg()), [{
          a: h,
          b: d
        }, {
          a: p,
          b: g
        }]
      };
      ro.prototype._endoSplit = function (e) {
        var t = this.endo.basis,
          i = t[0],
          n = t[1],
          s = n.b.mul(e).divRound(this.n),
          o = i.b.neg().mul(e).divRound(this.n),
          a = s.mul(i.a),
          c = o.mul(n.a),
          u = s.mul(i.b),
          f = o.mul(n.b),
          h = e.sub(a).sub(c),
          d = u.add(f).neg();
        return {
          k1: h,
          k2: d
        }
      };
      ro.prototype.pointFromX = function (e, t) {
        e = new Qr(e, 16), e.red || (e = e.toRed(this.red));
        var i = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
          n = i.redSqrt();
        if (n.redSqr().redSub(i).cmp(this.zero) !== 0) throw new Error("invalid point");
        var s = n.fromRed().isOdd();
        return (t && !s || !t && s) && (n = n.redNeg()), this.point(e, n)
      };
      ro.prototype.validate = function (e) {
        if (e.inf) return !0;
        var t = e.x,
          i = e.y,
          n = this.a.redMul(t),
          s = t.redSqr().redMul(t).redIAdd(n).redIAdd(this.b);
        return i.redSqr().redISub(s).cmpn(0) === 0
      };
      ro.prototype._endoWnafMulAdd = function (e, t, i) {
        for (var n = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
          var a = this._endoSplit(t[o]),
            c = e[o],
            u = c._getBeta();
          a.k1.negative && (a.k1.ineg(), c = c.neg(!0)), a.k2.negative && (a.k2.ineg(), u = u.neg(!0)), n[o * 2] = c, n[o * 2 + 1] = u, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2
        }
        for (var f = this._wnafMulAdd(1, n, s, o * 2, i), h = 0; h < o * 2; h++) n[h] = null, s[h] = null;
        return f
      };

      function Gi(r, e, t, i) {
        vd.BasePoint.call(this, r, "affine"), e === null && t === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Qr(e, 16), this.y = new Qr(t, 16), i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
      }
      AS(Gi, vd.BasePoint);
      ro.prototype.point = function (e, t, i) {
        return new Gi(this, e, t, i)
      };
      ro.prototype.pointFromJSON = function (e, t) {
        return Gi.fromJSON(this, e, t)
      };
      Gi.prototype._getBeta = function () {
        if (!!this.curve.endo) {
          var e = this.precomputed;
          if (e && e.beta) return e.beta;
          var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
          if (e) {
            var i = this.curve,
              n = function (s) {
                return i.point(s.x.redMul(i.endo.beta), s.y)
              };
            e.beta = t, t.precomputed = {
              beta: null,
              naf: e.naf && {
                wnd: e.naf.wnd,
                points: e.naf.points.map(n)
              },
              doubles: e.doubles && {
                step: e.doubles.step,
                points: e.doubles.points.map(n)
              }
            }
          }
          return t
        }
      };
      Gi.prototype.toJSON = function () {
        return this.precomputed ? [this.x, this.y, this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
          }
        }] : [this.x, this.y]
      };
      Gi.fromJSON = function (e, t, i) {
        typeof t == "string" && (t = JSON.parse(t));
        var n = e.point(t[0], t[1], i);
        if (!t[2]) return n;

        function s(a) {
          return e.point(a[0], a[1], i)
        }
        var o = t[2];
        return n.precomputed = {
          beta: null,
          doubles: o.doubles && {
            step: o.doubles.step,
            points: [n].concat(o.doubles.points.map(s))
          },
          naf: o.naf && {
            wnd: o.naf.wnd,
            points: [n].concat(o.naf.points.map(s))
          }
        }, n
      };
      Gi.prototype.inspect = function () {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
      };
      Gi.prototype.isInfinity = function () {
        return this.inf
      };
      Gi.prototype.add = function (e) {
        if (this.inf) return e;
        if (e.inf) return this;
        if (this.eq(e)) return this.dbl();
        if (this.neg().eq(e)) return this.curve.point(null, null);
        if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
        var t = this.y.redSub(e.y);
        t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
        var i = t.redSqr().redISub(this.x).redISub(e.x),
          n = t.redMul(this.x.redSub(i)).redISub(this.y);
        return this.curve.point(i, n)
      };
      Gi.prototype.dbl = function () {
        if (this.inf) return this;
        var e = this.y.redAdd(this.y);
        if (e.cmpn(0) === 0) return this.curve.point(null, null);
        var t = this.curve.a,
          i = this.x.redSqr(),
          n = e.redInvm(),
          s = i.redAdd(i).redIAdd(i).redIAdd(t).redMul(n),
          o = s.redSqr().redISub(this.x.redAdd(this.x)),
          a = s.redMul(this.x.redSub(o)).redISub(this.y);
        return this.curve.point(o, a)
      };
      Gi.prototype.getX = function () {
        return this.x.fromRed()
      };
      Gi.prototype.getY = function () {
        return this.y.fromRed()
      };
      Gi.prototype.mul = function (e) {
        return e = new Qr(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
      };
      Gi.prototype.mulAdd = function (e, t, i) {
        var n = [this, t],
          s = [e, i];
        return this.curve.endo ? this.curve._endoWnafMulAdd(n, s) : this.curve._wnafMulAdd(1, n, s, 2)
      };
      Gi.prototype.jmulAdd = function (e, t, i) {
        var n = [this, t],
          s = [e, i];
        return this.curve.endo ? this.curve._endoWnafMulAdd(n, s, !0) : this.curve._wnafMulAdd(1, n, s, 2, !0)
      };
      Gi.prototype.eq = function (e) {
        return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)
      };
      Gi.prototype.neg = function (e) {
        if (this.inf) return this;
        var t = this.curve.point(this.x, this.y.redNeg());
        if (e && this.precomputed) {
          var i = this.precomputed,
            n = function (s) {
              return s.neg()
            };
          t.precomputed = {
            naf: i.naf && {
              wnd: i.naf.wnd,
              points: i.naf.points.map(n)
            },
            doubles: i.doubles && {
              step: i.doubles.step,
              points: i.doubles.points.map(n)
            }
          }
        }
        return t
      };
      Gi.prototype.toJ = function () {
        if (this.inf) return this.curve.jpoint(null, null, null);
        var e = this.curve.jpoint(this.x, this.y, this.curve.one);
        return e
      };

      function pn(r, e, t, i) {
        vd.BasePoint.call(this, r, "jacobian"), e === null && t === null && i === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Qr(0)) : (this.x = new Qr(e, 16), this.y = new Qr(t, 16), this.z = new Qr(i, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
      }
      AS(pn, vd.BasePoint);
      ro.prototype.jpoint = function (e, t, i) {
        return new pn(this, e, t, i)
      };
      pn.prototype.toP = function () {
        if (this.isInfinity()) return this.curve.point(null, null);
        var e = this.z.redInvm(),
          t = e.redSqr(),
          i = this.x.redMul(t),
          n = this.y.redMul(t).redMul(e);
        return this.curve.point(i, n)
      };
      pn.prototype.neg = function () {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
      };
      pn.prototype.add = function (e) {
        if (this.isInfinity()) return e;
        if (e.isInfinity()) return this;
        var t = e.z.redSqr(),
          i = this.z.redSqr(),
          n = this.x.redMul(t),
          s = e.x.redMul(i),
          o = this.y.redMul(t.redMul(e.z)),
          a = e.y.redMul(i.redMul(this.z)),
          c = n.redSub(s),
          u = o.redSub(a);
        if (c.cmpn(0) === 0) return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var f = c.redSqr(),
          h = f.redMul(c),
          d = n.redMul(f),
          p = u.redSqr().redIAdd(h).redISub(d).redISub(d),
          g = u.redMul(d.redISub(p)).redISub(o.redMul(h)),
          m = this.z.redMul(e.z).redMul(c);
        return this.curve.jpoint(p, g, m)
      };
      pn.prototype.mixedAdd = function (e) {
        if (this.isInfinity()) return e.toJ();
        if (e.isInfinity()) return this;
        var t = this.z.redSqr(),
          i = this.x,
          n = e.x.redMul(t),
          s = this.y,
          o = e.y.redMul(t).redMul(this.z),
          a = i.redSub(n),
          c = s.redSub(o);
        if (a.cmpn(0) === 0) return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var u = a.redSqr(),
          f = u.redMul(a),
          h = i.redMul(u),
          d = c.redSqr().redIAdd(f).redISub(h).redISub(h),
          p = c.redMul(h.redISub(d)).redISub(s.redMul(f)),
          g = this.z.redMul(a);
        return this.curve.jpoint(d, p, g)
      };
      pn.prototype.dblp = function (e) {
        if (e === 0) return this;
        if (this.isInfinity()) return this;
        if (!e) return this.dbl();
        var t;
        if (this.curve.zeroA || this.curve.threeA) {
          var i = this;
          for (t = 0; t < e; t++) i = i.dbl();
          return i
        }
        var n = this.curve.a,
          s = this.curve.tinv,
          o = this.x,
          a = this.y,
          c = this.z,
          u = c.redSqr().redSqr(),
          f = a.redAdd(a);
        for (t = 0; t < e; t++) {
          var h = o.redSqr(),
            d = f.redSqr(),
            p = d.redSqr(),
            g = h.redAdd(h).redIAdd(h).redIAdd(n.redMul(u)),
            m = o.redMul(d),
            E = g.redSqr().redISub(m.redAdd(m)),
            w = m.redISub(E),
            O = g.redMul(w);
          O = O.redIAdd(O).redISub(p);
          var q = f.redMul(c);
          t + 1 < e && (u = u.redMul(p)), o = E, c = q, f = O
        }
        return this.curve.jpoint(o, f.redMul(s), c)
      };
      pn.prototype.dbl = function () {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
      };
      pn.prototype._zeroDbl = function () {
        var e, t, i;
        if (this.zOne) {
          var n = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            a = this.x.redAdd(s).redSqr().redISub(n).redISub(o);
          a = a.redIAdd(a);
          var c = n.redAdd(n).redIAdd(n),
            u = c.redSqr().redISub(a).redISub(a),
            f = o.redIAdd(o);
          f = f.redIAdd(f), f = f.redIAdd(f), e = u, t = c.redMul(a.redISub(u)).redISub(f), i = this.y.redAdd(this.y)
        } else {
          var h = this.x.redSqr(),
            d = this.y.redSqr(),
            p = d.redSqr(),
            g = this.x.redAdd(d).redSqr().redISub(h).redISub(p);
          g = g.redIAdd(g);
          var m = h.redAdd(h).redIAdd(h),
            E = m.redSqr(),
            w = p.redIAdd(p);
          w = w.redIAdd(w), w = w.redIAdd(w), e = E.redISub(g).redISub(g), t = m.redMul(g.redISub(e)).redISub(w), i = this.y.redMul(this.z), i = i.redIAdd(i)
        }
        return this.curve.jpoint(e, t, i)
      };
      pn.prototype._threeDbl = function () {
        var e, t, i;
        if (this.zOne) {
          var n = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            a = this.x.redAdd(s).redSqr().redISub(n).redISub(o);
          a = a.redIAdd(a);
          var c = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a),
            u = c.redSqr().redISub(a).redISub(a);
          e = u;
          var f = o.redIAdd(o);
          f = f.redIAdd(f), f = f.redIAdd(f), t = c.redMul(a.redISub(u)).redISub(f), i = this.y.redAdd(this.y)
        } else {
          var h = this.z.redSqr(),
            d = this.y.redSqr(),
            p = this.x.redMul(d),
            g = this.x.redSub(h).redMul(this.x.redAdd(h));
          g = g.redAdd(g).redIAdd(g);
          var m = p.redIAdd(p);
          m = m.redIAdd(m);
          var E = m.redAdd(m);
          e = g.redSqr().redISub(E), i = this.y.redAdd(this.z).redSqr().redISub(d).redISub(h);
          var w = d.redSqr();
          w = w.redIAdd(w), w = w.redIAdd(w), w = w.redIAdd(w), t = g.redMul(m.redISub(e)).redISub(w)
        }
        return this.curve.jpoint(e, t, i)
      };
      pn.prototype._dbl = function () {
        var e = this.curve.a,
          t = this.x,
          i = this.y,
          n = this.z,
          s = n.redSqr().redSqr(),
          o = t.redSqr(),
          a = i.redSqr(),
          c = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)),
          u = t.redAdd(t);
        u = u.redIAdd(u);
        var f = u.redMul(a),
          h = c.redSqr().redISub(f.redAdd(f)),
          d = f.redISub(h),
          p = a.redSqr();
        p = p.redIAdd(p), p = p.redIAdd(p), p = p.redIAdd(p);
        var g = c.redMul(d).redISub(p),
          m = i.redAdd(i).redMul(n);
        return this.curve.jpoint(h, g, m)
      };
      pn.prototype.trpl = function () {
        if (!this.curve.zeroA) return this.dbl().add(this);
        var e = this.x.redSqr(),
          t = this.y.redSqr(),
          i = this.z.redSqr(),
          n = t.redSqr(),
          s = e.redAdd(e).redIAdd(e),
          o = s.redSqr(),
          a = this.x.redAdd(t).redSqr().redISub(e).redISub(n);
        a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
        var c = a.redSqr(),
          u = n.redIAdd(n);
        u = u.redIAdd(u), u = u.redIAdd(u), u = u.redIAdd(u);
        var f = s.redIAdd(a).redSqr().redISub(o).redISub(c).redISub(u),
          h = t.redMul(f);
        h = h.redIAdd(h), h = h.redIAdd(h);
        var d = this.x.redMul(c).redISub(h);
        d = d.redIAdd(d), d = d.redIAdd(d);
        var p = this.y.redMul(f.redMul(u.redISub(f)).redISub(a.redMul(c)));
        p = p.redIAdd(p), p = p.redIAdd(p), p = p.redIAdd(p);
        var g = this.z.redAdd(a).redSqr().redISub(i).redISub(c);
        return this.curve.jpoint(d, p, g)
      };
      pn.prototype.mul = function (e, t) {
        return e = new Qr(e, t), this.curve._wnafMul(this, e)
      };
      pn.prototype.eq = function (e) {
        if (e.type === "affine") return this.eq(e.toJ());
        if (this === e) return !0;
        var t = this.z.redSqr(),
          i = e.z.redSqr();
        if (this.x.redMul(i).redISub(e.x.redMul(t)).cmpn(0) !== 0) return !1;
        var n = t.redMul(this.z),
          s = i.redMul(e.z);
        return this.y.redMul(s).redISub(e.y.redMul(n)).cmpn(0) === 0
      };
      pn.prototype.eqXToP = function (e) {
        var t = this.z.redSqr(),
          i = e.toRed(this.curve.red).redMul(t);
        if (this.x.cmp(i) === 0) return !0;
        for (var n = e.clone(), s = this.curve.redN.redMul(t); ;) {
          if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0) return !1;
          if (i.redIAdd(s), this.x.cmp(i) === 0) return !0
        }
      };
      pn.prototype.inspect = function () {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
      };
      pn.prototype.isInfinity = function () {
        return this.z.cmpn(0) === 0
      }
    });
    var hB = y((Zbt, fB) => {
      l();
      "use strict";
      var wd = La(),
        lB = dn(),
        R2 = J1(),
        gIe = Is();

      function _d(r) {
        R2.call(this, "mont", r), this.a = new wd(r.a, 16).toRed(this.red), this.b = new wd(r.b, 16).toRed(this.red), this.i4 = new wd(4).toRed(this.red).redInvm(), this.two = new wd(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two))
      }
      lB(_d, R2);
      fB.exports = _d;
      _d.prototype.validate = function (e) {
        var t = e.normalize().x,
          i = t.redSqr(),
          n = i.redMul(t).redAdd(i.redMul(this.a)).redAdd(t),
          s = n.redSqrt();
        return s.redSqr().cmp(n) === 0
      };

      function $i(r, e, t) {
        R2.BasePoint.call(this, r, "projective"), e === null && t === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new wd(e, 16), this.z = new wd(t, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)))
      }
      lB($i, R2.BasePoint);
      _d.prototype.decodePoint = function (e, t) {
        return this.point(gIe.toArray(e, t), 1)
      };
      _d.prototype.point = function (e, t) {
        return new $i(this, e, t)
      };
      _d.prototype.pointFromJSON = function (e) {
        return $i.fromJSON(this, e)
      };
      $i.prototype.precompute = function () { };
      $i.prototype._encode = function () {
        return this.getX().toArray("be", this.curve.p.byteLength())
      };
      $i.fromJSON = function (e, t) {
        return new $i(e, t[0], t[1] || e.one)
      };
      $i.prototype.inspect = function () {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
      };
      $i.prototype.isInfinity = function () {
        return this.z.cmpn(0) === 0
      };
      $i.prototype.dbl = function () {
        var e = this.x.redAdd(this.z),
          t = e.redSqr(),
          i = this.x.redSub(this.z),
          n = i.redSqr(),
          s = t.redSub(n),
          o = t.redMul(n),
          a = s.redMul(n.redAdd(this.curve.a24.redMul(s)));
        return this.curve.point(o, a)
      };
      $i.prototype.add = function () {
        throw new Error("Not supported on Montgomery curve")
      };
      $i.prototype.diffAdd = function (e, t) {
        var i = this.x.redAdd(this.z),
          n = this.x.redSub(this.z),
          s = e.x.redAdd(e.z),
          o = e.x.redSub(e.z),
          a = o.redMul(i),
          c = s.redMul(n),
          u = t.z.redMul(a.redAdd(c).redSqr()),
          f = t.x.redMul(a.redISub(c).redSqr());
        return this.curve.point(u, f)
      };
      $i.prototype.mul = function (e) {
        for (var t = e.clone(), i = this, n = this.curve.point(null, null), s = this, o = []; t.cmpn(0) !== 0; t.iushrn(1)) o.push(t.andln(1));
        for (var a = o.length - 1; a >= 0; a--) o[a] === 0 ? (i = i.diffAdd(n, s), n = n.dbl()) : (n = i.diffAdd(n, s), i = i.dbl());
        return n
      };
      $i.prototype.mulAdd = function () {
        throw new Error("Not supported on Montgomery curve")
      };
      $i.prototype.jumlAdd = function () {
        throw new Error("Not supported on Montgomery curve")
      };
      $i.prototype.eq = function (e) {
        return this.getX().cmp(e.getX()) === 0
      };
      $i.prototype.normalize = function () {
        return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this
      };
      $i.prototype.getX = function () {
        return this.normalize(), this.x.fromRed()
      }
    });
    var yB = y((Qbt, dB) => {
      l();
      "use strict";
      var bIe = Is(),
        jc = La(),
        pB = dn(),
        k2 = J1(),
        mIe = bIe.assert;

      function Fa(r) {
        this.twisted = (r.a | 0) != 1, this.mOneA = this.twisted && (r.a | 0) == -1, this.extended = this.mOneA, k2.call(this, "edwards", r), this.a = new jc(r.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new jc(r.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new jc(r.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), mIe(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (r.c | 0) == 1
      }
      pB(Fa, k2);
      dB.exports = Fa;
      Fa.prototype._mulA = function (e) {
        return this.mOneA ? e.redNeg() : this.a.redMul(e)
      };
      Fa.prototype._mulC = function (e) {
        return this.oneC ? e : this.c.redMul(e)
      };
      Fa.prototype.jpoint = function (e, t, i, n) {
        return this.point(e, t, i, n)
      };
      Fa.prototype.pointFromX = function (e, t) {
        e = new jc(e, 16), e.red || (e = e.toRed(this.red));
        var i = e.redSqr(),
          n = this.c2.redSub(this.a.redMul(i)),
          s = this.one.redSub(this.c2.redMul(this.d).redMul(i)),
          o = n.redMul(s.redInvm()),
          a = o.redSqrt();
        if (a.redSqr().redSub(o).cmp(this.zero) !== 0) throw new Error("invalid point");
        var c = a.fromRed().isOdd();
        return (t && !c || !t && c) && (a = a.redNeg()), this.point(e, a)
      };
      Fa.prototype.pointFromY = function (e, t) {
        e = new jc(e, 16), e.red || (e = e.toRed(this.red));
        var i = e.redSqr(),
          n = i.redSub(this.c2),
          s = i.redMul(this.d).redMul(this.c2).redSub(this.a),
          o = n.redMul(s.redInvm());
        if (o.cmp(this.zero) === 0) {
          if (t) throw new Error("invalid point");
          return this.point(this.zero, e)
        }
        var a = o.redSqrt();
        if (a.redSqr().redSub(o).cmp(this.zero) !== 0) throw new Error("invalid point");
        return a.fromRed().isOdd() !== t && (a = a.redNeg()), this.point(a, e)
      };
      Fa.prototype.validate = function (e) {
        if (e.isInfinity()) return !0;
        e.normalize();
        var t = e.x.redSqr(),
          i = e.y.redSqr(),
          n = t.redMul(this.a).redAdd(i),
          s = this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(i)));
        return n.cmp(s) === 0
      };

      function Rr(r, e, t, i, n) {
        k2.BasePoint.call(this, r, "projective"), e === null && t === null && i === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new jc(e, 16), this.y = new jc(t, 16), this.z = i ? new jc(i, 16) : this.curve.one, this.t = n && new jc(n, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
      }
      pB(Rr, k2.BasePoint);
      Fa.prototype.pointFromJSON = function (e) {
        return Rr.fromJSON(this, e)
      };
      Fa.prototype.point = function (e, t, i, n) {
        return new Rr(this, e, t, i, n)
      };
      Rr.fromJSON = function (e, t) {
        return new Rr(e, t[0], t[1], t[2])
      };
      Rr.prototype.inspect = function () {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
      };
      Rr.prototype.isInfinity = function () {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0)
      };
      Rr.prototype._extDbl = function () {
        var e = this.x.redSqr(),
          t = this.y.redSqr(),
          i = this.z.redSqr();
        i = i.redIAdd(i);
        var n = this.curve._mulA(e),
          s = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),
          o = n.redAdd(t),
          a = o.redSub(i),
          c = n.redSub(t),
          u = s.redMul(a),
          f = o.redMul(c),
          h = s.redMul(c),
          d = a.redMul(o);
        return this.curve.point(u, f, d, h)
      };
      Rr.prototype._projDbl = function () {
        var e = this.x.redAdd(this.y).redSqr(),
          t = this.x.redSqr(),
          i = this.y.redSqr(),
          n, s, o, a, c, u;
        if (this.curve.twisted) {
          a = this.curve._mulA(t);
          var f = a.redAdd(i);
          this.zOne ? (n = e.redSub(t).redSub(i).redMul(f.redSub(this.curve.two)), s = f.redMul(a.redSub(i)), o = f.redSqr().redSub(f).redSub(f)) : (c = this.z.redSqr(), u = f.redSub(c).redISub(c), n = e.redSub(t).redISub(i).redMul(u), s = f.redMul(a.redSub(i)), o = f.redMul(u))
        } else a = t.redAdd(i), c = this.curve._mulC(this.z).redSqr(), u = a.redSub(c).redSub(c), n = this.curve._mulC(e.redISub(a)).redMul(u), s = this.curve._mulC(a).redMul(t.redISub(i)), o = a.redMul(u);
        return this.curve.point(n, s, o)
      };
      Rr.prototype.dbl = function () {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
      };
      Rr.prototype._extAdd = function (e) {
        var t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)),
          i = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),
          n = this.t.redMul(this.curve.dd).redMul(e.t),
          s = this.z.redMul(e.z.redAdd(e.z)),
          o = i.redSub(t),
          a = s.redSub(n),
          c = s.redAdd(n),
          u = i.redAdd(t),
          f = o.redMul(a),
          h = c.redMul(u),
          d = o.redMul(u),
          p = a.redMul(c);
        return this.curve.point(f, h, p, d)
      };
      Rr.prototype._projAdd = function (e) {
        var t = this.z.redMul(e.z),
          i = t.redSqr(),
          n = this.x.redMul(e.x),
          s = this.y.redMul(e.y),
          o = this.curve.d.redMul(n).redMul(s),
          a = i.redSub(o),
          c = i.redAdd(o),
          u = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(n).redISub(s),
          f = t.redMul(a).redMul(u),
          h, d;
        return this.curve.twisted ? (h = t.redMul(c).redMul(s.redSub(this.curve._mulA(n))), d = a.redMul(c)) : (h = t.redMul(c).redMul(s.redSub(n)), d = this.curve._mulC(a).redMul(c)), this.curve.point(f, h, d)
      };
      Rr.prototype.add = function (e) {
        return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e)
      };
      Rr.prototype.mul = function (e) {
        return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e)
      };
      Rr.prototype.mulAdd = function (e, t, i) {
        return this.curve._wnafMulAdd(1, [this, t], [e, i], 2, !1)
      };
      Rr.prototype.jmulAdd = function (e, t, i) {
        return this.curve._wnafMulAdd(1, [this, t], [e, i], 2, !0)
      };
      Rr.prototype.normalize = function () {
        if (this.zOne) return this;
        var e = this.z.redInvm();
        return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this
      };
      Rr.prototype.neg = function () {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
      };
      Rr.prototype.getX = function () {
        return this.normalize(), this.x.fromRed()
      };
      Rr.prototype.getY = function () {
        return this.normalize(), this.y.fromRed()
      };
      Rr.prototype.eq = function (e) {
        return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0
      };
      Rr.prototype.eqXToP = function (e) {
        var t = e.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(t) === 0) return !0;
        for (var i = e.clone(), n = this.curve.redN.redMul(this.z); ;) {
          if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return !1;
          if (t.redIAdd(n), this.x.cmp(t) === 0) return !0
        }
      };
      Rr.prototype.toP = Rr.prototype.normalize;
      Rr.prototype.mixedAdd = Rr.prototype.add
    });
    var IS = y(gB => {
      l();
      "use strict";
      var P2 = gB;
      P2.base = J1();
      P2.short = uB();
      P2.mont = hB();
      P2.edwards = yB()
    });
    var Vo = y(Er => {
      l();
      "use strict";
      var vIe = Vu(),
        wIe = dn();
      Er.inherits = wIe;

      function _Ie(r, e) {
        return (r.charCodeAt(e) & 64512) != 55296 || e < 0 || e + 1 >= r.length ? !1 : (r.charCodeAt(e + 1) & 64512) == 56320
      }

      function EIe(r, e) {
        if (Array.isArray(r)) return r.slice();
        if (!r) return [];
        var t = [];
        if (typeof r == "string")
          if (e) {
            if (e === "hex")
              for (r = r.replace(/[^a-z0-9]+/ig, ""), r.length % 2 != 0 && (r = "0" + r), n = 0; n < r.length; n += 2) t.push(parseInt(r[n] + r[n + 1], 16))
          } else
            for (var i = 0, n = 0; n < r.length; n++) {
              var s = r.charCodeAt(n);
              s < 128 ? t[i++] = s : s < 2048 ? (t[i++] = s >> 6 | 192, t[i++] = s & 63 | 128) : _Ie(r, n) ? (s = 65536 + ((s & 1023) << 10) + (r.charCodeAt(++n) & 1023), t[i++] = s >> 18 | 240, t[i++] = s >> 12 & 63 | 128, t[i++] = s >> 6 & 63 | 128, t[i++] = s & 63 | 128) : (t[i++] = s >> 12 | 224, t[i++] = s >> 6 & 63 | 128, t[i++] = s & 63 | 128)
            } else
          for (n = 0; n < r.length; n++) t[n] = r[n] | 0;
        return t
      }
      Er.toArray = EIe;

      function SIe(r) {
        for (var e = "", t = 0; t < r.length; t++) e += bB(r[t].toString(16));
        return e
      }
      Er.toHex = SIe;

      function mB(r) {
        var e = r >>> 24 | r >>> 8 & 65280 | r << 8 & 16711680 | (r & 255) << 24;
        return e >>> 0
      }
      Er.htonl = mB;

      function xIe(r, e) {
        for (var t = "", i = 0; i < r.length; i++) {
          var n = r[i];
          e === "little" && (n = mB(n)), t += vB(n.toString(16))
        }
        return t
      }
      Er.toHex32 = xIe;

      function bB(r) {
        return r.length === 1 ? "0" + r : r
      }
      Er.zero2 = bB;

      function vB(r) {
        return r.length === 7 ? "0" + r : r.length === 6 ? "00" + r : r.length === 5 ? "000" + r : r.length === 4 ? "0000" + r : r.length === 3 ? "00000" + r : r.length === 2 ? "000000" + r : r.length === 1 ? "0000000" + r : r
      }
      Er.zero8 = vB;

      function AIe(r, e, t, i) {
        var n = t - e;
        vIe(n % 4 == 0);
        for (var s = new Array(n / 4), o = 0, a = e; o < s.length; o++, a += 4) {
          var c;
          i === "big" ? c = r[a] << 24 | r[a + 1] << 16 | r[a + 2] << 8 | r[a + 3] : c = r[a + 3] << 24 | r[a + 2] << 16 | r[a + 1] << 8 | r[a], s[o] = c >>> 0
        }
        return s
      }
      Er.join32 = AIe;

      function IIe(r, e) {
        for (var t = new Array(r.length * 4), i = 0, n = 0; i < r.length; i++, n += 4) {
          var s = r[i];
          e === "big" ? (t[n] = s >>> 24, t[n + 1] = s >>> 16 & 255, t[n + 2] = s >>> 8 & 255, t[n + 3] = s & 255) : (t[n + 3] = s >>> 24, t[n + 2] = s >>> 16 & 255, t[n + 1] = s >>> 8 & 255, t[n] = s & 255)
        }
        return t
      }
      Er.split32 = IIe;

      function TIe(r, e) {
        return r >>> e | r << 32 - e
      }
      Er.rotr32 = TIe;

      function RIe(r, e) {
        return r << e | r >>> 32 - e
      }
      Er.rotl32 = RIe;

      function kIe(r, e) {
        return r + e >>> 0
      }
      Er.sum32 = kIe;

      function PIe(r, e, t) {
        return r + e + t >>> 0
      }
      Er.sum32_3 = PIe;

      function CIe(r, e, t, i) {
        return r + e + t + i >>> 0
      }
      Er.sum32_4 = CIe;

      function OIe(r, e, t, i, n) {
        return r + e + t + i + n >>> 0
      }
      Er.sum32_5 = OIe;

      function NIe(r, e, t, i) {
        var n = r[e],
          s = r[e + 1],
          o = i + s >>> 0,
          a = (o < i ? 1 : 0) + t + n;
        r[e] = a >>> 0, r[e + 1] = o
      }
      Er.sum64 = NIe;

      function qIe(r, e, t, i) {
        var n = e + i >>> 0,
          s = (n < e ? 1 : 0) + r + t;
        return s >>> 0
      }
      Er.sum64_hi = qIe;

      function MIe(r, e, t, i) {
        var n = e + i;
        return n >>> 0
      }
      Er.sum64_lo = MIe;

      function BIe(r, e, t, i, n, s, o, a) {
        var c = 0,
          u = e;
        u = u + i >>> 0, c += u < e ? 1 : 0, u = u + s >>> 0, c += u < s ? 1 : 0, u = u + a >>> 0, c += u < a ? 1 : 0;
        var f = r + t + n + o + c;
        return f >>> 0
      }
      Er.sum64_4_hi = BIe;

      function DIe(r, e, t, i, n, s, o, a) {
        var c = e + i + s + a;
        return c >>> 0
      }
      Er.sum64_4_lo = DIe;

      function LIe(r, e, t, i, n, s, o, a, c, u) {
        var f = 0,
          h = e;
        h = h + i >>> 0, f += h < e ? 1 : 0, h = h + s >>> 0, f += h < s ? 1 : 0, h = h + a >>> 0, f += h < a ? 1 : 0, h = h + u >>> 0, f += h < u ? 1 : 0;
        var d = r + t + n + o + c + f;
        return d >>> 0
      }
      Er.sum64_5_hi = LIe;

      function FIe(r, e, t, i, n, s, o, a, c, u) {
        var f = e + i + s + a + u;
        return f >>> 0
      }
      Er.sum64_5_lo = FIe;

      function UIe(r, e, t) {
        var i = e << 32 - t | r >>> t;
        return i >>> 0
      }
      Er.rotr64_hi = UIe;

      function KIe(r, e, t) {
        var i = r << 32 - t | e >>> t;
        return i >>> 0
      }
      Er.rotr64_lo = KIe;

      function zIe(r, e, t) {
        return r >>> t
      }
      Er.shr64_hi = zIe;

      function jIe(r, e, t) {
        var i = r << 32 - t | e >>> t;
        return i >>> 0
      }
      Er.shr64_lo = jIe
    });
    var Ed = y(wB => {
      l();
      "use strict";
      var _B = Vo(),
        VIe = Vu();

      function C2() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
      }
      wB.BlockHash = C2;
      C2.prototype.update = function (e, t) {
        if (e = _B.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
          e = this.pending;
          var i = e.length % this._delta8;
          this.pending = e.slice(e.length - i, e.length), this.pending.length === 0 && (this.pending = null), e = _B.join32(e, 0, e.length - i, this.endian);
          for (var n = 0; n < e.length; n += this._delta32) this._update(e, n, n + this._delta32)
        }
        return this
      };
      C2.prototype.digest = function (e) {
        return this.update(this._pad()), VIe(this.pending === null), this._digest(e)
      };
      C2.prototype._pad = function () {
        var e = this.pendingTotal,
          t = this._delta8,
          i = t - (e + this.padLength) % t,
          n = new Array(i + this.padLength);
        n[0] = 128;
        for (var s = 1; s < i; s++) n[s] = 0;
        if (e <<= 3, this.endian === "big") {
          for (var o = 8; o < this.padLength; o++) n[s++] = 0;
          n[s++] = 0, n[s++] = 0, n[s++] = 0, n[s++] = 0, n[s++] = e >>> 24 & 255, n[s++] = e >>> 16 & 255, n[s++] = e >>> 8 & 255, n[s++] = e & 255
        } else
          for (n[s++] = e & 255, n[s++] = e >>> 8 & 255, n[s++] = e >>> 16 & 255, n[s++] = e >>> 24 & 255, n[s++] = 0, n[s++] = 0, n[s++] = 0, n[s++] = 0, o = 8; o < this.padLength; o++) n[s++] = 0;
        return n
      }
    });
    var TS = y(Vc => {
      l();
      "use strict";
      var HIe = Vo(),
        Ua = HIe.rotr32;

      function GIe(r, e, t, i) {
        if (r === 0) return EB(e, t, i);
        if (r === 1 || r === 3) return xB(e, t, i);
        if (r === 2) return SB(e, t, i)
      }
      Vc.ft_1 = GIe;

      function EB(r, e, t) {
        return r & e ^ ~r & t
      }
      Vc.ch32 = EB;

      function SB(r, e, t) {
        return r & e ^ r & t ^ e & t
      }
      Vc.maj32 = SB;

      function xB(r, e, t) {
        return r ^ e ^ t
      }
      Vc.p32 = xB;

      function $Ie(r) {
        return Ua(r, 2) ^ Ua(r, 13) ^ Ua(r, 22)
      }
      Vc.s0_256 = $Ie;

      function WIe(r) {
        return Ua(r, 6) ^ Ua(r, 11) ^ Ua(r, 25)
      }
      Vc.s1_256 = WIe;

      function YIe(r) {
        return Ua(r, 7) ^ Ua(r, 18) ^ r >>> 3
      }
      Vc.g0_256 = YIe;

      function JIe(r) {
        return Ua(r, 17) ^ Ua(r, 19) ^ r >>> 10
      }
      Vc.g1_256 = JIe
    });
    var TB = y((nmt, AB) => {
      l();
      "use strict";
      var Sd = Vo(),
        XIe = Ed(),
        ZIe = TS(),
        RS = Sd.rotl32,
        X1 = Sd.sum32,
        QIe = Sd.sum32_5,
        eTe = ZIe.ft_1,
        IB = XIe.BlockHash,
        tTe = [1518500249, 1859775393, 2400959708, 3395469782];

      function Ka() {
        if (!(this instanceof Ka)) return new Ka;
        IB.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
      }
      Sd.inherits(Ka, IB);
      AB.exports = Ka;
      Ka.blockSize = 512;
      Ka.outSize = 160;
      Ka.hmacStrength = 80;
      Ka.padLength = 64;
      Ka.prototype._update = function (e, t) {
        for (var i = this.W, n = 0; n < 16; n++) i[n] = e[t + n];
        for (; n < i.length; n++) i[n] = RS(i[n - 3] ^ i[n - 8] ^ i[n - 14] ^ i[n - 16], 1);
        var s = this.h[0],
          o = this.h[1],
          a = this.h[2],
          c = this.h[3],
          u = this.h[4];
        for (n = 0; n < i.length; n++) {
          var f = ~~(n / 20),
            h = QIe(RS(s, 5), eTe(f, o, a, c), u, i[n], tTe[f]);
          u = c, c = a, a = RS(o, 30), o = s, s = h
        }
        this.h[0] = X1(this.h[0], s), this.h[1] = X1(this.h[1], o), this.h[2] = X1(this.h[2], a), this.h[3] = X1(this.h[3], c), this.h[4] = X1(this.h[4], u)
      };
      Ka.prototype._digest = function (e) {
        return e === "hex" ? Sd.toHex32(this.h, "big") : Sd.split32(this.h, "big")
      }
    });
    var kS = y((smt, RB) => {
      l();
      "use strict";
      var xd = Vo(),
        rTe = Ed(),
        Ad = TS(),
        iTe = Vu(),
        Ho = xd.sum32,
        nTe = xd.sum32_4,
        sTe = xd.sum32_5,
        oTe = Ad.ch32,
        aTe = Ad.maj32,
        cTe = Ad.s0_256,
        uTe = Ad.s1_256,
        fTe = Ad.g0_256,
        lTe = Ad.g1_256,
        kB = rTe.BlockHash,
        hTe = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

      function za() {
        if (!(this instanceof za)) return new za;
        kB.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = hTe, this.W = new Array(64)
      }
      xd.inherits(za, kB);
      RB.exports = za;
      za.blockSize = 512;
      za.outSize = 256;
      za.hmacStrength = 192;
      za.padLength = 64;
      za.prototype._update = function (e, t) {
        for (var i = this.W, n = 0; n < 16; n++) i[n] = e[t + n];
        for (; n < i.length; n++) i[n] = nTe(lTe(i[n - 2]), i[n - 7], fTe(i[n - 15]), i[n - 16]);
        var s = this.h[0],
          o = this.h[1],
          a = this.h[2],
          c = this.h[3],
          u = this.h[4],
          f = this.h[5],
          h = this.h[6],
          d = this.h[7];
        for (iTe(this.k.length === i.length), n = 0; n < i.length; n++) {
          var p = sTe(d, uTe(u), oTe(u, f, h), this.k[n], i[n]),
            g = Ho(cTe(s), aTe(s, o, a));
          d = h, h = f, f = u, u = Ho(c, p), c = a, a = o, o = s, s = Ho(p, g)
        }
        this.h[0] = Ho(this.h[0], s), this.h[1] = Ho(this.h[1], o), this.h[2] = Ho(this.h[2], a), this.h[3] = Ho(this.h[3], c), this.h[4] = Ho(this.h[4], u), this.h[5] = Ho(this.h[5], f), this.h[6] = Ho(this.h[6], h), this.h[7] = Ho(this.h[7], d)
      };
      za.prototype._digest = function (e) {
        return e === "hex" ? xd.toHex32(this.h, "big") : xd.split32(this.h, "big")
      }
    });
    var OB = y((omt, PB) => {
      l();
      "use strict";
      var PS = Vo(),
        CB = kS();

      function Hc() {
        if (!(this instanceof Hc)) return new Hc;
        CB.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
      }
      PS.inherits(Hc, CB);
      PB.exports = Hc;
      Hc.blockSize = 512;
      Hc.outSize = 224;
      Hc.hmacStrength = 192;
      Hc.padLength = 64;
      Hc.prototype._digest = function (e) {
        return e === "hex" ? PS.toHex32(this.h.slice(0, 7), "big") : PS.split32(this.h.slice(0, 7), "big")
      }
    });
    var NS = y((amt, NB) => {
      l();
      "use strict";
      var ps = Vo(),
        dTe = Ed(),
        pTe = Vu(),
        ja = ps.rotr64_hi,
        Va = ps.rotr64_lo,
        qB = ps.shr64_hi,
        MB = ps.shr64_lo,
        $u = ps.sum64,
        CS = ps.sum64_hi,
        OS = ps.sum64_lo,
        yTe = ps.sum64_4_hi,
        gTe = ps.sum64_4_lo,
        bTe = ps.sum64_5_hi,
        mTe = ps.sum64_5_lo,
        BB = dTe.BlockHash,
        vTe = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

      function Go() {
        if (!(this instanceof Go)) return new Go;
        BB.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = vTe, this.W = new Array(160)
      }
      ps.inherits(Go, BB);
      NB.exports = Go;
      Go.blockSize = 1024;
      Go.outSize = 512;
      Go.hmacStrength = 192;
      Go.padLength = 128;
      Go.prototype._prepareBlock = function (e, t) {
        for (var i = this.W, n = 0; n < 32; n++) i[n] = e[t + n];
        for (; n < i.length; n += 2) {
          var s = ETe(i[n - 4], i[n - 3]),
            o = STe(i[n - 4], i[n - 3]),
            a = i[n - 14],
            c = i[n - 13],
            u = wTe(i[n - 30], i[n - 29]),
            f = _Te(i[n - 30], i[n - 29]),
            h = i[n - 32],
            d = i[n - 31];
          i[n] = yTe(s, o, a, c, u, f, h, d), i[n + 1] = gTe(s, o, a, c, u, f, h, d)
        }
      };
      Go.prototype._update = function (e, t) {
        this._prepareBlock(e, t);
        var i = this.W,
          n = this.h[0],
          s = this.h[1],
          o = this.h[2],
          a = this.h[3],
          c = this.h[4],
          u = this.h[5],
          f = this.h[6],
          h = this.h[7],
          d = this.h[8],
          p = this.h[9],
          g = this.h[10],
          m = this.h[11],
          E = this.h[12],
          w = this.h[13],
          O = this.h[14],
          q = this.h[15];
        pTe(this.k.length === i.length);
        for (var J = 0; J < i.length; J += 2) {
          var Z = O,
            H = q,
            te = PTe(d, p),
            ae = CTe(d, p),
            oe = xTe(d, p, g, m, E, w),
            U = ATe(d, p, g, m, E, w),
            b = this.k[J],
            _ = this.k[J + 1],
            R = i[J],
            D = i[J + 1],
            K = bTe(Z, H, te, ae, oe, U, b, _, R, D),
            ee = mTe(Z, H, te, ae, oe, U, b, _, R, D);
          Z = RTe(n, s), H = kTe(n, s), te = ITe(n, s, o, a, c, u), ae = TTe(n, s, o, a, c, u);
          var re = CS(Z, H, te, ae),
            V = OS(Z, H, te, ae);
          O = E, q = w, E = g, w = m, g = d, m = p, d = CS(f, h, K, ee), p = OS(h, h, K, ee), f = c, h = u, c = o, u = a, o = n, a = s, n = CS(K, ee, re, V), s = OS(K, ee, re, V)
        }
        $u(this.h, 0, n, s), $u(this.h, 2, o, a), $u(this.h, 4, c, u), $u(this.h, 6, f, h), $u(this.h, 8, d, p), $u(this.h, 10, g, m), $u(this.h, 12, E, w), $u(this.h, 14, O, q)
      };
      Go.prototype._digest = function (e) {
        return e === "hex" ? ps.toHex32(this.h, "big") : ps.split32(this.h, "big")
      };

      function xTe(r, e, t, i, n) {
        var s = r & t ^ ~r & n;
        return s < 0 && (s += 4294967296), s
      }

      function ATe(r, e, t, i, n, s) {
        var o = e & i ^ ~e & s;
        return o < 0 && (o += 4294967296), o
      }

      function ITe(r, e, t, i, n) {
        var s = r & t ^ r & n ^ t & n;
        return s < 0 && (s += 4294967296), s
      }

      function TTe(r, e, t, i, n, s) {
        var o = e & i ^ e & s ^ i & s;
        return o < 0 && (o += 4294967296), o
      }

      function RTe(r, e) {
        var t = ja(r, e, 28),
          i = ja(e, r, 2),
          n = ja(e, r, 7),
          s = t ^ i ^ n;
        return s < 0 && (s += 4294967296), s
      }

      function kTe(r, e) {
        var t = Va(r, e, 28),
          i = Va(e, r, 2),
          n = Va(e, r, 7),
          s = t ^ i ^ n;
        return s < 0 && (s += 4294967296), s
      }

      function PTe(r, e) {
        var t = ja(r, e, 14),
          i = ja(r, e, 18),
          n = ja(e, r, 9),
          s = t ^ i ^ n;
        return s < 0 && (s += 4294967296), s
      }

      function CTe(r, e) {
        var t = Va(r, e, 14),
          i = Va(r, e, 18),
          n = Va(e, r, 9),
          s = t ^ i ^ n;
        return s < 0 && (s += 4294967296), s
      }

      function wTe(r, e) {
        var t = ja(r, e, 1),
          i = ja(r, e, 8),
          n = qB(r, e, 7),
          s = t ^ i ^ n;
        return s < 0 && (s += 4294967296), s
      }

      function _Te(r, e) {
        var t = Va(r, e, 1),
          i = Va(r, e, 8),
          n = MB(r, e, 7),
          s = t ^ i ^ n;
        return s < 0 && (s += 4294967296), s
      }

      function ETe(r, e) {
        var t = ja(r, e, 19),
          i = ja(e, r, 29),
          n = qB(r, e, 6),
          s = t ^ i ^ n;
        return s < 0 && (s += 4294967296), s
      }

      function STe(r, e) {
        var t = Va(r, e, 19),
          i = Va(e, r, 29),
          n = MB(r, e, 6),
          s = t ^ i ^ n;
        return s < 0 && (s += 4294967296), s
      }
    });
    var FB = y((cmt, DB) => {
      l();
      "use strict";
      var qS = Vo(),
        LB = NS();

      function Gc() {
        if (!(this instanceof Gc)) return new Gc;
        LB.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
      }
      qS.inherits(Gc, LB);
      DB.exports = Gc;
      Gc.blockSize = 1024;
      Gc.outSize = 384;
      Gc.hmacStrength = 192;
      Gc.padLength = 128;
      Gc.prototype._digest = function (e) {
        return e === "hex" ? qS.toHex32(this.h.slice(0, 12), "big") : qS.split32(this.h.slice(0, 12), "big")
      }
    });
    var UB = y(Id => {
      l();
      "use strict";
      Id.sha1 = TB();
      Id.sha224 = OB();
      Id.sha256 = kS();
      Id.sha384 = FB();
      Id.sha512 = NS()
    });
    var GB = y(KB => {
      l();
      "use strict";
      var dl = Vo(),
        OTe = Ed(),
        O2 = dl.rotl32,
        zB = dl.sum32,
        Z1 = dl.sum32_3,
        jB = dl.sum32_4,
        VB = OTe.BlockHash;

      function Ha() {
        if (!(this instanceof Ha)) return new Ha;
        VB.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
      }
      dl.inherits(Ha, VB);
      KB.ripemd160 = Ha;
      Ha.blockSize = 512;
      Ha.outSize = 160;
      Ha.hmacStrength = 192;
      Ha.padLength = 64;
      Ha.prototype._update = function (e, t) {
        for (var i = this.h[0], n = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], c = i, u = n, f = s, h = o, d = a, p = 0; p < 80; p++) {
          var g = zB(O2(jB(i, HB(p, n, s, o), e[MTe[p] + t], NTe(p)), DTe[p]), a);
          i = a, a = o, o = O2(s, 10), s = n, n = g, g = zB(O2(jB(c, HB(79 - p, u, f, h), e[BTe[p] + t], qTe(p)), LTe[p]), d), c = d, d = h, h = O2(f, 10), f = u, u = g
        }
        g = Z1(this.h[1], s, h), this.h[1] = Z1(this.h[2], o, d), this.h[2] = Z1(this.h[3], a, c), this.h[3] = Z1(this.h[4], i, u), this.h[4] = Z1(this.h[0], n, f), this.h[0] = g
      };
      Ha.prototype._digest = function (e) {
        return e === "hex" ? dl.toHex32(this.h, "little") : dl.split32(this.h, "little")
      };

      function HB(r, e, t, i) {
        return r <= 15 ? e ^ t ^ i : r <= 31 ? e & t | ~e & i : r <= 47 ? (e | ~t) ^ i : r <= 63 ? e & i | t & ~i : e ^ (t | ~i)
      }

      function NTe(r) {
        return r <= 15 ? 0 : r <= 31 ? 1518500249 : r <= 47 ? 1859775393 : r <= 63 ? 2400959708 : 2840853838
      }

      function qTe(r) {
        return r <= 15 ? 1352829926 : r <= 31 ? 1548603684 : r <= 47 ? 1836072691 : r <= 63 ? 2053994217 : 0
      }
      var MTe = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
        BTe = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
        DTe = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
        LTe = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
    });
    var WB = y((lmt, $B) => {
      l();
      "use strict";
      var FTe = Vo(),
        UTe = Vu();

      function Td(r, e, t) {
        if (!(this instanceof Td)) return new Td(r, e, t);
        this.Hash = r, this.blockSize = r.blockSize / 8, this.outSize = r.outSize / 8, this.inner = null, this.outer = null, this._init(FTe.toArray(e, t))
      }
      $B.exports = Td;
      Td.prototype._init = function (e) {
        e.length > this.blockSize && (e = new this.Hash().update(e).digest()), UTe(e.length <= this.blockSize);
        for (var t = e.length; t < this.blockSize; t++) e.push(0);
        for (t = 0; t < e.length; t++) e[t] ^= 54;
        for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++) e[t] ^= 106;
        this.outer = new this.Hash().update(e)
      };
      Td.prototype.update = function (e, t) {
        return this.inner.update(e, t), this
      };
      Td.prototype.digest = function (e) {
        return this.outer.update(this.inner.digest()), this.outer.digest(e)
      }
    });
    var N2 = y(YB => {
      l();
      var yn = YB;
      yn.utils = Vo();
      yn.common = Ed();
      yn.sha = UB();
      yn.ripemd = GB();
      yn.hmac = WB();
      yn.sha1 = yn.sha.sha1;
      yn.sha256 = yn.sha.sha256;
      yn.sha224 = yn.sha.sha224;
      yn.sha384 = yn.sha.sha384;
      yn.sha512 = yn.sha.sha512;
      yn.ripemd160 = yn.ripemd.ripemd160
    });
    var XB = y((dmt, JB) => {
      l();
      JB.exports = {
        doubles: {
          step: 4,
          points: [
            ["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],
            ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],
            ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],
            ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],
            ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],
            ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],
            ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],
            ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],
            ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],
            ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],
            ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],
            ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],
            ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],
            ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],
            ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],
            ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],
            ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],
            ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],
            ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],
            ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],
            ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],
            ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],
            ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],
            ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],
            ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],
            ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],
            ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],
            ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],
            ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],
            ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],
            ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],
            ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],
            ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],
            ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],
            ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],
            ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],
            ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],
            ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],
            ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],
            ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],
            ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],
            ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],
            ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],
            ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],
            ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],
            ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],
            ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],
            ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],
            ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],
            ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],
            ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],
            ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],
            ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],
            ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],
            ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],
            ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],
            ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],
            ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],
            ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],
            ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],
            ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],
            ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],
            ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],
            ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],
            ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]
          ]
        },
        naf: {
          wnd: 7,
          points: [
            ["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],
            ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],
            ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],
            ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],
            ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],
            ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],
            ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],
            ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],
            ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],
            ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],
            ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],
            ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],
            ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],
            ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],
            ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],
            ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],
            ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],
            ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],
            ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],
            ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],
            ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],
            ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],
            ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],
            ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],
            ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],
            ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],
            ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],
            ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],
            ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],
            ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],
            ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],
            ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],
            ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],
            ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],
            ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],
            ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],
            ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],
            ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],
            ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],
            ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],
            ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],
            ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],
            ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],
            ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],
            ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],
            ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],
            ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],
            ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],
            ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],
            ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],
            ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],
            ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],
            ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],
            ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],
            ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],
            ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],
            ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],
            ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],
            ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],
            ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],
            ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],
            ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],
            ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],
            ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],
            ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],
            ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],
            ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],
            ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],
            ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],
            ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],
            ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],
            ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],
            ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],
            ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],
            ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],
            ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],
            ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],
            ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],
            ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],
            ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],
            ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],
            ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],
            ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],
            ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],
            ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],
            ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],
            ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],
            ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],
            ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],
            ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],
            ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],
            ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],
            ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],
            ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],
            ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],
            ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],
            ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],
            ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],
            ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],
            ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],
            ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],
            ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],
            ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],
            ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],
            ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],
            ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],
            ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],
            ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],
            ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],
            ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],
            ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],
            ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],
            ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],
            ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],
            ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],
            ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],
            ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],
            ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],
            ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],
            ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],
            ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],
            ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],
            ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],
            ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],
            ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],
            ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],
            ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]
          ]
        }
      }
    });
    var q2 = y(ZB => {
      l();
      "use strict";
      var MS = ZB,
        Wu = N2(),
        BS = IS(),
        KTe = Is(),
        QB = KTe.assert;

      function eD(r) {
        r.type === "short" ? this.curve = new BS.short(r) : r.type === "edwards" ? this.curve = new BS.edwards(r) : this.curve = new BS.mont(r), this.g = this.curve.g, this.n = this.curve.n, this.hash = r.hash, QB(this.g.validate(), "Invalid curve"), QB(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
      }
      MS.PresetCurve = eD;

      function Yu(r, e) {
        Object.defineProperty(MS, r, {
          configurable: !0,
          enumerable: !0,
          get: function () {
            var t = new eD(e);
            return Object.defineProperty(MS, r, {
              configurable: !0,
              enumerable: !0,
              value: t
            }), t
          }
        })
      }
      Yu("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: Wu.sha256,
        gRed: !1,
        g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
      });
      Yu("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: Wu.sha256,
        gRed: !1,
        g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
      });
      Yu("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: Wu.sha256,
        gRed: !1,
        g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
      });
      Yu("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: Wu.sha384,
        gRed: !1,
        g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
      });
      Yu("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: Wu.sha512,
        gRed: !1,
        g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
      });
      Yu("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: Wu.sha256,
        gRed: !1,
        g: ["9"]
      });
      Yu("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: Wu.sha256,
        gRed: !1,
        g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
      });
      var DS;
      try {
        DS = XB()
      } catch (r) {
        DS = void 0
      }
      Yu("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: Wu.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [{
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        }, {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }],
        gRed: !1,
        g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", DS]
      })
    });
    var iD = y((ymt, tD) => {
      l();
      "use strict";
      var zTe = N2(),
        pl = vS(),
        rD = Vu();

      function Ju(r) {
        if (!(this instanceof Ju)) return new Ju(r);
        this.hash = r.hash, this.predResist = !!r.predResist, this.outLen = this.hash.outSize, this.minEntropy = r.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
        var e = pl.toArray(r.entropy, r.entropyEnc || "hex"),
          t = pl.toArray(r.nonce, r.nonceEnc || "hex"),
          i = pl.toArray(r.pers, r.persEnc || "hex");
        rD(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, t, i)
      }
      tD.exports = Ju;
      Ju.prototype._init = function (e, t, i) {
        var n = e.concat(t).concat(i);
        this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
        for (var s = 0; s < this.V.length; s++) this.K[s] = 0, this.V[s] = 1;
        this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656
      };
      Ju.prototype._hmac = function () {
        return new zTe.hmac(this.hash, this.K)
      };
      Ju.prototype._update = function (e) {
        var t = this._hmac().update(this.V).update([0]);
        e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), !!e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest())
      };
      Ju.prototype.reseed = function (e, t, i, n) {
        typeof t != "string" && (n = i, i = t, t = null), e = pl.toArray(e, t), i = pl.toArray(i, n), rD(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(i || [])), this._reseed = 1
      };
      Ju.prototype.generate = function (e, t, i, n) {
        if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
        typeof t != "string" && (n = i, i = t, t = null), i && (i = pl.toArray(i, n || "hex"), this._update(i));
        for (var s = []; s.length < e;) this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
        var o = s.slice(0, e);
        return this._update(i), this._reseed++, pl.encode(o, t)
      }
    });
    var sD = y((gmt, nD) => {
      l();
      "use strict";
      var jTe = La(),
        VTe = Is(),
        LS = VTe.assert;

      function xn(r, e) {
        this.ec = r, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc)
      }
      nD.exports = xn;
      xn.fromPublic = function (e, t, i) {
        return t instanceof xn ? t : new xn(e, {
          pub: t,
          pubEnc: i
        })
      };
      xn.fromPrivate = function (e, t, i) {
        return t instanceof xn ? t : new xn(e, {
          priv: t,
          privEnc: i
        })
      };
      xn.prototype.validate = function () {
        var e = this.getPublic();
        return e.isInfinity() ? {
          result: !1,
          reason: "Invalid public key"
        } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
          result: !0,
          reason: null
        } : {
          result: !1,
          reason: "Public key * N != O"
        } : {
          result: !1,
          reason: "Public key is not a point"
        }
      };
      xn.prototype.getPublic = function (e, t) {
        return typeof e == "string" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub
      };
      xn.prototype.getPrivate = function (e) {
        return e === "hex" ? this.priv.toString(16, 2) : this.priv
      };
      xn.prototype._importPrivate = function (e, t) {
        this.priv = new jTe(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n)
      };
      xn.prototype._importPublic = function (e, t) {
        if (e.x || e.y) {
          this.ec.curve.type === "mont" ? LS(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && LS(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
          return
        }
        this.pub = this.ec.curve.decodePoint(e, t)
      };
      xn.prototype.derive = function (e) {
        return e.validate() || LS(e.validate(), "public point not validated"), e.mul(this.priv).getX()
      };
      xn.prototype.sign = function (e, t, i) {
        return this.ec.sign(e, this, t, i)
      };
      xn.prototype.verify = function (e, t) {
        return this.ec.verify(e, t, this)
      };
      xn.prototype.inspect = function () {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
      }
    });
    var cD = y((bmt, oD) => {
      l();
      "use strict";
      var M2 = La(),
        FS = Is(),
        HTe = FS.assert;

      function B2(r, e) {
        if (r instanceof B2) return r;
        this._importDER(r, e) || (HTe(r.r && r.s, "Signature without r or s"), this.r = new M2(r.r, 16), this.s = new M2(r.s, 16), r.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = r.recoveryParam)
      }
      oD.exports = B2;

      function GTe() {
        this.place = 0
      }

      function US(r, e) {
        var t = r[e.place++];
        if (!(t & 128)) return t;
        var i = t & 15;
        if (i === 0 || i > 4) return !1;
        for (var n = 0, s = 0, o = e.place; s < i; s++, o++) n <<= 8, n |= r[o], n >>>= 0;
        return n <= 127 ? !1 : (e.place = o, n)
      }

      function aD(r) {
        for (var e = 0, t = r.length - 1; !r[e] && !(r[e + 1] & 128) && e < t;) e++;
        return e === 0 ? r : r.slice(e)
      }
      B2.prototype._importDER = function (e, t) {
        e = FS.toArray(e, t);
        var i = new GTe;
        if (e[i.place++] !== 48) return !1;
        var n = US(e, i);
        if (n === !1 || n + i.place !== e.length || e[i.place++] !== 2) return !1;
        var s = US(e, i);
        if (s === !1) return !1;
        var o = e.slice(i.place, s + i.place);
        if (i.place += s, e[i.place++] !== 2) return !1;
        var a = US(e, i);
        if (a === !1 || e.length !== a + i.place) return !1;
        var c = e.slice(i.place, a + i.place);
        if (o[0] === 0)
          if (o[1] & 128) o = o.slice(1);
          else return !1;
        if (c[0] === 0)
          if (c[1] & 128) c = c.slice(1);
          else return !1;
        return this.r = new M2(o), this.s = new M2(c), this.recoveryParam = null, !0
      };

      function KS(r, e) {
        if (e < 128) {
          r.push(e);
          return
        }
        var t = 1 + (Math.log(e) / Math.LN2 >>> 3);
        for (r.push(t | 128); --t;) r.push(e >>> (t << 3) & 255);
        r.push(e)
      }
      B2.prototype.toDER = function (e) {
        var t = this.r.toArray(),
          i = this.s.toArray();
        for (t[0] & 128 && (t = [0].concat(t)), i[0] & 128 && (i = [0].concat(i)), t = aD(t), i = aD(i); !i[0] && !(i[1] & 128);) i = i.slice(1);
        var n = [2];
        KS(n, t.length), n = n.concat(t), n.push(2), KS(n, i.length);
        var s = n.concat(i),
          o = [48];
        return KS(o, s.length), o = o.concat(s), FS.encode(o, e)
      }
    });
    var hD = y((mmt, uD) => {
      l();
      "use strict";
      var yl = La(),
        fD = iD(),
        $Te = Is(),
        zS = q2(),
        WTe = SS(),
        lD = $Te.assert,
        jS = sD(),
        D2 = cD();

      function io(r) {
        if (!(this instanceof io)) return new io(r);
        typeof r == "string" && (lD(Object.prototype.hasOwnProperty.call(zS, r), "Unknown curve " + r), r = zS[r]), r instanceof zS.PresetCurve && (r = {
          curve: r
        }), this.curve = r.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = r.curve.g, this.g.precompute(r.curve.n.bitLength() + 1), this.hash = r.hash || r.curve.hash
      }
      uD.exports = io;
      io.prototype.keyPair = function (e) {
        return new jS(this, e)
      };
      io.prototype.keyFromPrivate = function (e, t) {
        return jS.fromPrivate(this, e, t)
      };
      io.prototype.keyFromPublic = function (e, t) {
        return jS.fromPublic(this, e, t)
      };
      io.prototype.genKeyPair = function (e) {
        e || (e = {});
        for (var t = new fD({
          hash: this.hash,
          pers: e.pers,
          persEnc: e.persEnc || "utf8",
          entropy: e.entropy || WTe(this.hash.hmacStrength),
          entropyEnc: e.entropy && e.entropyEnc || "utf8",
          nonce: this.n.toArray()
        }), i = this.n.byteLength(), n = this.n.sub(new yl(2)); ;) {
          var s = new yl(t.generate(i));
          if (!(s.cmp(n) > 0)) return s.iaddn(1), this.keyFromPrivate(s)
        }
      };
      io.prototype._truncateToN = function (e, t) {
        var i = e.byteLength() * 8 - this.n.bitLength();
        return i > 0 && (e = e.ushrn(i)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
      };
      io.prototype.sign = function (e, t, i, n) {
        typeof i == "object" && (n = i, i = null), n || (n = {}), t = this.keyFromPrivate(t, i), e = this._truncateToN(new yl(e, 16));
        for (var s = this.n.byteLength(), o = t.getPrivate().toArray("be", s), a = e.toArray("be", s), c = new fD({
          hash: this.hash,
          entropy: o,
          nonce: a,
          pers: n.pers,
          persEnc: n.persEnc || "utf8"
        }), u = this.n.sub(new yl(1)), f = 0; ; f++) {
          var h = n.k ? n.k(f) : new yl(c.generate(this.n.byteLength()));
          if (h = this._truncateToN(h, !0), !(h.cmpn(1) <= 0 || h.cmp(u) >= 0)) {
            var d = this.g.mul(h);
            if (!d.isInfinity()) {
              var p = d.getX(),
                g = p.umod(this.n);
              if (g.cmpn(0) !== 0) {
                var m = h.invm(this.n).mul(g.mul(t.getPrivate()).iadd(e));
                if (m = m.umod(this.n), m.cmpn(0) !== 0) {
                  var E = (d.getY().isOdd() ? 1 : 0) | (p.cmp(g) !== 0 ? 2 : 0);
                  return n.canonical && m.cmp(this.nh) > 0 && (m = this.n.sub(m), E ^= 1), new D2({
                    r: g,
                    s: m,
                    recoveryParam: E
                  })
                }
              }
            }
          }
        }
      };
      io.prototype.verify = function (e, t, i, n) {
        e = this._truncateToN(new yl(e, 16)), i = this.keyFromPublic(i, n), t = new D2(t, "hex");
        var s = t.r,
          o = t.s;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1;
        var a = o.invm(this.n),
          c = a.mul(e).umod(this.n),
          u = a.mul(s).umod(this.n),
          f;
        return this.curve._maxwellTrick ? (f = this.g.jmulAdd(c, i.getPublic(), u), f.isInfinity() ? !1 : f.eqXToP(s)) : (f = this.g.mulAdd(c, i.getPublic(), u), f.isInfinity() ? !1 : f.getX().umod(this.n).cmp(s) === 0)
      };
      io.prototype.recoverPubKey = function (r, e, t, i) {
        lD((3 & t) === t, "The recovery param is more than two bits"), e = new D2(e, i);
        var n = this.n,
          s = new yl(r),
          o = e.r,
          a = e.s,
          c = t & 1,
          u = t >> 1;
        if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && u) throw new Error("Unable to find sencond key candinate");
        u ? o = this.curve.pointFromX(o.add(this.curve.n), c) : o = this.curve.pointFromX(o, c);
        var f = e.r.invm(n),
          h = n.sub(s).mul(f).umod(n),
          d = a.mul(f).umod(n);
        return this.g.mulAdd(h, o, d)
      };
      io.prototype.getKeyRecoveryParam = function (r, e, t, i) {
        if (e = new D2(e, i), e.recoveryParam !== null) return e.recoveryParam;
        for (var n = 0; n < 4; n++) {
          var s;
          try {
            s = this.recoverPubKey(r, e, n)
          } catch (o) {
            continue
          }
          if (s.eq(t)) return n
        }
        throw new Error("Unable to find valid recovery factor")
      }
    });
    var gD = y((vmt, dD) => {
      l();
      "use strict";
      var Q1 = Is(),
        pD = Q1.assert,
        yD = Q1.parseBytes,
        Rd = Q1.cachedProperty;

      function Wi(r, e) {
        this.eddsa = r, this._secret = yD(e.secret), r.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = yD(e.pub)
      }
      Wi.fromPublic = function (e, t) {
        return t instanceof Wi ? t : new Wi(e, {
          pub: t
        })
      };
      Wi.fromSecret = function (e, t) {
        return t instanceof Wi ? t : new Wi(e, {
          secret: t
        })
      };
      Wi.prototype.secret = function () {
        return this._secret
      };
      Rd(Wi, "pubBytes", function () {
        return this.eddsa.encodePoint(this.pub())
      });
      Rd(Wi, "pub", function () {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
      });
      Rd(Wi, "privBytes", function () {
        var e = this.eddsa,
          t = this.hash(),
          i = e.encodingLength - 1,
          n = t.slice(0, e.encodingLength);
        return n[0] &= 248, n[i] &= 127, n[i] |= 64, n
      });
      Rd(Wi, "priv", function () {
        return this.eddsa.decodeInt(this.privBytes())
      });
      Rd(Wi, "hash", function () {
        return this.eddsa.hash().update(this.secret()).digest()
      });
      Rd(Wi, "messagePrefix", function () {
        return this.hash().slice(this.eddsa.encodingLength)
      });
      Wi.prototype.sign = function (e) {
        return pD(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this)
      };
      Wi.prototype.verify = function (e, t) {
        return this.eddsa.verify(e, t, this)
      };
      Wi.prototype.getSecret = function (e) {
        return pD(this._secret, "KeyPair is public only"), Q1.encode(this.secret(), e)
      };
      Wi.prototype.getPublic = function (e) {
        return Q1.encode(this.pubBytes(), e)
      };
      dD.exports = Wi
    });
    var mD = y((wmt, bD) => {
      l();
      "use strict";
      var YTe = La(),
        L2 = Is(),
        JTe = L2.assert,
        F2 = L2.cachedProperty,
        XTe = L2.parseBytes;

      function gl(r, e) {
        this.eddsa = r, typeof e != "object" && (e = XTe(e)), Array.isArray(e) && (e = {
          R: e.slice(0, r.encodingLength),
          S: e.slice(r.encodingLength)
        }), JTe(e.R && e.S, "Signature without R or S"), r.isPoint(e.R) && (this._R = e.R), e.S instanceof YTe && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded
      }
      F2(gl, "S", function () {
        return this.eddsa.decodeInt(this.Sencoded())
      });
      F2(gl, "R", function () {
        return this.eddsa.decodePoint(this.Rencoded())
      });
      F2(gl, "Rencoded", function () {
        return this.eddsa.encodePoint(this.R())
      });
      F2(gl, "Sencoded", function () {
        return this.eddsa.encodeInt(this.S())
      });
      gl.prototype.toBytes = function () {
        return this.Rencoded().concat(this.Sencoded())
      };
      gl.prototype.toHex = function () {
        return L2.encode(this.toBytes(), "hex").toUpperCase()
      };
      bD.exports = gl
    });
    var SD = y((_mt, vD) => {
      l();
      "use strict";
      var ZTe = N2(),
        QTe = q2(),
        kd = Is(),
        e7e = kd.assert,
        wD = kd.parseBytes,
        _D = gD(),
        ED = mD();

      function ys(r) {
        if (e7e(r === "ed25519", "only tested with ed25519 so far"), !(this instanceof ys)) return new ys(r);
        r = QTe[r].curve, this.curve = r, this.g = r.g, this.g.precompute(r.n.bitLength() + 1), this.pointClass = r.point().constructor, this.encodingLength = Math.ceil(r.n.bitLength() / 8), this.hash = ZTe.sha512
      }
      vD.exports = ys;
      ys.prototype.sign = function (e, t) {
        e = wD(e);
        var i = this.keyFromSecret(t),
          n = this.hashInt(i.messagePrefix(), e),
          s = this.g.mul(n),
          o = this.encodePoint(s),
          a = this.hashInt(o, i.pubBytes(), e).mul(i.priv()),
          c = n.add(a).umod(this.curve.n);
        return this.makeSignature({
          R: s,
          S: c,
          Rencoded: o
        })
      };
      ys.prototype.verify = function (e, t, i) {
        e = wD(e), t = this.makeSignature(t);
        var n = this.keyFromPublic(i),
          s = this.hashInt(t.Rencoded(), n.pubBytes(), e),
          o = this.g.mul(t.S()),
          a = t.R().add(n.pub().mul(s));
        return a.eq(o)
      };
      ys.prototype.hashInt = function () {
        for (var e = this.hash(), t = 0; t < arguments.length; t++) e.update(arguments[t]);
        return kd.intFromLE(e.digest()).umod(this.curve.n)
      };
      ys.prototype.keyFromPublic = function (e) {
        return _D.fromPublic(this, e)
      };
      ys.prototype.keyFromSecret = function (e) {
        return _D.fromSecret(this, e)
      };
      ys.prototype.makeSignature = function (e) {
        return e instanceof ED ? e : new ED(this, e)
      };
      ys.prototype.encodePoint = function (e) {
        var t = e.getY().toArray("le", this.encodingLength);
        return t[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, t
      };
      ys.prototype.decodePoint = function (e) {
        e = kd.parseBytes(e);
        var t = e.length - 1,
          i = e.slice(0, t).concat(e[t] & ~128),
          n = (e[t] & 128) != 0,
          s = kd.intFromLE(i);
        return this.curve.pointFromY(s, n)
      };
      ys.prototype.encodeInt = function (e) {
        return e.toArray("le", this.encodingLength)
      };
      ys.prototype.decodeInt = function (e) {
        return kd.intFromLE(e)
      };
      ys.prototype.isPoint = function (e) {
        return e instanceof this.pointClass
      }
    });
    var AD = y(xD => {
      l();
      "use strict";
      var bl = xD;
      bl.version = ZM().version;
      bl.utils = Is();
      bl.rand = SS();
      bl.curve = IS();
      bl.curves = q2();
      bl.ec = hD();
      bl.eddsa = SD()
    });
    var TD = y((Smt, ID) => {
      l();
      var t7e = AD().ec,
        Ga = new t7e("secp256k1"),
        Ft = Ga.curve,
        Sr = Ft.n.constructor;

      function r7e(r, e) {
        let t = new Sr(e);
        if (t.cmp(Ft.p) >= 0) return null;
        t = t.toRed(Ft.red);
        let i = t.redSqr().redIMul(t).redIAdd(Ft.b).redSqrt();
        return r === 3 !== i.isOdd() && (i = i.redNeg()), Ga.keyPair({
          pub: {
            x: t,
            y: i
          }
        })
      }

      function i7e(r, e, t) {
        let i = new Sr(e),
          n = new Sr(t);
        if (i.cmp(Ft.p) >= 0 || n.cmp(Ft.p) >= 0 || (i = i.toRed(Ft.red), n = n.toRed(Ft.red), (r === 6 || r === 7) && n.isOdd() !== (r === 7))) return null;
        let s = i.redSqr().redIMul(i);
        return n.redSqr().redISub(s.redIAdd(Ft.b)).isZero() ? Ga.keyPair({
          pub: {
            x: i,
            y: n
          }
        }) : null
      }

      function Xu(r) {
        let e = r[0];
        switch (e) {
          case 2:
          case 3:
            return r.length !== 33 ? null : r7e(e, r.subarray(1, 33));
          case 4:
          case 6:
          case 7:
            return r.length !== 65 ? null : i7e(e, r.subarray(1, 33), r.subarray(33, 65));
          default:
            return null
        }
      }

      function ml(r, e) {
        let t = e.encode(null, r.length === 33);
        for (let i = 0; i < r.length; ++i) r[i] = t[i]
      }
      ID.exports = {
        contextRandomize() {
          return 0
        },
        privateKeyVerify(r) {
          let e = new Sr(r);
          return e.cmp(Ft.n) < 0 && !e.isZero() ? 0 : 1
        },
        privateKeyNegate(r) {
          let e = new Sr(r),
            t = Ft.n.sub(e).umod(Ft.n).toArrayLike(Uint8Array, "be", 32);
          return r.set(t), 0
        },
        privateKeyTweakAdd(r, e) {
          let t = new Sr(e);
          if (t.cmp(Ft.n) >= 0 || (t.iadd(new Sr(r)), t.cmp(Ft.n) >= 0 && t.isub(Ft.n), t.isZero())) return 1;
          let i = t.toArrayLike(Uint8Array, "be", 32);
          return r.set(i), 0
        },
        privateKeyTweakMul(r, e) {
          let t = new Sr(e);
          if (t.cmp(Ft.n) >= 0 || t.isZero()) return 1;
          t.imul(new Sr(r)), t.cmp(Ft.n) >= 0 && (t = t.umod(Ft.n));
          let i = t.toArrayLike(Uint8Array, "be", 32);
          return r.set(i), 0
        },
        publicKeyVerify(r) {
          return Xu(r) === null ? 1 : 0
        },
        publicKeyCreate(r, e) {
          let t = new Sr(e);
          if (t.cmp(Ft.n) >= 0 || t.isZero()) return 1;
          let i = Ga.keyFromPrivate(e).getPublic();
          return ml(r, i), 0
        },
        publicKeyConvert(r, e) {
          let t = Xu(e);
          if (t === null) return 1;
          let i = t.getPublic();
          return ml(r, i), 0
        },
        publicKeyNegate(r, e) {
          let t = Xu(e);
          if (t === null) return 1;
          let i = t.getPublic();
          return i.y = i.y.redNeg(), ml(r, i), 0
        },
        publicKeyCombine(r, e) {
          let t = new Array(e.length);
          for (let n = 0; n < e.length; ++n)
            if (t[n] = Xu(e[n]), t[n] === null) return 1;
          let i = t[0].getPublic();
          for (let n = 1; n < t.length; ++n) i = i.add(t[n].pub);
          return i.isInfinity() ? 2 : (ml(r, i), 0)
        },
        publicKeyTweakAdd(r, e, t) {
          let i = Xu(e);
          if (i === null) return 1;
          if (t = new Sr(t), t.cmp(Ft.n) >= 0) return 2;
          let n = i.getPublic().add(Ft.g.mul(t));
          return n.isInfinity() ? 2 : (ml(r, n), 0)
        },
        publicKeyTweakMul(r, e, t) {
          let i = Xu(e);
          if (i === null) return 1;
          if (t = new Sr(t), t.cmp(Ft.n) >= 0 || t.isZero()) return 2;
          let n = i.getPublic().mul(t);
          return ml(r, n), 0
        },
        signatureNormalize(r) {
          let e = new Sr(r.subarray(0, 32)),
            t = new Sr(r.subarray(32, 64));
          return e.cmp(Ft.n) >= 0 || t.cmp(Ft.n) >= 0 ? 1 : (t.cmp(Ga.nh) === 1 && r.set(Ft.n.sub(t).toArrayLike(Uint8Array, "be", 32), 32), 0)
        },
        signatureExport(r, e) {
          let t = e.subarray(0, 32),
            i = e.subarray(32, 64);
          if (new Sr(t).cmp(Ft.n) >= 0 || new Sr(i).cmp(Ft.n) >= 0) return 1;
          let {
            output: n
          } = r, s = n.subarray(4, 4 + 33);
          s[0] = 0, s.set(t, 1);
          let o = 33,
            a = 0;
          for (; o > 1 && s[a] === 0 && !(s[a + 1] & 128); --o, ++a);
          if (s = s.subarray(a), s[0] & 128 || o > 1 && s[0] === 0 && !(s[1] & 128)) return 1;
          let c = n.subarray(6 + 33, 6 + 33 + 33);
          c[0] = 0, c.set(i, 1);
          let u = 33,
            f = 0;
          for (; u > 1 && c[f] === 0 && !(c[f + 1] & 128); --u, ++f);
          return c = c.subarray(f), c[0] & 128 || u > 1 && c[0] === 0 && !(c[1] & 128) ? 1 : (r.outputlen = 6 + o + u, n[0] = 48, n[1] = r.outputlen - 2, n[2] = 2, n[3] = s.length, n.set(s, 4), n[4 + o] = 2, n[5 + o] = c.length, n.set(c, 6 + o), 0)
        },
        signatureImport(r, e) {
          if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return 1;
          let t = e[3];
          if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return 1;
          let i = e[5 + t];
          if (i === 0 || 6 + t + i !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || i > 1 && e[t + 6] === 0 && !(e[t + 7] & 128)) return 1;
          let n = e.subarray(4, 4 + t);
          if (n.length === 33 && n[0] === 0 && (n = n.subarray(1)), n.length > 32) return 1;
          let s = e.subarray(6 + t);
          if (s.length === 33 && s[0] === 0 && (s = s.slice(1)), s.length > 32) throw new Error("S length is too long");
          let o = new Sr(n);
          o.cmp(Ft.n) >= 0 && (o = new Sr(0));
          let a = new Sr(e.subarray(6 + t));
          return a.cmp(Ft.n) >= 0 && (a = new Sr(0)), r.set(o.toArrayLike(Uint8Array, "be", 32), 0), r.set(a.toArrayLike(Uint8Array, "be", 32), 32), 0
        },
        ecdsaSign(r, e, t, i, n) {
          if (n) {
            let a = n;
            n = c => {
              let u = a(e, t, null, i, c);
              if (!(u instanceof Uint8Array && u.length === 32)) throw new Error("This is the way");
              return new Sr(u)
            }
          }
          let s = new Sr(t);
          if (s.cmp(Ft.n) >= 0 || s.isZero()) return 1;
          let o;
          try {
            o = Ga.sign(e, t, {
              canonical: !0,
              k: n,
              pers: i
            })
          } catch (a) {
            return 1
          }
          return r.signature.set(o.r.toArrayLike(Uint8Array, "be", 32), 0), r.signature.set(o.s.toArrayLike(Uint8Array, "be", 32), 32), r.recid = o.recoveryParam, 0
        },
        ecdsaVerify(r, e, t) {
          let i = {
            r: r.subarray(0, 32),
            s: r.subarray(32, 64)
          },
            n = new Sr(i.r),
            s = new Sr(i.s);
          if (n.cmp(Ft.n) >= 0 || s.cmp(Ft.n) >= 0) return 1;
          if (s.cmp(Ga.nh) === 1 || n.isZero() || s.isZero()) return 3;
          let o = Xu(t);
          if (o === null) return 2;
          let a = o.getPublic();
          return Ga.verify(e, i, a) ? 0 : 3
        },
        ecdsaRecover(r, e, t, i) {
          let n = {
            r: e.slice(0, 32),
            s: e.slice(32, 64)
          },
            s = new Sr(n.r),
            o = new Sr(n.s);
          if (s.cmp(Ft.n) >= 0 || o.cmp(Ft.n) >= 0) return 1;
          if (s.isZero() || o.isZero()) return 2;
          let a;
          try {
            a = Ga.recoverPubKey(i, n, t)
          } catch (c) {
            return 2
          }
          return ml(r, a), 0
        },
        ecdh(r, e, t, i, n, s, o) {
          let a = Xu(e);
          if (a === null) return 1;
          let c = new Sr(t);
          if (c.cmp(Ft.n) >= 0 || c.isZero()) return 2;
          let u = a.getPublic().mul(c);
          if (n === void 0) {
            let f = u.encode(null, !0),
              h = Ga.hash().update(f).digest();
            for (let d = 0; d < 32; ++d) r[d] = h[d]
          } else {
            s || (s = new Uint8Array(32));
            let f = u.getX().toArray("be", 32);
            for (let g = 0; g < 32; ++g) s[g] = f[g];
            o || (o = new Uint8Array(32));
            let h = u.getY().toArray("be", 32);
            for (let g = 0; g < 32; ++g) o[g] = h[g];
            let d = n(s, o, i);
            if (!(d instanceof Uint8Array && d.length === r.length)) return 2;
            r.set(d)
          }
          return 0
        }
      }
    });
    var kD = y((xmt, RD) => {
      l();
      RD.exports = JM()(TD())
    });
    var ND = y((Amt, PD) => {
      l();
      "use strict";
      var $o = kD(),
        CD = hd(),
        OD = "sha2-256";
      PD.exports = r => {
        let e = 32;

        function t() {
          let f;
          do f = r(32); while (!$o.privateKeyVerify(f));
          return f
        }
        async function i(f, h) {
          let d = await CD.digest(h, OD),
            p = $o.ecdsaSign(d, f);
          return $o.signatureExport(p.signature)
        }
        async function n(f, h, d) {
          let p = await CD.digest(d, OD);
          return h = $o.signatureImport(h), $o.ecdsaVerify(h, p, f)
        }

        function s(f) {
          if (!$o.publicKeyVerify(f)) throw new Error("Invalid public key");
          return $o.publicKeyConvert(f, !0)
        }

        function o(f) {
          return $o.publicKeyConvert(f, !1)
        }

        function a(f) {
          if (!$o.privateKeyVerify(f)) throw new Error("Invalid private key")
        }

        function c(f) {
          if (!$o.publicKeyVerify(f)) throw new Error("Invalid public key")
        }

        function u(f) {
          return a(f), $o.publicKeyCreate(f)
        }
        return {
          generateKey: t,
          privateKeyLength: e,
          hashAndSign: i,
          hashAndVerify: n,
          compressPublicKey: s,
          decompressPublicKey: o,
          validatePrivateKey: a,
          validatePublicKey: c,
          computePublicKey: u
        }
      }
    });
    var DD = y((Imt, qD) => {
      l();
      "use strict";
      var MD = hd(),
        n7e = xe(),
        BD = Lr(),
        s7e = ct(),
        o7e = m2();
      qD.exports = (r, e, t) => {
        t = t || ND()(e);
        class i {
          constructor(u) {
            t.validatePublicKey(u), this._key = u
          }
          verify(u, f) {
            return t.hashAndVerify(this._key, f, u)
          }
          marshal() {
            return t.compressPublicKey(this._key)
          }
          get bytes() {
            return r.PublicKey.encode({
              Type: r.KeyType.Secp256k1,
              Data: this.marshal()
            }).finish()
          }
          equals(u) {
            return BD(this.bytes, u.bytes)
          }
          hash() {
            return MD.multihashing(this.bytes, "sha2-256")
          }
        }
        class n {
          constructor(u, f) {
            this._key = u, this._publicKey = f || t.computePublicKey(u), t.validatePrivateKey(this._key), t.validatePublicKey(this._publicKey)
          }
          sign(u) {
            return t.hashAndSign(this._key, u)
          }
          get public() {
            return new i(this._publicKey)
          }
          marshal() {
            return this._key
          }
          get bytes() {
            return r.PrivateKey.encode({
              Type: r.KeyType.Secp256k1,
              Data: this.marshal()
            }).finish()
          }
          equals(u) {
            return BD(this.bytes, u.bytes)
          }
          hash() {
            return MD.multihashing(this.bytes, "sha2-256")
          }
          async id() {
            let u = await this.public.hash();
            return s7e(u, "base58btc")
          }
          async export(u, f = "libp2p-key") {
            if (f === "libp2p-key") return o7e.export(this.bytes, u);
            throw n7e(new Error(`export format '${f}' is not supported`), "ERR_INVALID_EXPORT_FORMAT")
          }
        }

        function s(c) {
          return new n(c)
        }

        function o(c) {
          return new i(c)
        }
        async function a() {
          let c = await t.generateKey();
          return new n(c)
        }
        return {
          Secp256k1PublicKey: i,
          Secp256k1PrivateKey: n,
          unmarshalSecp256k1PrivateKey: s,
          unmarshalSecp256k1PublicKey: o,
          generateKeyPair: a
        }
      }
    });
    var FD = y((Tmt, LD) => {
      l();
      "use strict";
      LD.exports = {
        SHA1: 20,
        SHA256: 32,
        SHA512: 64
      }
    });
    var VS = y(UD => {
      l();
      "use strict";
      var KD = z1(),
        a7e = FD(),
        c7e = {
          SHA1: "SHA-1",
          SHA256: "SHA-256",
          SHA512: "SHA-512"
        },
        u7e = async (r, e) => {
          let t = await KD.get().subtle.sign({
            name: "HMAC"
          }, r, e);
          return new Uint8Array(t, t.byteOffset, t.byteLength)
        };
      UD.create = async function (r, e) {
        let t = c7e[r],
          i = await KD.get().subtle.importKey("raw", e, {
            name: "HMAC",
            hash: {
              name: t
            }
          }, !1, ["sign"]);
        return {
          async digest(n) {
            return u7e(i, n)
          },
          length: a7e[r]
        }
      }
    });
    var GD = y((kmt, zD) => {
      l();
      "use strict";
      var jD = xe(),
        VD = xi(),
        f7e = gt(),
        l7e = VS(),
        HD = {
          "AES-128": {
            ivSize: 16,
            keySize: 16
          },
          "AES-256": {
            ivSize: 16,
            keySize: 32
          },
          Blowfish: {
            ivSize: 8,
            cipherKeySize: 32
          }
        };
      zD.exports = async (r, e, t) => {
        let i = HD[r];
        if (!i) {
          let O = Object.keys(HD).join(" / ");
          throw jD(new Error(`unknown cipher type '${r}'. Must be ${O}`), "ERR_INVALID_CIPHER_TYPE")
        }
        if (!e) throw jD(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
        let n = i.keySize,
          s = i.ivSize,
          o = 20,
          a = f7e("key expansion"),
          c = 2 * (s + n + o),
          u = await l7e.create(e, t),
          f = await u.digest(a),
          h = [],
          d = 0;
        for (; d < c;) {
          let O = await u.digest(VD([f, a])),
            q = O.length;
          d + q > c && (q = c - d), h.push(O), d += q, f = await u.digest(f)
        }
        let p = c / 2,
          g = VD(h),
          m = g.slice(0, p),
          E = g.slice(p, c),
          w = O => ({
            iv: O.slice(0, s),
            cipherKey: O.slice(s, s + n),
            macKey: O.slice(s + n)
          });
        return {
          k1: w(m),
          k2: w(E)
        }
      }
    });
    var WD = y((Pmt, $D) => {
      l();
      "use strict";
      var h7e = xe();
      $D.exports = function (r, e) {
        if (!r.includes(e)) {
          let t = r.join(" / ");
          throw h7e(new Error(`Unknown curve: ${e}. Must be ${t}`), "ERR_INVALID_CURVE")
        }
      }
    });
    var eL = y(YD => {
      l();
      "use strict";
      var d7e = xe(),
        ey = z1(),
        {
          base64urlToBuffer: JD
        } = b2(),
        p7e = WD(),
        HS = ct(),
        y7e = xi(),
        g7e = Lr(),
        XD = {
          "P-256": 256,
          "P-384": 384,
          "P-521": 521
        };
      YD.generateEphmeralKeyPair = async function (r) {
        p7e(Object.keys(XD), r);
        let e = await ey.get().subtle.generateKey({
          name: "ECDH",
          namedCurve: r
        }, !0, ["deriveBits"]),
          t = async (n, s) => {
            let o;
            s ? o = await ey.get().subtle.importKey("jwk", m7e(r, s), {
              name: "ECDH",
              namedCurve: r
            }, !1, ["deriveBits"]) : o = e.privateKey;
            let a = [await ey.get().subtle.importKey("jwk", ZD(r, n), {
              name: "ECDH",
              namedCurve: r
            }, !1, []), o],
              c = await ey.get().subtle.deriveBits({
                name: "ECDH",
                namedCurve: r,
                public: a[0]
              }, a[1], XD[r]);
            return new Uint8Array(c, c.byteOffset, c.byteLength)
          }, i = await ey.get().subtle.exportKey("jwk", e.publicKey);
        return {
          key: b7e(i),
          genSharedKey: t
        }
      };
      var QD = {
        "P-256": 32,
        "P-384": 48,
        "P-521": 66
      };

      function b7e(r) {
        let e = QD[r.crv];
        return y7e([Uint8Array.from([4]), JD(r.x, e), JD(r.y, e)], 1 + e * 2)
      }

      function ZD(r, e) {
        let t = QD[r];
        if (g7e(!e.slice(0, 1), Uint8Array.from([4]))) throw d7e(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT");
        return {
          kty: "EC",
          crv: r,
          x: HS(e.slice(1, t + 1), "base64url"),
          y: HS(e.slice(1 + t), "base64url"),
          ext: !0
        }
      }
      var m7e = (r, e) => ({
        ...ZD(r, e.public),
        d: HS(e.private, "base64url")
      })
    });
    var rL = y((Omt, tL) => {
      l();
      "use strict";
      var v7e = eL();
      tL.exports = async r => v7e.generateEphmeralKeyPair(r)
    });
    var K2 = y((Nmt, iL) => {
      l();
      "use strict";
      var $a = Ym();
      Bc();
      iS();
      var GS = At(),
        ty = xe(),
        w7e = gt(),
        _7e = rM(),
        no = {
          rsa: KM(),
          ed25519: WM(),
          secp256k1: DD()($a, H1())
        },
        U2 = {
          message: "secp256k1 support requires libp2p-crypto-secp256k1 package",
          code: "ERR_MISSING_PACKAGE"
        };

      function Pd(r) {
        let e = no[r.toLowerCase()];
        if (!e) {
          let t = Object.keys(no).join(" / ");
          throw ty(new Error(`invalid or unsupported key type ${r}. Must be ${t}`), "ERR_UNSUPPORTED_KEY_TYPE")
        }
        return e
      }
      var E7e = async (r, e) => Pd(r).generateKeyPair(e), S7e = async (r, e, t) => {
        let i = Pd(r);
        if (r.toLowerCase() !== "ed25519") throw ty(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
        return i.generateKeyPairFromSeed(e, t)
      }, x7e = r => {
        let e = $a.PublicKey.decode(r),
          t = e.Data;
        switch (e.Type) {
          case $a.KeyType.RSA:
            return no.rsa.unmarshalRsaPublicKey(t);
          case $a.KeyType.Ed25519:
            return no.ed25519.unmarshalEd25519PublicKey(t);
          case $a.KeyType.Secp256k1:
            if (no.secp256k1) return no.secp256k1.unmarshalSecp256k1PublicKey(t);
            throw ty(new Error(U2.message), U2.code);
          default:
            Pd(e.Type)
        }
      }, A7e = (r, e) => (e = (e || "rsa").toLowerCase(), Pd(e), r.bytes), nL = async r => {
        let e = $a.PrivateKey.decode(r),
          t = e.Data;
        switch (e.Type) {
          case $a.KeyType.RSA:
            return no.rsa.unmarshalRsaPrivateKey(t);
          case $a.KeyType.Ed25519:
            return no.ed25519.unmarshalEd25519PrivateKey(t);
          case $a.KeyType.Secp256k1:
            if (no.secp256k1) return no.secp256k1.unmarshalSecp256k1PrivateKey(t);
            throw ty(new Error(U2.message), U2.code);
          default:
            Pd(e.Type)
        }
      }, I7e = (r, e) => (e = (e || "rsa").toLowerCase(), Pd(e), r.bytes), T7e = async (r, e) => {
        try {
          let n = await _7e.import(r, e);
          return nL(n)
        } catch (n) { }
        let t = GS.pki.decryptRsaPrivateKey(r, e);
        if (t === null) throw ty(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
        let i = GS.asn1.toDer(GS.pki.privateKeyToAsn1(t));
        return i = w7e(i.getBytes(), "ascii"), no.rsa.unmarshalRsaPrivateKey(i)
      };
      iL.exports = {
        supportedKeys: no,
        keysPBM: $a,
        keyStretcher: GD(),
        generateEphemeralKeyPair: rL(),
        generateKeyPair: E7e,
        generateKeyPairFromSeed: S7e,
        unmarshalPublicKey: x7e,
        marshalPublicKey: A7e,
        unmarshalPrivateKey: nL,
        marshalPrivateKey: I7e,
        import: T7e
      }
    });
    var z2 = y((qmt, $S) => {
      l();
      "use strict";

      function R7e(r, {
        className: e,
        symbolName: t
      }) {
        let i = Symbol.for(t),
          n = {
            [e]: class extends r {
              constructor(...s) {
                super(...s);
                Object.defineProperty(this, i, {
                  value: !0
                })
              }
              get [Symbol.toStringTag]() {
                return e
              }
            }
          }[e];
        return n[`is${e}`] = s => !!(s && s[i]), n
      }

      function k7e(r, {
        className: e,
        symbolName: t,
        withoutNew: i
      }) {
        let n = Symbol.for(t),
          s = {
            [e]: function (...o) {
              if (i && !(this instanceof s)) return new s(...o);
              let a = r.call(this, ...o) || this;
              return a && !a[n] && Object.defineProperty(a, n, {
                value: !0
              }), a
            }
          }[e];
        return s.prototype = Object.create(r.prototype), s.prototype.constructor = s, Object.defineProperty(s.prototype, Symbol.toStringTag, {
          get() {
            return e
          }
        }), s[`is${e}`] = o => !!(o && o[n]), s
      }
      $S.exports = R7e;
      $S.exports.proto = k7e
    });
    var aL = y((Mmt, sL) => {
      l();
      "use strict";
      var Cd = bi(),
        oL = Cd.Reader,
        P7e = Cd.Writer,
        Ai = Cd.util,
        ry = Cd.roots["libp2p-peer-id"] || (Cd.roots["libp2p-peer-id"] = {});
      ry.PeerIdProto = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.id = Ai.newBuffer([]), r.prototype.pubKey = Ai.newBuffer([]), r.prototype.privKey = Ai.newBuffer([]), r.encode = function (t, i) {
          return i || (i = P7e.create()), i.uint32(10).bytes(t.id), t.pubKey != null && Object.hasOwnProperty.call(t, "pubKey") && i.uint32(18).bytes(t.pubKey), t.privKey != null && Object.hasOwnProperty.call(t, "privKey") && i.uint32(26).bytes(t.privKey), i
        }, r.decode = function (t, i) {
          t instanceof oL || (t = oL.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new ry.PeerIdProto; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.id = t.bytes();
                break;
              case 2:
                s.pubKey = t.bytes();
                break;
              case 3:
                s.privKey = t.bytes();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          if (!s.hasOwnProperty("id")) throw Ai.ProtocolError("missing required 'id'", {
            instance: s
          });
          return s
        }, r.fromObject = function (t) {
          if (t instanceof ry.PeerIdProto) return t;
          var i = new ry.PeerIdProto;
          return t.id != null && (typeof t.id == "string" ? Ai.base64.decode(t.id, i.id = Ai.newBuffer(Ai.base64.length(t.id)), 0) : t.id.length && (i.id = t.id)), t.pubKey != null && (typeof t.pubKey == "string" ? Ai.base64.decode(t.pubKey, i.pubKey = Ai.newBuffer(Ai.base64.length(t.pubKey)), 0) : t.pubKey.length && (i.pubKey = t.pubKey)), t.privKey != null && (typeof t.privKey == "string" ? Ai.base64.decode(t.privKey, i.privKey = Ai.newBuffer(Ai.base64.length(t.privKey)), 0) : t.privKey.length && (i.privKey = t.privKey)), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          return i.defaults && (i.bytes === String ? n.id = "" : (n.id = [], i.bytes !== Array && (n.id = Ai.newBuffer(n.id))), i.bytes === String ? n.pubKey = "" : (n.pubKey = [], i.bytes !== Array && (n.pubKey = Ai.newBuffer(n.pubKey))), i.bytes === String ? n.privKey = "" : (n.privKey = [], i.bytes !== Array && (n.privKey = Ai.newBuffer(n.privKey)))), t.id != null && t.hasOwnProperty("id") && (n.id = i.bytes === String ? Ai.base64.encode(t.id, 0, t.id.length) : i.bytes === Array ? Array.prototype.slice.call(t.id) : t.id), t.pubKey != null && t.hasOwnProperty("pubKey") && (n.pubKey = i.bytes === String ? Ai.base64.encode(t.pubKey, 0, t.pubKey.length) : i.bytes === Array ? Array.prototype.slice.call(t.pubKey) : t.pubKey), t.privKey != null && t.hasOwnProperty("privKey") && (n.privKey = i.bytes === String ? Ai.base64.encode(t.privKey, 0, t.privKey.length) : i.bytes === Array ? Array.prototype.slice.call(t.privKey) : t.privKey), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, Cd.util.toJSONOptions)
        }, r
      }();
      sL.exports = ry
    });
    var Et = y((Ts, cL) => {
      l();
      "use strict";
      var vl = Do(),
        WS = at(),
        Wa = K2(),
        C7e = z2(),
        {
          PeerIdProto: uL
        } = aL(),
        wl = Lr(),
        iy = gt(),
        O7e = ct(),
        fL = class {
          constructor(e, t, i) {
            if (!(e instanceof Uint8Array)) throw new Error("invalid id provided");
            if (t && i && !wl(t.public.bytes, i.bytes)) throw new Error("inconsistent arguments");
            this._id = e, this._idB58String = vl.toB58String(this.id), this._privKey = t, this._pubKey = i
          }
          get id() {
            return this._id
          }
          set id(e) {
            throw new Error("Id is immutable")
          }
          get privKey() {
            return this._privKey
          }
          set privKey(e) {
            this._privKey = e
          }
          get pubKey() {
            if (this._pubKey) return this._pubKey;
            if (this._privKey) return this._privKey.public;
            try {
              let e = vl.decode(this.id);
              e.name === "identity" && (this._pubKey = Wa.unmarshalPublicKey(e.digest))
            } catch (e) { }
            return this._pubKey
          }
          set pubKey(e) {
            this._pubKey = e
          }
          marshalPubKey() {
            if (this.pubKey) return Wa.marshalPublicKey(this.pubKey)
          }
          marshalPrivKey() {
            if (this.privKey) return Wa.marshalPrivateKey(this.privKey)
          }
          marshal(e) {
            return uL.encode({
              id: this.toBytes(),
              pubKey: this.marshalPubKey(),
              privKey: e ? null : this.marshalPrivKey()
            }).finish()
          }
          toPrint() {
            let e = this.toB58String();
            e.startsWith("Qm") && (e = e.slice(2));
            let t = 6;
            return e.length < t && (t = e.length), "<peer.ID " + e.substr(0, t) + ">"
          }
          toJSON() {
            return {
              id: this.toB58String(),
              privKey: lL(this.marshalPrivKey()),
              pubKey: lL(this.marshalPubKey())
            }
          }
          toHexString() {
            return vl.toHexString(this.id)
          }
          toBytes() {
            return this.id
          }
          toB58String() {
            return this._idB58String
          }
          toString() {
            if (!this._idCIDString) {
              let e = new WS(1, "libp2p-key", this.id, "base32");
              Object.defineProperty(this, "_idCIDString", {
                value: e.toBaseEncodedString("base32"),
                enumerable: !1
              })
            }
            return this._idCIDString
          }
          equals(e) {
            if (e instanceof Uint8Array) return wl(this.id, e);
            if (e.id) return wl(this.id, e.id);
            throw new Error("not valid Id")
          }
          isEqual(e) {
            return this.equals(e)
          }
          isValid() {
            return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && wl(this.privKey.public.bytes, this.pubKey.bytes))
          }
          hasInlinePublicKey() {
            try {
              if (vl.decode(this.id).name === "identity") return !0
            } catch (e) { }
            return !1
          }
        },
        Ya = C7e(fL, {
          className: "PeerId",
          symbolName: "@libp2p/js-peer-id/PeerId"
        });
      Ts = cL.exports = Ya;
      var ny = r => r.bytes.length <= 42 ? vl.encode(r.bytes, "identity") : r.hash(),
        YS = async (r, e) => {
          let t = await ny(e);
          return new Ya(t, r, e)
        };
      Ts.create = async r => {
        r = r || {}, r.bits = r.bits || 2048, r.keyType = r.keyType || "RSA";
        let e = await Wa.generateKeyPair(r.keyType, r.bits);
        return YS(e, e.public)
      };
      Ts.createFromHexString = r => new Ya(vl.fromHexString(r));
      Ts.createFromBytes = r => new Ya(r);
      Ts.createFromB58String = r => Ts.createFromCID(r);
      var N7e = r => r.codec === "libp2p-key" || r.codec === "dag-pb";
      Ts.createFromCID = r => {
        if (r = WS.isCID(r) ? r : new WS(r), !N7e(r)) throw new Error("Supplied PeerID CID has invalid multicodec: " + r.codec);
        return new Ya(r.multihash)
      };
      Ts.createFromPubKey = async r => {
        let e = r;
        if (typeof e == "string" && (e = iy(r, "base64pad")), !(e instanceof Uint8Array)) throw new Error("Supplied key is neither a base64 string nor a Uint8Array");
        let t = await Wa.unmarshalPublicKey(e);
        return YS(null, t)
      };
      Ts.createFromPrivKey = async r => {
        if (typeof r == "string" && (r = iy(r, "base64pad")), !(r instanceof Uint8Array)) throw new Error("Supplied key is neither a base64 string nor a Uint8Array");
        let e = await Wa.unmarshalPrivateKey(r);
        return YS(e, e.public)
      };
      Ts.createFromJSON = async r => {
        let e = vl.fromB58String(r.id),
          t = r.privKey && iy(r.privKey, "base64pad"),
          i = r.pubKey && iy(r.pubKey, "base64pad"),
          n = i && await Wa.unmarshalPublicKey(i);
        if (!t) return new Ya(e, null, n);
        let s = await Wa.unmarshalPrivateKey(t),
          o = await ny(s.public),
          a;
        if (n && (a = await ny(n)), n && !wl(o, a)) throw new Error("Public and private key do not match");
        if (e && !wl(o, e)) throw new Error("Id and private key do not match");
        return new Ya(e, s, n)
      };
      Ts.createFromProtobuf = async r => {
        typeof r == "string" && (r = iy(r, "base16"));
        let {
          id: e,
          privKey: t,
          pubKey: i
        } = uL.decode(r);
        t = t ? await Wa.unmarshalPrivateKey(t) : !1, i = i ? await Wa.unmarshalPublicKey(i) : !1;
        let n, s;
        if (t && (s = await ny(t.public)), i && (n = await ny(i)), t) {
          if (i && !wl(s, n)) throw new Error("Public and private key do not match");
          return new Ya(s, t, t.public)
        }
        if (i) return new Ya(n, null, i);
        if (e) return new Ya(e);
        throw new Error("Protobuf did not contain any usable key material")
      };
      Ts.isPeerId = r => Boolean(typeof r == "object" && r._id && r._idB58String);

      function lL(r) {
        if (r) return O7e(r, "base64pad")
      }
    });
    var pL = y((Bmt, hL) => {
      l();
      "use strict";
      cd();
      var j2 = At(),
        Od = ct(),
        dL = gt();
      hL.exports = {
        createCipheriv: (r, e, t) => {
          let i = j2.cipher.createCipher("AES-CTR", Od(e, "ascii"));
          return i.start({
            iv: Od(t, "ascii")
          }), {
            update: n => (i.update(j2.util.createBuffer(Od(n, "ascii"))), dL(i.output.getBytes(), "ascii"))
          }
        },
        createDecipheriv: (r, e, t) => {
          let i = j2.cipher.createDecipher("AES-CTR", Od(e, "ascii"));
          return i.start({
            iv: Od(t, "ascii")
          }), {
            update: n => (i.update(j2.util.createBuffer(Od(n, "ascii"))), dL(i.output.getBytes(), "ascii"))
          }
        }
      }
    });
    var bL = y((Dmt, yL) => {
      l();
      "use strict";
      var q7e = xe(),
        gL = {
          16: "aes-128-ctr",
          32: "aes-256-ctr"
        };
      yL.exports = function (r) {
        let e = gL[r.length];
        if (!e) {
          let t = Object.entries(gL).map(([i, n]) => `${i} (${n})`).join(" / ");
          throw q7e(new Error(`Invalid key length ${r.length} bytes. Must be ${t}`), "ERR_INVALID_KEY_LENGTH")
        }
        return e
      }
    });
    var wL = y(mL => {
      l();
      "use strict";
      var vL = pL(),
        M7e = bL();
      mL.create = async function (r, e) {
        let t = M7e(r),
          i = vL.createCipheriv(t, r, e),
          n = vL.createDecipheriv(t, r, e);
        return {
          async encrypt(o) {
            return i.update(o)
          },
          async decrypt(o) {
            return n.update(o)
          }
        }
      }
    });
    var SL = y((Fmt, _L) => {
      l();
      "use strict";
      var B7e = $E(),
        D7e = wr(),
        L7e = xe(),
        EL = {
          sha1: "sha1",
          "sha2-256": "sha256",
          "sha2-512": "sha512"
        };

      function F7e(r, e, t, i, n) {
        let s = EL[n];
        if (!s) {
          let a = Object.keys(EL).join(" / ");
          throw L7e(new Error(`Hash '${n}' is unknown or not supported. Must be ${a}`), "ERR_UNSUPPORTED_HASH_TYPE")
        }
        let o = B7e(r, e, t, i, s);
        return D7e.encode64(o)
      }
      _L.exports = F7e
    });
    var Ja = y(Nd => {
      l();
      "use strict";
      var U7e = VS(),
        K7e = wL(),
        z7e = K2();
      Nd.aes = K7e;
      Nd.hmac = U7e;
      Nd.keys = z7e;
      Nd.randomBytes = H1();
      Nd.pbkdf2 = SL()
    });
    var XS = y((Kmt, xL) => {
      l();
      "use strict";
      var AL = "[a-fA-F\\d:]",
        Zu = r => r && r.includeBoundaries ? `(?:(?<=\\s|^)(?=${AL})|(?<=${AL})(?=\\s|$))` : "",
        Wo = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",
        mi = "[a-fA-F\\d]{1,4}",
        V2 = `
(?:
(?:${mi}:){7}(?:${mi}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${mi}:){6}(?:${Wo}|:${mi}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${mi}:){5}(?::${Wo}|(?::${mi}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${mi}:){4}(?:(?::${mi}){0,1}:${Wo}|(?::${mi}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${mi}:){3}(?:(?::${mi}){0,2}:${Wo}|(?::${mi}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${mi}:){2}(?:(?::${mi}){0,3}:${Wo}|(?::${mi}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${mi}:){1}(?:(?::${mi}){0,4}:${Wo}|(?::${mi}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${mi}){0,5}:${Wo}|(?::${mi}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(),
        j7e = new RegExp(`(?:^${Wo}$)|(?:^${V2}$)`),
        V7e = new RegExp(`^${Wo}$`),
        H7e = new RegExp(`^${V2}$`),
        JS = r => r && r.exact ? j7e : new RegExp(`(?:${Zu(r)}${Wo}${Zu(r)})|(?:${Zu(r)}${V2}${Zu(r)})`, "g");
      JS.v4 = r => r && r.exact ? V7e : new RegExp(`${Zu(r)}${Wo}${Zu(r)}`, "g");
      JS.v6 = r => r && r.exact ? H7e : new RegExp(`${Zu(r)}${V2}${Zu(r)}`, "g");
      xL.exports = JS
    });
    var TL = y((zmt, IL) => {
      l();
      "use strict";
      var ZS = XS(),
        qd = r => ZS({
          exact: !0
        }).test(r);
      qd.v4 = r => ZS.v4({
        exact: !0
      }).test(r);
      qd.v6 = r => ZS.v6({
        exact: !0
      }).test(r);
      qd.version = r => qd(r) ? qd.v4(r) ? 4 : 6 : void 0;
      IL.exports = qd
    });
    var OL = y((jmt, RL) => {
      l();
      "use strict";
      var QS = TL(),
        kL = ct(),
        G7e = QS,
        e5 = QS.v4,
        PL = QS.v6,
        CL = function (r, e, t) {
          t = ~~t;
          let i;
          if (e5(r)) i = e || new Uint8Array(t + 4), r.split(/\./g).map(function (s) {
            i[t++] = parseInt(s, 10) & 255
          });
          else if (PL(r)) {
            let s = r.split(":", 8),
              o;
            for (o = 0; o < s.length; o++) {
              let a = e5(s[o]);
              var n;
              a && (n = CL(s[o]), s[o] = kL(n.slice(0, 2), "base16")), n && ++o < 8 && s.splice(o, 0, kL(n.slice(2, 4), "base16"))
            }
            if (s[0] === "")
              for (; s.length < 8;) s.unshift("0");
            else if (s[s.length - 1] === "")
              for (; s.length < 8;) s.push("0");
            else if (s.length < 8) {
              for (o = 0; o < s.length && s[o] !== ""; o++);
              let a = [o, "1"];
              for (o = 9 - s.length; o > 0; o--) a.push("0");
              s.splice.apply(s, a)
            }
            for (i = e || new Uint8Array(t + 16), o = 0; o < s.length; o++) {
              let a = parseInt(s[o], 16);
              i[t++] = a >> 8 & 255, i[t++] = a & 255
            }
          }
          if (!i) throw Error("Invalid ip address: " + r);
          return i
        },
        $7e = function (r, e, t) {
          e = ~~e, t = t || r.length - e;
          let i = [],
            n, s = new DataView(r.buffer);
          if (t === 4) {
            for (let o = 0; o < t; o++) i.push(r[e + o]);
            n = i.join(".")
          } else if (t === 16) {
            for (let o = 0; o < t; o += 2) i.push(s.getUint16(e + o).toString(16));
            n = i.join(":"), n = n.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3"), n = n.replace(/:{3,4}/, "::")
          }
          return n
        };
      RL.exports = {
        isIP: G7e,
        isV4: e5,
        isV6: PL,
        toBytes: CL,
        toString: $7e
      }
    });
    var sy = y((Vmt, NL) => {
      l();
      "use strict";

      function gs(r) {
        if (typeof r == "number") {
          if (gs.codes[r]) return gs.codes[r];
          throw new Error("no protocol with code: " + r)
        } else if (typeof r == "string") {
          if (gs.names[r]) return gs.names[r];
          throw new Error("no protocol with name: " + r)
        }
        throw new Error("invalid protocol id type: " + r)
      }
      var so = -1;
      gs.lengthPrefixedVarSize = so;
      gs.V = so;
      gs.table = [
        [4, 32, "ip4"],
        [6, 16, "tcp"],
        [33, 16, "dccp"],
        [41, 128, "ip6"],
        [42, so, "ip6zone"],
        [53, so, "dns", "resolvable"],
        [54, so, "dns4", "resolvable"],
        [55, so, "dns6", "resolvable"],
        [56, so, "dnsaddr", "resolvable"],
        [132, 16, "sctp"],
        [273, 16, "udp"],
        [275, 0, "p2p-webrtc-star"],
        [276, 0, "p2p-webrtc-direct"],
        [277, 0, "p2p-stardust"],
        [290, 0, "p2p-circuit"],
        [301, 0, "udt"],
        [302, 0, "utp"],
        [400, so, "unix", !1, "path"],
        [421, so, "ipfs"],
        [421, so, "p2p"],
        [443, 0, "https"],
        [444, 96, "onion"],
        [445, 296, "onion3"],
        [446, so, "garlic64"],
        [460, 0, "quic"],
        [477, 0, "ws"],
        [478, 0, "wss"],
        [479, 0, "p2p-websocket-star"],
        [480, 0, "http"],
        [777, so, "memory"]
      ];
      gs.names = {};
      gs.codes = {};
      gs.table.map(r => {
        let e = qL.apply(null, r);
        return gs.codes[e.code] = e, gs.names[e.name] = e, null
      });
      gs.object = qL;

      function qL(r, e, t, i, n) {
        return {
          code: r,
          size: e,
          name: t,
          resolvable: Boolean(i),
          path: Boolean(n)
        }
      }
      NL.exports = gs
    });
    var DL = y((Hmt, ML) => {
      l();
      ML.exports = t5;
      var BL = 128,
        W7e = 127,
        Y7e = ~W7e,
        J7e = Math.pow(2, 31);

      function t5(r, e, t) {
        if (Number.MAX_SAFE_INTEGER && r > Number.MAX_SAFE_INTEGER) throw t5.bytes = 0, new RangeError("Could not encode varint");
        e = e || [], t = t || 0;
        for (var i = t; r >= J7e;) e[t++] = r & 255 | BL, r /= 128;
        for (; r & Y7e;) e[t++] = r & 255 | BL, r >>>= 7;
        return e[t] = r | 0, t5.bytes = t - i + 1, e
      }
    });
    var UL = y((Gmt, LL) => {
      l();
      LL.exports = r5;
      var X7e = 128,
        FL = 127;

      function r5(r, e) {
        var t = 0,
          e = e || 0,
          i = 0,
          n = e,
          s, o = r.length;
        do {
          if (n >= o || i > 49) throw r5.bytes = 0, new RangeError("Could not decode varint");
          s = r[n++], t += i < 28 ? (s & FL) << i : (s & FL) * Math.pow(2, i), i += 7
        } while (s >= X7e);
        return r5.bytes = n - e, t
      }
    });
    var zL = y(($mt, KL) => {
      l();
      var Z7e = Math.pow(2, 7),
        Q7e = Math.pow(2, 14),
        eRe = Math.pow(2, 21),
        tRe = Math.pow(2, 28),
        rRe = Math.pow(2, 35),
        iRe = Math.pow(2, 42),
        nRe = Math.pow(2, 49),
        sRe = Math.pow(2, 56),
        oRe = Math.pow(2, 63);
      KL.exports = function (r) {
        return r < Z7e ? 1 : r < Q7e ? 2 : r < eRe ? 3 : r < tRe ? 4 : r < rRe ? 5 : r < iRe ? 6 : r < nRe ? 7 : r < sRe ? 8 : r < oRe ? 9 : 10
      }
    });
    var Yo = y((Wmt, jL) => {
      l();
      jL.exports = {
        encode: DL(),
        decode: UL(),
        encodingLength: zL()
      }
    });
    var XL = y((Ymt, VL) => {
      l();
      "use strict";
      var H2 = OL(),
        HL = sy(),
        aRe = at(),
        GL = ln(),
        Md = Yo(),
        G2 = ct(),
        $L = gt(),
        $2 = xi();
      VL.exports = oy;

      function oy(r, e) {
        return e instanceof Uint8Array ? oy.toString(r, e) : oy.toBytes(r, e)
      }
      oy.toString = function (e, t) {
        switch (HL(e).code) {
          case 4:
          case 41:
            return cRe(t);
          case 6:
          case 273:
          case 33:
          case 132:
            return WL(t).toString();
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 777:
            return uRe(t);
          case 421:
            return fRe(t);
          case 444:
            return YL(t);
          case 445:
            return YL(t);
          default:
            return G2(t, "base16")
        }
      };
      oy.toBytes = function (e, t) {
        switch (HL(e).code) {
          case 4:
            return JL(t);
          case 41:
            return JL(t);
          case 6:
          case 273:
          case 33:
          case 132:
            return i5(parseInt(t, 10));
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 777:
            return lRe(t);
          case 421:
            return hRe(t);
          case 444:
            return dRe(t);
          case 445:
            return pRe(t);
          default:
            return $L(t, "base16")
        }
      };

      function JL(r) {
        if (!H2.isIP(r)) throw new Error("invalid ip address");
        return H2.toBytes(r)
      }

      function cRe(r) {
        let e = H2.toString(r);
        if (!e || !H2.isIP(e)) throw new Error("invalid ip address");
        return e
      }

      function i5(r) {
        let e = new ArrayBuffer(2);
        return new DataView(e).setUint16(0, r), new Uint8Array(e)
      }

      function WL(r) {
        return new DataView(r.buffer).getUint16(0)
      }

      function lRe(r) {
        let e = $L(r),
          t = Uint8Array.from(Md.encode(e.length));
        return $2([t, e], t.length + e.length)
      }

      function uRe(r) {
        let e = Md.decode(r);
        if (r = r.slice(Md.decode.bytes), r.length !== e) throw new Error("inconsistent lengths");
        return G2(r)
      }

      function hRe(r) {
        let e = new aRe(r).multihash,
          t = Uint8Array.from(Md.encode(e.length));
        return $2([t, e], t.length + e.length)
      }

      function fRe(r) {
        let e = Md.decode(r),
          t = r.slice(Md.decode.bytes);
        if (t.length !== e) throw new Error("inconsistent lengths");
        return G2(t, "base58btc")
      }

      function dRe(r) {
        let e = r.split(":");
        if (e.length !== 2) throw new Error("failed to parse onion addr: " + e + " does not contain a port number");
        if (e[0].length !== 16) throw new Error("failed to parse onion addr: " + e[0] + " not a Tor onion address.");
        let t = GL.decode("b" + e[0]),
          i = parseInt(e[1], 10);
        if (i < 1 || i > 65536) throw new Error("Port number is not in range(1, 65536)");
        let n = i5(i);
        return $2([t, n], t.length + n.length)
      }

      function pRe(r) {
        let e = r.split(":");
        if (e.length !== 2) throw new Error("failed to parse onion addr: " + e + " does not contain a port number");
        if (e[0].length !== 56) throw new Error("failed to parse onion addr: " + e[0] + " not a Tor onion3 address.");
        let t = GL.decode("b" + e[0]),
          i = parseInt(e[1], 10);
        if (i < 1 || i > 65536) throw new Error("Port number is not in range(1, 65536)");
        let n = i5(i);
        return $2([t, n], t.length + n.length)
      }

      function YL(r) {
        let e = r.slice(0, r.length - 2),
          t = r.slice(r.length - 2),
          i = G2(e, "base32"),
          n = WL(t);
        return i + ":" + n
      }
    });
    var uF = y((Jmt, ZL) => {
      l();
      "use strict";
      var QL = XL(),
        n5 = sy(),
        ay = Yo(),
        eF = xi(),
        yRe = ct();
      ZL.exports = {
        stringToStringTuples: tF,
        stringTuplesToString: rF,
        tuplesToStringTuples: nF,
        stringTuplesToTuples: iF,
        bytesToTuples: s5,
        tuplesToBytes: sF,
        bytesToString: gRe,
        stringToBytes: aF,
        fromString: bRe,
        fromBytes: cF,
        validateBytes: o5,
        isValidBytes: mRe,
        cleanPath: W2,
        ParseError: a5,
        protoFromTuple: cy,
        sizeForAddr: oF
      };

      function tF(r) {
        let e = [],
          t = r.split("/").slice(1);
        if (t.length === 1 && t[0] === "") return [];
        for (let i = 0; i < t.length; i++) {
          let n = t[i],
            s = n5(n);
          if (s.size === 0) {
            e.push([n]);
            continue
          }
          if (i++, i >= t.length) throw a5("invalid address: " + r);
          if (s.path) {
            e.push([n, W2(t.slice(i).join("/"))]);
            break
          }
          e.push([n, t[i]])
        }
        return e
      }

      function rF(r) {
        let e = [];
        return r.map(t => {
          let i = cy(t);
          return e.push(i.name), t.length > 1 && e.push(t[1]), null
        }), W2(e.join("/"))
      }

      function iF(r) {
        return r.map(e => {
          Array.isArray(e) || (e = [e]);
          let t = cy(e);
          return e.length > 1 ? [t.code, QL.toBytes(t.code, e[1])] : [t.code]
        })
      }

      function nF(r) {
        return r.map(e => {
          let t = cy(e);
          return e[1] ? [t.code, QL.toString(t.code, e[1])] : [t.code]
        })
      }

      function sF(r) {
        return cF(eF(r.map(e => {
          let t = cy(e),
            i = Uint8Array.from(ay.encode(t.code));
          return e.length > 1 && (i = eF([i, e[1]])), i
        })))
      }

      function oF(r, e) {
        return r.size > 0 ? r.size / 8 : r.size === 0 ? 0 : ay.decode(e) + ay.decode.bytes
      }

      function s5(r) {
        let e = [],
          t = 0;
        for (; t < r.length;) {
          let i = ay.decode(r, t),
            n = ay.decode.bytes,
            s = n5(i),
            o = oF(s, r.slice(t + n));
          if (o === 0) {
            e.push([i]), t += n;
            continue
          }
          let a = r.slice(t + n, t + n + o);
          if (t += o + n, t > r.length) throw a5("Invalid address Uint8Array: " + yRe(r, "base16"));
          e.push([i, a])
        }
        return e
      }

      function gRe(r) {
        let e = s5(r),
          t = nF(e);
        return rF(t)
      }

      function aF(r) {
        r = W2(r);
        let e = tF(r),
          t = iF(e);
        return sF(t)
      }

      function bRe(r) {
        return aF(r)
      }

      function cF(r) {
        let e = o5(r);
        if (e) throw e;
        return Uint8Array.from(r)
      }

      function o5(r) {
        try {
          s5(r)
        } catch (e) {
          return e
        }
      }

      function mRe(r) {
        return o5(r) === void 0
      }

      function W2(r) {
        return "/" + r.trim().split("/").filter(e => e).join("/")
      }

      function a5(r) {
        return new Error("Error parsing address: " + r)
      }

      function cy(r) {
        return n5(r[0])
      }
    });
    var pr = y((Xmt, fF) => {
      l();
      "use strict";
      var Jo = uF(),
        Bd = sy(),
        lF = Yo(),
        vRe = at(),
        wRe = xe(),
        _Re = Symbol.for("nodejs.util.inspect.custom"),
        c5 = ct(),
        ERe = Lr(),
        u5 = new Map,
        hF = Symbol.for("@multiformats/js-multiaddr/multiaddr"),
        Vn = class {
          constructor(e) {
            if (e == null && (e = ""), Object.defineProperty(this, hF, {
              value: !0
            }), e instanceof Uint8Array) this.bytes = Jo.fromBytes(e);
            else if (typeof e == "string") {
              if (e.length > 0 && e.charAt(0) !== "/") throw new Error(`multiaddr "${e}" must start with a "/"`);
              this.bytes = Jo.fromString(e)
            } else if (Vn.isMultiaddr(e)) this.bytes = Jo.fromBytes(e.bytes);
            else throw new Error("addr must be a string, Buffer, or another Multiaddr")
          }
          toString() {
            return Jo.bytesToString(this.bytes)
          }
          toJSON() {
            return this.toString()
          }
          toOptions() {
            let e = {},
              t = this.toString().split("/");
            return e.family = t[1] === "ip4" ? 4 : 6, e.host = t[2], e.transport = t[3], e.port = parseInt(t[4]), e
          }
          protos() {
            return this.protoCodes().map(e => Object.assign({}, Bd(e)))
          }
          protoCodes() {
            let e = [],
              t = this.bytes,
              i = 0;
            for (; i < t.length;) {
              let n = lF.decode(t, i),
                s = lF.decode.bytes,
                o = Bd(n);
              i += Jo.sizeForAddr(o, t.slice(i + s)) + s, e.push(n)
            }
            return e
          }
          protoNames() {
            return this.protos().map(e => e.name)
          }
          tuples() {
            return Jo.bytesToTuples(this.bytes)
          }
          stringTuples() {
            let e = Jo.bytesToTuples(this.bytes);
            return Jo.tuplesToStringTuples(e)
          }
          encapsulate(e) {
            return e = new Vn(e), new Vn(this.toString() + e.toString())
          }
          decapsulate(e) {
            let t = e.toString(),
              i = this.toString(),
              n = i.lastIndexOf(t);
            if (n < 0) throw new Error("Address " + this + " does not contain subaddress: " + e);
            return new Vn(i.slice(0, n))
          }
          decapsulateCode(e) {
            let t = this.tuples();
            for (let i = t.length - 1; i >= 0; i--)
              if (t[i][0] === e) return new Vn(Jo.tuplesToBytes(t.slice(0, i)));
            return this
          }
          getPeerId() {
            try {
              let t = this.stringTuples().filter(i => i[0] === Bd.names.ipfs.code).pop();
              return t && t[1] ? c5(new vRe(t[1]).multihash, "base58btc") : null
            } catch (e) {
              return null
            }
          }
          getPath() {
            let e = null;
            try {
              e = this.stringTuples().filter(t => !!Bd(t[0]).path)[0][1], e || (e = null)
            } catch (t) {
              e = null
            }
            return e
          }
          equals(e) {
            return ERe(this.bytes, e.bytes)
          }
          async resolve() {
            let e = this.protos().find(n => n.resolvable);
            if (!e) return [this];
            let t = u5.get(e.name);
            if (!t) throw wRe(new Error(`no available resolver for ${e.name}`), "ERR_NO_AVAILABLE_RESOLVER");
            return (await t(this)).map(n => new Vn(n))
          }
          nodeAddress() {
            let e = this.protoCodes(),
              t = this.protoNames(),
              i = this.toString().split("/").slice(1);
            if (i.length < 4) throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
            if (e[0] !== 4 && e[0] !== 41 && e[0] !== 54 && e[0] !== 55) throw new Error(`no protocol with name: "'${t[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
            if (i[2] !== "tcp" && i[2] !== "udp") throw new Error(`no protocol with name: "'${t[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
            return {
              family: e[0] === 41 || e[0] === 55 ? 6 : 4,
              address: i[1],
              port: parseInt(i[3])
            }
          }
          isThinWaistAddress(e) {
            let t = (e || this).protos();
            return !(t.length !== 2 || t[0].code !== 4 && t[0].code !== 41 || t[1].code !== 6 && t[1].code !== 273)
          }
          static fromNodeAddress(e, t) {
            if (!e) throw new Error("requires node address object");
            if (!t) throw new Error("requires transport protocol");
            let i;
            switch (e.family) {
              case 4:
                i = "ip4";
                break;
              case 6:
                i = "ip6";
                break;
              default:
                throw Error(`Invalid addr family. Got '${e.family}' instead of 4 or 6`)
            }
            return new Vn("/" + [i, e.address, t, e.port].join("/"))
          }
          static isName(e) {
            return Vn.isMultiaddr(e) ? e.protos().some(t => t.resolvable) : !1
          }
          static isMultiaddr(e) {
            return e instanceof Vn || Boolean(e && e[hF])
          } [_Re]() {
            return "<Multiaddr " + c5(this.bytes, "base16") + " - " + Jo.bytesToString(this.bytes) + ">"
          }
          inspect() {
            return "<Multiaddr " + c5(this.bytes, "base16") + " - " + Jo.bytesToString(this.bytes) + ">"
          }
        };
      Vn.protocols = Bd;
      Vn.resolvers = u5;

      function SRe(r) {
        return new Vn(r)
      }
      fF.exports = {
        Multiaddr: Vn,
        multiaddr: SRe,
        protocols: Bd,
        resolvers: u5
      }
    });
    var El = y((Zmt, dF) => {
      l();
      "use strict";
      var {
        Multiaddr: f5
      } = pr(), pF = lt("dns4"), yF = lt("dns6"), gF = lt("dnsaddr"), _l = An(lt("dns"), gF, pF, yF), uy = An(lt("ip4"), lt("ip6")), Dd = An(It(uy, lt("tcp")), It(_l, lt("tcp"))), l5 = It(uy, lt("udp")), bF = It(l5, lt("utp")), mF = It(l5, lt("quic")), Ld = An(It(Dd, lt("ws")), It(_l, lt("ws"))), Fd = An(It(Dd, lt("wss")), It(_l, lt("wss"))), Y2 = An(It(Dd, lt("http")), It(uy, lt("http")), It(_l, lt("http"))), J2 = An(It(Dd, lt("https")), It(uy, lt("https")), It(_l, lt("https"))), h5 = An(It(Ld, lt("p2p-webrtc-star"), lt("p2p")), It(Fd, lt("p2p-webrtc-star"), lt("p2p")), It(Ld, lt("p2p-webrtc-star")), It(Fd, lt("p2p-webrtc-star"))), xRe = An(It(Ld, lt("p2p-websocket-star"), lt("p2p")), It(Fd, lt("p2p-websocket-star"), lt("p2p")), It(Ld, lt("p2p-websocket-star")), It(Fd, lt("p2p-websocket-star"))), d5 = An(It(Y2, lt("p2p-webrtc-direct"), lt("p2p")), It(J2, lt("p2p-webrtc-direct"), lt("p2p")), It(Y2, lt("p2p-webrtc-direct")), It(J2, lt("p2p-webrtc-direct"))), Ud = An(Ld, Fd, Y2, J2, h5, d5, Dd, bF, mF, _l), ARe = An(It(Ud, lt("p2p-stardust"), lt("p2p")), It(Ud, lt("p2p-stardust"))), Qu = An(It(Ud, lt("p2p")), h5, d5, lt("p2p")), vF = An(It(Qu, lt("p2p-circuit"), Qu), It(Qu, lt("p2p-circuit")), It(lt("p2p-circuit"), Qu), It(Ud, lt("p2p-circuit")), It(lt("p2p-circuit"), Ud), lt("p2p-circuit")), wF = () => An(It(vF, wF), vF), Kd = wF(), _F = An(It(Kd, Qu, Kd), It(Qu, Kd), It(Kd, Qu), Kd, Qu);
      dF.exports = {
        DNS: _l,
        DNS4: pF,
        DNS6: yF,
        DNSADDR: gF,
        IP: uy,
        TCP: Dd,
        UDP: l5,
        QUIC: mF,
        UTP: bF,
        HTTP: Y2,
        HTTPS: J2,
        WebSockets: Ld,
        WebSocketsSecure: Fd,
        WebSocketStar: xRe,
        WebRTCStar: h5,
        WebRTCDirect: d5,
        Reliable: Ud,
        Stardust: ARe,
        Circuit: Kd,
        P2P: _F,
        IPFS: _F
      };

      function EF(r) {
        function e(t) {
          if (!f5.isMultiaddr(t)) try {
            t = new f5(t)
          } catch (n) {
            return !1
          }
          let i = r(t.protoNames());
          return i === null ? !1 : i === !0 || i === !1 ? i : i.length === 0
        }
        return e
      }

      function It(...r) {
        function e(t) {
          if (t.length < r.length) return null;
          let i = t;
          return r.some(n => (i = typeof n == "function" ? n().partialMatch(t) : n.partialMatch(t), Array.isArray(i) && (t = i), i === null)), i
        }
        return {
          toString: function () {
            return "{ " + r.join(" ") + " }"
          },
          input: r,
          matches: EF(e),
          partialMatch: e
        }
      }

      function An(...r) {
        function e(i) {
          let n = null;
          return r.some(s => {
            let o = typeof s == "function" ? s().partialMatch(i) : s.partialMatch(i);
            return o ? (n = o, !0) : !1
          }), n
        }
        return {
          toString: function () {
            return "{ " + r.join(" ") + " }"
          },
          input: r,
          matches: EF(e),
          partialMatch: e
        }
      }

      function lt(r) {
        let e = r;

        function t(n) {
          if (typeof n == "string") try {
            n = new f5(n)
          } catch (o) {
            return !1
          }
          let s = n.protoNames();
          return s.length === 1 && s[0] === e
        }

        function i(n) {
          return n.length === 0 ? null : n[0] === e ? n.slice(1) : null
        }
        return {
          toString: function () {
            return e
          },
          matches: t,
          partialMatch: i
        }
      }
    });
    var Sl = y((Qmt, SF) => {
      l();
      "use strict";
      var IRe = Do(),
        xF = ln(),
        {
          Multiaddr: AF
        } = pr(),
        TRe = El(),
        RRe = at(),
        {
          URL: kRe
        } = Qh(),
        PRe = ct(),
        p5 = /^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/,
        zd = /^\/(ip[fn]s)\/([^/?#]+)/,
        IF = 1,
        TF = 2,
        fy = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/,
        RF = 1,
        kF = 2,
        CRe = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;

      function ORe(r) {
        let e = y5(r);
        try {
          return IRe.decode(xF.decode("z" + e)), !0
        } catch (t) {
          return !1
        }
      }

      function NRe(r) {
        try {
          return xF.isEncoded(r)
        } catch (e) {
          return !1
        }
      }

      function ly(r) {
        try {
          return new RRe(r), !0
        } catch (e) {
          return !1
        }
      }

      function PF(r) {
        if (!r) return !1;
        if (AF.isMultiaddr(r)) return !0;
        try {
          return new AF(r), !0
        } catch (e) {
          return !1
        }
      }

      function qRe(r) {
        return PF(r) && TRe.P2P.matches(r)
      }

      function hy(r, e, t = IF, i = TF) {
        let n = y5(r);
        if (!n) return !1;
        let s = n.match(e);
        if (!s || s[t] !== "ipfs") return !1;
        let o = s[i];
        return o && e === fy && (o = o.toLowerCase()), ly(o)
      }

      function X2(r, e, t = IF, i = TF) {
        let n = y5(r);
        if (!n) return !1;
        let s = n.match(e);
        if (!s || s[t] !== "ipns") return !1;
        let o = s[i];
        if (o && e === fy) {
          if (o = o.toLowerCase(), ly(o)) return !0;
          try {
            !o.includes(".") && o.includes("-") && (o = o.replace(/--/g, "@").replace(/-/g, ".").replace(/@/g, "-"));
            let {
              hostname: a
            } = new kRe(`http://${o}`);
            return CRe.test(a)
          } catch (a) {
            return !1
          }
        }
        return !0
      }

      function CF(r) {
        return typeof r == "string"
      }

      function y5(r) {
        return r instanceof Uint8Array ? PRe(r, "base58btc") : CF(r) ? r : !1
      }
      var g5 = r => hy(r, fy, kF, RF),
        b5 = r => X2(r, fy, kF, RF),
        OF = r => g5(r) || b5(r),
        NF = r => hy(r, p5) || g5(r),
        qF = r => X2(r, p5) || b5(r),
        MF = r => NF(r) || qF(r) || OF(r),
        BF = r => hy(r, zd) || X2(r, zd);
      SF.exports = {
        multihash: ORe,
        multiaddr: PF,
        peerMultiaddr: qRe,
        cid: ly,
        base32cid: r => NRe(r) === "base32" && ly(r),
        ipfsSubdomain: g5,
        ipnsSubdomain: b5,
        subdomain: OF,
        subdomainGatewayPattern: fy,
        ipfsUrl: NF,
        ipnsUrl: qF,
        url: MF,
        pathGatewayPattern: p5,
        ipfsPath: r => hy(r, zd),
        ipnsPath: r => X2(r, zd),
        path: BF,
        pathPattern: zd,
        urlOrPath: r => MF(r) || BF(r),
        cidPath: r => CF(r) && !ly(r) && hy(`/ipfs/${r}`, zd)
      }
    });
    var DF = y((e2t, Z2) => {
      l();
      (function () {
        "use strict";
        var r = "input is invalid type",
          e = "finalize already called",
          t = typeof window == "object",
          i = t ? window : {};
        i.JS_SHA3_NO_WINDOW && (t = !1);
        var n = !t && typeof self == "object",
          s = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
        s ? i = globalThis : n && (i = self);
        var o = !i.JS_SHA3_NO_COMMON_JS && typeof Z2 == "object" && Z2.exports,
          a = typeof define == "function" && define.amd,
          c = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined",
          u = "0123456789abcdef".split(""),
          f = [31, 7936, 2031616, 520093696],
          h = [4, 1024, 262144, 67108864],
          d = [1, 256, 65536, 16777216],
          p = [6, 1536, 393216, 100663296],
          g = [0, 8, 16, 24],
          m = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
          E = [224, 256, 384, 512],
          w = [128, 256],
          O = ["hex", "buffer", "arrayBuffer", "array", "digest"],
          q = {
            "128": 168,
            "256": 136
          };
        (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function (I) {
          return Object.prototype.toString.call(I) === "[object Array]"
        }), c && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function (I) {
          return typeof I == "object" && I.buffer && I.buffer.constructor === ArrayBuffer
        });
        for (var J = function (I, le, he) {
          return function (S) {
            return new Q(I, le, I).update(S)[he]()
          }
        }, Z = function (I, le, he) {
          return function (S, T) {
            return new Q(I, le, T).update(S)[he]()
          }
        }, H = function (I, le, he) {
          return function (S, T, j, G) {
            return D["cshake" + I].update(S, T, j, G)[he]()
          }
        }, te = function (I, le, he) {
          return function (S, T, j, G) {
            return D["kmac" + I].update(S, T, j, G)[he]()
          }
        }, ae = function (I, le, he, S) {
          for (var T = 0; T < O.length; ++T) {
            var j = O[T];
            I[j] = le(he, S, j)
          }
          return I
        }, oe = function (I, le) {
          var he = J(I, le, "hex");
          return he.create = function () {
            return new Q(I, le, I)
          }, he.update = function (S) {
            return he.create().update(S)
          }, ae(he, J, I, le)
        }, U = function (I, le) {
          var he = Z(I, le, "hex");
          return he.create = function (S) {
            return new Q(I, le, S)
          }, he.update = function (S, T) {
            return he.create(T).update(S)
          }, ae(he, Z, I, le)
        }, b = function (I, le) {
          var he = q[I],
            S = H(I, le, "hex");
          return S.create = function (T, j, G) {
            return !j && !G ? D["shake" + I].create(T) : new Q(I, le, T).bytepad([j, G], he)
          }, S.update = function (T, j, G, k) {
            return S.create(j, G, k).update(T)
          }, ae(S, H, I, le)
        }, _ = function (I, le) {
          var he = q[I],
            S = te(I, le, "hex");
          return S.create = function (T, j, G) {
            return new ve(I, le, j).bytepad(["KMAC", G], he).bytepad([T], he)
          }, S.update = function (T, j, G, k) {
            return S.create(T, G, k).update(j)
          }, ae(S, te, I, le)
        }, R = [{
          name: "keccak",
          padding: d,
          bits: E,
          createMethod: oe
        }, {
          name: "sha3",
          padding: p,
          bits: E,
          createMethod: oe
        }, {
          name: "shake",
          padding: f,
          bits: w,
          createMethod: U
        }, {
          name: "cshake",
          padding: h,
          bits: w,
          createMethod: b
        }, {
          name: "kmac",
          padding: h,
          bits: w,
          createMethod: _
        }], D = {}, K = [], ee = 0; ee < R.length; ++ee)
          for (var re = R[ee], V = re.bits, v = 0; v < V.length; ++v) {
            var Y = re.name + "_" + V[v];
            if (K.push(Y), D[Y] = re.createMethod(V[v], re.padding), re.name !== "sha3") {
              var Se = re.name + V[v];
              K.push(Se), D[Se] = D[Y]
            }
          }

        function Q(I, le, he) {
          this.blocks = [], this.s = [], this.padding = le, this.outputBits = he, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (I << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = he >> 5, this.extraBytes = (he & 31) >> 3;
          for (var S = 0; S < 50; ++S) this.s[S] = 0
        }
        Q.prototype.update = function (I) {
          if (this.finalized) throw new Error(e);
          var le, he = typeof I;
          if (he !== "string") {
            if (he === "object") {
              if (I === null) throw new Error(r);
              if (c && I.constructor === ArrayBuffer) I = new Uint8Array(I);
              else if (!Array.isArray(I) && (!c || !ArrayBuffer.isView(I))) throw new Error(r)
            } else throw new Error(r);
            le = !0
          }
          for (var S = this.blocks, T = this.byteCount, j = I.length, G = this.blockCount, k = 0, F = this.s, B, L; k < j;) {
            if (this.reset)
              for (this.reset = !1, S[0] = this.block, B = 1; B < G + 1; ++B) S[B] = 0;
            if (le)
              for (B = this.start; k < j && B < T; ++k) S[B >> 2] |= I[k] << g[B++ & 3];
            else
              for (B = this.start; k < j && B < T; ++k) L = I.charCodeAt(k), L < 128 ? S[B >> 2] |= L << g[B++ & 3] : L < 2048 ? (S[B >> 2] |= (192 | L >> 6) << g[B++ & 3], S[B >> 2] |= (128 | L & 63) << g[B++ & 3]) : L < 55296 || L >= 57344 ? (S[B >> 2] |= (224 | L >> 12) << g[B++ & 3], S[B >> 2] |= (128 | L >> 6 & 63) << g[B++ & 3], S[B >> 2] |= (128 | L & 63) << g[B++ & 3]) : (L = 65536 + ((L & 1023) << 10 | I.charCodeAt(++k) & 1023), S[B >> 2] |= (240 | L >> 18) << g[B++ & 3], S[B >> 2] |= (128 | L >> 12 & 63) << g[B++ & 3], S[B >> 2] |= (128 | L >> 6 & 63) << g[B++ & 3], S[B >> 2] |= (128 | L & 63) << g[B++ & 3]);
            if (this.lastByteIndex = B, B >= T) {
              for (this.start = B - T, this.block = S[G], B = 0; B < G; ++B) F[B] ^= S[B];
              x(F), this.reset = !0
            } else this.start = B
          }
          return this
        }, Q.prototype.encode = function (I, le) {
          var he = I & 255,
            S = 1,
            T = [he];
          for (I = I >> 8, he = I & 255; he > 0;) T.unshift(he), I = I >> 8, he = I & 255, ++S;
          return le ? T.push(S) : T.unshift(S), this.update(T), T.length
        }, Q.prototype.encodeString = function (I) {
          var le, he = typeof I;
          if (he !== "string") {
            if (he === "object") {
              if (I === null) throw new Error(r);
              if (c && I.constructor === ArrayBuffer) I = new Uint8Array(I);
              else if (!Array.isArray(I) && (!c || !ArrayBuffer.isView(I))) throw new Error(r)
            } else throw new Error(r);
            le = !0
          }
          var S = 0,
            T = I.length;
          if (le) S = T;
          else
            for (var j = 0; j < I.length; ++j) {
              var G = I.charCodeAt(j);
              G < 128 ? S += 1 : G < 2048 ? S += 2 : G < 55296 || G >= 57344 ? S += 3 : (G = 65536 + ((G & 1023) << 10 | I.charCodeAt(++j) & 1023), S += 4)
            }
          return S += this.encode(S * 8), this.update(I), S
        }, Q.prototype.bytepad = function (I, le) {
          for (var he = this.encode(le), S = 0; S < I.length; ++S) he += this.encodeString(I[S]);
          var T = le - he % le,
            j = [];
          return j.length = T, this.update(j), this
        }, Q.prototype.finalize = function () {
          if (!this.finalized) {
            this.finalized = !0;
            var I = this.blocks,
              le = this.lastByteIndex,
              he = this.blockCount,
              S = this.s;
            if (I[le >> 2] |= this.padding[le & 3], this.lastByteIndex === this.byteCount)
              for (I[0] = I[he], le = 1; le < he + 1; ++le) I[le] = 0;
            for (I[he - 1] |= 2147483648, le = 0; le < he; ++le) S[le] ^= I[le];
            x(S)
          }
        }, Q.prototype.toString = Q.prototype.hex = function () {
          this.finalize();
          for (var I = this.blockCount, le = this.s, he = this.outputBlocks, S = this.extraBytes, T = 0, j = 0, G = "", k; j < he;) {
            for (T = 0; T < I && j < he; ++T, ++j) k = le[T], G += u[k >> 4 & 15] + u[k & 15] + u[k >> 12 & 15] + u[k >> 8 & 15] + u[k >> 20 & 15] + u[k >> 16 & 15] + u[k >> 28 & 15] + u[k >> 24 & 15];
            j % I == 0 && (x(le), T = 0)
          }
          return S && (k = le[T], G += u[k >> 4 & 15] + u[k & 15], S > 1 && (G += u[k >> 12 & 15] + u[k >> 8 & 15]), S > 2 && (G += u[k >> 20 & 15] + u[k >> 16 & 15])), G
        }, Q.prototype.arrayBuffer = function () {
          this.finalize();
          var I = this.blockCount,
            le = this.s,
            he = this.outputBlocks,
            S = this.extraBytes,
            T = 0,
            j = 0,
            G = this.outputBits >> 3,
            k;
          S ? k = new ArrayBuffer(he + 1 << 2) : k = new ArrayBuffer(G);
          for (var F = new Uint32Array(k); j < he;) {
            for (T = 0; T < I && j < he; ++T, ++j) F[j] = le[T];
            j % I == 0 && x(le)
          }
          return S && (F[T] = le[T], k = k.slice(0, G)), k
        }, Q.prototype.buffer = Q.prototype.arrayBuffer, Q.prototype.digest = Q.prototype.array = function () {
          this.finalize();
          for (var I = this.blockCount, le = this.s, he = this.outputBlocks, S = this.extraBytes, T = 0, j = 0, G = [], k, F; j < he;) {
            for (T = 0; T < I && j < he; ++T, ++j) k = j << 2, F = le[T], G[k] = F & 255, G[k + 1] = F >> 8 & 255, G[k + 2] = F >> 16 & 255, G[k + 3] = F >> 24 & 255;
            j % I == 0 && x(le)
          }
          return S && (k = j << 2, F = le[T], G[k] = F & 255, S > 1 && (G[k + 1] = F >> 8 & 255), S > 2 && (G[k + 2] = F >> 16 & 255)), G
        };

        function ve(I, le, he) {
          Q.call(this, I, le, he)
        }
        ve.prototype = new Q, ve.prototype.finalize = function () {
          return this.encode(this.outputBits, !0), Q.prototype.finalize.call(this)
        };
        var x = function (I) {
          var le, he, S, T, j, G, k, F, B, L, $, ie, ne, pe, be, de, Ne, Re, $e, Ke, Me, Ie, tt, nt, Ge, se, A, X, Kt, st, Nt, on, qt, De, an, Mt, Bt, cn, Dt, yt, Bn, Ht, Gt, Dn, et, $t, Ln, dr, nr, Ss, sr, or, ut, ar, Lt, Fn, ns, ss, os, as, cs, Ze, us;
          for (S = 0; S < 48; S += 2) T = I[0] ^ I[10] ^ I[20] ^ I[30] ^ I[40], j = I[1] ^ I[11] ^ I[21] ^ I[31] ^ I[41], G = I[2] ^ I[12] ^ I[22] ^ I[32] ^ I[42], k = I[3] ^ I[13] ^ I[23] ^ I[33] ^ I[43], F = I[4] ^ I[14] ^ I[24] ^ I[34] ^ I[44], B = I[5] ^ I[15] ^ I[25] ^ I[35] ^ I[45], L = I[6] ^ I[16] ^ I[26] ^ I[36] ^ I[46], $ = I[7] ^ I[17] ^ I[27] ^ I[37] ^ I[47], ie = I[8] ^ I[18] ^ I[28] ^ I[38] ^ I[48], ne = I[9] ^ I[19] ^ I[29] ^ I[39] ^ I[49], le = ie ^ (G << 1 | k >>> 31), he = ne ^ (k << 1 | G >>> 31), I[0] ^= le, I[1] ^= he, I[10] ^= le, I[11] ^= he, I[20] ^= le, I[21] ^= he, I[30] ^= le, I[31] ^= he, I[40] ^= le, I[41] ^= he, le = T ^ (F << 1 | B >>> 31), he = j ^ (B << 1 | F >>> 31), I[2] ^= le, I[3] ^= he, I[12] ^= le, I[13] ^= he, I[22] ^= le, I[23] ^= he, I[32] ^= le, I[33] ^= he, I[42] ^= le, I[43] ^= he, le = G ^ (L << 1 | $ >>> 31), he = k ^ ($ << 1 | L >>> 31), I[4] ^= le, I[5] ^= he, I[14] ^= le, I[15] ^= he, I[24] ^= le, I[25] ^= he, I[34] ^= le, I[35] ^= he, I[44] ^= le, I[45] ^= he, le = F ^ (ie << 1 | ne >>> 31), he = B ^ (ne << 1 | ie >>> 31), I[6] ^= le, I[7] ^= he, I[16] ^= le, I[17] ^= he, I[26] ^= le, I[27] ^= he, I[36] ^= le, I[37] ^= he, I[46] ^= le, I[47] ^= he, le = L ^ (T << 1 | j >>> 31), he = $ ^ (j << 1 | T >>> 31), I[8] ^= le, I[9] ^= he, I[18] ^= le, I[19] ^= he, I[28] ^= le, I[29] ^= he, I[38] ^= le, I[39] ^= he, I[48] ^= le, I[49] ^= he, pe = I[0], be = I[1], $t = I[11] << 4 | I[10] >>> 28, Ln = I[10] << 4 | I[11] >>> 28, X = I[20] << 3 | I[21] >>> 29, Kt = I[21] << 3 | I[20] >>> 29, as = I[31] << 9 | I[30] >>> 23, cs = I[30] << 9 | I[31] >>> 23, Ht = I[40] << 18 | I[41] >>> 14, Gt = I[41] << 18 | I[40] >>> 14, De = I[2] << 1 | I[3] >>> 31, an = I[3] << 1 | I[2] >>> 31, de = I[13] << 12 | I[12] >>> 20, Ne = I[12] << 12 | I[13] >>> 20, dr = I[22] << 10 | I[23] >>> 22, nr = I[23] << 10 | I[22] >>> 22, st = I[33] << 13 | I[32] >>> 19, Nt = I[32] << 13 | I[33] >>> 19, Ze = I[42] << 2 | I[43] >>> 30, us = I[43] << 2 | I[42] >>> 30, ar = I[5] << 30 | I[4] >>> 2, Lt = I[4] << 30 | I[5] >>> 2, Mt = I[14] << 6 | I[15] >>> 26, Bt = I[15] << 6 | I[14] >>> 26, Re = I[25] << 11 | I[24] >>> 21, $e = I[24] << 11 | I[25] >>> 21, Ss = I[34] << 15 | I[35] >>> 17, sr = I[35] << 15 | I[34] >>> 17, on = I[45] << 29 | I[44] >>> 3, qt = I[44] << 29 | I[45] >>> 3, nt = I[6] << 28 | I[7] >>> 4, Ge = I[7] << 28 | I[6] >>> 4, Fn = I[17] << 23 | I[16] >>> 9, ns = I[16] << 23 | I[17] >>> 9, cn = I[26] << 25 | I[27] >>> 7, Dt = I[27] << 25 | I[26] >>> 7, Ke = I[36] << 21 | I[37] >>> 11, Me = I[37] << 21 | I[36] >>> 11, or = I[47] << 24 | I[46] >>> 8, ut = I[46] << 24 | I[47] >>> 8, Dn = I[8] << 27 | I[9] >>> 5, et = I[9] << 27 | I[8] >>> 5, se = I[18] << 20 | I[19] >>> 12, A = I[19] << 20 | I[18] >>> 12, ss = I[29] << 7 | I[28] >>> 25, os = I[28] << 7 | I[29] >>> 25, yt = I[38] << 8 | I[39] >>> 24, Bn = I[39] << 8 | I[38] >>> 24, Ie = I[48] << 14 | I[49] >>> 18, tt = I[49] << 14 | I[48] >>> 18, I[0] = pe ^ ~de & Re, I[1] = be ^ ~Ne & $e, I[10] = nt ^ ~se & X, I[11] = Ge ^ ~A & Kt, I[20] = De ^ ~Mt & cn, I[21] = an ^ ~Bt & Dt, I[30] = Dn ^ ~$t & dr, I[31] = et ^ ~Ln & nr, I[40] = ar ^ ~Fn & ss, I[41] = Lt ^ ~ns & os, I[2] = de ^ ~Re & Ke, I[3] = Ne ^ ~$e & Me, I[12] = se ^ ~X & st, I[13] = A ^ ~Kt & Nt, I[22] = Mt ^ ~cn & yt, I[23] = Bt ^ ~Dt & Bn, I[32] = $t ^ ~dr & Ss, I[33] = Ln ^ ~nr & sr, I[42] = Fn ^ ~ss & as, I[43] = ns ^ ~os & cs, I[4] = Re ^ ~Ke & Ie, I[5] = $e ^ ~Me & tt, I[14] = X ^ ~st & on, I[15] = Kt ^ ~Nt & qt, I[24] = cn ^ ~yt & Ht, I[25] = Dt ^ ~Bn & Gt, I[34] = dr ^ ~Ss & or, I[35] = nr ^ ~sr & ut, I[44] = ss ^ ~as & Ze, I[45] = os ^ ~cs & us, I[6] = Ke ^ ~Ie & pe, I[7] = Me ^ ~tt & be, I[16] = st ^ ~on & nt, I[17] = Nt ^ ~qt & Ge, I[26] = yt ^ ~Ht & De, I[27] = Bn ^ ~Gt & an, I[36] = Ss ^ ~or & Dn, I[37] = sr ^ ~ut & et, I[46] = as ^ ~Ze & ar, I[47] = cs ^ ~us & Lt, I[8] = Ie ^ ~pe & de, I[9] = tt ^ ~be & Ne, I[18] = on ^ ~nt & se, I[19] = qt ^ ~Ge & A, I[28] = Ht ^ ~De & Mt, I[29] = Gt ^ ~an & Bt, I[38] = or ^ ~Dn & $t, I[39] = ut ^ ~et & Ln, I[48] = Ze ^ ~ar & Fn, I[49] = us ^ ~Lt & ns, I[0] ^= m[S], I[1] ^= m[S + 1]
        };
        if (o) Z2.exports = D;
        else {
          for (ee = 0; ee < K.length; ++ee) i[K[ee]] = D[K[ee]];
          a && define(function () {
            return D
          })
        }
      })()
    });
    var LF = y((dy, Q2) => {
      l();
      (function (r, e) {
        "use strict";
        var t = {
          version: "3.0.0",
          x86: {},
          x64: {},
          inputValidation: !0
        };

        function i(p) {
          if (!Array.isArray(p) && !ArrayBuffer.isView(p)) return !1;
          for (var g = 0; g < p.length; g++)
            if (!Number.isInteger(p[g]) || p[g] < 0 || p[g] > 255) return !1;
          return !0
        }

        function n(p, g) {
          return (p & 65535) * g + (((p >>> 16) * g & 65535) << 16)
        }

        function s(p, g) {
          return p << g | p >>> 32 - g
        }

        function o(p) {
          return p ^= p >>> 16, p = n(p, 2246822507), p ^= p >>> 13, p = n(p, 3266489909), p ^= p >>> 16, p
        }

        function a(p, g) {
          p = [p[0] >>> 16, p[0] & 65535, p[1] >>> 16, p[1] & 65535], g = [g[0] >>> 16, g[0] & 65535, g[1] >>> 16, g[1] & 65535];
          var m = [0, 0, 0, 0];
          return m[3] += p[3] + g[3], m[2] += m[3] >>> 16, m[3] &= 65535, m[2] += p[2] + g[2], m[1] += m[2] >>> 16, m[2] &= 65535, m[1] += p[1] + g[1], m[0] += m[1] >>> 16, m[1] &= 65535, m[0] += p[0] + g[0], m[0] &= 65535, [m[0] << 16 | m[1], m[2] << 16 | m[3]]
        }

        function c(p, g) {
          p = [p[0] >>> 16, p[0] & 65535, p[1] >>> 16, p[1] & 65535], g = [g[0] >>> 16, g[0] & 65535, g[1] >>> 16, g[1] & 65535];
          var m = [0, 0, 0, 0];
          return m[3] += p[3] * g[3], m[2] += m[3] >>> 16, m[3] &= 65535, m[2] += p[2] * g[3], m[1] += m[2] >>> 16, m[2] &= 65535, m[2] += p[3] * g[2], m[1] += m[2] >>> 16, m[2] &= 65535, m[1] += p[1] * g[3], m[0] += m[1] >>> 16, m[1] &= 65535, m[1] += p[2] * g[2], m[0] += m[1] >>> 16, m[1] &= 65535, m[1] += p[3] * g[1], m[0] += m[1] >>> 16, m[1] &= 65535, m[0] += p[0] * g[3] + p[1] * g[2] + p[2] * g[1] + p[3] * g[0], m[0] &= 65535, [m[0] << 16 | m[1], m[2] << 16 | m[3]]
        }

        function u(p, g) {
          return g %= 64, g === 32 ? [p[1], p[0]] : g < 32 ? [p[0] << g | p[1] >>> 32 - g, p[1] << g | p[0] >>> 32 - g] : (g -= 32, [p[1] << g | p[0] >>> 32 - g, p[0] << g | p[1] >>> 32 - g])
        }

        function f(p, g) {
          return g %= 64, g === 0 ? p : g < 32 ? [p[0] << g | p[1] >>> 32 - g, p[1] << g] : [p[1] << g - 32, 0]
        }

        function h(p, g) {
          return [p[0] ^ g[0], p[1] ^ g[1]]
        }

        function d(p) {
          return p = h(p, [0, p[0] >>> 1]), p = c(p, [4283543511, 3981806797]), p = h(p, [0, p[0] >>> 1]), p = c(p, [3301882366, 444984403]), p = h(p, [0, p[0] >>> 1]), p
        }
        t.x86.hash32 = function (p, g) {
          if (t.inputValidation && !i(p)) return e;
          g = g || 0;
          for (var m = p.length % 4, E = p.length - m, w = g, O = 0, q = 3432918353, J = 461845907, Z = 0; Z < E; Z = Z + 4) O = p[Z] | p[Z + 1] << 8 | p[Z + 2] << 16 | p[Z + 3] << 24, O = n(O, q), O = s(O, 15), O = n(O, J), w ^= O, w = s(w, 13), w = n(w, 5) + 3864292196;
          switch (O = 0, m) {
            case 3:
              O ^= p[Z + 2] << 16;
            case 2:
              O ^= p[Z + 1] << 8;
            case 1:
              O ^= p[Z], O = n(O, q), O = s(O, 15), O = n(O, J), w ^= O
          }
          return w ^= p.length, w = o(w), w >>> 0
        }, t.x86.hash128 = function (p, g) {
          if (t.inputValidation && !i(p)) return e;
          g = g || 0;
          for (var m = p.length % 16, E = p.length - m, w = g, O = g, q = g, J = g, Z = 0, H = 0, te = 0, ae = 0, oe = 597399067, U = 2869860233, b = 951274213, _ = 2716044179, R = 0; R < E; R = R + 16) Z = p[R] | p[R + 1] << 8 | p[R + 2] << 16 | p[R + 3] << 24, H = p[R + 4] | p[R + 5] << 8 | p[R + 6] << 16 | p[R + 7] << 24, te = p[R + 8] | p[R + 9] << 8 | p[R + 10] << 16 | p[R + 11] << 24, ae = p[R + 12] | p[R + 13] << 8 | p[R + 14] << 16 | p[R + 15] << 24, Z = n(Z, oe), Z = s(Z, 15), Z = n(Z, U), w ^= Z, w = s(w, 19), w += O, w = n(w, 5) + 1444728091, H = n(H, U), H = s(H, 16), H = n(H, b), O ^= H, O = s(O, 17), O += q, O = n(O, 5) + 197830471, te = n(te, b), te = s(te, 17), te = n(te, _), q ^= te, q = s(q, 15), q += J, q = n(q, 5) + 2530024501, ae = n(ae, _), ae = s(ae, 18), ae = n(ae, oe), J ^= ae, J = s(J, 13), J += w, J = n(J, 5) + 850148119;
          switch (Z = 0, H = 0, te = 0, ae = 0, m) {
            case 15:
              ae ^= p[R + 14] << 16;
            case 14:
              ae ^= p[R + 13] << 8;
            case 13:
              ae ^= p[R + 12], ae = n(ae, _), ae = s(ae, 18), ae = n(ae, oe), J ^= ae;
            case 12:
              te ^= p[R + 11] << 24;
            case 11:
              te ^= p[R + 10] << 16;
            case 10:
              te ^= p[R + 9] << 8;
            case 9:
              te ^= p[R + 8], te = n(te, b), te = s(te, 17), te = n(te, _), q ^= te;
            case 8:
              H ^= p[R + 7] << 24;
            case 7:
              H ^= p[R + 6] << 16;
            case 6:
              H ^= p[R + 5] << 8;
            case 5:
              H ^= p[R + 4], H = n(H, U), H = s(H, 16), H = n(H, b), O ^= H;
            case 4:
              Z ^= p[R + 3] << 24;
            case 3:
              Z ^= p[R + 2] << 16;
            case 2:
              Z ^= p[R + 1] << 8;
            case 1:
              Z ^= p[R], Z = n(Z, oe), Z = s(Z, 15), Z = n(Z, U), w ^= Z
          }
          return w ^= p.length, O ^= p.length, q ^= p.length, J ^= p.length, w += O, w += q, w += J, O += w, q += w, J += w, w = o(w), O = o(O), q = o(q), J = o(J), w += O, w += q, w += J, O += w, q += w, J += w, ("00000000" + (w >>> 0).toString(16)).slice(-8) + ("00000000" + (O >>> 0).toString(16)).slice(-8) + ("00000000" + (q >>> 0).toString(16)).slice(-8) + ("00000000" + (J >>> 0).toString(16)).slice(-8)
        }, t.x64.hash128 = function (p, g) {
          if (t.inputValidation && !i(p)) return e;
          g = g || 0;
          for (var m = p.length % 16, E = p.length - m, w = [0, g], O = [0, g], q = [0, 0], J = [0, 0], Z = [2277735313, 289559509], H = [1291169091, 658871167], te = 0; te < E; te = te + 16) q = [p[te + 4] | p[te + 5] << 8 | p[te + 6] << 16 | p[te + 7] << 24, p[te] | p[te + 1] << 8 | p[te + 2] << 16 | p[te + 3] << 24], J = [p[te + 12] | p[te + 13] << 8 | p[te + 14] << 16 | p[te + 15] << 24, p[te + 8] | p[te + 9] << 8 | p[te + 10] << 16 | p[te + 11] << 24], q = c(q, Z), q = u(q, 31), q = c(q, H), w = h(w, q), w = u(w, 27), w = a(w, O), w = a(c(w, [0, 5]), [0, 1390208809]), J = c(J, H), J = u(J, 33), J = c(J, Z), O = h(O, J), O = u(O, 31), O = a(O, w), O = a(c(O, [0, 5]), [0, 944331445]);
          switch (q = [0, 0], J = [0, 0], m) {
            case 15:
              J = h(J, f([0, p[te + 14]], 48));
            case 14:
              J = h(J, f([0, p[te + 13]], 40));
            case 13:
              J = h(J, f([0, p[te + 12]], 32));
            case 12:
              J = h(J, f([0, p[te + 11]], 24));
            case 11:
              J = h(J, f([0, p[te + 10]], 16));
            case 10:
              J = h(J, f([0, p[te + 9]], 8));
            case 9:
              J = h(J, [0, p[te + 8]]), J = c(J, H), J = u(J, 33), J = c(J, Z), O = h(O, J);
            case 8:
              q = h(q, f([0, p[te + 7]], 56));
            case 7:
              q = h(q, f([0, p[te + 6]], 48));
            case 6:
              q = h(q, f([0, p[te + 5]], 40));
            case 5:
              q = h(q, f([0, p[te + 4]], 32));
            case 4:
              q = h(q, f([0, p[te + 3]], 24));
            case 3:
              q = h(q, f([0, p[te + 2]], 16));
            case 2:
              q = h(q, f([0, p[te + 1]], 8));
            case 1:
              q = h(q, [0, p[te]]), q = c(q, Z), q = u(q, 31), q = c(q, H), w = h(w, q)
          }
          return w = h(w, [0, p.length]), O = h(O, [0, p.length]), w = a(w, O), O = a(O, w), w = d(w), O = d(O), w = a(w, O), O = a(O, w), ("00000000" + (w[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (w[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (O[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (O[1] >>> 0).toString(16)).slice(-8)
        }, typeof dy != "undefined" ? (typeof Q2 != "undefined" && Q2.exports && (dy = Q2.exports = t), dy.murmurHash3 = t) : typeof define == "function" && define.amd ? define([], function () {
          return t
        }) : (t._murmurHash3 = r.murmurHash3, t.noConflict = function () {
          return r.murmurHash3 = t._murmurHash3, t._murmurHash3 = e, t.noConflict = e, t
        }, r.murmurHash3 = t)
      })(dy)
    });
    var UF = y((t2t, FF) => {
      l();
      FF.exports = LF()
    });
    var zF = y((r2t, KF) => {
      l();
      "use strict";
      var MRe = r => {
        let e = new Uint8Array(4);
        for (let t = 0; t < 4; t++) e[t] = r & 255, r = r >> 8;
        return e
      };
      KF.exports = {
        fromNumberTo32BitBuf: MRe
      }
    });
    var m5 = y((i2t, jF) => {
      l();
      var BRe = "Input must be an string, Buffer or Uint8Array";

      function DRe(r) {
        var e;
        if (r instanceof Uint8Array) e = r;
        else if (r instanceof Buffer) e = new Uint8Array(r);
        else if (typeof r == "string") e = new Uint8Array(Buffer.from(r, "utf8"));
        else throw new Error(BRe);
        return e
      }

      function LRe(r) {
        return Array.prototype.map.call(r, function (e) {
          return (e < 16 ? "0" : "") + e.toString(16)
        }).join("")
      }

      function ev(r) {
        return (4294967296 + r).toString(16).substring(1)
      }

      function FRe(r, e, t) {
        for (var i = `
` + r + " = ", n = 0; n < e.length; n += 2) {
          if (t === 32) i += ev(e[n]).toUpperCase(), i += " ", i += ev(e[n + 1]).toUpperCase();
          else if (t === 64) i += ev(e[n + 1]).toUpperCase(), i += ev(e[n]).toUpperCase();
          else throw new Error("Invalid size " + t);
          n % 6 == 4 ? i += `
` + new Array(r.length + 4).join(" ") : n < e.length - 2 && (i += " ")
        }
        console.log(i)
      }

      function URe(r, e, t) {
        for (var i = new Date().getTime(), n = new Uint8Array(e), s = 0; s < e; s++) n[s] = s % 256;
        var o = new Date().getTime();
        for (console.log("Generated random input in " + (o - i) + "ms"), i = o, s = 0; s < t; s++) {
          var a = r(n),
            c = new Date().getTime(),
            u = c - i;
          i = c, console.log("Hashed in " + u + "ms: " + a.substring(0, 20) + "..."), console.log(Math.round(e / (1 << 20) / (u / 1e3) * 100) / 100 + " MB PER SECOND")
        }
      }
      jF.exports = {
        normalizeInput: DRe,
        toHex: LRe,
        debugPrint: FRe,
        testSpeed: URe
      }
    });
    var ZF = y((n2t, VF) => {
      l();
      var HF = m5();

      function tv(r, e, t) {
        var i = r[e] + r[t],
          n = r[e + 1] + r[t + 1];
        i >= 4294967296 && n++, r[e] = i, r[e + 1] = n
      }

      function GF(r, e, t, i) {
        var n = r[e] + t;
        t < 0 && (n += 4294967296);
        var s = r[e + 1] + i;
        n >= 4294967296 && s++, r[e] = n, r[e + 1] = s
      }

      function KRe(r, e) {
        return r[e] ^ r[e + 1] << 8 ^ r[e + 2] << 16 ^ r[e + 3] << 24
      }

      function ef(r, e, t, i, n, s) {
        var o = py[n],
          a = py[n + 1],
          c = py[s],
          u = py[s + 1];
        tv(St, r, e), GF(St, r, o, a);
        var f = St[i] ^ St[r],
          h = St[i + 1] ^ St[r + 1];
        St[i] = h, St[i + 1] = f, tv(St, t, i), f = St[e] ^ St[t], h = St[e + 1] ^ St[t + 1], St[e] = f >>> 24 ^ h << 8, St[e + 1] = h >>> 24 ^ f << 8, tv(St, r, e), GF(St, r, c, u), f = St[i] ^ St[r], h = St[i + 1] ^ St[r + 1], St[i] = f >>> 16 ^ h << 16, St[i + 1] = h >>> 16 ^ f << 16, tv(St, t, i), f = St[e] ^ St[t], h = St[e + 1] ^ St[t + 1], St[e] = h >>> 31 ^ f << 1, St[e + 1] = f >>> 31 ^ h << 1
      }
      var $F = new Uint32Array([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]),
        zRe = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
        In = new Uint8Array(zRe.map(function (r) {
          return r * 2
        })),
        St = new Uint32Array(32),
        py = new Uint32Array(32);

      function WF(r, e) {
        var t = 0;
        for (t = 0; t < 16; t++) St[t] = r.h[t], St[t + 16] = $F[t];
        for (St[24] = St[24] ^ r.t, St[25] = St[25] ^ r.t / 4294967296, e && (St[28] = ~St[28], St[29] = ~St[29]), t = 0; t < 32; t++) py[t] = KRe(r.b, 4 * t);
        for (t = 0; t < 12; t++) ef(0, 8, 16, 24, In[t * 16 + 0], In[t * 16 + 1]), ef(2, 10, 18, 26, In[t * 16 + 2], In[t * 16 + 3]), ef(4, 12, 20, 28, In[t * 16 + 4], In[t * 16 + 5]), ef(6, 14, 22, 30, In[t * 16 + 6], In[t * 16 + 7]), ef(0, 10, 20, 30, In[t * 16 + 8], In[t * 16 + 9]), ef(2, 12, 22, 24, In[t * 16 + 10], In[t * 16 + 11]), ef(4, 14, 16, 26, In[t * 16 + 12], In[t * 16 + 13]), ef(6, 8, 18, 28, In[t * 16 + 14], In[t * 16 + 15]);
        for (t = 0; t < 16; t++) r.h[t] = r.h[t] ^ St[t] ^ St[t + 16]
      }

      function YF(r, e) {
        if (r === 0 || r > 64) throw new Error("Illegal output length, expected 0 < length <= 64");
        if (e && e.length > 64) throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
        for (var t = {
          b: new Uint8Array(128),
          h: new Uint32Array(16),
          t: 0,
          c: 0,
          outlen: r
        }, i = 0; i < 16; i++) t.h[i] = $F[i];
        var n = e ? e.length : 0;
        return t.h[0] ^= 16842752 ^ n << 8 ^ r, e && (v5(t, e), t.c = 128), t
      }

      function v5(r, e) {
        for (var t = 0; t < e.length; t++) r.c === 128 && (r.t += r.c, WF(r, !1), r.c = 0), r.b[r.c++] = e[t]
      }

      function JF(r) {
        for (r.t += r.c; r.c < 128;) r.b[r.c++] = 0;
        WF(r, !0);
        for (var e = new Uint8Array(r.outlen), t = 0; t < r.outlen; t++) e[t] = r.h[t >> 2] >> 8 * (t & 3);
        return e
      }

      function XF(r, e, t) {
        t = t || 64, r = HF.normalizeInput(r);
        var i = YF(t, e);
        return v5(i, r), JF(i)
      }

      function jRe(r, e, t) {
        var i = XF(r, e, t);
        return HF.toHex(i)
      }
      VF.exports = {
        blake2b: XF,
        blake2bHex: jRe,
        blake2bInit: YF,
        blake2bUpdate: v5,
        blake2bFinal: JF
      }
    });
    var oU = y((s2t, QF) => {
      l();
      var eU = m5();

      function VRe(r, e) {
        return r[e] ^ r[e + 1] << 8 ^ r[e + 2] << 16 ^ r[e + 3] << 24
      }

      function tf(r, e, t, i, n, s) {
        tr[r] = tr[r] + tr[e] + n, tr[i] = rv(tr[i] ^ tr[r], 16), tr[t] = tr[t] + tr[i], tr[e] = rv(tr[e] ^ tr[t], 12), tr[r] = tr[r] + tr[e] + s, tr[i] = rv(tr[i] ^ tr[r], 8), tr[t] = tr[t] + tr[i], tr[e] = rv(tr[e] ^ tr[t], 7)
      }

      function rv(r, e) {
        return r >>> e ^ r << 32 - e
      }
      var tU = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
        Tn = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0]),
        tr = new Uint32Array(16),
        gn = new Uint32Array(16);

      function rU(r, e) {
        var t = 0;
        for (t = 0; t < 8; t++) tr[t] = r.h[t], tr[t + 8] = tU[t];
        for (tr[12] ^= r.t, tr[13] ^= r.t / 4294967296, e && (tr[14] = ~tr[14]), t = 0; t < 16; t++) gn[t] = VRe(r.b, 4 * t);
        for (t = 0; t < 10; t++) tf(0, 4, 8, 12, gn[Tn[t * 16 + 0]], gn[Tn[t * 16 + 1]]), tf(1, 5, 9, 13, gn[Tn[t * 16 + 2]], gn[Tn[t * 16 + 3]]), tf(2, 6, 10, 14, gn[Tn[t * 16 + 4]], gn[Tn[t * 16 + 5]]), tf(3, 7, 11, 15, gn[Tn[t * 16 + 6]], gn[Tn[t * 16 + 7]]), tf(0, 5, 10, 15, gn[Tn[t * 16 + 8]], gn[Tn[t * 16 + 9]]), tf(1, 6, 11, 12, gn[Tn[t * 16 + 10]], gn[Tn[t * 16 + 11]]), tf(2, 7, 8, 13, gn[Tn[t * 16 + 12]], gn[Tn[t * 16 + 13]]), tf(3, 4, 9, 14, gn[Tn[t * 16 + 14]], gn[Tn[t * 16 + 15]]);
        for (t = 0; t < 8; t++) r.h[t] ^= tr[t] ^ tr[t + 8]
      }

      function iU(r, e) {
        if (!(r > 0 && r <= 32)) throw new Error("Incorrect output length, should be in [1, 32]");
        var t = e ? e.length : 0;
        if (e && !(t > 0 && t <= 32)) throw new Error("Incorrect key length, should be in [1, 32]");
        var i = {
          h: new Uint32Array(tU),
          b: new Uint32Array(64),
          c: 0,
          t: 0,
          outlen: r
        };
        return i.h[0] ^= 16842752 ^ t << 8 ^ r, t > 0 && (w5(i, e), i.c = 64), i
      }

      function w5(r, e) {
        for (var t = 0; t < e.length; t++) r.c === 64 && (r.t += r.c, rU(r, !1), r.c = 0), r.b[r.c++] = e[t]
      }

      function nU(r) {
        for (r.t += r.c; r.c < 64;) r.b[r.c++] = 0;
        rU(r, !0);
        for (var e = new Uint8Array(r.outlen), t = 0; t < r.outlen; t++) e[t] = r.h[t >> 2] >> 8 * (t & 3) & 255;
        return e
      }

      function sU(r, e, t) {
        t = t || 32, r = eU.normalizeInput(r);
        var i = iU(t, e);
        return w5(i, r), nU(i)
      }

      function HRe(r, e, t) {
        var i = sU(r, e, t);
        return eU.toHex(i)
      }
      QF.exports = {
        blake2s: sU,
        blake2sHex: HRe,
        blake2sInit: iU,
        blake2sUpdate: w5,
        blake2sFinal: nU
      }
    });
    var cU = y((o2t, aU) => {
      l();
      var yy = ZF(),
        gy = oU();
      aU.exports = {
        blake2b: yy.blake2b,
        blake2bHex: yy.blake2bHex,
        blake2bInit: yy.blake2bInit,
        blake2bUpdate: yy.blake2bUpdate,
        blake2bFinal: yy.blake2bFinal,
        blake2s: gy.blake2s,
        blake2sHex: gy.blake2sHex,
        blake2sInit: gy.blake2sInit,
        blake2sUpdate: gy.blake2sUpdate,
        blake2sFinal: gy.blake2sFinal
      }
    });
    var lU = y((a2t, uU) => {
      l();
      "use strict";
      var jd = cU(),
        GRe = 45569,
        $Re = 45633,
        WRe = {
          init: jd.blake2bInit,
          update: jd.blake2bUpdate,
          digest: jd.blake2bFinal
        },
        YRe = {
          init: jd.blake2sInit,
          update: jd.blake2sUpdate,
          digest: jd.blake2sFinal
        },
        fU = (r, e) => async t => {
          let i = e.init(r, null);
          return e.update(i, t), e.digest(i)
        };
      uU.exports = r => {
        for (let e = 0; e < 64; e++) r[GRe + e] = fU(e + 1, WRe);
        for (let e = 0; e < 32; e++) r[$Re + e] = fU(e + 1, YRe)
      }
    });
    var pU = y((c2t, hU) => {
      l();
      "use strict";
      var Xa = DF(),
        dU = UF(),
        {
          factory: iv
        } = hd(),
        {
          fromNumberTo32BitBuf: JRe
        } = zF(),
        XRe = gt(),
        oo = r => async e => {
          switch (r) {
            case "sha3-224":
              return new Uint8Array(Xa.sha3_224.arrayBuffer(e));
            case "sha3-256":
              return new Uint8Array(Xa.sha3_256.arrayBuffer(e));
            case "sha3-384":
              return new Uint8Array(Xa.sha3_384.arrayBuffer(e));
            case "sha3-512":
              return new Uint8Array(Xa.sha3_512.arrayBuffer(e));
            case "shake-128":
              return new Uint8Array(Xa.shake128.create(128).update(e).arrayBuffer());
            case "shake-256":
              return new Uint8Array(Xa.shake256.create(256).update(e).arrayBuffer());
            case "keccak-224":
              return new Uint8Array(Xa.keccak224.arrayBuffer(e));
            case "keccak-256":
              return new Uint8Array(Xa.keccak256.arrayBuffer(e));
            case "keccak-384":
              return new Uint8Array(Xa.keccak384.arrayBuffer(e));
            case "keccak-512":
              return new Uint8Array(Xa.keccak512.arrayBuffer(e));
            case "murmur3-128":
              return XRe(dU.x64.hash128(e), "base16");
            case "murmur3-32":
              return JRe(dU.x86.hash32(e));
            default:
              throw new TypeError(`${r} is not a supported algorithm`)
          }
        }, ZRe = r => r;
      hU.exports = {
        identity: ZRe,
        sha1: iv("sha1"),
        sha2256: iv("sha2-256"),
        sha2512: iv("sha2-512"),
        dblSha2256: iv("dbl-sha2-256"),
        sha3224: oo("sha3-224"),
        sha3256: oo("sha3-256"),
        sha3384: oo("sha3-384"),
        sha3512: oo("sha3-512"),
        shake128: oo("shake-128"),
        shake256: oo("shake-256"),
        keccak224: oo("keccak-224"),
        keccak256: oo("keccak-256"),
        keccak384: oo("keccak-384"),
        keccak512: oo("keccak-512"),
        murmur3128: oo("murmur3-128"),
        murmur332: oo("murmur3-32"),
        addBlake: lU()
      }
    });
    var cr = y((u2t, yU) => {
      l();
      "use strict";
      var gU = xe(),
        nv = Do(),
        Yi = pU(),
        QRe = Lr();
      async function ao(r, e, t) {
        let i = await ao.digest(r, e, t);
        return nv.encode(i, e, t)
      }
      ao.multihash = nv;
      ao.digest = async (r, e, t) => {
        let n = await ao.createHash(e)(r);
        return t ? n.slice(0, t) : n
      };
      ao.createHash = function (r) {
        if (!r) throw gU(new Error("hash algorithm must be specified"), "ERR_HASH_ALGORITHM_NOT_SPECIFIED");
        let e = nv.coerceCode(r);
        if (!ao.functions[e]) throw gU(new Error(`multihash function '${r}' not yet supported`), "ERR_HASH_ALGORITHM_NOT_SUPPORTED");
        return ao.functions[e]
      };
      ao.functions = {
        0: Yi.identity,
        17: Yi.sha1,
        18: Yi.sha2256,
        19: Yi.sha2512,
        20: Yi.sha3512,
        21: Yi.sha3384,
        22: Yi.sha3256,
        23: Yi.sha3224,
        24: Yi.shake128,
        25: Yi.shake256,
        26: Yi.keccak224,
        27: Yi.keccak256,
        28: Yi.keccak384,
        29: Yi.keccak512,
        34: Yi.murmur3128,
        35: Yi.murmur332,
        86: Yi.dblSha2256
      };
      Yi.addBlake(ao.functions);
      ao.validate = async (r, e) => {
        let t = await ao(r, nv.decode(e).name);
        return QRe(e, t)
      };
      yU.exports = ao
    });
    var bU, mU = gi(() => {
      l();
      bU = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"
    });
    var by = {};
    vP(by, {
      customAlphabet: () => e9e,
      customRandom: () => wU,
      nanoid: () => t9e,
      random: () => vU,
      urlAlphabet: () => bU
    });
    var vU, wU, e9e, t9e, my = gi(() => {
      l();
      mU();
      vU = r => crypto.getRandomValues(new Uint8Array(r)), wU = (r, e, t) => {
        let i = (2 << Math.log(r.length - 1) / Math.LN2) - 1,
          n = -~(1.6 * i * e / r.length);
        return () => {
          let s = "";
          for (; ;) {
            let o = t(n),
              a = n;
            for (; a--;)
              if (s += r[o[a] & i] || "", s.length === e) return s
          }
        }
      }, e9e = (r, e) => wU(r, e, vU), t9e = (r = 21) => {
        let e = "",
          t = crypto.getRandomValues(new Uint8Array(r));
        for (; r--;) {
          let i = t[r] & 63;
          i < 36 ? e += i.toString(36) : i < 62 ? e += (i - 26).toString(36).toUpperCase() : i < 63 ? e += "_" : e += "-"
        }
        return e
      }
    });
    var _5 = y((h2t, _U) => {
      l();
      "use strict";
      var {
        nanoid: r9e
      } = (my(), by), i9e = ct(), n9e = gt(), EU = Symbol.for("@ipfs/interface-datastore/key"), $c = "/", SU = new TextEncoder().encode($c), sv = SU[0], Rs = class {
        constructor(e, t) {
          if (typeof e == "string") this._buf = n9e(e);
          else if (e instanceof Uint8Array) this._buf = e;
          else throw new Error("Invalid key, should be String of Uint8Array");
          if (t == null && (t = !0), t && this.clean(), this._buf.byteLength === 0 || this._buf[0] !== sv) throw new Error("Invalid key")
        }
        toString(e = "utf8") {
          return i9e(this._buf, e)
        }
        uint8Array() {
          return this._buf
        }
        get [EU]() {
          return !0
        }
        get [Symbol.toStringTag]() {
          return `Key(${this.toString()})`
        }
        static withNamespaces(e) {
          return new Rs(e.join($c))
        }
        static random() {
          return new Rs(r9e().replace(/-/g, ""))
        }
        clean() {
          if ((!this._buf || this._buf.byteLength === 0) && (this._buf = SU), this._buf[0] !== sv) {
            let e = new Uint8Array(this._buf.byteLength + 1);
            e.fill(sv, 0, 1), e.set(this._buf, 1), this._buf = e
          }
          for (; this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === sv;) this._buf = this._buf.subarray(0, -1)
        }
        less(e) {
          let t = this.list(),
            i = e.list();
          for (let n = 0; n < t.length; n++) {
            if (i.length < n + 1) return !1;
            let s = t[n],
              o = i[n];
            if (s < o) return !0;
            if (s > o) return !1
          }
          return t.length < i.length
        }
        reverse() {
          return Rs.withNamespaces(this.list().slice().reverse())
        }
        namespaces() {
          return this.list()
        }
        baseNamespace() {
          let e = this.namespaces();
          return e[e.length - 1]
        }
        list() {
          return this.toString().split($c).slice(1)
        }
        type() {
          return s9e(this.baseNamespace())
        }
        name() {
          return o9e(this.baseNamespace())
        }
        instance(e) {
          return new Rs(this.toString() + ":" + e)
        }
        path() {
          let e = this.parent().toString();
          return e.endsWith($c) || (e += $c), e += this.type(), new Rs(e)
        }
        parent() {
          let e = this.list();
          return e.length === 1 ? new Rs($c) : new Rs(e.slice(0, -1).join($c))
        }
        child(e) {
          return this.toString() === $c ? e : e.toString() === $c ? this : new Rs(this.toString() + e.toString(), !1)
        }
        isAncestorOf(e) {
          return e.toString() === this.toString() ? !1 : e.toString().startsWith(this.toString())
        }
        isDecendantOf(e) {
          return e.toString() === this.toString() ? !1 : this.toString().startsWith(e.toString())
        }
        isTopLevel() {
          return this.list().length === 1
        }
        concat(...e) {
          return Rs.withNamespaces([...this.namespaces(), ...a9e(e.map(t => t.namespaces()))])
        }
        static isKey(e) {
          return e instanceof Rs || Boolean(e && e[EU])
        }
      };

      function s9e(r) {
        let e = r.split(":");
        return e.length < 2 ? "" : e.slice(0, -1).join(":")
      }

      function o9e(r) {
        let e = r.split(":");
        return e[e.length - 1]
      }

      function a9e(r) {
        return [].concat(...r)
      }
      _U.exports = Rs
    });
    var AU = y((d2t, xU) => {
      l();
      "use strict";
      var {
        nanoid: c9e
      } = (my(), by), u9e = (r = e => e) => r(c9e());
      xU.exports = u9e
    });
    var vy = y((p2t, IU) => {
      l();
      "use strict";
      var f9e = async r => {
        let e = [];
        for await (let t of r) e.push(t);
        return e
      };
      IU.exports = f9e
    });
    var E5 = y((y2t, TU) => {
      l();
      "use strict";
      var l9e = AU(),
        h9e = vy(),
        d9e = (r, e) => async function* () {
          yield* (await h9e(r)).sort(e)
        }(), p9e = (r, e) => {
          let t = new RegExp("^" + e);
          return r.replace(t, "")
        };
      TU.exports = {
        sortAll: d9e,
        tmpdir: l9e,
        replaceStartWith: p9e
      }
    });
    var Vd = y((g2t, RU) => {
      l();
      "use strict";
      var y9e = async r => {
        for await (let e of r);
      };
      RU.exports = y9e
    });
    var xl = y((b2t, kU) => {
      l();
      "use strict";
      var g9e = async function* (r, e) {
        for await (let t of r) await e(t) && (yield t)
      };
      kU.exports = g9e
    });
    var ov = y((m2t, PU) => {
      l();
      "use strict";
      var b9e = async function* (r, e) {
        let t = 0;
        if (!(e < 1)) {
          for await (let i of r) if (yield i, t++, t === e) return
        }
      };
      PU.exports = b9e
    });
    var S5 = y((v2t, CU) => {
      l();
      "use strict";
      var {
        sortAll: OU
      } = E5(), NU = Vd(), Hd = xl(), qU = ov(), MU = class {
        open() {
          return Promise.reject(new Error(".open is not implemented"))
        }
        close() {
          return Promise.reject(new Error(".close is not implemented"))
        }
        put(e, t, i) {
          return Promise.reject(new Error(".put is not implemented"))
        }
        get(e, t) {
          return Promise.reject(new Error(".get is not implemented"))
        }
        has(e, t) {
          return Promise.reject(new Error(".has is not implemented"))
        }
        delete(e, t) {
          return Promise.reject(new Error(".delete is not implemented"))
        }
        async *putMany(e, t = {}) {
          for await (let {
            key: i,
            value: n
          } of e) await this.put(i, n, t), yield {
            key: i,
            value: n
          }
        }
        async *getMany(e, t = {}) {
          for await (let i of e) yield this.get(i, t)
        }
        async *deleteMany(e, t = {}) {
          for await (let i of e) await this.delete(i, t), yield i
        }
        batch() {
          let e = [],
            t = [];
          return {
            put(i, n) {
              e.push({
                key: i,
                value: n
              })
            },
            delete(i) {
              t.push(i)
            },
            commit: async i => {
              await NU(this.putMany(e, i)), e = [], await NU(this.deleteMany(t, i)), t = []
            }
          }
        }
        async *_all(e, t) {
          throw new Error("._all is not implemented")
        }
        async *_allKeys(e, t) {
          throw new Error("._allKeys is not implemented")
        }
        query(e, t) {
          let i = this._all(e, t);
          if (e.prefix != null && (i = Hd(i, n => n.key.toString().startsWith(e.prefix))), Array.isArray(e.filters) && (i = e.filters.reduce((n, s) => Hd(n, s), i)), Array.isArray(e.orders) && (i = e.orders.reduce((n, s) => OU(n, s), i)), e.offset != null) {
            let n = 0;
            i = Hd(i, () => n++ >= e.offset)
          }
          return e.limit != null && (i = qU(i, e.limit)), i
        }
        queryKeys(e, t) {
          let i = this._allKeys(e, t);
          if (e.prefix != null && (i = Hd(i, n => n.toString().startsWith(e.prefix))), Array.isArray(e.filters) && (i = e.filters.reduce((n, s) => Hd(n, s), i)), Array.isArray(e.orders) && (i = e.orders.reduce((n, s) => OU(n, s), i)), e.offset != null) {
            let n = 0;
            i = Hd(i, () => n++ >= e.offset)
          }
          return e.limit != null && (i = qU(i, e.limit)), i
        }
      };
      CU.exports = MU
    });
    var x5 = y((w2t, BU) => {
      l();
      "use strict";
      var wy = xe();

      function m9e(r) {
        return r = r || new Error("Cannot open database"), wy(r, "ERR_DB_OPEN_FAILED")
      }

      function v9e(r) {
        return r = r || new Error("Delete failed"), wy(r, "ERR_DB_DELETE_FAILED")
      }

      function w9e(r) {
        return r = r || new Error("Write failed"), wy(r, "ERR_DB_WRITE_FAILED")
      }

      function _9e(r) {
        return r = r || new Error("Not Found"), wy(r, "ERR_NOT_FOUND")
      }

      function E9e(r) {
        return r = r || new Error("Aborted"), wy(r, "ERR_ABORTED")
      }
      BU.exports = {
        dbOpenFailedError: m9e,
        dbDeleteFailedError: v9e,
        dbWriteFailedError: w9e,
        notFoundError: _9e,
        abortedError: E9e
      }
    });
    var UU = y((_2t, DU) => {
      l();
      "use strict";
      var LU = _5(),
        S9e = S5(),
        x9e = x5(),
        FU = class extends S9e {
          constructor() {
            super();
            this.data = {}
          }
          open() {
            return Promise.resolve()
          }
          close() {
            return Promise.resolve()
          }
          async put(e, t) {
            this.data[e.toString()] = t
          }
          async get(e) {
            if (!await this.has(e)) throw x9e.notFoundError();
            return this.data[e.toString()]
          }
          async has(e) {
            return this.data[e.toString()] !== void 0
          }
          async delete(e) {
            delete this.data[e.toString()]
          }
          async *_all() {
            yield* Object.entries(this.data).map(([e, t]) => ({
              key: new LU(e),
              value: t
            }))
          }
          async *_allKeys() {
            yield* Object.entries(this.data).map(([e]) => new LU(e))
          }
        };
      DU.exports = FU
    });
    var fr = y((E2t, KU) => {
      l();
      "use strict";
      var A9e = _5(),
        I9e = UU(),
        T9e = E5(),
        R9e = x5(),
        k9e = S5();
      KU.exports = {
        Key: A9e,
        MemoryDatastore: I9e,
        utils: T9e,
        Errors: R9e,
        Adapter: k9e
      }
    });
    var jU = y((S2t, zU) => {
      l();
      "use strict";
      zU.exports = function () {
        return Date.now()
      }
    });
    var HU = y((x2t, VU) => {
      l();
      "use strict";
      var A5 = jU();

      function I5(r, e, t) {
        var i = this;
        this._started = A5(), this._rescheduled = 0, this._scheduled = e, this._args = t, this._timer = setTimeout(n, e);

        function n() {
          i._rescheduled > 0 ? (i._scheduled = i._rescheduled - (A5() - i._started), i._timer = setTimeout(n, i._scheduled), i._rescheduled = 0) : r.apply(null, i._args)
        }
      }
      I5.prototype.reschedule = function (r) {
        var e = A5();
        return e + r - (this._started + this._scheduled) < 0 ? !1 : (this._started = e, this._rescheduled = r, !0)
      };
      I5.prototype.clear = function () {
        clearTimeout(this._timer)
      };

      function P9e() {
        if (typeof arguments[0] != "function") throw new Error("callback needed");
        if (typeof arguments[1] != "number") throw new Error("timeout needed");
        var r;
        if (arguments.length > 0) {
          r = new Array(arguments.length - 2);
          for (var e = 0; e < r.length; e++) r[e] = arguments[e + 2]
        }
        return new I5(arguments[0], arguments[1], r)
      }
      VU.exports = P9e
    });
    var R5 = y((A2t, T5) => {
      l();
      "use strict";
      var {
        AbortController: C9e
      } = typeof self != "undefined" ? self : typeof window != "undefined" ? window : Zf(), GU = HU(), _y = class extends C9e {
        constructor(e) {
          super();
          this._ms = e, this._timer = GU(() => this.abort(), e), Object.setPrototypeOf(this, _y.prototype)
        }
        abort() {
          return this._timer.clear(), super.abort()
        }
        clear() {
          this._timer.clear()
        }
        reset() {
          this._timer.clear(), this._timer = GU(() => this.abort(), this._ms)
        }
      };
      T5.exports = _y;
      T5.exports.TimeoutController = _y
    });
    var av = y((I2t, k5) => {
      l();
      "use strict";
      var O9e = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
      k5.exports = Tt;
      k5.exports.default = Tt;
      Tt.nanosecond = Tt.ns = 1 / 1e6;
      Tt.\u00B5s = Tt.\u03BCs = Tt.us = Tt.microsecond = 1 / 1e3;
      Tt.millisecond = Tt.ms = Tt[""] = 1;
      Tt.second = Tt.sec = Tt.s = Tt.ms * 1e3;
      Tt.minute = Tt.min = Tt.m = Tt.s * 60;
      Tt.hour = Tt.hr = Tt.h = Tt.m * 60;
      Tt.day = Tt.d = Tt.h * 24;
      Tt.week = Tt.wk = Tt.w = Tt.d * 7;
      Tt.month = Tt.b = Tt.d * (365.25 / 12);
      Tt.year = Tt.yr = Tt.y = Tt.d * 365.25;

      function Tt(r = "", e = "ms") {
        var t = null;
        return r = (r + "").replace(/(\d)[,_](\d)/g, "$1$2"), r.replace(O9e, function (i, n, s) {
          s = $U(s), s && (t = (t || 0) + parseFloat(n, 10) * s)
        }), t && t / ($U(e) || 1)
      }

      function $U(r) {
        return Tt[r] || Tt[r.toLowerCase().replace(/s$/, "")]
      }
    });
    var YU = y(WU => {
      l();
      "use strict";
      var Ey = class extends Error {
        constructor(e = "request timed out") {
          super(e);
          this.name = "TimeoutError", this.code = Ey.code
        }
      };
      Ey.code = "ERR_TIMEOUT";
      WU.TimeoutError = Ey
    });
    var ze = y((R2t, JU) => {
      l();
      "use strict";
      var N9e = R5(),
        {
          anySignal: q9e
        } = ed(),
        {
          default: M9e
        } = av(),
        {
          TimeoutError: P5
        } = YU();

      function B9e(r, e) {
        return (...t) => {
          let i = t[e ?? t.length - 1];
          if (!i || !i.timeout) return r(...t);
          let n = typeof i.timeout == "string" ? M9e(i.timeout) : i.timeout,
            s = new N9e(n);
          i.signal = q9e([i.signal, s.signal]);
          let o = r(...t),
            a = new Promise((f, h) => {
              s.signal.addEventListener("abort", () => {
                h(new P5)
              })
            }),
            c = Date.now(),
            u = () => {
              if (s.signal.aborted) throw new P5;
              if (Date.now() - c > n) throw s.abort(), new P5
            };
          return o[Symbol.asyncIterator] ? async function* () {
            let f = o[Symbol.asyncIterator]();
            try {
              for (; ;) {
                let {
                  value: h,
                  done: d
                } = await Promise.race([f.next(), a]);
                if (d) break;
                u(), yield h
              }
            } catch (h) {
              throw u(), h
            } finally {
              s.clear(), f.return && f.return()
            }
          }() : (async () => {
            try {
              let f = await Promise.race([o, a]);
              return u(), f
            } catch (f) {
              throw u(), f
            } finally {
              s.clear()
            }
          })()
        }
      }
      JU.exports = B9e
    });
    var Sy = y((k2t, XU) => {
      l();
      "use strict";
      var C5 = at(),
        ZU = xe(),
        QU = "/ipfs/",
        D9e = r => {
          if (r instanceof Uint8Array) try {
            r = new C5(r)
          } catch (n) {
            throw ZU(n, "ERR_INVALID_CID")
          }
          if (C5.isCID(r)) return {
            cid: r,
            path: void 0
          };
          r.startsWith(QU) && (r = r.substring(QU.length));
          let e = r.split("/"),
            t, i;
          try {
            t = new C5(e.shift())
          } catch (n) {
            throw ZU(n, "ERR_INVALID_CID")
          }
          return e.length && (i = `/${e.join("/")}`), {
            cid: t,
            path: i
          }
        };
      XU.exports = D9e
    });
    var O5 = y((P2t, eK) => {
      l();
      "use strict";
      var L9e = at(),
        F9e = ze(),
        U9e = Sy();
      eK.exports = ({
        ipld: r,
        preload: e
      }) => {
        async function t(i, n = {}) {
          let {
            cid: s,
            path: o
          } = U9e(i);
          n.preload !== !1 && e(s), o && (n.path = o);
          let a = s,
            c = n.path || "";
          if (c.startsWith("/") && (c = c.substring(1)), n.path) try {
            for await (let {
              value: u,
              remainderPath: f
            } of r.resolve(s, n.path, {
              signal: n.signal
            })) {
              if (!L9e.isCID(u)) break;
              c = f, a = u
            }
          } catch (u) {
            throw u.message.startsWith("Object has no property") && (u.message = `no link named "${c.split("/")[0]}" under ${a}`, u.code = "ERR_NO_LINK"), u
          }
          return {
            cid: a,
            remainderPath: c || ""
          }
        }
        return F9e(t)
      }
    });
    var Ji = y(co => {
      l();
      "use strict";
      var tK = Sl(),
        cv = at(),
        K9e = fr().Key,
        z9e = xe(),
        rK = ze(),
        j9e = Yr(),
        V9e = O5();
      co.mergeOptions = j9e;
      var H9e = "ERR_BAD_PATH";
      co.OFFLINE_ERROR = "This command must be run in online mode. Try running 'ipfs daemon' first.";
      co.MFS_ROOT_KEY = new K9e("/local/filesroot");
      co.MFS_MAX_CHUNK_SIZE = 262144;
      co.MFS_MAX_LINKS = 174;
      var G9e = r => {
        if (tK.cid(r) || cv.isCID(r)) return `/ipfs/${new cv(r)}`;
        if (tK.path(r)) return r;
        throw z9e(new Error(`invalid path: ${r}`), H9e)
      },
        $9e = r => r instanceof Uint8Array ? new cv(r).toString() : cv.isCID(r) ? r.toString() : (r.indexOf("/ipfs/") === 0 && (r = r.substring("/ipfs/".length)), r.charAt(r.length - 1) === "/" && (r = r.substring(0, r.length - 1)), r),
        W9e = async function (r, e, t = {}) {
          let i = () => { };
          i.stop = () => { }, i.start = () => { };
          let {
            cid: n
          } = await V9e({
            ipld: r,
            preload: i
          })(e, {
            preload: !1
          });
          return n
        }, Y9e = (r, e = {}) => {
          if (r.type !== "file" && r.type !== "directory" && r.type !== "raw") throw new Error(`Unknown node type '${r.type}'`);
          let t = {
            cid: r.cid,
            path: r.path,
            name: r.name,
            depth: r.path.split("/").length,
            size: r.size,
            type: "file"
          };
          return r.type === "directory" && (t.type = "dir"), r.type === "file" && (t.size = r.unixfs.fileSize()), (r.type === "file" || r.type === "directory") && (t.mode = r.unixfs.mode, r.unixfs.mtime !== void 0 && (t.mtime = r.unixfs.mtime)), e.includeContent && (r.type === "file" || r.type === "raw") && (t.content = r.content()), t
        }, J9e = rK(async (r, e) => await r);
      co.normalizePath = G9e;
      co.normalizeCidPath = $9e;
      co.resolvePath = W9e;
      co.mapFile = Y9e;
      co.withTimeoutOption = rK;
      co.withTimeout = J9e
    });
    var nK = y((O2t, iK) => {
      l();
      var Gd = 1e3,
        $d = Gd * 60,
        Wd = $d * 60,
        Al = Wd * 24,
        X9e = Al * 7,
        Z9e = Al * 365.25;
      iK.exports = function (r, e) {
        e = e || {};
        var t = typeof r;
        if (t === "string" && r.length > 0) return Q9e(r);
        if (t === "number" && isFinite(r)) return e.long ? tke(r) : eke(r);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(r))
      };

      function Q9e(r) {
        if (r = String(r), !(r.length > 100)) {
          var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);
          if (!!e) {
            var t = parseFloat(e[1]),
              i = (e[2] || "ms").toLowerCase();
            switch (i) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return t * Z9e;
              case "weeks":
              case "week":
              case "w":
                return t * X9e;
              case "days":
              case "day":
              case "d":
                return t * Al;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return t * Wd;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return t * $d;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return t * Gd;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return t;
              default:
                return
            }
          }
        }
      }

      function eke(r) {
        var e = Math.abs(r);
        return e >= Al ? Math.round(r / Al) + "d" : e >= Wd ? Math.round(r / Wd) + "h" : e >= $d ? Math.round(r / $d) + "m" : e >= Gd ? Math.round(r / Gd) + "s" : r + "ms"
      }

      function tke(r) {
        var e = Math.abs(r);
        return e >= Al ? uv(r, e, Al, "day") : e >= Wd ? uv(r, e, Wd, "hour") : e >= $d ? uv(r, e, $d, "minute") : e >= Gd ? uv(r, e, Gd, "second") : r + " ms"
      }

      function uv(r, e, t, i) {
        var n = e >= t * 1.5;
        return Math.round(r / t) + " " + i + (n ? "s" : "")
      }
    });
    var oK = y((N2t, sK) => {
      l();

      function rke(r) {
        t.debug = t, t.default = t, t.coerce = c, t.disable = s, t.enable = n, t.enabled = o, t.humanize = nK(), t.destroy = u, Object.keys(r).forEach(f => {
          t[f] = r[f]
        }), t.names = [], t.skips = [], t.formatters = {};

        function e(f) {
          let h = 0;
          for (let d = 0; d < f.length; d++) h = (h << 5) - h + f.charCodeAt(d), h |= 0;
          return t.colors[Math.abs(h) % t.colors.length]
        }
        t.selectColor = e;

        function t(f) {
          let h, d = null;

          function p(...g) {
            if (!p.enabled) return;
            let m = p,
              E = Number(new Date),
              w = E - (h || E);
            m.diff = w, m.prev = h, m.curr = E, h = E, g[0] = t.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
            let O = 0;
            g[0] = g[0].replace(/%([a-zA-Z%])/g, (J, Z) => {
              if (J === "%%") return "%";
              O++;
              let H = t.formatters[Z];
              if (typeof H == "function") {
                let te = g[O];
                J = H.call(m, te), g.splice(O, 1), O--
              }
              return J
            }), t.formatArgs.call(m, g), (m.log || t.log).apply(m, g)
          }
          return p.namespace = f, p.useColors = t.useColors(), p.color = t.selectColor(f), p.extend = i, p.destroy = t.destroy, Object.defineProperty(p, "enabled", {
            enumerable: !0,
            configurable: !1,
            get: () => d === null ? t.enabled(f) : d,
            set: g => {
              d = g
            }
          }), typeof t.init == "function" && t.init(p), p
        }

        function i(f, h) {
          let d = t(this.namespace + (typeof h == "undefined" ? ":" : h) + f);
          return d.log = this.log, d
        }

        function n(f) {
          t.save(f), t.names = [], t.skips = [];
          let h, d = (typeof f == "string" ? f : "").split(/[\s,]+/),
            p = d.length;
          for (h = 0; h < p; h++) !d[h] || (f = d[h].replace(/\*/g, ".*?"), f[0] === "-" ? t.skips.push(new RegExp("^" + f.substr(1) + "$")) : t.names.push(new RegExp("^" + f + "$")))
        }

        function s() {
          let f = [...t.names.map(a), ...t.skips.map(a).map(h => "-" + h)].join(",");
          return t.enable(""), f
        }

        function o(f) {
          if (f[f.length - 1] === "*") return !0;
          let h, d;
          for (h = 0, d = t.skips.length; h < d; h++)
            if (t.skips[h].test(f)) return !1;
          for (h = 0, d = t.names.length; h < d; h++)
            if (t.names[h].test(f)) return !0;
          return !1
        }

        function a(f) {
          return f.toString().substring(2, f.toString().length - 2).replace(/\.\*\?$/, "*")
        }

        function c(f) {
          return f instanceof Error ? f.stack || f.message : f
        }

        function u() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
        }
        return t.enable(t.load()), t
      }
      sK.exports = rke
    });
    var Oe = y((ks, fv) => {
      l();
      ks.formatArgs = ike;
      ks.save = nke;
      ks.load = ske;
      ks.useColors = oke;
      ks.storage = ake();
      ks.destroy = (() => {
        let r = !1;
        return () => {
          r || (r = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
        }
      })();
      ks.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];

      function oke() {
        return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
      }

      function ike(r) {
        if (r[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + r[0] + (this.useColors ? "%c " : " ") + "+" + fv.exports.humanize(this.diff), !this.useColors) return;
        let e = "color: " + this.color;
        r.splice(1, 0, e, "color: inherit");
        let t = 0,
          i = 0;
        r[0].replace(/%[a-zA-Z%]/g, n => {
          n !== "%%" && (t++, n === "%c" && (i = t))
        }), r.splice(i, 0, e)
      }
      ks.log = console.debug || console.log || (() => { });

      function nke(r) {
        try {
          r ? ks.storage.setItem("debug", r) : ks.storage.removeItem("debug")
        } catch (e) { }
      }

      function ske() {
        let r;
        try {
          r = ks.storage.getItem("debug")
        } catch (e) { }
        return !r && typeof process != "undefined" && "env" in process && (r = process.env.DEBUG), r
      }

      function ake() {
        try {
          return localStorage
        } catch (r) { }
      }
      fv.exports = oK()(ks);
      var {
        formatters: cke
      } = fv.exports;
      cke.j = function (r) {
        try {
          return JSON.stringify(r)
        } catch (e) {
          return "[UnexpectedJSONParseError]: " + e.message
        }
      }
    });
    var N5 = y((q2t, aK) => {
      l();
      "use strict";
      var Il = bi(),
        lv = Il.Reader,
        cK = Il.Writer,
        ei = Il.util,
        Ps = Il.roots.default || (Il.roots.default = {});
      Ps.PBLink = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.Hash = ei.newBuffer([]), r.prototype.Name = "", r.prototype.Tsize = ei.Long ? ei.Long.fromBits(0, 0, !0) : 0, r.encode = function (t, i) {
          return i || (i = cK.create()), t.Hash != null && Object.hasOwnProperty.call(t, "Hash") && i.uint32(10).bytes(t.Hash), t.Name != null && Object.hasOwnProperty.call(t, "Name") && i.uint32(18).string(t.Name), t.Tsize != null && Object.hasOwnProperty.call(t, "Tsize") && i.uint32(24).uint64(t.Tsize), i
        }, r.decode = function (t, i) {
          t instanceof lv || (t = lv.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Ps.PBLink; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.Hash = t.bytes();
                break;
              case 2:
                s.Name = t.string();
                break;
              case 3:
                s.Tsize = t.uint64();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Ps.PBLink) return t;
          var i = new Ps.PBLink;
          return t.Hash != null && (typeof t.Hash == "string" ? ei.base64.decode(t.Hash, i.Hash = ei.newBuffer(ei.base64.length(t.Hash)), 0) : t.Hash.length && (i.Hash = t.Hash)), t.Name != null && (i.Name = String(t.Name)), t.Tsize != null && (ei.Long ? (i.Tsize = ei.Long.fromValue(t.Tsize)).unsigned = !0 : typeof t.Tsize == "string" ? i.Tsize = parseInt(t.Tsize, 10) : typeof t.Tsize == "number" ? i.Tsize = t.Tsize : typeof t.Tsize == "object" && (i.Tsize = new ei.LongBits(t.Tsize.low >>> 0, t.Tsize.high >>> 0).toNumber(!0))), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if (i.defaults)
            if (i.bytes === String ? n.Hash = "" : (n.Hash = [], i.bytes !== Array && (n.Hash = ei.newBuffer(n.Hash))), n.Name = "", ei.Long) {
              var s = new ei.Long(0, 0, !0);
              n.Tsize = i.longs === String ? s.toString() : i.longs === Number ? s.toNumber() : s
            } else n.Tsize = i.longs === String ? "0" : 0;
          return t.Hash != null && t.hasOwnProperty("Hash") && (n.Hash = i.bytes === String ? ei.base64.encode(t.Hash, 0, t.Hash.length) : i.bytes === Array ? Array.prototype.slice.call(t.Hash) : t.Hash), t.Name != null && t.hasOwnProperty("Name") && (n.Name = t.Name), t.Tsize != null && t.hasOwnProperty("Tsize") && (typeof t.Tsize == "number" ? n.Tsize = i.longs === String ? String(t.Tsize) : t.Tsize : n.Tsize = i.longs === String ? ei.Long.prototype.toString.call(t.Tsize) : i.longs === Number ? new ei.LongBits(t.Tsize.low >>> 0, t.Tsize.high >>> 0).toNumber(!0) : t.Tsize), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, Il.util.toJSONOptions)
        }, r
      }();
      Ps.PBNode = function () {
        function r(e) {
          if (this.Links = [], e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.Links = ei.emptyArray, r.prototype.Data = ei.newBuffer([]), r.encode = function (t, i) {
          if (i || (i = cK.create()), t.Data != null && Object.hasOwnProperty.call(t, "Data") && i.uint32(10).bytes(t.Data), t.Links != null && t.Links.length)
            for (var n = 0; n < t.Links.length; ++n) Ps.PBLink.encode(t.Links[n], i.uint32(18).fork()).ldelim();
          return i
        }, r.decode = function (t, i) {
          t instanceof lv || (t = lv.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Ps.PBNode; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 2:
                s.Links && s.Links.length || (s.Links = []), s.Links.push(Ps.PBLink.decode(t, t.uint32()));
                break;
              case 1:
                s.Data = t.bytes();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Ps.PBNode) return t;
          var i = new Ps.PBNode;
          if (t.Links) {
            if (!Array.isArray(t.Links)) throw TypeError(".PBNode.Links: array expected");
            i.Links = [];
            for (var n = 0; n < t.Links.length; ++n) {
              if (typeof t.Links[n] != "object") throw TypeError(".PBNode.Links: object expected");
              i.Links[n] = Ps.PBLink.fromObject(t.Links[n])
            }
          }
          return t.Data != null && (typeof t.Data == "string" ? ei.base64.decode(t.Data, i.Data = ei.newBuffer(ei.base64.length(t.Data)), 0) : t.Data.length && (i.Data = t.Data)), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if ((i.arrays || i.defaults) && (n.Links = []), i.defaults && (i.bytes === String ? n.Data = "" : (n.Data = [], i.bytes !== Array && (n.Data = ei.newBuffer(n.Data)))), t.Data != null && t.hasOwnProperty("Data") && (n.Data = i.bytes === String ? ei.base64.encode(t.Data, 0, t.Data.length) : i.bytes === Array ? Array.prototype.slice.call(t.Data) : t.Data), t.Links && t.Links.length) {
            n.Links = [];
            for (var s = 0; s < t.Links.length; ++s) n.Links[s] = Ps.PBLink.toObject(t.Links[s], i)
          }
          return n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, Il.util.toJSONOptions)
        }, r
      }();
      aK.exports = Ps
    });
    var rf = y((M2t, uK) => {
      l();
      "use strict";
      var uke = at(),
        fke = gt(),
        fK = class {
          constructor(e, t, i) {
            if (!i) throw new Error("A link requires a cid to point to");
            this.Name = e || "", this.Tsize = t, this.Hash = new uke(i), Object.defineProperties(this, {
              _nameBuf: {
                value: null,
                writable: !0,
                enumerable: !1
              }
            })
          }
          toString() {
            return `DAGLink <${this.Hash.toBaseEncodedString()} - name: "${this.Name}", size: ${this.Tsize}>`
          }
          toJSON() {
            return this._json || (this._json = Object.freeze({
              name: this.Name,
              size: this.Tsize,
              cid: this.Hash.toBaseEncodedString()
            })), Object.assign({}, this._json)
          }
          get nameAsBuffer() {
            return this._nameBuf != null ? this._nameBuf : (this._nameBuf = fke(this.Name), this._nameBuf)
          }
        };
      uK.exports = fK
    });
    var lK = y((q5, M5) => {
      l();
      (function (r, e) {
        typeof q5 == "object" && typeof M5 != "undefined" ? M5.exports = e() : typeof define == "function" && define.amd ? define(e) : r.stable = e()
      })(q5, function () {
        "use strict";
        var r = function (i, n) {
          return e(i.slice(), n)
        };
        r.inplace = function (i, n) {
          var s = e(i, n);
          return s !== i && t(s, null, i.length, i), i
        };

        function e(i, n) {
          typeof n != "function" && (n = function (u, f) {
            return String(u).localeCompare(f)
          });
          var s = i.length;
          if (s <= 1) return i;
          for (var o = new Array(s), a = 1; a < s; a *= 2) {
            t(i, n, a, o);
            var c = i;
            i = o, o = c
          }
          return i
        }
        var t = function (i, n, s, o) {
          var a = i.length,
            c = 0,
            u = s * 2,
            f, h, d, p, g;
          for (f = 0; f < a; f += u)
            for (h = f + s, d = h + s, h > a && (h = a), d > a && (d = a), p = f, g = h; ;)
              if (p < h && g < d) n(i[p], i[g]) <= 0 ? o[c++] = i[p++] : o[c++] = i[g++];
              else if (p < h) o[c++] = i[p++];
              else if (g < d) o[c++] = i[g++];
              else break
        };
        return r
      })
    });
    var B5 = y((B2t, hK) => {
      l();
      "use strict";

      function lke(r, e) {
        for (let t = 0; t < r.byteLength; t++) {
          if (r[t] < e[t]) return -1;
          if (r[t] > e[t]) return 1
        }
        return r.byteLength > e.byteLength ? 1 : r.byteLength < e.byteLength ? -1 : 0
      }
      hK.exports = lke
    });
    var D5 = y((D2t, dK) => {
      l();
      "use strict";
      var hke = lK(),
        dke = B5(),
        pke = (r, e) => {
          let t = r.nameAsBuffer,
            i = e.nameAsBuffer;
          return dke(t, i)
        },
        yke = r => {
          hke.inplace(r, pke)
        };
      dK.exports = yke
    });
    var L5 = y((L2t, pK) => {
      l();
      "use strict";
      var gke = rf();

      function bke(r) {
        return new gke(r.Name || r.name || "", r.Tsize || r.Size || r.size || 0, r.Hash || r.hash || r.multihash || r.cid)
      }
      pK.exports = {
        createDagLinkFromB58EncodedHash: bke
      }
    });
    var F5 = y((F2t, yK) => {
      l();
      "use strict";
      var mke = bi(),
        {
          PBLink: vke
        } = N5(),
        {
          createDagLinkFromB58EncodedHash: wke
        } = L5(),
        gK = r => {
          let e = {};
          return r.Data && r.Data.byteLength > 0 ? e.Data = r.Data : e.Data = null, r.Links && r.Links.length > 0 ? e.Links = r.Links.map(t => ({
            Hash: t.Hash.bytes,
            Name: t.Name,
            Tsize: t.Tsize
          })) : e.Links = null, e
        },
        _ke = r => bK(gK(r)),
        Eke = (r, e = []) => {
          let t = {
            Data: r,
            Links: e.map(i => wke(i))
          };
          return bK(gK(t))
        };
      yK.exports = {
        serializeDAGNode: _ke,
        serializeDAGNodeLike: Eke
      };

      function bK(r) {
        let e = mke.Writer.create();
        if (r.Links != null)
          for (let t = 0; t < r.Links.length; t++) vke.encode(r.Links[t], e.uint32(18).fork()).ldelim();
        return r.Data != null && e.uint32(10).bytes(r.Data), e.finish()
      }
    });
    var U5 = y((U2t, mK) => {
      l();
      "use strict";
      var Ske = at(),
        vK = Jr(),
        wK = cr(),
        {
          multihash: _K
        } = wK,
        EK = vK.DAG_PB,
        SK = _K.names["sha2-256"],
        xke = async (r, e = {}) => {
          let t = {
            cidVersion: e.cidVersion == null ? 1 : e.cidVersion,
            hashAlg: e.hashAlg == null ? SK : e.hashAlg
          },
            i = _K.codes[t.hashAlg],
            n = await wK(r, i),
            s = vK.getNameFromCode(EK);
          return new Ske(t.cidVersion, s, n)
        };
      mK.exports = {
        codec: EK,
        defaultHashAlg: SK,
        cid: xke
      }
    });
    var AK = y((K2t, xK) => {
      l();
      "use strict";
      var Ake = rf(),
        Ike = U5(),
        Tke = async (r, e = {}) => {
          let t = r.serialize(),
            i = await Ike.cid(t, e);
          return new Ake(e.name || "", r.size, i)
        };
      xK.exports = Tke
    });
    var RK = y((z2t, IK) => {
      l();
      "use strict";
      var Rke = D5(),
        TK = rf(),
        kke = r => {
          if (r instanceof TK) return r;
          if (!("cid" in r || "hash" in r || "Hash" in r || "multihash" in r)) throw new Error("Link must be a DAGLink or DAGLink-like. Convert the DAGNode into a DAGLink via `node.toDAGLink()`.");
          return new TK(r.Name || r.name, r.Tsize || r.size, r.Hash || r.multihash || r.hash || r.cid)
        },
        Pke = (r, e) => {
          let t = kke(e);
          r.Links.push(t), Rke(r.Links)
        };
      IK.exports = Pke
    });
    var CK = y((j2t, kK) => {
      l();
      "use strict";
      var Cke = at(),
        PK = Lr(),
        Oke = (r, e) => {
          let t = null;
          if (typeof e == "string" ? t = i => i.Name === e : e instanceof Uint8Array ? t = i => PK(i.Hash.bytes, e) : Cke.isCID(e) && (t = i => PK(i.Hash.bytes, e.bytes)), t) {
            let i = r.Links,
              n = 0;
            for (; n < i.length;) {
              let s = i[n];
              t(s) ? i.splice(n, 1) : n++
            }
          } else throw new Error("second arg needs to be a name or CID")
        };
      kK.exports = Oke
    });
    var hv = y((V2t, OK) => {
      l();
      "use strict";
      var Nke = D5(),
        qke = rf(),
        {
          createDagLinkFromB58EncodedHash: Mke
        } = L5(),
        {
          serializeDAGNode: Bke
        } = F5(),
        Dke = AK(),
        Lke = RK(),
        Fke = CK(),
        Uke = gt(),
        Kke = ct(),
        NK = class {
          constructor(e, t = [], i = null) {
            if (e || (e = new Uint8Array(0)), typeof e == "string" && (e = Uke(e)), !(e instanceof Uint8Array)) throw new Error("Passed 'data' is not a Uint8Array or a String!");
            if (i !== null && typeof i != "number") throw new Error("Passed 'serializedSize' must be a number!");
            let n = t.map(s => s instanceof qke ? s : Mke(s));
            Nke(n), this.Data = e, this.Links = n, Object.defineProperties(this, {
              _serializedSize: {
                value: i,
                writable: !0,
                enumerable: !1
              },
              _size: {
                value: null,
                writable: !0,
                enumerable: !1
              }
            })
          }
          toJSON() {
            return this._json || (this._json = Object.freeze({
              data: this.Data,
              links: this.Links.map(e => e.toJSON()),
              size: this.size
            })), Object.assign({}, this._json)
          }
          toString() {
            return `DAGNode <data: "${Kke(this.Data, "base64urlpad")}", links: ${this.Links.length}, size: ${this.size}>`
          }
          _invalidateCached() {
            this._serializedSize = null, this._size = null
          }
          addLink(e) {
            return this._invalidateCached(), Lke(this, e)
          }
          rmLink(e) {
            return this._invalidateCached(), Fke(this, e)
          }
          toDAGLink(e) {
            return Dke(this, e)
          }
          serialize() {
            let e = Bke(this);
            return this._serializedSize = e.length, e
          }
          get size() {
            if (this._size == null) {
              let e;
              e == null && (this._serializedSize = this.serialize().length, e = this._serializedSize), this._size = this.Links.reduce((t, i) => t + i.Tsize, e)
            }
            return this._size
          }
          set size(e) {
            throw new Error("Can't set property: 'size' is immutable")
          }
        };
      OK.exports = NK
    });
    var z5 = y((H2t, qK) => {
      l();
      "use strict";
      var {
        PBNode: MK
      } = N5(), zke = rf(), BK = hv(), {
        serializeDAGNode: jke,
        serializeDAGNodeLike: Vke
      } = F5(), K5 = U5(), Hke = (r, e) => K5.cid(r, e), Gke = r => r instanceof BK ? jke(r) : Vke(r.Data, r.Links), $ke = r => {
        let e = MK.decode(r),
          t = MK.toObject(e, {
            defaults: !1,
            arrays: !0,
            longs: Number,
            objects: !1
          }),
          i = t.Links.map(s => new zke(s.Name, s.Tsize, s.Hash)),
          n = t.Data == null ? new Uint8Array(0) : t.Data;
        return new BK(n, i, r.byteLength)
      };
      qK.exports = {
        codec: K5.codec,
        defaultHashAlg: K5.defaultHashAlg,
        serialize: Gke,
        deserialize: $ke,
        cid: Hke
      }
    });
    var LK = y(j5 => {
      l();
      "use strict";
      var Wke = at(),
        DK = z5();
      j5.resolve = (r, e = "/") => {
        let t = DK.deserialize(r),
          i = e.split("/").filter(Boolean);
        for (; i.length;) {
          let n = i.shift();
          if (t[n] === void 0) {
            for (let s of t.Links)
              if (s.Name === n) return {
                value: s.Hash,
                remainderPath: i.join("/")
              };
            throw new Error(`Object has no property '${n}'`)
          }
          if (t = t[n], Wke.isCID(t)) return {
            value: t,
            remainderPath: i.join("/")
          }
        }
        return {
          value: t,
          remainderPath: ""
        }
      };
      j5.tree = function* (r) {
        let e = DK.deserialize(r);
        yield "Data", yield "Links";
        for (let t = 0; t < e.Links.length; t++) yield `Links/${t}`, yield `Links/${t}/Name`, yield `Links/${t}/Tsize`, yield `Links/${t}/Hash`
      }
    });
    var Mr = y(($2t, FK) => {
      l();
      "use strict";
      var Yke = LK(),
        V5 = z5(),
        Jke = hv(),
        Xke = rf(),
        Zke = {
          DAGNode: Jke,
          DAGLink: Xke,
          resolver: Yke,
          util: V5,
          codec: V5.codec,
          defaultHashAlg: V5.defaultHashAlg
        };
      FK.exports = Zke
    });
    var KK = y((W2t, UK) => {
      l();
      "use strict";
      var nf = bi(),
        Yd = nf.Reader,
        H5 = nf.Writer,
        ht = nf.util,
        Xi = nf.roots["ipfs-unixfs"] || (nf.roots["ipfs-unixfs"] = {});
      Xi.Data = function () {
        function r(e) {
          if (this.blocksizes = [], e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.Type = 0, r.prototype.Data = ht.newBuffer([]), r.prototype.filesize = ht.Long ? ht.Long.fromBits(0, 0, !0) : 0, r.prototype.blocksizes = ht.emptyArray, r.prototype.hashType = ht.Long ? ht.Long.fromBits(0, 0, !0) : 0, r.prototype.fanout = ht.Long ? ht.Long.fromBits(0, 0, !0) : 0, r.prototype.mode = 0, r.prototype.mtime = null, r.encode = function (t, i) {
          if (i || (i = H5.create()), i.uint32(8).int32(t.Type), t.Data != null && Object.hasOwnProperty.call(t, "Data") && i.uint32(18).bytes(t.Data), t.filesize != null && Object.hasOwnProperty.call(t, "filesize") && i.uint32(24).uint64(t.filesize), t.blocksizes != null && t.blocksizes.length)
            for (var n = 0; n < t.blocksizes.length; ++n) i.uint32(32).uint64(t.blocksizes[n]);
          return t.hashType != null && Object.hasOwnProperty.call(t, "hashType") && i.uint32(40).uint64(t.hashType), t.fanout != null && Object.hasOwnProperty.call(t, "fanout") && i.uint32(48).uint64(t.fanout), t.mode != null && Object.hasOwnProperty.call(t, "mode") && i.uint32(56).uint32(t.mode), t.mtime != null && Object.hasOwnProperty.call(t, "mtime") && Xi.UnixTime.encode(t.mtime, i.uint32(66).fork()).ldelim(), i
        }, r.decode = function (t, i) {
          t instanceof Yd || (t = Yd.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Xi.Data; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.Type = t.int32();
                break;
              case 2:
                s.Data = t.bytes();
                break;
              case 3:
                s.filesize = t.uint64();
                break;
              case 4:
                if (s.blocksizes && s.blocksizes.length || (s.blocksizes = []), (o & 7) == 2)
                  for (var a = t.uint32() + t.pos; t.pos < a;) s.blocksizes.push(t.uint64());
                else s.blocksizes.push(t.uint64());
                break;
              case 5:
                s.hashType = t.uint64();
                break;
              case 6:
                s.fanout = t.uint64();
                break;
              case 7:
                s.mode = t.uint32();
                break;
              case 8:
                s.mtime = Xi.UnixTime.decode(t, t.uint32());
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          if (!s.hasOwnProperty("Type")) throw ht.ProtocolError("missing required 'Type'", {
            instance: s
          });
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Xi.Data) return t;
          var i = new Xi.Data;
          switch (t.Type) {
            case "Raw":
            case 0:
              i.Type = 0;
              break;
            case "Directory":
            case 1:
              i.Type = 1;
              break;
            case "File":
            case 2:
              i.Type = 2;
              break;
            case "Metadata":
            case 3:
              i.Type = 3;
              break;
            case "Symlink":
            case 4:
              i.Type = 4;
              break;
            case "HAMTShard":
            case 5:
              i.Type = 5;
              break
          }
          if (t.Data != null && (typeof t.Data == "string" ? ht.base64.decode(t.Data, i.Data = ht.newBuffer(ht.base64.length(t.Data)), 0) : t.Data.length && (i.Data = t.Data)), t.filesize != null && (ht.Long ? (i.filesize = ht.Long.fromValue(t.filesize)).unsigned = !0 : typeof t.filesize == "string" ? i.filesize = parseInt(t.filesize, 10) : typeof t.filesize == "number" ? i.filesize = t.filesize : typeof t.filesize == "object" && (i.filesize = new ht.LongBits(t.filesize.low >>> 0, t.filesize.high >>> 0).toNumber(!0))), t.blocksizes) {
            if (!Array.isArray(t.blocksizes)) throw TypeError(".Data.blocksizes: array expected");
            i.blocksizes = [];
            for (var n = 0; n < t.blocksizes.length; ++n) ht.Long ? (i.blocksizes[n] = ht.Long.fromValue(t.blocksizes[n])).unsigned = !0 : typeof t.blocksizes[n] == "string" ? i.blocksizes[n] = parseInt(t.blocksizes[n], 10) : typeof t.blocksizes[n] == "number" ? i.blocksizes[n] = t.blocksizes[n] : typeof t.blocksizes[n] == "object" && (i.blocksizes[n] = new ht.LongBits(t.blocksizes[n].low >>> 0, t.blocksizes[n].high >>> 0).toNumber(!0))
          }
          if (t.hashType != null && (ht.Long ? (i.hashType = ht.Long.fromValue(t.hashType)).unsigned = !0 : typeof t.hashType == "string" ? i.hashType = parseInt(t.hashType, 10) : typeof t.hashType == "number" ? i.hashType = t.hashType : typeof t.hashType == "object" && (i.hashType = new ht.LongBits(t.hashType.low >>> 0, t.hashType.high >>> 0).toNumber(!0))), t.fanout != null && (ht.Long ? (i.fanout = ht.Long.fromValue(t.fanout)).unsigned = !0 : typeof t.fanout == "string" ? i.fanout = parseInt(t.fanout, 10) : typeof t.fanout == "number" ? i.fanout = t.fanout : typeof t.fanout == "object" && (i.fanout = new ht.LongBits(t.fanout.low >>> 0, t.fanout.high >>> 0).toNumber(!0))), t.mode != null && (i.mode = t.mode >>> 0), t.mtime != null) {
            if (typeof t.mtime != "object") throw TypeError(".Data.mtime: object expected");
            i.mtime = Xi.UnixTime.fromObject(t.mtime)
          }
          return i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if ((i.arrays || i.defaults) && (n.blocksizes = []), i.defaults) {
            if (n.Type = i.enums === String ? "Raw" : 0, i.bytes === String ? n.Data = "" : (n.Data = [], i.bytes !== Array && (n.Data = ht.newBuffer(n.Data))), ht.Long) {
              var s = new ht.Long(0, 0, !0);
              n.filesize = i.longs === String ? s.toString() : i.longs === Number ? s.toNumber() : s
            } else n.filesize = i.longs === String ? "0" : 0;
            if (ht.Long) {
              var s = new ht.Long(0, 0, !0);
              n.hashType = i.longs === String ? s.toString() : i.longs === Number ? s.toNumber() : s
            } else n.hashType = i.longs === String ? "0" : 0;
            if (ht.Long) {
              var s = new ht.Long(0, 0, !0);
              n.fanout = i.longs === String ? s.toString() : i.longs === Number ? s.toNumber() : s
            } else n.fanout = i.longs === String ? "0" : 0;
            n.mode = 0, n.mtime = null
          }
          if (t.Type != null && t.hasOwnProperty("Type") && (n.Type = i.enums === String ? Xi.Data.DataType[t.Type] : t.Type), t.Data != null && t.hasOwnProperty("Data") && (n.Data = i.bytes === String ? ht.base64.encode(t.Data, 0, t.Data.length) : i.bytes === Array ? Array.prototype.slice.call(t.Data) : t.Data), t.filesize != null && t.hasOwnProperty("filesize") && (typeof t.filesize == "number" ? n.filesize = i.longs === String ? String(t.filesize) : t.filesize : n.filesize = i.longs === String ? ht.Long.prototype.toString.call(t.filesize) : i.longs === Number ? new ht.LongBits(t.filesize.low >>> 0, t.filesize.high >>> 0).toNumber(!0) : t.filesize), t.blocksizes && t.blocksizes.length) {
            n.blocksizes = [];
            for (var o = 0; o < t.blocksizes.length; ++o) typeof t.blocksizes[o] == "number" ? n.blocksizes[o] = i.longs === String ? String(t.blocksizes[o]) : t.blocksizes[o] : n.blocksizes[o] = i.longs === String ? ht.Long.prototype.toString.call(t.blocksizes[o]) : i.longs === Number ? new ht.LongBits(t.blocksizes[o].low >>> 0, t.blocksizes[o].high >>> 0).toNumber(!0) : t.blocksizes[o]
          }
          return t.hashType != null && t.hasOwnProperty("hashType") && (typeof t.hashType == "number" ? n.hashType = i.longs === String ? String(t.hashType) : t.hashType : n.hashType = i.longs === String ? ht.Long.prototype.toString.call(t.hashType) : i.longs === Number ? new ht.LongBits(t.hashType.low >>> 0, t.hashType.high >>> 0).toNumber(!0) : t.hashType), t.fanout != null && t.hasOwnProperty("fanout") && (typeof t.fanout == "number" ? n.fanout = i.longs === String ? String(t.fanout) : t.fanout : n.fanout = i.longs === String ? ht.Long.prototype.toString.call(t.fanout) : i.longs === Number ? new ht.LongBits(t.fanout.low >>> 0, t.fanout.high >>> 0).toNumber(!0) : t.fanout), t.mode != null && t.hasOwnProperty("mode") && (n.mode = t.mode), t.mtime != null && t.hasOwnProperty("mtime") && (n.mtime = Xi.UnixTime.toObject(t.mtime, i)), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, nf.util.toJSONOptions)
        }, r.DataType = function () {
          var e = {},
            t = Object.create(e);
          return t[e[0] = "Raw"] = 0, t[e[1] = "Directory"] = 1, t[e[2] = "File"] = 2, t[e[3] = "Metadata"] = 3, t[e[4] = "Symlink"] = 4, t[e[5] = "HAMTShard"] = 5, t
        }(), r
      }();
      Xi.UnixTime = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.Seconds = ht.Long ? ht.Long.fromBits(0, 0, !1) : 0, r.prototype.FractionalNanoseconds = 0, r.encode = function (t, i) {
          return i || (i = H5.create()), i.uint32(8).int64(t.Seconds), t.FractionalNanoseconds != null && Object.hasOwnProperty.call(t, "FractionalNanoseconds") && i.uint32(21).fixed32(t.FractionalNanoseconds), i
        }, r.decode = function (t, i) {
          t instanceof Yd || (t = Yd.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Xi.UnixTime; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.Seconds = t.int64();
                break;
              case 2:
                s.FractionalNanoseconds = t.fixed32();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          if (!s.hasOwnProperty("Seconds")) throw ht.ProtocolError("missing required 'Seconds'", {
            instance: s
          });
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Xi.UnixTime) return t;
          var i = new Xi.UnixTime;
          return t.Seconds != null && (ht.Long ? (i.Seconds = ht.Long.fromValue(t.Seconds)).unsigned = !1 : typeof t.Seconds == "string" ? i.Seconds = parseInt(t.Seconds, 10) : typeof t.Seconds == "number" ? i.Seconds = t.Seconds : typeof t.Seconds == "object" && (i.Seconds = new ht.LongBits(t.Seconds.low >>> 0, t.Seconds.high >>> 0).toNumber())), t.FractionalNanoseconds != null && (i.FractionalNanoseconds = t.FractionalNanoseconds >>> 0), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if (i.defaults) {
            if (ht.Long) {
              var s = new ht.Long(0, 0, !1);
              n.Seconds = i.longs === String ? s.toString() : i.longs === Number ? s.toNumber() : s
            } else n.Seconds = i.longs === String ? "0" : 0;
            n.FractionalNanoseconds = 0
          }
          return t.Seconds != null && t.hasOwnProperty("Seconds") && (typeof t.Seconds == "number" ? n.Seconds = i.longs === String ? String(t.Seconds) : t.Seconds : n.Seconds = i.longs === String ? ht.Long.prototype.toString.call(t.Seconds) : i.longs === Number ? new ht.LongBits(t.Seconds.low >>> 0, t.Seconds.high >>> 0).toNumber() : t.Seconds), t.FractionalNanoseconds != null && t.hasOwnProperty("FractionalNanoseconds") && (n.FractionalNanoseconds = t.FractionalNanoseconds), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, nf.util.toJSONOptions)
        }, r
      }();
      Xi.Metadata = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.MimeType = "", r.encode = function (t, i) {
          return i || (i = H5.create()), t.MimeType != null && Object.hasOwnProperty.call(t, "MimeType") && i.uint32(10).string(t.MimeType), i
        }, r.decode = function (t, i) {
          t instanceof Yd || (t = Yd.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Xi.Metadata; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.MimeType = t.string();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Xi.Metadata) return t;
          var i = new Xi.Metadata;
          return t.MimeType != null && (i.MimeType = String(t.MimeType)), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          return i.defaults && (n.MimeType = ""), t.MimeType != null && t.hasOwnProperty("MimeType") && (n.MimeType = t.MimeType), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, nf.util.toJSONOptions)
        }, r
      }();
      UK.exports = Xi
    });
    var Ii = y((Y2t, zK) => {
      l();
      "use strict";
      var {
        Data: Wc
      } = KK(), G5 = xe(), jK = ["raw", "directory", "file", "metadata", "symlink", "hamt-sharded-directory"], Qke = ["directory", "hamt-sharded-directory"], VK = parseInt("0644", 8), HK = parseInt("0755", 8);

      function dv(r) {
        if (r != null) return typeof r == "number" ? r & 4095 : (r = r.toString(), r.substring(0, 1) === "0" ? parseInt(r, 8) & 4095 : parseInt(r, 10) & 4095)
      }

      function $5(r) {
        if (r == null) return;
        let e;
        if (r.secs != null && (e = {
          secs: r.secs,
          nsecs: r.nsecs
        }), r.Seconds != null && (e = {
          secs: r.Seconds,
          nsecs: r.FractionalNanoseconds
        }), Array.isArray(r) && (e = {
          secs: r[0],
          nsecs: r[1]
        }), r instanceof Date) {
          let t = r.getTime(),
            i = Math.floor(t / 1e3);
          e = {
            secs: i,
            nsecs: (t - i * 1e3) * 1e3
          }
        }
        if (!!Object.prototype.hasOwnProperty.call(e, "secs")) {
          if (e != null && e.nsecs != null && (e.nsecs < 0 || e.nsecs > 999999999)) throw G5(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
          return e
        }
      }
      var pv = class {
        static unmarshal(e) {
          let t = Wc.decode(e),
            i = Wc.toObject(t, {
              defaults: !1,
              arrays: !0,
              longs: Number,
              objects: !1
            }),
            n = new pv({
              type: jK[i.Type],
              data: i.Data,
              blockSizes: i.blocksizes,
              mode: i.mode,
              mtime: i.mtime ? {
                secs: i.mtime.Seconds,
                nsecs: i.mtime.FractionalNanoseconds
              } : void 0
            });
          return n._originalMode = i.mode || 0, n
        }
        constructor(e = {
          type: "file"
        }) {
          let {
            type: t,
            data: i,
            blockSizes: n,
            hashType: s,
            fanout: o,
            mtime: a,
            mode: c
          } = e;
          if (t && !jK.includes(t)) throw G5(new Error("Type: " + t + " is not valid"), "ERR_INVALID_TYPE");
          this.type = t || "file", this.data = i, this.hashType = s, this.fanout = o, this.blockSizes = n || [], this._originalMode = 0, this.mode = dv(c), a && (this.mtime = $5(a), this.mtime && !this.mtime.nsecs && (this.mtime.nsecs = 0))
        }
        set mode(e) {
          this._mode = this.isDirectory() ? HK : VK;
          let t = dv(e);
          t !== void 0 && (this._mode = t)
        }
        get mode() {
          return this._mode
        }
        isDirectory() {
          return Boolean(this.type && Qke.includes(this.type))
        }
        addBlockSize(e) {
          this.blockSizes.push(e)
        }
        removeBlockSize(e) {
          this.blockSizes.splice(e, 1)
        }
        fileSize() {
          if (this.isDirectory()) return 0;
          let e = 0;
          return this.blockSizes.forEach(t => {
            e += t
          }), this.data && (e += this.data.length), e
        }
        marshal() {
          let e;
          switch (this.type) {
            case "raw":
              e = Wc.DataType.Raw;
              break;
            case "directory":
              e = Wc.DataType.Directory;
              break;
            case "file":
              e = Wc.DataType.File;
              break;
            case "metadata":
              e = Wc.DataType.Metadata;
              break;
            case "symlink":
              e = Wc.DataType.Symlink;
              break;
            case "hamt-sharded-directory":
              e = Wc.DataType.HAMTShard;
              break;
            default:
              throw G5(new Error("Type: " + e + " is not valid"), "ERR_INVALID_TYPE")
          }
          let t = this.data;
          (!this.data || !this.data.length) && (t = void 0);
          let i;
          this.mode != null && (i = this._originalMode & 4294963200 | (dv(this.mode) || 0), i === VK && !this.isDirectory() && (i = void 0), i === HK && this.isDirectory() && (i = void 0));
          let n;
          if (this.mtime != null) {
            let o = $5(this.mtime);
            o && (n = {
              Seconds: o.secs,
              FractionalNanoseconds: o.nsecs
            }, n.FractionalNanoseconds === 0 && delete n.FractionalNanoseconds)
          }
          let s = {
            Type: e,
            Data: t,
            filesize: this.isDirectory() ? void 0 : this.fileSize(),
            blocksizes: this.blockSizes,
            hashType: this.hashType,
            fanout: this.fanout,
            mode: i,
            mtime: n
          };
          return Wc.encode(s).finish()
        }
      };
      zK.exports = {
        UnixFS: pv,
        parseMode: dv,
        parseMtime: $5
      }
    });
    var $K = y((J2t, GK) => {
      l();
      "use strict";
      GK.exports = () => { }
    });
    var of = y(sf => {
      l();
      "use strict";
      var xy = class extends Error {
        constructor(e = "not initialized") {
          super(e);
          this.name = "NotInitializedError", this.code = xy.code
        }
      };
      xy.code = "ERR_NOT_INITIALIZED";
      sf.NotInitializedError = xy;
      var W5 = class extends Error {
        constructor(e = "cannot initialize an initializing node") {
          super(e);
          this.name = "AlreadyInitializingError", this.code = Jd.code
        }
      };
      W5.code = "ERR_ALREADY_INITIALIZING";
      sf.AlreadyInitializingError = W5;
      var Jd = class extends Error {
        constructor(e = "cannot re-initialize an initialized node") {
          super(e);
          this.name = "AlreadyInitializedError", this.code = Jd.code
        }
      };
      Jd.code = "ERR_ALREADY_INITIALIZED";
      sf.AlreadyInitializedError = Jd;
      var Ay = class extends Error {
        constructor(e = "not started") {
          super(e);
          this.name = "NotStartedError", this.code = Ay.code
        }
      };
      Ay.code = "ERR_NOT_STARTED";
      sf.NotStartedError = Ay;
      var Iy = class extends Error {
        constructor(e = "cannot start, already startin") {
          super(e);
          this.name = "AlreadyStartingError", this.code = Iy.code
        }
      };
      Iy.code = "ERR_ALREADY_STARTING";
      sf.AlreadyStartingError = Iy;
      var Ty = class extends Error {
        constructor(e = "cannot start, already started") {
          super(e);
          this.name = "AlreadyStartedError", this.code = Ty.code
        }
      };
      Ty.code = "ERR_ALREADY_STARTED";
      sf.AlreadyStartedError = Ty;
      var Ry = class extends Error {
        constructor(e = "not enabled") {
          super(e);
          this.name = "NotEnabledError", this.code = Ry.code
        }
      };
      Ry.code = "ERR_NOT_ENABLED";
      sf.NotEnabledError = Ry
    });
    var yv = y((Z2t, WK) => {
      l();
      "use strict";
      var {
        NotStartedError: ePe,
        AlreadyStartingError: tPe,
        AlreadyStartedError: rPe
      } = of(), {
        withTimeout: iPe
      } = Ji(), Za = class {
        static create({
          start: e,
          stop: t
        }) {
          return new Za(e, t)
        }
        static async start(e, t) {
          let {
            state: i,
            activate: n
          } = e;
          switch (i.status) {
            case "stopped":
              try {
                let s = n(t);
                e.state = {
                  status: "starting",
                  ready: s
                };
                let o = await s;
                return e.state = {
                  status: "started",
                  value: o
                }, o
              } catch (s) {
                throw e.state = {
                  status: "stopped"
                }, s
              }
            case "starting":
              throw new tPe;
            case "started":
              throw new rPe;
            case "stopping":
              return await i.ready, await Za.start(e, t);
            default:
              return Za.panic(e)
          }
        }
        static async stop(e) {
          let {
            state: t,
            deactivate: i
          } = e;
          switch (t.status) {
            case "stopped":
              break;
            case "starting": {
              try {
                await t.ready
              } catch (n) { }
              return await Za.stop(e)
            }
            case "stopping":
              return await t.ready;
            case "started": {
              i && await i(t.value), e.state = {
                status: "stopped"
              };
              break
            }
            default:
              Za.panic(t)
          }
        }
        static
        try({
          state: e
        }) {
          switch (e.status) {
            case "started":
              return e.value;
            default:
              return null
          }
        }
        static async use({
          state: e
        }, t) {
          switch (e.status) {
            case "started":
              return e.value;
            case "starting":
              return await iPe(e.ready, t);
            default:
              throw new ePe
          }
        }
        static panic({
          state: e
        }) {
          let t = JSON.stringify({
            status: e.status
          });
          throw RangeError(`Service in invalid state ${t}, should never happen if you see this please report a bug`)
        }
        constructor(e, t) {
          this.activate = e, this.deactivate = t, this.state = {
            status: "stopped"
          }
        }
        async use(e) {
          return await Za.use(this, e)
        }
        try() {
          return Za.try(this)
        }
      };
      WK.exports = Za
    });
    var JK = y((Q2t, YK) => {
      l();
      "use strict";
      var nPe = yv();
      YK.exports = ({
        network: r,
        preload: e,
        peerId: t,
        keychain: i,
        repo: n,
        ipns: s,
        blockService: o,
        mfsPreload: a,
        print: c,
        options: u
      }) => async () => {
        let {
          bitswap: h,
          libp2p: d
        } = await nPe.start(r, {
          peerId: t,
          repo: n,
          print: c,
          options: u
        });
        o.setExchange(h), await Promise.all([s.startOnline({
          keychain: i,
          libp2p: d,
          peerId: t,
          repo: n
        }), e.start(), a.start()])
      }
    });
    var ZK = y((evt, XK) => {
      l();
      "use strict";
      var sPe = yv();
      XK.exports = ({
        network: r,
        preload: e,
        blockService: t,
        ipns: i,
        repo: n,
        mfsPreload: s
      }) => async () => {
        t.unsetExchange(), await Promise.all([e.stop(), i.stop(), s.stop(), sPe.stop(r), n.close()])
      }
    });
    var ky = y((tvt, QK) => {
      l();
      QK.exports = function (r) {
        if (!r) throw Error("hashlru must have a max value, of type number, greater than 0");
        var e = 0,
          t = Object.create(null),
          i = Object.create(null);

        function n(s, o) {
          t[s] = o, e++, e >= r && (e = 0, i = t, t = Object.create(null))
        }
        return {
          has: function (s) {
            return t[s] !== void 0 || i[s] !== void 0
          },
          remove: function (s) {
            t[s] !== void 0 && (t[s] = void 0), i[s] !== void 0 && (i[s] = void 0)
          },
          get: function (s) {
            var o = t[s];
            if (o !== void 0) return o;
            if ((o = i[s]) !== void 0) return n(s, o), o
          },
          set: function (s, o) {
            t[s] !== void 0 ? t[s] = o : n(s, o)
          },
          clear: function () {
            t = Object.create(null), i = Object.create(null)
          }
        }
      }
    });
    var Y5 = y((rvt, ez) => {
      l();
      "use strict";
      var oPe = ky(),
        tz = class {
          constructor(e) {
            this.lru = oPe(e)
          }
          get(e) {
            let t = this.lru.get(e);
            if (t) {
              if (t.expire && t.expire < Date.now()) {
                this.lru.remove(e);
                return
              }
              return t.value
            }
          }
          set(e, t, i) {
            this.lru.set(e, {
              value: t,
              expire: Date.now() + i
            })
          }
          has(e) {
            return !!this.get(e)
          }
          remove(e) {
            this.lru.remove(e)
          }
          clear() {
            this.lru.clear()
          }
        };
      ez.exports = tz
    });
    var iz = y((ivt, J5) => {
      l();
      "use strict";
      var aPe = Object.prototype.hasOwnProperty,
        Hn = "~";

      function Py() { }
      Object.create && (Py.prototype = Object.create(null), new Py().__proto__ || (Hn = !1));

      function cPe(r, e, t) {
        this.fn = r, this.context = e, this.once = t || !1
      }

      function rz(r, e, t, i, n) {
        if (typeof t != "function") throw new TypeError("The listener must be a function");
        var s = new cPe(t, i || r, n),
          o = Hn ? Hn + e : e;
        return r._events[o] ? r._events[o].fn ? r._events[o] = [r._events[o], s] : r._events[o].push(s) : (r._events[o] = s, r._eventsCount++), r
      }

      function gv(r, e) {
        --r._eventsCount == 0 ? r._events = new Py : delete r._events[e]
      }

      function Rn() {
        this._events = new Py, this._eventsCount = 0
      }
      Rn.prototype.eventNames = function () {
        var e = [],
          t, i;
        if (this._eventsCount === 0) return e;
        for (i in t = this._events) aPe.call(t, i) && e.push(Hn ? i.slice(1) : i);
        return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t)) : e
      };
      Rn.prototype.listeners = function (e) {
        var t = Hn ? Hn + e : e,
          i = this._events[t];
        if (!i) return [];
        if (i.fn) return [i.fn];
        for (var n = 0, s = i.length, o = new Array(s); n < s; n++) o[n] = i[n].fn;
        return o
      };
      Rn.prototype.listenerCount = function (e) {
        var t = Hn ? Hn + e : e,
          i = this._events[t];
        return i ? i.fn ? 1 : i.length : 0
      };
      Rn.prototype.emit = function (e, t, i, n, s, o) {
        var a = Hn ? Hn + e : e;
        if (!this._events[a]) return !1;
        var c = this._events[a],
          u = arguments.length,
          f, h;
        if (c.fn) {
          switch (c.once && this.removeListener(e, c.fn, void 0, !0), u) {
            case 1:
              return c.fn.call(c.context), !0;
            case 2:
              return c.fn.call(c.context, t), !0;
            case 3:
              return c.fn.call(c.context, t, i), !0;
            case 4:
              return c.fn.call(c.context, t, i, n), !0;
            case 5:
              return c.fn.call(c.context, t, i, n, s), !0;
            case 6:
              return c.fn.call(c.context, t, i, n, s, o), !0
          }
          for (h = 1, f = new Array(u - 1); h < u; h++) f[h - 1] = arguments[h];
          c.fn.apply(c.context, f)
        } else {
          var d = c.length,
            p;
          for (h = 0; h < d; h++) switch (c[h].once && this.removeListener(e, c[h].fn, void 0, !0), u) {
            case 1:
              c[h].fn.call(c[h].context);
              break;
            case 2:
              c[h].fn.call(c[h].context, t);
              break;
            case 3:
              c[h].fn.call(c[h].context, t, i);
              break;
            case 4:
              c[h].fn.call(c[h].context, t, i, n);
              break;
            default:
              if (!f)
                for (p = 1, f = new Array(u - 1); p < u; p++) f[p - 1] = arguments[p];
              c[h].fn.apply(c[h].context, f)
          }
        }
        return !0
      };
      Rn.prototype.on = function (e, t, i) {
        return rz(this, e, t, i, !1)
      };
      Rn.prototype.once = function (e, t, i) {
        return rz(this, e, t, i, !0)
      };
      Rn.prototype.removeListener = function (e, t, i, n) {
        var s = Hn ? Hn + e : e;
        if (!this._events[s]) return this;
        if (!t) return gv(this, s), this;
        var o = this._events[s];
        if (o.fn) o.fn === t && (!n || o.once) && (!i || o.context === i) && gv(this, s);
        else {
          for (var a = 0, c = [], u = o.length; a < u; a++)(o[a].fn !== t || n && !o[a].once || i && o[a].context !== i) && c.push(o[a]);
          c.length ? this._events[s] = c.length === 1 ? c[0] : c : gv(this, s)
        }
        return this
      };
      Rn.prototype.removeAllListeners = function (e) {
        var t;
        return e ? (t = Hn ? Hn + e : e, this._events[t] && gv(this, t)) : (this._events = new Py, this._eventsCount = 0), this
      };
      Rn.prototype.off = Rn.prototype.removeListener;
      Rn.prototype.addListener = Rn.prototype.on;
      Rn.prefixed = Hn;
      Rn.EventEmitter = Rn;
      typeof J5 != "undefined" && (J5.exports = Rn)
    });
    var sz = y((nvt, nz) => {
      l();
      "use strict";
      nz.exports = (r, e) => (e = e || (() => { }), r.then(t => new Promise(i => {
        i(e())
      }).then(() => t), t => new Promise(i => {
        i(e())
      }).then(() => {
        throw t
      })))
    });
    var az = y((svt, bv) => {
      l();
      "use strict";
      var uPe = sz(),
        X5 = class extends Error {
          constructor(e) {
            super(e);
            this.name = "TimeoutError"
          }
        },
        oz = (r, e, t) => new Promise((i, n) => {
          if (typeof e != "number" || e < 0) throw new TypeError("Expected `milliseconds` to be a positive number");
          if (e === Infinity) {
            i(r);
            return
          }
          let s = setTimeout(() => {
            if (typeof t == "function") {
              try {
                i(t())
              } catch (c) {
                n(c)
              }
              return
            }
            let o = typeof t == "string" ? t : `Promise timed out after ${e} milliseconds`,
              a = t instanceof Error ? t : new X5(o);
            typeof r.cancel == "function" && r.cancel(), n(a)
          }, e);
          uPe(r.then(i, n), () => {
            clearTimeout(s)
          })
        });
      bv.exports = oz;
      bv.exports.default = oz;
      bv.exports.TimeoutError = X5
    });
    var cz = y(Z5 => {
      l();
      "use strict";
      Object.defineProperty(Z5, "__esModule", {
        value: !0
      });

      function fPe(r, e, t) {
        let i = 0,
          n = r.length;
        for (; n > 0;) {
          let s = n / 2 | 0,
            o = i + s;
          t(r[o], e) <= 0 ? (i = ++o, n -= s + 1) : n = s
        }
        return i
      }
      Z5.default = fPe
    });
    var fz = y(Q5 => {
      l();
      "use strict";
      Object.defineProperty(Q5, "__esModule", {
        value: !0
      });
      var lPe = cz(),
        uz = class {
          constructor() {
            this._queue = []
          }
          enqueue(e, t) {
            t = Object.assign({
              priority: 0
            }, t);
            let i = {
              priority: t.priority,
              run: e
            };
            if (this.size && this._queue[this.size - 1].priority >= t.priority) {
              this._queue.push(i);
              return
            }
            let n = lPe.default(this._queue, i, (s, o) => o.priority - s.priority);
            this._queue.splice(n, 0, i)
          }
          dequeue() {
            let e = this._queue.shift();
            return e == null ? void 0 : e.run
          }
          filter(e) {
            return this._queue.filter(t => t.priority === e.priority).map(t => t.run)
          }
          get size() {
            return this._queue.length
          }
        };
      Q5.default = uz
    });
    var Tl = y(e8 => {
      l();
      "use strict";
      Object.defineProperty(e8, "__esModule", {
        value: !0
      });
      var hPe = iz(),
        lz = az(),
        dPe = fz(),
        mv = () => { },
        pPe = new lz.TimeoutError,
        hz = class extends hPe {
          constructor(e) {
            var t, i, n, s;
            super();
            if (this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = mv, this._resolveIdle = mv, e = Object.assign({
              carryoverConcurrencyCount: !1,
              intervalCap: Infinity,
              interval: 0,
              concurrency: Infinity,
              autoStart: !0,
              queueClass: dPe.default
            }, e), !(typeof e.intervalCap == "number" && e.intervalCap >= 1)) throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(i = (t = e.intervalCap) === null || t === void 0 ? void 0 : t.toString()) !== null && i !== void 0 ? i : ""}\` (${typeof e.intervalCap})`);
            if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0)) throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(s = (n = e.interval) === null || n === void 0 ? void 0 : n.toString()) !== null && s !== void 0 ? s : ""}\` (${typeof e.interval})`);
            this._carryoverConcurrencyCount = e.carryoverConcurrencyCount, this._isIntervalIgnored = e.intervalCap === Infinity || e.interval === 0, this._intervalCap = e.intervalCap, this._interval = e.interval, this._queue = new e.queueClass, this._queueClass = e.queueClass, this.concurrency = e.concurrency, this._timeout = e.timeout, this._throwOnTimeout = e.throwOnTimeout === !0, this._isPaused = e.autoStart === !1
          }
          get _doesIntervalAllowAnother() {
            return this._isIntervalIgnored || this._intervalCount < this._intervalCap
          }
          get _doesConcurrentAllowAnother() {
            return this._pendingCount < this._concurrency
          }
          _next() {
            this._pendingCount--, this._tryToStartAnother(), this.emit("next")
          }
          _resolvePromises() {
            this._resolveEmpty(), this._resolveEmpty = mv, this._pendingCount === 0 && (this._resolveIdle(), this._resolveIdle = mv, this.emit("idle"))
          }
          _onResumeInterval() {
            this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0
          }
          _isIntervalPaused() {
            let e = Date.now();
            if (this._intervalId === void 0) {
              let t = this._intervalEnd - e;
              if (t < 0) this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
              else return this._timeoutId === void 0 && (this._timeoutId = setTimeout(() => {
                this._onResumeInterval()
              }, t)), !0
            }
            return !1
          }
          _tryToStartAnother() {
            if (this._queue.size === 0) return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), !1;
            if (!this._isPaused) {
              let e = !this._isIntervalPaused();
              if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
                let t = this._queue.dequeue();
                return t ? (this.emit("active"), t(), e && this._initializeIntervalIfNeeded(), !0) : !1
              }
            }
            return !1
          }
          _initializeIntervalIfNeeded() {
            this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval(() => {
              this._onInterval()
            }, this._interval), this._intervalEnd = Date.now() + this._interval)
          }
          _onInterval() {
            this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue()
          }
          _processQueue() {
            for (; this._tryToStartAnother(););
          }
          get concurrency() {
            return this._concurrency
          }
          set concurrency(e) {
            if (!(typeof e == "number" && e >= 1)) throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
            this._concurrency = e, this._processQueue()
          }
          async add(e, t = {}) {
            return new Promise((i, n) => {
              let s = async () => {
                this._pendingCount++, this._intervalCount++;
                try {
                  let o = this._timeout === void 0 && t.timeout === void 0 ? e() : lz.default(Promise.resolve(e()), t.timeout === void 0 ? this._timeout : t.timeout, () => {
                    (t.throwOnTimeout === void 0 ? this._throwOnTimeout : t.throwOnTimeout) && n(pPe)
                  });
                  i(await o)
                } catch (o) {
                  n(o)
                }
                this._next()
              };
              this._queue.enqueue(s, t), this._tryToStartAnother(), this.emit("add")
            })
          }
          async addAll(e, t) {
            return Promise.all(e.map(async i => this.add(i, t)))
          }
          start() {
            return this._isPaused ? (this._isPaused = !1, this._processQueue(), this) : this
          }
          pause() {
            this._isPaused = !0
          }
          clear() {
            this._queue = new this._queueClass
          }
          async onEmpty() {
            if (this._queue.size !== 0) return new Promise(e => {
              let t = this._resolveEmpty;
              this._resolveEmpty = () => {
                t(), e()
              }
            })
          }
          async onIdle() {
            if (!(this._pendingCount === 0 && this._queue.size === 0)) return new Promise(e => {
              let t = this._resolveIdle;
              this._resolveIdle = () => {
                t(), e()
              }
            })
          }
          get size() {
            return this._queue.size
          }
          sizeBy(e) {
            return this._queue.filter(e).length
          }
          get pending() {
            return this._pendingCount
          }
          get isPaused() {
            return this._isPaused
          }
          get timeout() {
            return this._timeout
          }
          set timeout(e) {
            this._timeout = e
          }
        };
      e8.default = hz
    });
    var yz = y((uvt, dz) => {
      l();
      "use strict";
      var yPe = Y5(),
        {
          default: gPe
        } = Tl(),
        bPe = Mm(),
        t8 = new yPe(1e3),
        mPe = 60 * 1e3,
        vPe = new gPe({
          concurrency: 4
        }),
        pz = r => {
          if (r.Path) return r.Path;
          throw new Error(r.Message)
        };
      dz.exports = async (r, e) => (async (i, n = {}) => {
        let s = new URLSearchParams(n);
        s.set("arg", i);
        let o = s.toString();
        if (!n.nocache && t8.has(o)) {
          let c = t8.get(o);
          return pz(c)
        }
        let a = await vPe.add(async () => {
          let c = await bPe.get("https://ipfs.io/api/v0/dns", {
            searchParams: s
          }),
            u = new URL(c.url).search.slice(1),
            f = await c.json();
          return t8.set(u, f, mPe), f
        });
        return pz(a)
      })(r, e)
    });
    var bz = y((fvt, gz) => {
      l();
      "use strict";
      var wPe = yz(),
        _Pe = ze();

      function EPe(r) {
        return r.endsWith(".eth") && (r = r.replace(/.eth$/, ".eth.link")), r
      }
      gz.exports = () => _Pe(async (e, t = {
        recursive: !0
      }) => {
        if (typeof e != "string") throw new Error("Invalid arguments, domain must be a string");
        return e = EPe(e), wPe(e, t)
      })
    });
    var vz = y((lvt, mz) => {
      l();
      "use strict";
      mz.exports = ({
        network: r
      }) => () => {
        let e = r.try();
        return e != null && Boolean(e.libp2p.isStarted())
      }
    });
    var r8 = y(wz => {
      l();
      "use strict";
      var _z = at();
      wz.cidToString = (r, e = {}) => {
        let t = e.upgrade !== !1,
          i = _z.isCID(r) ? r : new _z(r);
        if (i.version === 0 && e.base && e.base !== "base58btc") {
          if (!t) return i.toString();
          i = i.toV1()
        }
        return i.toBaseEncodedString(e.base)
      }
    });
    var Iz = y((dvt, Ez) => {
      l();
      "use strict";
      var Sz = Sl(),
        xz = at(),
        {
          cidToString: Az
        } = r8(),
        SPe = ze();
      Ez.exports = ({
        ipld: r,
        name: e
      }) => {
        async function t(i, n = {}) {
          if (!Sz.path(i)) throw new Error("invalid argument " + i);
          if (Sz.ipnsPath(i)) {
            if (!e) throw new Error("failed to resolve IPNS path: name API unavailable");
            for await (let h of e.resolve(i, n)) i = h
          }
          let [, , s, ...o] = i.split("/"), a = new xz(s);
          if (o.length === 0) return `/ipfs/${Az(a, { base: n.cidBase })}`;
          i = o.join("/");
          let c = r.resolve(a, i),
            u = a,
            f = i;
          for await (let h of c) xz.isCID(h.value) && (u = h.value, f = h.remainderPath);
          return `/ipfs/${Az(u, { base: n.cidBase })}${f ? "/" + f : ""}`
        }
        return SPe(t)
      }
    });
    var Qa = y((pvt, Tz) => {
      l();
      "use strict";
      var xPe = async r => {
        let e;
        for await (let t of r) e = t;
        return e
      };
      Tz.exports = xPe
    });
    var kz = y((yvt, Rz) => {
      l();
      "use strict";
      var APe = Qa(),
        IPe = at();
      Rz.exports = ({
        addAll: r
      }) => (e, t = {}) => {
        let i;
        return IPe.isCID(e) ? i = r([{
          cid: e,
          ...t
        }], t) : i = r([{
          path: e.toString(),
          ...t
        }], t), APe(i)
      }
    });
    var Cy = y(Xd => {
      l();
      "use strict";
      var i8 = V4(),
        Zd = x1(),
        Pz = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      Xd.Buffer = Te;
      Xd.SlowBuffer = TPe;
      Xd.INSPECT_MAX_BYTES = 50;
      var vv = 2147483647;
      Xd.kMaxLength = vv;
      Te.TYPED_ARRAY_SUPPORT = RPe();
      !Te.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

      function RPe() {
        try {
          var r = new Uint8Array(1),
            e = {
              foo: function () {
                return 42
              }
            };
          return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(r, e), r.foo() === 42
        } catch (t) {
          return !1
        }
      }
      Object.defineProperty(Te.prototype, "parent", {
        enumerable: !0,
        get: function () {
          if (!!Te.isBuffer(this)) return this.buffer
        }
      });
      Object.defineProperty(Te.prototype, "offset", {
        enumerable: !0,
        get: function () {
          if (!!Te.isBuffer(this)) return this.byteOffset
        }
      });

      function Yc(r) {
        if (r > vv) throw new RangeError('The value "' + r + '" is invalid for option "size"');
        var e = new Uint8Array(r);
        return Object.setPrototypeOf(e, Te.prototype), e
      }

      function Te(r, e, t) {
        if (typeof r == "number") {
          if (typeof e == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
          return n8(r)
        }
        return Cz(r, e, t)
      }
      Te.poolSize = 8192;

      function Cz(r, e, t) {
        if (typeof r == "string") return kPe(r, e);
        if (ArrayBuffer.isView(r)) return PPe(r);
        if (r == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
        if (ec(r, ArrayBuffer) || r && ec(r.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (ec(r, SharedArrayBuffer) || r && ec(r.buffer, SharedArrayBuffer))) return s8(r, e, t);
        if (typeof r == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        var i = r.valueOf && r.valueOf();
        if (i != null && i !== r) return Te.from(i, e, t);
        var n = CPe(r);
        if (n) return n;
        if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof r[Symbol.toPrimitive] == "function") return Te.from(r[Symbol.toPrimitive]("string"), e, t);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r)
      }
      Te.from = function (r, e, t) {
        return Cz(r, e, t)
      };
      Object.setPrototypeOf(Te.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Te, Uint8Array);

      function Oz(r) {
        if (typeof r != "number") throw new TypeError('"size" argument must be of type number');
        if (r < 0) throw new RangeError('The value "' + r + '" is invalid for option "size"')
      }

      function OPe(r, e, t) {
        return Oz(r), r <= 0 ? Yc(r) : e !== void 0 ? typeof t == "string" ? Yc(r).fill(e, t) : Yc(r).fill(e) : Yc(r)
      }
      Te.alloc = function (r, e, t) {
        return OPe(r, e, t)
      };

      function n8(r) {
        return Oz(r), Yc(r < 0 ? 0 : o8(r) | 0)
      }
      Te.allocUnsafe = function (r) {
        return n8(r)
      };
      Te.allocUnsafeSlow = function (r) {
        return n8(r)
      };

      function kPe(r, e) {
        if ((typeof e != "string" || e === "") && (e = "utf8"), !Te.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
        var t = Nz(r, e) | 0,
          i = Yc(t),
          n = i.write(r, e);
        return n !== t && (i = i.slice(0, n)), i
      }

      function a8(r) {
        for (var e = r.length < 0 ? 0 : o8(r.length) | 0, t = Yc(e), i = 0; i < e; i += 1) t[i] = r[i] & 255;
        return t
      }

      function PPe(r) {
        if (ec(r, Uint8Array)) {
          var e = new Uint8Array(r);
          return s8(e.buffer, e.byteOffset, e.byteLength)
        }
        return a8(r)
      }

      function s8(r, e, t) {
        if (e < 0 || r.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
        if (r.byteLength < e + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
        var i;
        return e === void 0 && t === void 0 ? i = new Uint8Array(r) : t === void 0 ? i = new Uint8Array(r, e) : i = new Uint8Array(r, e, t), Object.setPrototypeOf(i, Te.prototype), i
      }

      function CPe(r) {
        if (Te.isBuffer(r)) {
          var e = o8(r.length) | 0,
            t = Yc(e);
          return t.length === 0 || r.copy(t, 0, 0, e), t
        }
        if (r.length !== void 0) return typeof r.length != "number" || c8(r.length) ? Yc(0) : a8(r);
        if (r.type === "Buffer" && Array.isArray(r.data)) return a8(r.data)
      }

      function o8(r) {
        if (r >= vv) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + vv.toString(16) + " bytes");
        return r | 0
      }

      function TPe(r) {
        return +r != r && (r = 0), Te.alloc(+r)
      }
      Te.isBuffer = function (e) {
        return e != null && e._isBuffer === !0 && e !== Te.prototype
      };
      Te.compare = function (e, t) {
        if (ec(e, Uint8Array) && (e = Te.from(e, e.offset, e.byteLength)), ec(t, Uint8Array) && (t = Te.from(t, t.offset, t.byteLength)), !Te.isBuffer(e) || !Te.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (e === t) return 0;
        for (var i = e.length, n = t.length, s = 0, o = Math.min(i, n); s < o; ++s)
          if (e[s] !== t[s]) {
            i = e[s], n = t[s];
            break
          } return i < n ? -1 : n < i ? 1 : 0
      };
      Te.isEncoding = function (e) {
        switch (String(e).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1
        }
      };
      Te.concat = function (e, t) {
        if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (e.length === 0) return Te.alloc(0);
        var i;
        if (t === void 0)
          for (t = 0, i = 0; i < e.length; ++i) t += e[i].length;
        var n = Te.allocUnsafe(t),
          s = 0;
        for (i = 0; i < e.length; ++i) {
          var o = e[i];
          if (ec(o, Uint8Array)) s + o.length > n.length ? Te.from(o).copy(n, s) : Uint8Array.prototype.set.call(n, o, s);
          else if (Te.isBuffer(o)) o.copy(n, s);
          else throw new TypeError('"list" argument must be an Array of Buffers');
          s += o.length
        }
        return n
      };

      function Nz(r, e) {
        if (Te.isBuffer(r)) return r.length;
        if (ArrayBuffer.isView(r) || ec(r, ArrayBuffer)) return r.byteLength;
        if (typeof r != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r);
        var t = r.length,
          i = arguments.length > 2 && arguments[2] === !0;
        if (!i && t === 0) return 0;
        for (var n = !1; ;) switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return t;
          case "utf8":
          case "utf-8":
            return u8(r).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return t * 2;
          case "hex":
            return t >>> 1;
          case "base64":
            return qz(r).length;
          default:
            if (n) return i ? -1 : u8(r).length;
            e = ("" + e).toLowerCase(), n = !0
        }
      }
      Te.byteLength = Nz;

      function LPe(r, e, t) {
        var i = !1;
        if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e)) return "";
        for (r || (r = "utf8"); ;) switch (r) {
          case "hex":
            return BPe(this, e, t);
          case "utf8":
          case "utf-8":
            return Mz(this, e, t);
          case "ascii":
            return qPe(this, e, t);
          case "latin1":
          case "binary":
            return MPe(this, e, t);
          case "base64":
            return NPe(this, e, t);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return DPe(this, e, t);
          default:
            if (i) throw new TypeError("Unknown encoding: " + r);
            r = (r + "").toLowerCase(), i = !0
        }
      }
      Te.prototype._isBuffer = !0;

      function Rl(r, e, t) {
        var i = r[e];
        r[e] = r[t], r[t] = i
      }
      Te.prototype.swap16 = function () {
        var e = this.length;
        if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var t = 0; t < e; t += 2) Rl(this, t, t + 1);
        return this
      };
      Te.prototype.swap32 = function () {
        var e = this.length;
        if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var t = 0; t < e; t += 4) Rl(this, t, t + 3), Rl(this, t + 1, t + 2);
        return this
      };
      Te.prototype.swap64 = function () {
        var e = this.length;
        if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var t = 0; t < e; t += 8) Rl(this, t, t + 7), Rl(this, t + 1, t + 6), Rl(this, t + 2, t + 5), Rl(this, t + 3, t + 4);
        return this
      };
      Te.prototype.toString = function () {
        var e = this.length;
        return e === 0 ? "" : arguments.length === 0 ? Mz(this, 0, e) : LPe.apply(this, arguments)
      };
      Te.prototype.toLocaleString = Te.prototype.toString;
      Te.prototype.equals = function (e) {
        if (!Te.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
        return this === e ? !0 : Te.compare(this, e) === 0
      };
      Te.prototype.inspect = function () {
        var e = "",
          t = Xd.INSPECT_MAX_BYTES;
        return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">"
      };
      Pz && (Te.prototype[Pz] = Te.prototype.inspect);
      Te.prototype.compare = function (e, t, i, n, s) {
        if (ec(e, Uint8Array) && (e = Te.from(e, e.offset, e.byteLength)), !Te.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
        if (t === void 0 && (t = 0), i === void 0 && (i = e ? e.length : 0), n === void 0 && (n = 0), s === void 0 && (s = this.length), t < 0 || i > e.length || n < 0 || s > this.length) throw new RangeError("out of range index");
        if (n >= s && t >= i) return 0;
        if (n >= s) return -1;
        if (t >= i) return 1;
        if (t >>>= 0, i >>>= 0, n >>>= 0, s >>>= 0, this === e) return 0;
        for (var o = s - n, a = i - t, c = Math.min(o, a), u = this.slice(n, s), f = e.slice(t, i), h = 0; h < c; ++h)
          if (u[h] !== f[h]) {
            o = u[h], a = f[h];
            break
          } return o < a ? -1 : a < o ? 1 : 0
      };

      function Dz(r, e, t, i, n) {
        if (r.length === 0) return -1;
        if (typeof t == "string" ? (i = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, c8(t) && (t = n ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
          if (n) return -1;
          t = r.length - 1
        } else if (t < 0)
          if (n) t = 0;
          else return -1;
        if (typeof e == "string" && (e = Te.from(e, i)), Te.isBuffer(e)) return e.length === 0 ? -1 : Bz(r, e, t, i, n);
        if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : Bz(r, [e], t, i, n);
        throw new TypeError("val must be string, number or Buffer")
      }

      function Bz(r, e, t, i, n) {
        var s = 1,
          o = r.length,
          a = e.length;
        if (i !== void 0 && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
          if (r.length < 2 || e.length < 2) return -1;
          s = 2, o /= 2, a /= 2, t /= 2
        }

        function c(p, g) {
          return s === 1 ? p[g] : p.readUInt16BE(g * s)
        }
        var u;
        if (n) {
          var f = -1;
          for (u = t; u < o; u++)
            if (c(r, u) === c(e, f === -1 ? 0 : u - f)) {
              if (f === -1 && (f = u), u - f + 1 === a) return f * s
            } else f !== -1 && (u -= u - f), f = -1
        } else
          for (t + a > o && (t = o - a), u = t; u >= 0; u--) {
            for (var h = !0, d = 0; d < a; d++)
              if (c(r, u + d) !== c(e, d)) {
                h = !1;
                break
              } if (h) return u
          }
        return -1
      }
      Te.prototype.includes = function (e, t, i) {
        return this.indexOf(e, t, i) !== -1
      };
      Te.prototype.indexOf = function (e, t, i) {
        return Dz(this, e, t, i, !0)
      };
      Te.prototype.lastIndexOf = function (e, t, i) {
        return Dz(this, e, t, i, !1)
      };

      function FPe(r, e, t, i) {
        t = Number(t) || 0;
        var n = r.length - t;
        i ? (i = Number(i), i > n && (i = n)) : i = n;
        var s = e.length;
        i > s / 2 && (i = s / 2);
        for (var o = 0; o < i; ++o) {
          var a = parseInt(e.substr(o * 2, 2), 16);
          if (c8(a)) return o;
          r[t + o] = a
        }
        return o
      }

      function UPe(r, e, t, i) {
        return wv(u8(e, r.length - t), r, t, i)
      }

      function zPe(r, e, t, i) {
        return wv(KPe(e), r, t, i)
      }

      function jPe(r, e, t, i) {
        return wv(qz(e), r, t, i)
      }

      function HPe(r, e, t, i) {
        return wv(VPe(e, r.length - t), r, t, i)
      }
      Te.prototype.write = function (e, t, i, n) {
        if (t === void 0) n = "utf8", i = this.length, t = 0;
        else if (i === void 0 && typeof t == "string") n = t, i = this.length, t = 0;
        else if (isFinite(t)) t = t >>> 0, isFinite(i) ? (i = i >>> 0, n === void 0 && (n = "utf8")) : (n = i, i = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        var s = this.length - t;
        if ((i === void 0 || i > s) && (i = s), e.length > 0 && (i < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        n || (n = "utf8");
        for (var o = !1; ;) switch (n) {
          case "hex":
            return FPe(this, e, t, i);
          case "utf8":
          case "utf-8":
            return UPe(this, e, t, i);
          case "ascii":
          case "latin1":
          case "binary":
            return zPe(this, e, t, i);
          case "base64":
            return jPe(this, e, t, i);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return HPe(this, e, t, i);
          default:
            if (o) throw new TypeError("Unknown encoding: " + n);
            n = ("" + n).toLowerCase(), o = !0
        }
      };
      Te.prototype.toJSON = function () {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        }
      };

      function NPe(r, e, t) {
        return e === 0 && t === r.length ? i8.fromByteArray(r) : i8.fromByteArray(r.slice(e, t))
      }

      function Mz(r, e, t) {
        t = Math.min(r.length, t);
        for (var i = [], n = e; n < t;) {
          var s = r[n],
            o = null,
            a = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
          if (n + a <= t) {
            var c, u, f, h;
            switch (a) {
              case 1:
                s < 128 && (o = s);
                break;
              case 2:
                c = r[n + 1], (c & 192) == 128 && (h = (s & 31) << 6 | c & 63, h > 127 && (o = h));
                break;
              case 3:
                c = r[n + 1], u = r[n + 2], (c & 192) == 128 && (u & 192) == 128 && (h = (s & 15) << 12 | (c & 63) << 6 | u & 63, h > 2047 && (h < 55296 || h > 57343) && (o = h));
                break;
              case 4:
                c = r[n + 1], u = r[n + 2], f = r[n + 3], (c & 192) == 128 && (u & 192) == 128 && (f & 192) == 128 && (h = (s & 15) << 18 | (c & 63) << 12 | (u & 63) << 6 | f & 63, h > 65535 && h < 1114112 && (o = h))
            }
          }
          o === null ? (o = 65533, a = 1) : o > 65535 && (o -= 65536, i.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), i.push(o), n += a
        }
        return GPe(i)
      }
      var Lz = 4096;

      function GPe(r) {
        var e = r.length;
        if (e <= Lz) return String.fromCharCode.apply(String, r);
        for (var t = "", i = 0; i < e;) t += String.fromCharCode.apply(String, r.slice(i, i += Lz));
        return t
      }

      function qPe(r, e, t) {
        var i = "";
        t = Math.min(r.length, t);
        for (var n = e; n < t; ++n) i += String.fromCharCode(r[n] & 127);
        return i
      }

      function MPe(r, e, t) {
        var i = "";
        t = Math.min(r.length, t);
        for (var n = e; n < t; ++n) i += String.fromCharCode(r[n]);
        return i
      }

      function BPe(r, e, t) {
        var i = r.length;
        (!e || e < 0) && (e = 0), (!t || t < 0 || t > i) && (t = i);
        for (var n = "", s = e; s < t; ++s) n += $Pe[r[s]];
        return n
      }

      function DPe(r, e, t) {
        for (var i = r.slice(e, t), n = "", s = 0; s < i.length - 1; s += 2) n += String.fromCharCode(i[s] + i[s + 1] * 256);
        return n
      }
      Te.prototype.slice = function (e, t) {
        var i = this.length;
        e = ~~e, t = t === void 0 ? i : ~~t, e < 0 ? (e += i, e < 0 && (e = 0)) : e > i && (e = i), t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), t < e && (t = e);
        var n = this.subarray(e, t);
        return Object.setPrototypeOf(n, Te.prototype), n
      };

      function Zi(r, e, t) {
        if (r % 1 != 0 || r < 0) throw new RangeError("offset is not uint");
        if (r + e > t) throw new RangeError("Trying to access beyond buffer length")
      }
      Te.prototype.readUintLE = Te.prototype.readUIntLE = function (e, t, i) {
        e = e >>> 0, t = t >>> 0, i || Zi(e, t, this.length);
        for (var n = this[e], s = 1, o = 0; ++o < t && (s *= 256);) n += this[e + o] * s;
        return n
      };
      Te.prototype.readUintBE = Te.prototype.readUIntBE = function (e, t, i) {
        e = e >>> 0, t = t >>> 0, i || Zi(e, t, this.length);
        for (var n = this[e + --t], s = 1; t > 0 && (s *= 256);) n += this[e + --t] * s;
        return n
      };
      Te.prototype.readUint8 = Te.prototype.readUInt8 = function (e, t) {
        return e = e >>> 0, t || Zi(e, 1, this.length), this[e]
      };
      Te.prototype.readUint16LE = Te.prototype.readUInt16LE = function (e, t) {
        return e = e >>> 0, t || Zi(e, 2, this.length), this[e] | this[e + 1] << 8
      };
      Te.prototype.readUint16BE = Te.prototype.readUInt16BE = function (e, t) {
        return e = e >>> 0, t || Zi(e, 2, this.length), this[e] << 8 | this[e + 1]
      };
      Te.prototype.readUint32LE = Te.prototype.readUInt32LE = function (e, t) {
        return e = e >>> 0, t || Zi(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216
      };
      Te.prototype.readUint32BE = Te.prototype.readUInt32BE = function (e, t) {
        return e = e >>> 0, t || Zi(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
      };
      Te.prototype.readIntLE = function (e, t, i) {
        e = e >>> 0, t = t >>> 0, i || Zi(e, t, this.length);
        for (var n = this[e], s = 1, o = 0; ++o < t && (s *= 256);) n += this[e + o] * s;
        return s *= 128, n >= s && (n -= Math.pow(2, 8 * t)), n
      };
      Te.prototype.readIntBE = function (e, t, i) {
        e = e >>> 0, t = t >>> 0, i || Zi(e, t, this.length);
        for (var n = t, s = 1, o = this[e + --n]; n > 0 && (s *= 256);) o += this[e + --n] * s;
        return s *= 128, o >= s && (o -= Math.pow(2, 8 * t)), o
      };
      Te.prototype.readInt8 = function (e, t) {
        return e = e >>> 0, t || Zi(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e]
      };
      Te.prototype.readInt16LE = function (e, t) {
        e = e >>> 0, t || Zi(e, 2, this.length);
        var i = this[e] | this[e + 1] << 8;
        return i & 32768 ? i | 4294901760 : i
      };
      Te.prototype.readInt16BE = function (e, t) {
        e = e >>> 0, t || Zi(e, 2, this.length);
        var i = this[e + 1] | this[e] << 8;
        return i & 32768 ? i | 4294901760 : i
      };
      Te.prototype.readInt32LE = function (e, t) {
        return e = e >>> 0, t || Zi(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
      };
      Te.prototype.readInt32BE = function (e, t) {
        return e = e >>> 0, t || Zi(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
      };
      Te.prototype.readFloatLE = function (e, t) {
        return e = e >>> 0, t || Zi(e, 4, this.length), Zd.read(this, e, !0, 23, 4)
      };
      Te.prototype.readFloatBE = function (e, t) {
        return e = e >>> 0, t || Zi(e, 4, this.length), Zd.read(this, e, !1, 23, 4)
      };
      Te.prototype.readDoubleLE = function (e, t) {
        return e = e >>> 0, t || Zi(e, 8, this.length), Zd.read(this, e, !0, 52, 8)
      };
      Te.prototype.readDoubleBE = function (e, t) {
        return e = e >>> 0, t || Zi(e, 8, this.length), Zd.read(this, e, !1, 52, 8)
      };

      function bs(r, e, t, i, n, s) {
        if (!Te.isBuffer(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > n || e < s) throw new RangeError('"value" argument is out of bounds');
        if (t + i > r.length) throw new RangeError("Index out of range")
      }
      Te.prototype.writeUintLE = Te.prototype.writeUIntLE = function (e, t, i, n) {
        if (e = +e, t = t >>> 0, i = i >>> 0, !n) {
          var s = Math.pow(2, 8 * i) - 1;
          bs(this, e, t, i, s, 0)
        }
        var o = 1,
          a = 0;
        for (this[t] = e & 255; ++a < i && (o *= 256);) this[t + a] = e / o & 255;
        return t + i
      };
      Te.prototype.writeUintBE = Te.prototype.writeUIntBE = function (e, t, i, n) {
        if (e = +e, t = t >>> 0, i = i >>> 0, !n) {
          var s = Math.pow(2, 8 * i) - 1;
          bs(this, e, t, i, s, 0)
        }
        var o = i - 1,
          a = 1;
        for (this[t + o] = e & 255; --o >= 0 && (a *= 256);) this[t + o] = e / a & 255;
        return t + i
      };
      Te.prototype.writeUint8 = Te.prototype.writeUInt8 = function (e, t, i) {
        return e = +e, t = t >>> 0, i || bs(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1
      };
      Te.prototype.writeUint16LE = Te.prototype.writeUInt16LE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || bs(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
      };
      Te.prototype.writeUint16BE = Te.prototype.writeUInt16BE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || bs(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
      };
      Te.prototype.writeUint32LE = Te.prototype.writeUInt32LE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || bs(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4
      };
      Te.prototype.writeUint32BE = Te.prototype.writeUInt32BE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || bs(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
      };
      Te.prototype.writeIntLE = function (e, t, i, n) {
        if (e = +e, t = t >>> 0, !n) {
          var s = Math.pow(2, 8 * i - 1);
          bs(this, e, t, i, s - 1, -s)
        }
        var o = 0,
          a = 1,
          c = 0;
        for (this[t] = e & 255; ++o < i && (a *= 256);) e < 0 && c === 0 && this[t + o - 1] !== 0 && (c = 1), this[t + o] = (e / a >> 0) - c & 255;
        return t + i
      };
      Te.prototype.writeIntBE = function (e, t, i, n) {
        if (e = +e, t = t >>> 0, !n) {
          var s = Math.pow(2, 8 * i - 1);
          bs(this, e, t, i, s - 1, -s)
        }
        var o = i - 1,
          a = 1,
          c = 0;
        for (this[t + o] = e & 255; --o >= 0 && (a *= 256);) e < 0 && c === 0 && this[t + o + 1] !== 0 && (c = 1), this[t + o] = (e / a >> 0) - c & 255;
        return t + i
      };
      Te.prototype.writeInt8 = function (e, t, i) {
        return e = +e, t = t >>> 0, i || bs(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1
      };
      Te.prototype.writeInt16LE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || bs(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2
      };
      Te.prototype.writeInt16BE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || bs(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2
      };
      Te.prototype.writeInt32LE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || bs(this, e, t, 4, 2147483647, -2147483648), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
      };
      Te.prototype.writeInt32BE = function (e, t, i) {
        return e = +e, t = t >>> 0, i || bs(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4
      };

      function Fz(r, e, t, i, n, s) {
        if (t + i > r.length) throw new RangeError("Index out of range");
        if (t < 0) throw new RangeError("Index out of range")
      }

      function Uz(r, e, t, i, n) {
        return e = +e, t = t >>> 0, n || Fz(r, e, t, 4, 34028234663852886e22, -34028234663852886e22), Zd.write(r, e, t, i, 23, 4), t + 4
      }
      Te.prototype.writeFloatLE = function (e, t, i) {
        return Uz(this, e, t, !0, i)
      };
      Te.prototype.writeFloatBE = function (e, t, i) {
        return Uz(this, e, t, !1, i)
      };

      function Kz(r, e, t, i, n) {
        return e = +e, t = t >>> 0, n || Fz(r, e, t, 8, 17976931348623157e292, -17976931348623157e292), Zd.write(r, e, t, i, 52, 8), t + 8
      }
      Te.prototype.writeDoubleLE = function (e, t, i) {
        return Kz(this, e, t, !0, i)
      };
      Te.prototype.writeDoubleBE = function (e, t, i) {
        return Kz(this, e, t, !1, i)
      };
      Te.prototype.copy = function (e, t, i, n) {
        if (!Te.isBuffer(e)) throw new TypeError("argument should be a Buffer");
        if (i || (i = 0), !n && n !== 0 && (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < i && (n = i), n === i || e.length === 0 || this.length === 0) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (i < 0 || i >= this.length) throw new RangeError("Index out of range");
        if (n < 0) throw new RangeError("sourceEnd out of bounds");
        n > this.length && (n = this.length), e.length - t < n - i && (n = e.length - t + i);
        var s = n - i;
        return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, i, n) : Uint8Array.prototype.set.call(e, this.subarray(i, n), t), s
      };
      Te.prototype.fill = function (e, t, i, n) {
        if (typeof e == "string") {
          if (typeof t == "string" ? (n = t, t = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), n !== void 0 && typeof n != "string") throw new TypeError("encoding must be a string");
          if (typeof n == "string" && !Te.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
          if (e.length === 1) {
            var s = e.charCodeAt(0);
            (n === "utf8" && s < 128 || n === "latin1") && (e = s)
          }
        } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
        if (t < 0 || this.length < t || this.length < i) throw new RangeError("Out of range index");
        if (i <= t) return this;
        t = t >>> 0, i = i === void 0 ? this.length : i >>> 0, e || (e = 0);
        var o;
        if (typeof e == "number")
          for (o = t; o < i; ++o) this[o] = e;
        else {
          var a = Te.isBuffer(e) ? e : Te.from(e, n),
            c = a.length;
          if (c === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
          for (o = 0; o < i - t; ++o) this[o + t] = a[o % c]
        }
        return this
      };
      var WPe = /[^+/0-9A-Za-z-_]/g;

      function YPe(r) {
        if (r = r.split("=")[0], r = r.trim().replace(WPe, ""), r.length < 2) return "";
        for (; r.length % 4 != 0;) r = r + "=";
        return r
      }

      function u8(r, e) {
        e = e || Infinity;
        for (var t, i = r.length, n = null, s = [], o = 0; o < i; ++o) {
          if (t = r.charCodeAt(o), t > 55295 && t < 57344) {
            if (!n) {
              if (t > 56319) {
                (e -= 3) > -1 && s.push(239, 191, 189);
                continue
              } else if (o + 1 === i) {
                (e -= 3) > -1 && s.push(239, 191, 189);
                continue
              }
              n = t;
              continue
            }
            if (t < 56320) {
              (e -= 3) > -1 && s.push(239, 191, 189), n = t;
              continue
            }
            t = (n - 55296 << 10 | t - 56320) + 65536
          } else n && (e -= 3) > -1 && s.push(239, 191, 189);
          if (n = null, t < 128) {
            if ((e -= 1) < 0) break;
            s.push(t)
          } else if (t < 2048) {
            if ((e -= 2) < 0) break;
            s.push(t >> 6 | 192, t & 63 | 128)
          } else if (t < 65536) {
            if ((e -= 3) < 0) break;
            s.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128)
          } else if (t < 1114112) {
            if ((e -= 4) < 0) break;
            s.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128)
          } else throw new Error("Invalid code point")
        }
        return s
      }

      function KPe(r) {
        for (var e = [], t = 0; t < r.length; ++t) e.push(r.charCodeAt(t) & 255);
        return e
      }

      function VPe(r, e) {
        for (var t, i, n, s = [], o = 0; o < r.length && !((e -= 2) < 0); ++o) t = r.charCodeAt(o), i = t >> 8, n = t % 256, s.push(n), s.push(i);
        return s
      }

      function qz(r) {
        return i8.toByteArray(YPe(r))
      }

      function wv(r, e, t, i) {
        for (var n = 0; n < i && !(n + t >= e.length || n >= r.length); ++n) e[n + t] = r[n];
        return n
      }

      function ec(r, e) {
        return r instanceof e || r != null && r.constructor != null && r.constructor.name != null && r.constructor.name === e.name
      }

      function c8(r) {
        return r !== r
      }
      var $Pe = function () {
        for (var r = "0123456789abcdef", e = new Array(256), t = 0; t < 16; ++t)
          for (var i = t * 16, n = 0; n < 16; ++n) e[i + n] = r[t] + r[n];
        return e
      }()
    });
    var tc = y((zz, _v) => {
      l();
      (function (r) {
        "use strict";
        var e, t = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
          i = Math.ceil,
          n = Math.floor,
          s = "[BigNumber Error] ",
          o = s + "Number primitive has more than 15 significant digits: ",
          a = 1e14,
          c = 14,
          u = 9007199254740991,
          f = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
          h = 1e7,
          d = 1e9;

        function p(Z) {
          var H, te, ae, oe = Q.prototype = {
            constructor: Q,
            toString: null,
            valueOf: null
          },
            U = new Q(1),
            b = 20,
            _ = 4,
            R = -7,
            D = 21,
            K = -1e7,
            ee = 1e7,
            re = !1,
            V = 1,
            v = 0,
            Y = {
              prefix: "",
              groupSize: 3,
              secondaryGroupSize: 0,
              groupSeparator: ",",
              decimalSeparator: ".",
              fractionGroupSize: 0,
              fractionGroupSeparator: "\xA0",
              suffix: ""
            },
            Se = "0123456789abcdefghijklmnopqrstuvwxyz";

          function Q(S, T) {
            var j, G, k, F, B, L, $, ie, ne = this;
            if (!(ne instanceof Q)) return new Q(S, T);
            if (T == null) {
              if (S && S._isBigNumber === !0) {
                ne.s = S.s, !S.c || S.e > ee ? ne.c = ne.e = null : S.e < K ? ne.c = [ne.e = 0] : (ne.e = S.e, ne.c = S.c.slice());
                return
              }
              if ((L = typeof S == "number") && S * 0 == 0) {
                if (ne.s = 1 / S < 0 ? (S = -S, -1) : 1, S === ~~S) {
                  for (F = 0, B = S; B >= 10; B /= 10, F++);
                  F > ee ? ne.c = ne.e = null : (ne.e = F, ne.c = [S]);
                  return
                }
                ie = String(S)
              } else {
                if (!t.test(ie = String(S))) return ae(ne, ie, L);
                ne.s = ie.charCodeAt(0) == 45 ? (ie = ie.slice(1), -1) : 1
              } (F = ie.indexOf(".")) > -1 && (ie = ie.replace(".", "")), (B = ie.search(/e/i)) > 0 ? (F < 0 && (F = B), F += +ie.slice(B + 1), ie = ie.substring(0, B)) : F < 0 && (F = ie.length)
            } else {
              if (w(T, 2, Se.length, "Base"), T == 10) return ne = new Q(S), le(ne, b + ne.e + 1, _);
              if (ie = String(S), L = typeof S == "number") {
                if (S * 0 != 0) return ae(ne, ie, L, T);
                if (ne.s = 1 / S < 0 ? (ie = ie.slice(1), -1) : 1, Q.DEBUG && ie.replace(/^0\.0*|\./, "").length > 15) throw Error(o + S)
              } else ne.s = ie.charCodeAt(0) === 45 ? (ie = ie.slice(1), -1) : 1;
              for (j = Se.slice(0, T), F = B = 0, $ = ie.length; B < $; B++)
                if (j.indexOf(G = ie.charAt(B)) < 0) {
                  if (G == ".") {
                    if (B > F) {
                      F = $;
                      continue
                    }
                  } else if (!k && (ie == ie.toUpperCase() && (ie = ie.toLowerCase()) || ie == ie.toLowerCase() && (ie = ie.toUpperCase()))) {
                    k = !0, B = -1, F = 0;
                    continue
                  }
                  return ae(ne, String(S), L, T)
                } L = !1, ie = te(ie, T, 10, ne.s), (F = ie.indexOf(".")) > -1 ? ie = ie.replace(".", "") : F = ie.length
            }
            for (B = 0; ie.charCodeAt(B) === 48; B++);
            for ($ = ie.length; ie.charCodeAt(--$) === 48;);
            if (ie = ie.slice(B, ++$)) {
              if ($ -= B, L && Q.DEBUG && $ > 15 && (S > u || S !== n(S))) throw Error(o + ne.s * S);
              if ((F = F - B - 1) > ee) ne.c = ne.e = null;
              else if (F < K) ne.c = [ne.e = 0];
              else {
                if (ne.e = F, ne.c = [], B = (F + 1) % c, F < 0 && (B += c), B < $) {
                  for (B && ne.c.push(+ie.slice(0, B)), $ -= c; B < $;) ne.c.push(+ie.slice(B, B += c));
                  B = c - (ie = ie.slice(B)).length
                } else B -= $;
                for (; B--; ie += "0");
                ne.c.push(+ie)
              }
            } else ne.c = [ne.e = 0]
          }
          Q.clone = p, Q.ROUND_UP = 0, Q.ROUND_DOWN = 1, Q.ROUND_CEIL = 2, Q.ROUND_FLOOR = 3, Q.ROUND_HALF_UP = 4, Q.ROUND_HALF_DOWN = 5, Q.ROUND_HALF_EVEN = 6, Q.ROUND_HALF_CEIL = 7, Q.ROUND_HALF_FLOOR = 8, Q.EUCLID = 9, Q.config = Q.set = function (S) {
            var T, j;
            if (S != null)
              if (typeof S == "object") {
                if (S.hasOwnProperty(T = "DECIMAL_PLACES") && (j = S[T], w(j, 0, d, T), b = j), S.hasOwnProperty(T = "ROUNDING_MODE") && (j = S[T], w(j, 0, 8, T), _ = j), S.hasOwnProperty(T = "EXPONENTIAL_AT") && (j = S[T], j && j.pop ? (w(j[0], -d, 0, T), w(j[1], 0, d, T), R = j[0], D = j[1]) : (w(j, -d, d, T), R = -(D = j < 0 ? -j : j))), S.hasOwnProperty(T = "RANGE"))
                  if (j = S[T], j && j.pop) w(j[0], -d, -1, T), w(j[1], 1, d, T), K = j[0], ee = j[1];
                  else if (w(j, -d, d, T), j) K = -(ee = j < 0 ? -j : j);
                  else throw Error(s + T + " cannot be zero: " + j);
                if (S.hasOwnProperty(T = "CRYPTO"))
                  if (j = S[T], j === !!j)
                    if (j)
                      if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) re = j;
                      else throw re = !j, Error(s + "crypto unavailable");
                    else re = j;
                  else throw Error(s + T + " not true or false: " + j);
                if (S.hasOwnProperty(T = "MODULO_MODE") && (j = S[T], w(j, 0, 9, T), V = j), S.hasOwnProperty(T = "POW_PRECISION") && (j = S[T], w(j, 0, d, T), v = j), S.hasOwnProperty(T = "FORMAT"))
                  if (j = S[T], typeof j == "object") Y = j;
                  else throw Error(s + T + " not an object: " + j);
                if (S.hasOwnProperty(T = "ALPHABET"))
                  if (j = S[T], typeof j == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(j)) Se = j;
                  else throw Error(s + T + " invalid: " + j)
              } else throw Error(s + "Object expected: " + S);
            return {
              DECIMAL_PLACES: b,
              ROUNDING_MODE: _,
              EXPONENTIAL_AT: [R, D],
              RANGE: [K, ee],
              CRYPTO: re,
              MODULO_MODE: V,
              POW_PRECISION: v,
              FORMAT: Y,
              ALPHABET: Se
            }
          }, Q.isBigNumber = function (S) {
            if (!S || S._isBigNumber !== !0) return !1;
            if (!Q.DEBUG) return !0;
            var T, j, G = S.c,
              k = S.e,
              F = S.s;
            e: if ({}.toString.call(G) == "[object Array]") {
              if ((F === 1 || F === -1) && k >= -d && k <= d && k === n(k)) {
                if (G[0] === 0) {
                  if (k === 0 && G.length === 1) return !0;
                  break e
                }
                if (T = (k + 1) % c, T < 1 && (T += c), String(G[0]).length == T) {
                  for (T = 0; T < G.length; T++)
                    if (j = G[T], j < 0 || j >= a || j !== n(j)) break e;
                  if (j !== 0) return !0
                }
              }
            } else if (G === null && k === null && (F === null || F === 1 || F === -1)) return !0;
            throw Error(s + "Invalid BigNumber: " + S)
          }, Q.maximum = Q.max = function () {
            return x(arguments, oe.lt)
          }, Q.minimum = Q.min = function () {
            return x(arguments, oe.gt)
          }, Q.random = function () {
            var S = 9007199254740992,
              T = Math.random() * S & 2097151 ? function () {
                return n(Math.random() * S)
              } : function () {
                return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0)
              };
            return function (j) {
              var G, k, F, B, L, $ = 0,
                ie = [],
                ne = new Q(U);
              if (j == null ? j = b : w(j, 0, d), B = i(j / c), re)
                if (crypto.getRandomValues) {
                  for (G = crypto.getRandomValues(new Uint32Array(B *= 2)); $ < B;) L = G[$] * 131072 + (G[$ + 1] >>> 11), L >= 9e15 ? (k = crypto.getRandomValues(new Uint32Array(2)), G[$] = k[0], G[$ + 1] = k[1]) : (ie.push(L % 1e14), $ += 2);
                  $ = B / 2
                } else if (crypto.randomBytes) {
                  for (G = crypto.randomBytes(B *= 7); $ < B;) L = (G[$] & 31) * 281474976710656 + G[$ + 1] * 1099511627776 + G[$ + 2] * 4294967296 + G[$ + 3] * 16777216 + (G[$ + 4] << 16) + (G[$ + 5] << 8) + G[$ + 6], L >= 9e15 ? crypto.randomBytes(7).copy(G, $) : (ie.push(L % 1e14), $ += 7);
                  $ = B / 7
                } else throw re = !1, Error(s + "crypto unavailable");
              if (!re)
                for (; $ < B;) L = T(), L < 9e15 && (ie[$++] = L % 1e14);
              for (B = ie[--$], j %= c, B && j && (L = f[c - j], ie[$] = n(B / L) * L); ie[$] === 0; ie.pop(), $--);
              if ($ < 0) ie = [F = 0];
              else {
                for (F = -1; ie[0] === 0; ie.splice(0, 1), F -= c);
                for ($ = 1, L = ie[0]; L >= 10; L /= 10, $++);
                $ < c && (F -= c - $)
              }
              return ne.e = F, ne.c = ie, ne
            }
          }(), Q.sum = function () {
            for (var S = 1, T = arguments, j = new Q(T[0]); S < T.length;) j = j.plus(T[S++]);
            return j
          }, te = function () {
            var S = "0123456789";

            function T(j, G, k, F) {
              for (var B, L = [0], $, ie = 0, ne = j.length; ie < ne;) {
                for ($ = L.length; $--; L[$] *= G);
                for (L[0] += F.indexOf(j.charAt(ie++)), B = 0; B < L.length; B++) L[B] > k - 1 && (L[B + 1] == null && (L[B + 1] = 0), L[B + 1] += L[B] / k | 0, L[B] %= k)
              }
              return L.reverse()
            }
            return function (j, G, k, F, B) {
              var L, $, ie, ne, pe, be, de, Ne, Re = j.indexOf("."),
                $e = b,
                Ke = _;
              for (Re >= 0 && (ne = v, v = 0, j = j.replace(".", ""), Ne = new Q(G), be = Ne.pow(j.length - Re), v = ne, Ne.c = T(J(m(be.c), be.e, "0"), 10, k, S), Ne.e = Ne.c.length), de = T(j, G, k, B ? (L = Se, S) : (L = S, Se)), ie = ne = de.length; de[--ne] == 0; de.pop());
              if (!de[0]) return L.charAt(0);
              if (Re < 0 ? --ie : (be.c = de, be.e = ie, be.s = F, be = H(be, Ne, $e, Ke, k), de = be.c, pe = be.r, ie = be.e), $ = ie + $e + 1, Re = de[$], ne = k / 2, pe = pe || $ < 0 || de[$ + 1] != null, pe = Ke < 4 ? (Re != null || pe) && (Ke == 0 || Ke == (be.s < 0 ? 3 : 2)) : Re > ne || Re == ne && (Ke == 4 || pe || Ke == 6 && de[$ - 1] & 1 || Ke == (be.s < 0 ? 8 : 7)), $ < 1 || !de[0]) j = pe ? J(L.charAt(1), -$e, L.charAt(0)) : L.charAt(0);
              else {
                if (de.length = $, pe)
                  for (--k; ++de[--$] > k;) de[$] = 0, $ || (++ie, de = [1].concat(de));
                for (ne = de.length; !de[--ne];);
                for (Re = 0, j = ""; Re <= ne; j += L.charAt(de[Re++]));
                j = J(j, ie, L.charAt(0))
              }
              return j
            }
          }(), H = function () {
            function S(G, k, F) {
              var B, L, $, ie, ne = 0,
                pe = G.length,
                be = k % h,
                de = k / h | 0;
              for (G = G.slice(); pe--;) $ = G[pe] % h, ie = G[pe] / h | 0, B = de * $ + ie * be, L = be * $ + B % h * h + ne, ne = (L / F | 0) + (B / h | 0) + de * ie, G[pe] = L % F;
              return ne && (G = [ne].concat(G)), G
            }

            function T(G, k, F, B) {
              var L, $;
              if (F != B) $ = F > B ? 1 : -1;
              else
                for (L = $ = 0; L < F; L++)
                  if (G[L] != k[L]) {
                    $ = G[L] > k[L] ? 1 : -1;
                    break
                  } return $
            }

            function j(G, k, F, B) {
              for (var L = 0; F--;) G[F] -= L, L = G[F] < k[F] ? 1 : 0, G[F] = L * B + G[F] - k[F];
              for (; !G[0] && G.length > 1; G.splice(0, 1));
            }
            return function (G, k, F, B, L) {
              var $, ie, ne, pe, be, de, Ne, Re, $e, Ke, Me, Ie, tt, nt, Ge, se, A, X = G.s == k.s ? 1 : -1,
                Kt = G.c,
                st = k.c;
              if (!Kt || !Kt[0] || !st || !st[0]) return new Q(!G.s || !k.s || (Kt ? st && Kt[0] == st[0] : !st) ? NaN : Kt && Kt[0] == 0 || !st ? X * 0 : X / 0);
              for (Re = new Q(X), $e = Re.c = [], ie = G.e - k.e, X = F + ie + 1, L || (L = a, ie = g(G.e / c) - g(k.e / c), X = X / c | 0), ne = 0; st[ne] == (Kt[ne] || 0); ne++);
              if (st[ne] > (Kt[ne] || 0) && ie--, X < 0) $e.push(1), pe = !0;
              else {
                for (nt = Kt.length, se = st.length, ne = 0, X += 2, be = n(L / (st[0] + 1)), be > 1 && (st = S(st, be, L), Kt = S(Kt, be, L), se = st.length, nt = Kt.length), tt = se, Ke = Kt.slice(0, se), Me = Ke.length; Me < se; Ke[Me++] = 0);
                A = st.slice(), A = [0].concat(A), Ge = st[0], st[1] >= L / 2 && Ge++;
                do {
                  if (be = 0, $ = T(st, Ke, se, Me), $ < 0) {
                    if (Ie = Ke[0], se != Me && (Ie = Ie * L + (Ke[1] || 0)), be = n(Ie / Ge), be > 1)
                      for (be >= L && (be = L - 1), de = S(st, be, L), Ne = de.length, Me = Ke.length; T(de, Ke, Ne, Me) == 1;) be--, j(de, se < Ne ? A : st, Ne, L), Ne = de.length, $ = 1;
                    else be == 0 && ($ = be = 1), de = st.slice(), Ne = de.length;
                    if (Ne < Me && (de = [0].concat(de)), j(Ke, de, Me, L), Me = Ke.length, $ == -1)
                      for (; T(st, Ke, se, Me) < 1;) be++, j(Ke, se < Me ? A : st, Me, L), Me = Ke.length
                  } else $ === 0 && (be++, Ke = [0]);
                  $e[ne++] = be, Ke[0] ? Ke[Me++] = Kt[tt] || 0 : (Ke = [Kt[tt]], Me = 1)
                } while ((tt++ < nt || Ke[0] != null) && X--);
                pe = Ke[0] != null, $e[0] || $e.splice(0, 1)
              }
              if (L == a) {
                for (ne = 1, X = $e[0]; X >= 10; X /= 10, ne++);
                le(Re, F + (Re.e = ne + ie * c - 1) + 1, B, pe)
              } else Re.e = ie, Re.r = +pe;
              return Re
            }
          }();

          function ve(S, T, j, G) {
            var k, F, B, L, $;
            if (j == null ? j = _ : w(j, 0, 8), !S.c) return S.toString();
            if (k = S.c[0], B = S.e, T == null) $ = m(S.c), $ = G == 1 || G == 2 && (B <= R || B >= D) ? q($, B) : J($, B, "0");
            else if (S = le(new Q(S), T, j), F = S.e, $ = m(S.c), L = $.length, G == 1 || G == 2 && (T <= F || F <= R)) {
              for (; L < T; $ += "0", L++);
              $ = q($, F)
            } else if (T -= B, $ = J($, F, "0"), F + 1 > L) {
              if (--T > 0)
                for ($ += "."; T--; $ += "0");
            } else if (T += F - L, T > 0)
              for (F + 1 == L && ($ += "."); T--; $ += "0");
            return S.s < 0 && k ? "-" + $ : $
          }

          function x(S, T) {
            for (var j, G = 1, k = new Q(S[0]); G < S.length; G++)
              if (j = new Q(S[G]), j.s) T.call(k, j) && (k = j);
              else {
                k = j;
                break
              } return k
          }

          function I(S, T, j) {
            for (var G = 1, k = T.length; !T[--k]; T.pop());
            for (k = T[0]; k >= 10; k /= 10, G++);
            return (j = G + j * c - 1) > ee ? S.c = S.e = null : j < K ? S.c = [S.e = 0] : (S.e = j, S.c = T), S
          }
          ae = function () {
            var S = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
              T = /^([^.]+)\.$/,
              j = /^\.([^.]+)$/,
              G = /^-?(Infinity|NaN)$/,
              k = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
            return function (F, B, L, $) {
              var ie, ne = L ? B : B.replace(k, "");
              if (G.test(ne)) F.s = isNaN(ne) ? null : ne < 0 ? -1 : 1;
              else {
                if (!L && (ne = ne.replace(S, function (pe, be, de) {
                  return ie = (de = de.toLowerCase()) == "x" ? 16 : de == "b" ? 2 : 8, !$ || $ == ie ? be : pe
                }), $ && (ie = $, ne = ne.replace(T, "$1").replace(j, "0.$1")), B != ne)) return new Q(ne, ie);
                if (Q.DEBUG) throw Error(s + "Not a" + ($ ? " base " + $ : "") + " number: " + B);
                F.s = null
              }
              F.c = F.e = null
            }
          }();

          function le(S, T, j, G) {
            var k, F, B, L, $, ie, ne, pe = S.c,
              be = f;
            if (pe) {
              e: {
                for (k = 1, L = pe[0]; L >= 10; L /= 10, k++);
                if (F = T - k, F < 0) F += c,
                  B = T,
                  $ = pe[ie = 0],
                  ne = $ / be[k - B - 1] % 10 | 0;
                else if (ie = i((F + 1) / c), ie >= pe.length)
                  if (G) {
                    for (; pe.length <= ie; pe.push(0));
                    $ = ne = 0, k = 1, F %= c, B = F - c + 1
                  } else break e;
                else {
                  for ($ = L = pe[ie], k = 1; L >= 10; L /= 10, k++);
                  F %= c, B = F - c + k, ne = B < 0 ? 0 : $ / be[k - B - 1] % 10 | 0
                }
                if (G = G || T < 0 || pe[ie + 1] != null || (B < 0 ? $ : $ % be[k - B - 1]), G = j < 4 ? (ne || G) && (j == 0 || j == (S.s < 0 ? 3 : 2)) : ne > 5 || ne == 5 && (j == 4 || G || j == 6 && (F > 0 ? B > 0 ? $ / be[k - B] : 0 : pe[ie - 1]) % 10 & 1 || j == (S.s < 0 ? 8 : 7)), T < 1 || !pe[0]) return pe.length = 0,
                  G ? (T -= S.e + 1, pe[0] = be[(c - T % c) % c], S.e = -T || 0) : pe[0] = S.e = 0,
                  S;
                if (F == 0 ? (pe.length = ie, L = 1, ie--) : (pe.length = ie + 1, L = be[c - F], pe[ie] = B > 0 ? n($ / be[k - B] % be[B]) * L : 0), G)
                  for (; ;)
                    if (ie == 0) {
                      for (F = 1, B = pe[0]; B >= 10; B /= 10, F++);
                      for (B = pe[0] += L, L = 1; B >= 10; B /= 10, L++);
                      F != L && (S.e++, pe[0] == a && (pe[0] = 1));
                      break
                    } else {
                      if (pe[ie] += L, pe[ie] != a) break;
                      pe[ie--] = 0, L = 1
                    } for (F = pe.length; pe[--F] === 0; pe.pop());
              }
              S.e > ee ? S.c = S.e = null : S.e < K && (S.c = [S.e = 0])
            }
            return S
          }

          function he(S) {
            var T, j = S.e;
            return j === null ? S.toString() : (T = m(S.c), T = j <= R || j >= D ? q(T, j) : J(T, j, "0"), S.s < 0 ? "-" + T : T)
          }
          return oe.absoluteValue = oe.abs = function () {
            var S = new Q(this);
            return S.s < 0 && (S.s = 1), S
          }, oe.comparedTo = function (S, T) {
            return E(this, new Q(S, T))
          }, oe.decimalPlaces = oe.dp = function (S, T) {
            var j, G, k, F = this;
            if (S != null) return w(S, 0, d), T == null ? T = _ : w(T, 0, 8), le(new Q(F), S + F.e + 1, T);
            if (!(j = F.c)) return null;
            if (G = ((k = j.length - 1) - g(this.e / c)) * c, k = j[k])
              for (; k % 10 == 0; k /= 10, G--);
            return G < 0 && (G = 0), G
          }, oe.dividedBy = oe.div = function (S, T) {
            return H(this, new Q(S, T), b, _)
          }, oe.dividedToIntegerBy = oe.idiv = function (S, T) {
            return H(this, new Q(S, T), 0, 1)
          }, oe.exponentiatedBy = oe.pow = function (S, T) {
            var j, G, k, F, B, L, $, ie, ne, pe = this;
            if (S = new Q(S), S.c && !S.isInteger()) throw Error(s + "Exponent not an integer: " + he(S));
            if (T != null && (T = new Q(T)), L = S.e > 14, !pe.c || !pe.c[0] || pe.c[0] == 1 && !pe.e && pe.c.length == 1 || !S.c || !S.c[0]) return ne = new Q(Math.pow(+he(pe), L ? 2 - O(S) : +he(S))), T ? ne.mod(T) : ne;
            if ($ = S.s < 0, T) {
              if (T.c ? !T.c[0] : !T.s) return new Q(NaN);
              G = !$ && pe.isInteger() && T.isInteger(), G && (pe = pe.mod(T))
            } else {
              if (S.e > 9 && (pe.e > 0 || pe.e < -1 || (pe.e == 0 ? pe.c[0] > 1 || L && pe.c[1] >= 24e7 : pe.c[0] < 8e13 || L && pe.c[0] <= 9999975e7))) return F = (pe.s < 0 && O(S), -0), pe.e > -1 && (F = 1 / F), new Q($ ? 1 / F : F);
              v && (F = i(v / c + 2))
            }
            for (L ? (j = new Q(.5), $ && (S.s = 1), ie = O(S)) : (k = Math.abs(+he(S)), ie = k % 2), ne = new Q(U); ;) {
              if (ie) {
                if (ne = ne.times(pe), !ne.c) break;
                F ? ne.c.length > F && (ne.c.length = F) : G && (ne = ne.mod(T))
              }
              if (k) {
                if (k = n(k / 2), k === 0) break;
                ie = k % 2
              } else if (S = S.times(j), le(S, S.e + 1, 1), S.e > 14) ie = O(S);
              else {
                if (k = +he(S), k === 0) break;
                ie = k % 2
              }
              pe = pe.times(pe), F ? pe.c && pe.c.length > F && (pe.c.length = F) : G && (pe = pe.mod(T))
            }
            return G ? ne : ($ && (ne = U.div(ne)), T ? ne.mod(T) : F ? le(ne, v, _, B) : ne)
          }, oe.integerValue = function (S) {
            var T = new Q(this);
            return S == null ? S = _ : w(S, 0, 8), le(T, T.e + 1, S)
          }, oe.isEqualTo = oe.eq = function (S, T) {
            return E(this, new Q(S, T)) === 0
          }, oe.isFinite = function () {
            return !!this.c
          }, oe.isGreaterThan = oe.gt = function (S, T) {
            return E(this, new Q(S, T)) > 0
          }, oe.isGreaterThanOrEqualTo = oe.gte = function (S, T) {
            return (T = E(this, new Q(S, T))) === 1 || T === 0
          }, oe.isInteger = function () {
            return !!this.c && g(this.e / c) > this.c.length - 2
          }, oe.isLessThan = oe.lt = function (S, T) {
            return E(this, new Q(S, T)) < 0
          }, oe.isLessThanOrEqualTo = oe.lte = function (S, T) {
            return (T = E(this, new Q(S, T))) === -1 || T === 0
          }, oe.isNaN = function () {
            return !this.s
          }, oe.isNegative = function () {
            return this.s < 0
          }, oe.isPositive = function () {
            return this.s > 0
          }, oe.isZero = function () {
            return !!this.c && this.c[0] == 0
          }, oe.minus = function (S, T) {
            var j, G, k, F, B = this,
              L = B.s;
            if (S = new Q(S, T), T = S.s, !L || !T) return new Q(NaN);
            if (L != T) return S.s = -T, B.plus(S);
            var $ = B.e / c,
              ie = S.e / c,
              ne = B.c,
              pe = S.c;
            if (!$ || !ie) {
              if (!ne || !pe) return ne ? (S.s = -T, S) : new Q(pe ? B : NaN);
              if (!ne[0] || !pe[0]) return pe[0] ? (S.s = -T, S) : new Q(ne[0] ? B : (_ == 3, -0))
            }
            if ($ = g($), ie = g(ie), ne = ne.slice(), L = $ - ie) {
              for ((F = L < 0) ? (L = -L, k = ne) : (ie = $, k = pe), k.reverse(), T = L; T--; k.push(0));
              k.reverse()
            } else
              for (G = (F = (L = ne.length) < (T = pe.length)) ? L : T, L = T = 0; T < G; T++)
                if (ne[T] != pe[T]) {
                  F = ne[T] < pe[T];
                  break
                } if (F && (k = ne, ne = pe, pe = k, S.s = -S.s), T = (G = pe.length) - (j = ne.length), T > 0)
              for (; T--; ne[j++] = 0);
            for (T = a - 1; G > L;) {
              if (ne[--G] < pe[G]) {
                for (j = G; j && !ne[--j]; ne[j] = T);
                --ne[j], ne[G] += a
              }
              ne[G] -= pe[G]
            }
            for (; ne[0] == 0; ne.splice(0, 1), --ie);
            return ne[0] ? I(S, ne, ie) : (S.s = _ == 3 ? -1 : 1, S.c = [S.e = 0], S)
          }, oe.modulo = oe.mod = function (S, T) {
            var j, G, k = this;
            return S = new Q(S, T), !k.c || !S.s || S.c && !S.c[0] ? new Q(NaN) : !S.c || k.c && !k.c[0] ? new Q(k) : (V == 9 ? (G = S.s, S.s = 1, j = H(k, S, 0, 3), S.s = G, j.s *= G) : j = H(k, S, 0, V), S = k.minus(j.times(S)), !S.c[0] && V == 1 && (S.s = k.s), S)
          }, oe.multipliedBy = oe.times = function (S, T) {
            var j, G, k, F, B, L, $, ie, ne, pe, be, de, Ne, Re, $e, Ke = this,
              Me = Ke.c,
              Ie = (S = new Q(S, T)).c;
            if (!Me || !Ie || !Me[0] || !Ie[0]) return !Ke.s || !S.s || Me && !Me[0] && !Ie || Ie && !Ie[0] && !Me ? S.c = S.e = S.s = null : (S.s *= Ke.s, !Me || !Ie ? S.c = S.e = null : (S.c = [0], S.e = 0)), S;
            for (G = g(Ke.e / c) + g(S.e / c), S.s *= Ke.s, $ = Me.length, pe = Ie.length, $ < pe && (Ne = Me, Me = Ie, Ie = Ne, k = $, $ = pe, pe = k), k = $ + pe, Ne = []; k--; Ne.push(0));
            for (Re = a, $e = h, k = pe; --k >= 0;) {
              for (j = 0, be = Ie[k] % $e, de = Ie[k] / $e | 0, B = $, F = k + B; F > k;) ie = Me[--B] % $e, ne = Me[B] / $e | 0, L = de * ie + ne * be, ie = be * ie + L % $e * $e + Ne[F] + j, j = (ie / Re | 0) + (L / $e | 0) + de * ne, Ne[F--] = ie % Re;
              Ne[F] = j
            }
            return j ? ++G : Ne.splice(0, 1), I(S, Ne, G)
          }, oe.negated = function () {
            var S = new Q(this);
            return S.s = -S.s || null, S
          }, oe.plus = function (S, T) {
            var j, G = this,
              k = G.s;
            if (S = new Q(S, T), T = S.s, !k || !T) return new Q(NaN);
            if (k != T) return S.s = -T, G.minus(S);
            var F = G.e / c,
              B = S.e / c,
              L = G.c,
              $ = S.c;
            if (!F || !B) {
              if (!L || !$) return new Q(k / 0);
              if (!L[0] || !$[0]) return $[0] ? S : new Q(L[0] ? G : k * 0)
            }
            if (F = g(F), B = g(B), L = L.slice(), k = F - B) {
              for (k > 0 ? (B = F, j = $) : (k = -k, j = L), j.reverse(); k--; j.push(0));
              j.reverse()
            }
            for (k = L.length, T = $.length, k - T < 0 && (j = $, $ = L, L = j, T = k), k = 0; T;) k = (L[--T] = L[T] + $[T] + k) / a | 0, L[T] = a === L[T] ? 0 : L[T] % a;
            return k && (L = [k].concat(L), ++B), I(S, L, B)
          }, oe.precision = oe.sd = function (S, T) {
            var j, G, k, F = this;
            if (S != null && S !== !!S) return w(S, 1, d), T == null ? T = _ : w(T, 0, 8), le(new Q(F), S, T);
            if (!(j = F.c)) return null;
            if (k = j.length - 1, G = k * c + 1, k = j[k]) {
              for (; k % 10 == 0; k /= 10, G--);
              for (k = j[0]; k >= 10; k /= 10, G++);
            }
            return S && F.e + 1 > G && (G = F.e + 1), G
          }, oe.shiftedBy = function (S) {
            return w(S, -u, u), this.times("1e" + S)
          }, oe.squareRoot = oe.sqrt = function () {
            var S, T, j, G, k, F = this,
              B = F.c,
              L = F.s,
              $ = F.e,
              ie = b + 4,
              ne = new Q("0.5");
            if (L !== 1 || !B || !B[0]) return new Q(!L || L < 0 && (!B || B[0]) ? NaN : B ? F : 1 / 0);
            if (L = Math.sqrt(+he(F)), L == 0 || L == 1 / 0 ? (T = m(B), (T.length + $) % 2 == 0 && (T += "0"), L = Math.sqrt(+T), $ = g(($ + 1) / 2) - ($ < 0 || $ % 2), L == 1 / 0 ? T = "5e" + $ : (T = L.toExponential(), T = T.slice(0, T.indexOf("e") + 1) + $), j = new Q(T)) : j = new Q(L + ""), j.c[0]) {
              for ($ = j.e, L = $ + ie, L < 3 && (L = 0); ;)
                if (k = j, j = ne.times(k.plus(H(F, k, ie, 1))), m(k.c).slice(0, L) === (T = m(j.c)).slice(0, L))
                  if (j.e < $ && --L, T = T.slice(L - 3, L + 1), T == "9999" || !G && T == "4999") {
                    if (!G && (le(k, k.e + b + 2, 0), k.times(k).eq(F))) {
                      j = k;
                      break
                    }
                    ie += 4, L += 4, G = 1
                  } else {
                    (!+T || !+T.slice(1) && T.charAt(0) == "5") && (le(j, j.e + b + 2, 1), S = !j.times(j).eq(F));
                    break
                  }
            }
            return le(j, j.e + b + 1, _, S)
          }, oe.toExponential = function (S, T) {
            return S != null && (w(S, 0, d), S++), ve(this, S, T, 1)
          }, oe.toFixed = function (S, T) {
            return S != null && (w(S, 0, d), S = S + this.e + 1), ve(this, S, T)
          }, oe.toFormat = function (S, T, j) {
            var G, k = this;
            if (j == null) S != null && T && typeof T == "object" ? (j = T, T = null) : S && typeof S == "object" ? (j = S, S = T = null) : j = Y;
            else if (typeof j != "object") throw Error(s + "Argument not an object: " + j);
            if (G = k.toFixed(S, T), k.c) {
              var F, B = G.split("."),
                L = +j.groupSize,
                $ = +j.secondaryGroupSize,
                ie = j.groupSeparator || "",
                ne = B[0],
                pe = B[1],
                be = k.s < 0,
                de = be ? ne.slice(1) : ne,
                Ne = de.length;
              if ($ && (F = L, L = $, $ = F, Ne -= F), L > 0 && Ne > 0) {
                for (F = Ne % L || L, ne = de.substr(0, F); F < Ne; F += L) ne += ie + de.substr(F, L);
                $ > 0 && (ne += ie + de.slice(F)), be && (ne = "-" + ne)
              }
              G = pe ? ne + (j.decimalSeparator || "") + (($ = +j.fractionGroupSize) ? pe.replace(new RegExp("\\d{" + $ + "}\\B", "g"), "$&" + (j.fractionGroupSeparator || "")) : pe) : ne
            }
            return (j.prefix || "") + G + (j.suffix || "")
          }, oe.toFraction = function (S) {
            var T, j, G, k, F, B, L, $, ie, ne, pe, be, de = this,
              Ne = de.c;
            if (S != null && (L = new Q(S), !L.isInteger() && (L.c || L.s !== 1) || L.lt(U))) throw Error(s + "Argument " + (L.isInteger() ? "out of range: " : "not an integer: ") + he(L));
            if (!Ne) return new Q(de);
            for (T = new Q(U), ie = j = new Q(U), G = $ = new Q(U), be = m(Ne), F = T.e = be.length - de.e - 1, T.c[0] = f[(B = F % c) < 0 ? c + B : B], S = !S || L.comparedTo(T) > 0 ? F > 0 ? T : ie : L, B = ee, ee = 1 / 0, L = new Q(be), $.c[0] = 0; ne = H(L, T, 0, 1), k = j.plus(ne.times(G)), k.comparedTo(S) != 1;) j = G, G = k, ie = $.plus(ne.times(k = ie)), $ = k, T = L.minus(ne.times(k = T)), L = k;
            return k = H(S.minus(j), G, 0, 1), $ = $.plus(k.times(ie)), j = j.plus(k.times(G)), $.s = ie.s = de.s, F = F * 2, pe = H(ie, G, F, _).minus(de).abs().comparedTo(H($, j, F, _).minus(de).abs()) < 1 ? [ie, G] : [$, j], ee = B, pe
          }, oe.toNumber = function () {
            return +he(this)
          }, oe.toPrecision = function (S, T) {
            return S != null && w(S, 1, d), ve(this, S, T, 2)
          }, oe.toString = function (S) {
            var T, j = this,
              G = j.s,
              k = j.e;
            return k === null ? G ? (T = "Infinity", G < 0 && (T = "-" + T)) : T = "NaN" : (S == null ? T = k <= R || k >= D ? q(m(j.c), k) : J(m(j.c), k, "0") : S === 10 ? (j = le(new Q(j), b + k + 1, _), T = J(m(j.c), j.e, "0")) : (w(S, 2, Se.length, "Base"), T = te(J(m(j.c), k, "0"), 10, S, G, !0)), G < 0 && j.c[0] && (T = "-" + T)), T
          }, oe.valueOf = oe.toJSON = function () {
            return he(this)
          }, oe._isBigNumber = !0, Z != null && Q.set(Z), Q
        }

        function g(Z) {
          var H = Z | 0;
          return Z > 0 || Z === H ? H : H - 1
        }

        function m(Z) {
          for (var H, te, ae = 1, oe = Z.length, U = Z[0] + ""; ae < oe;) {
            for (H = Z[ae++] + "", te = c - H.length; te--; H = "0" + H);
            U += H
          }
          for (oe = U.length; U.charCodeAt(--oe) === 48;);
          return U.slice(0, oe + 1 || 1)
        }

        function E(Z, H) {
          var te, ae, oe = Z.c,
            U = H.c,
            b = Z.s,
            _ = H.s,
            R = Z.e,
            D = H.e;
          if (!b || !_) return null;
          if (te = oe && !oe[0], ae = U && !U[0], te || ae) return te ? ae ? 0 : -_ : b;
          if (b != _) return b;
          if (te = b < 0, ae = R == D, !oe || !U) return ae ? 0 : !oe ^ te ? 1 : -1;
          if (!ae) return R > D ^ te ? 1 : -1;
          for (_ = (R = oe.length) < (D = U.length) ? R : D, b = 0; b < _; b++)
            if (oe[b] != U[b]) return oe[b] > U[b] ^ te ? 1 : -1;
          return R == D ? 0 : R > D ^ te ? 1 : -1
        }

        function w(Z, H, te, ae) {
          if (Z < H || Z > te || Z !== n(Z)) throw Error(s + (ae || "Argument") + (typeof Z == "number" ? Z < H || Z > te ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(Z))
        }

        function O(Z) {
          var H = Z.c.length - 1;
          return g(Z.e / c) == H && Z.c[H] % 2 != 0
        }

        function q(Z, H) {
          return (Z.length > 1 ? Z.charAt(0) + "." + Z.slice(1) : Z) + (H < 0 ? "e" : "e+") + H
        }

        function J(Z, H, te) {
          var ae, oe;
          if (H < 0) {
            for (oe = te + "."; ++H; oe += te);
            Z = oe + Z
          } else if (ae = Z.length, ++H > ae) {
            for (oe = te, H -= ae; --H; oe += te);
            Z += oe
          } else H < ae && (Z = Z.slice(0, H) + "." + Z.slice(H));
          return Z
        }
        e = p(), e.default = e.BigNumber = e, typeof define == "function" && define.amd ? define(function () {
          return e
        }) : typeof _v != "undefined" && _v.exports ? _v.exports = e : (r || (r = typeof self != "undefined" && self ? self : window), r.BigNumber = e)
      })(zz)
    });
    var Vz = y((bvt, jz) => {
      l();
      jz.exports = function (e, t, i) {
        var n = new e.Uint8Array(i),
          s = t.pushInt,
          o = t.pushInt32,
          a = t.pushInt32Neg,
          c = t.pushInt64,
          u = t.pushInt64Neg,
          f = t.pushFloat,
          h = t.pushFloatSingle,
          d = t.pushFloatDouble,
          p = t.pushTrue,
          g = t.pushFalse,
          m = t.pushUndefined,
          E = t.pushNull,
          w = t.pushInfinity,
          O = t.pushInfinityNeg,
          q = t.pushNaN,
          J = t.pushNaNNeg,
          Z = t.pushArrayStart,
          H = t.pushArrayStartFixed,
          te = t.pushArrayStartFixed32,
          ae = t.pushArrayStartFixed64,
          oe = t.pushObjectStart,
          U = t.pushObjectStartFixed,
          b = t.pushObjectStartFixed32,
          _ = t.pushObjectStartFixed64,
          R = t.pushByteString,
          D = t.pushByteStringStart,
          K = t.pushUtf8String,
          ee = t.pushUtf8StringStart,
          re = t.pushSimpleUnassigned,
          V = t.pushTagStart,
          v = t.pushTagStart4,
          Y = t.pushTagStart8,
          Se = t.pushTagUnassigned,
          Q = t.pushBreak,
          ve = e.Math.pow,
          x = 0,
          I = 0,
          le = 0;

        function he(P) {
          for (P = P | 0, x = 0, I = P;
            (x | 0) < (I | 0) && (le = kc[n[x] & 255](n[x] | 0) | 0, !((le | 0) > 0)););
          return le | 0
        }

        function S(P) {
          return P = P | 0, ((x | 0) + (P | 0) | 0) < (I | 0) ? 0 : 1
        }

        function T(P) {
          return P = P | 0, n[P | 0] << 8 | n[P + 1 | 0] | 0
        }

        function j(P) {
          return P = P | 0, n[P | 0] << 24 | n[P + 1 | 0] << 16 | n[P + 2 | 0] << 8 | n[P + 3 | 0] | 0
        }

        function G(P) {
          return P = P | 0, s(P | 0), x = x + 1 | 0, 0
        }

        function k(P) {
          return P = P | 0, S(1) | 0 ? 1 : (s(n[x + 1 | 0] | 0), x = x + 2 | 0, 0)
        }

        function F(P) {
          return P = P | 0, S(2) | 0 ? 1 : (s(T(x + 1 | 0) | 0), x = x + 3 | 0, 0)
        }

        function B(P) {
          return P = P | 0, S(4) | 0 ? 1 : (o(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0), x = x + 5 | 0, 0)
        }

        function L(P) {
          return P = P | 0, S(8) | 0 ? 1 : (c(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0, T(x + 5 | 0) | 0, T(x + 7 | 0) | 0), x = x + 9 | 0, 0)
        }

        function $(P) {
          return P = P | 0, s(-1 - (P - 32 | 0) | 0), x = x + 1 | 0, 0
        }

        function ie(P) {
          return P = P | 0, S(1) | 0 ? 1 : (s(-1 - (n[x + 1 | 0] | 0) | 0), x = x + 2 | 0, 0)
        }

        function ne(P) {
          P = P | 0;
          var Ve = 0;
          return S(2) | 0 ? 1 : (Ve = T(x + 1 | 0) | 0, s(-1 - (Ve | 0) | 0), x = x + 3 | 0, 0)
        }

        function pe(P) {
          return P = P | 0, S(4) | 0 ? 1 : (a(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0), x = x + 5 | 0, 0)
        }

        function be(P) {
          return P = P | 0, S(8) | 0 ? 1 : (u(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0, T(x + 5 | 0) | 0, T(x + 7 | 0) | 0), x = x + 9 | 0, 0)
        }

        function de(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return Fe = P - 64 | 0, S(Fe | 0) | 0 ? 1 : (Ve = x + 1 | 0, We = (x + 1 | 0) + (Fe | 0) | 0, R(Ve | 0, We | 0), x = We | 0, 0)
        }

        function Ne(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(1) | 0 || (Fe = n[x + 1 | 0] | 0, Ve = x + 2 | 0, We = (x + 2 | 0) + (Fe | 0) | 0, S(Fe + 1 | 0) | 0) ? 1 : (R(Ve | 0, We | 0), x = We | 0, 0)
        }

        function Re(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(2) | 0 || (Fe = T(x + 1 | 0) | 0, Ve = x + 3 | 0, We = (x + 3 | 0) + (Fe | 0) | 0, S(Fe + 2 | 0) | 0) ? 1 : (R(Ve | 0, We | 0), x = We | 0, 0)
        }

        function $e(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(4) | 0 || (Fe = j(x + 1 | 0) | 0, Ve = x + 5 | 0, We = (x + 5 | 0) + (Fe | 0) | 0, S(Fe + 4 | 0) | 0) ? 1 : (R(Ve | 0, We | 0), x = We | 0, 0)
        }

        function Ke(P) {
          return P = P | 0, 1
        }

        function Me(P) {
          return P = P | 0, D(), x = x + 1 | 0, 0
        }

        function Ie(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return Fe = P - 96 | 0, S(Fe | 0) | 0 ? 1 : (Ve = x + 1 | 0, We = (x + 1 | 0) + (Fe | 0) | 0, K(Ve | 0, We | 0), x = We | 0, 0)
        }

        function tt(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(1) | 0 || (Fe = n[x + 1 | 0] | 0, Ve = x + 2 | 0, We = (x + 2 | 0) + (Fe | 0) | 0, S(Fe + 1 | 0) | 0) ? 1 : (K(Ve | 0, We | 0), x = We | 0, 0)
        }

        function nt(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(2) | 0 || (Fe = T(x + 1 | 0) | 0, Ve = x + 3 | 0, We = (x + 3 | 0) + (Fe | 0) | 0, S(Fe + 2 | 0) | 0) ? 1 : (K(Ve | 0, We | 0), x = We | 0, 0)
        }

        function Ge(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(4) | 0 || (Fe = j(x + 1 | 0) | 0, Ve = x + 5 | 0, We = (x + 5 | 0) + (Fe | 0) | 0, S(Fe + 4 | 0) | 0) ? 1 : (K(Ve | 0, We | 0), x = We | 0, 0)
        }

        function se(P) {
          return P = P | 0, 1
        }

        function A(P) {
          return P = P | 0, ee(), x = x + 1 | 0, 0
        }

        function X(P) {
          return P = P | 0, H(P - 128 | 0), x = x + 1 | 0, 0
        }

        function Kt(P) {
          return P = P | 0, S(1) | 0 ? 1 : (H(n[x + 1 | 0] | 0), x = x + 2 | 0, 0)
        }

        function st(P) {
          return P = P | 0, S(2) | 0 ? 1 : (H(T(x + 1 | 0) | 0), x = x + 3 | 0, 0)
        }

        function Nt(P) {
          return P = P | 0, S(4) | 0 ? 1 : (te(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0), x = x + 5 | 0, 0)
        }

        function on(P) {
          return P = P | 0, S(8) | 0 ? 1 : (ae(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0, T(x + 5 | 0) | 0, T(x + 7 | 0) | 0), x = x + 9 | 0, 0)
        }

        function qt(P) {
          return P = P | 0, Z(), x = x + 1 | 0, 0
        }

        function De(P) {
          P = P | 0;
          var Ve = 0;
          return Ve = P - 160 | 0, S(Ve | 0) | 0 ? 1 : (U(Ve | 0), x = x + 1 | 0, 0)
        }

        function an(P) {
          return P = P | 0, S(1) | 0 ? 1 : (U(n[x + 1 | 0] | 0), x = x + 2 | 0, 0)
        }

        function Mt(P) {
          return P = P | 0, S(2) | 0 ? 1 : (U(T(x + 1 | 0) | 0), x = x + 3 | 0, 0)
        }

        function Bt(P) {
          return P = P | 0, S(4) | 0 ? 1 : (b(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0), x = x + 5 | 0, 0)
        }

        function cn(P) {
          return P = P | 0, S(8) | 0 ? 1 : (_(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0, T(x + 5 | 0) | 0, T(x + 7 | 0) | 0), x = x + 9 | 0, 0)
        }

        function Dt(P) {
          return P = P | 0, oe(), x = x + 1 | 0, 0
        }

        function yt(P) {
          return P = P | 0, V(P - 192 | 0 | 0), x = x + 1 | 0, 0
        }

        function Bn(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function Ht(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function Gt(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function Dn(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function et(P) {
          return P = P | 0, V(P - 192 | 0 | 0), x = x + 1 | 0, 0
        }

        function $t(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function Ln(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function dr(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function nr(P) {
          return P = P | 0, S(1) | 0 ? 1 : (V(n[x + 1 | 0] | 0), x = x + 2 | 0, 0)
        }

        function Ss(P) {
          return P = P | 0, S(2) | 0 ? 1 : (V(T(x + 1 | 0) | 0), x = x + 3 | 0, 0)
        }

        function sr(P) {
          return P = P | 0, S(4) | 0 ? 1 : (v(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0), x = x + 5 | 0, 0)
        }

        function or(P) {
          return P = P | 0, S(8) | 0 ? 1 : (Y(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0, T(x + 5 | 0) | 0, T(x + 7 | 0) | 0), x = x + 9 | 0, 0)
        }

        function ut(P) {
          return P = P | 0, re((P | 0) - 224 | 0), x = x + 1 | 0, 0
        }

        function ar(P) {
          return P = P | 0, g(), x = x + 1 | 0, 0
        }

        function Lt(P) {
          return P = P | 0, p(), x = x + 1 | 0, 0
        }

        function Fn(P) {
          return P = P | 0, E(), x = x + 1 | 0, 0
        }

        function ns(P) {
          return P = P | 0, m(), x = x + 1 | 0, 0
        }

        function ss(P) {
          return P = P | 0, S(1) | 0 ? 1 : (re(n[x + 1 | 0] | 0), x = x + 2 | 0, 0)
        }

        function os(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 1,
            Un = 0,
            un = 0,
            Yf = 0;
          return S(2) | 0 ? 1 : (Ve = n[x + 1 | 0] | 0, We = n[x + 2 | 0] | 0, (Ve | 0) & 128 && (Fe = -1), Un = +(((Ve | 0) & 124) >> 2), un = +(((Ve | 0) & 3) << 8 | We), +Un == 0 ? f(+(+Fe * 5960464477539063e-23 * +un)) : +Un == 31 ? +Fe == 1 ? +un > 0 ? q() : w() : +un > 0 ? J() : O() : f(+(+Fe * ve(2, +(+Un - 25)) * +(1024 + un))), x = x + 3 | 0, 0)
        }

        function as(P) {
          return P = P | 0, S(4) | 0 ? 1 : (h(n[x + 1 | 0] | 0, n[x + 2 | 0] | 0, n[x + 3 | 0] | 0, n[x + 4 | 0] | 0), x = x + 5 | 0, 0)
        }

        function cs(P) {
          return P = P | 0, S(8) | 0 ? 1 : (d(n[x + 1 | 0] | 0, n[x + 2 | 0] | 0, n[x + 3 | 0] | 0, n[x + 4 | 0] | 0, n[x + 5 | 0] | 0, n[x + 6 | 0] | 0, n[x + 7 | 0] | 0, n[x + 8 | 0] | 0), x = x + 9 | 0, 0)
        }

        function Ze(P) {
          return P = P | 0, 1
        }

        function us(P) {
          return P = P | 0, Q(), x = x + 1 | 0, 0
        }
        var kc = [G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, k, F, B, L, Ze, Ze, Ze, Ze, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, ie, ne, pe, be, Ze, Ze, Ze, Ze, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, Ne, Re, $e, Ke, Ze, Ze, Ze, Me, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, tt, nt, Ge, se, Ze, Ze, Ze, A, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, Kt, st, Nt, on, Ze, Ze, Ze, qt, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, an, Mt, Bt, cn, Ze, Ze, Ze, Dt, yt, yt, yt, yt, yt, yt, et, et, et, et, et, et, et, et, et, et, et, et, et, et, et, et, et, et, nr, Ss, sr, or, Ze, Ze, Ze, Ze, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ar, Lt, Fn, ns, ss, os, as, cs, Ze, Ze, Ze, us];
        return {
          parse: he
        }
      }
    });
    var Oy = y(Cs => {
      l();
      "use strict";
      var f8 = tc().BigNumber;
      Cs.MT = {
        POS_INT: 0,
        NEG_INT: 1,
        BYTE_STRING: 2,
        UTF8_STRING: 3,
        ARRAY: 4,
        MAP: 5,
        TAG: 6,
        SIMPLE_FLOAT: 7
      };
      Cs.TAG = {
        DATE_STRING: 0,
        DATE_EPOCH: 1,
        POS_BIGINT: 2,
        NEG_BIGINT: 3,
        DECIMAL_FRAC: 4,
        BIGFLOAT: 5,
        BASE64URL_EXPECTED: 21,
        BASE64_EXPECTED: 22,
        BASE16_EXPECTED: 23,
        CBOR: 24,
        URI: 32,
        BASE64URL: 33,
        BASE64: 34,
        REGEXP: 35,
        MIME: 36
      };
      Cs.NUMBYTES = {
        ZERO: 0,
        ONE: 24,
        TWO: 25,
        FOUR: 26,
        EIGHT: 27,
        INDEFINITE: 31
      };
      Cs.SIMPLE = {
        FALSE: 20,
        TRUE: 21,
        NULL: 22,
        UNDEFINED: 23
      };
      Cs.SYMS = {
        NULL: Symbol("null"),
        UNDEFINED: Symbol("undef"),
        PARENT: Symbol("parent"),
        BREAK: Symbol("break"),
        STREAM: Symbol("stream")
      };
      Cs.SHIFT32 = Math.pow(2, 32);
      Cs.SHIFT16 = Math.pow(2, 16);
      Cs.MAX_SAFE_HIGH = 2097151;
      Cs.NEG_ONE = new f8(-1);
      Cs.TEN = new f8(10);
      Cs.TWO = new f8(2);
      Cs.PARENT = {
        ARRAY: 0,
        OBJECT: 1,
        MAP: 2,
        TAG: 3,
        BYTE_STRING: 4,
        UTF8_STRING: 5
      }
    });
    var Ev = y(uo => {
      l();
      "use strict";
      var {
        Buffer: JPe
      } = Cy(), Hz = tc().BigNumber, Gz = Oy(), $z = Gz.SHIFT32, XPe = Gz.SHIFT16, ZPe = 2097151;
      uo.parseHalf = function (e) {
        var t, i, n;
        return n = e[0] & 128 ? -1 : 1, t = (e[0] & 124) >> 2, i = (e[0] & 3) << 8 | e[1], t ? t === 31 ? n * (i ? 0 / 0 : Infinity) : n * Math.pow(2, t - 25) * (1024 + i) : n * 5960464477539063e-23 * i
      };

      function QPe(r) {
        return r < 16 ? "0" + r.toString(16) : r.toString(16)
      }
      uo.arrayBufferToBignumber = function (r) {
        let e = r.byteLength,
          t = "";
        for (let i = 0; i < e; i++) t += QPe(r[i]);
        return new Hz(t, 16)
      };
      uo.buildMap = r => {
        let e = new Map,
          t = Object.keys(r),
          i = t.length;
        for (let n = 0; n < i; n++) e.set(t[n], r[t[n]]);
        return e
      };
      uo.buildInt32 = (r, e) => r * XPe + e;
      uo.buildInt64 = (r, e, t, i) => {
        let n = uo.buildInt32(r, e),
          s = uo.buildInt32(t, i);
        return n > ZPe ? new Hz(n).times($z).plus(s) : n * $z + s
      };
      uo.writeHalf = function (e, t) {
        let i = JPe.allocUnsafe(4);
        i.writeFloatBE(t, 0);
        let n = i.readUInt32BE(0);
        if ((n & 8191) != 0) return !1;
        var s = n >> 16 & 32768;
        let o = n >> 23 & 255,
          a = n & 8388607;
        if (o >= 113 && o <= 142) s += (o - 112 << 10) + (a >> 13);
        else if (o >= 103 && o < 113) {
          if (a & (1 << 126 - o) - 1) return !1;
          s += a + 8388608 >> 126 - o
        } else return !1;
        return e.writeUInt16BE(s, 0), !0
      };
      uo.keySorter = function (r, e) {
        var t = r[0].byteLength,
          i = e[0].byteLength;
        return t > i ? 1 : i > t ? -1 : r[0].compare(e[0])
      };
      uo.isNegativeZero = r => r === 0 && 1 / r < 0;
      uo.nextPowerOf2 = r => {
        let e = 0;
        if (r && !(r & r - 1)) return r;
        for (; r !== 0;) r >>= 1, e += 1;
        return 1 << e
      }
    });
    var d8 = y((wvt, Wz) => {
      l();
      "use strict";
      var l8 = Oy(),
        eCe = l8.MT,
        Sv = l8.SIMPLE,
        h8 = l8.SYMS,
        Ny = class {
          constructor(e) {
            if (typeof e != "number") throw new Error("Invalid Simple type: " + typeof e);
            if (e < 0 || e > 255 || (e | 0) !== e) throw new Error("value must be a small positive integer: " + e);
            this.value = e
          }
          toString() {
            return "simple(" + this.value + ")"
          }
          inspect() {
            return "simple(" + this.value + ")"
          }
          encodeCBOR(e) {
            return e._pushInt(this.value, eCe.SIMPLE_FLOAT)
          }
          static isSimple(e) {
            return e instanceof Ny
          }
          static decode(e, t) {
            switch (t == null && (t = !0), e) {
              case Sv.FALSE:
                return !1;
              case Sv.TRUE:
                return !0;
              case Sv.NULL:
                return t ? null : h8.NULL;
              case Sv.UNDEFINED:
                return t ? void 0 : h8.UNDEFINED;
              case -1:
                if (!t) throw new Error("Invalid BREAK");
                return h8.BREAK;
              default:
                return new Ny(e)
            }
          }
        };
      Wz.exports = Ny
    });
    var p8 = y((_vt, Yz) => {
      l();
      "use strict";
      var qy = class {
        constructor(e, t, i) {
          if (this.tag = e, this.value = t, this.err = i, typeof this.tag != "number") throw new Error("Invalid tag type (" + typeof this.tag + ")");
          if (this.tag < 0 || (this.tag | 0) !== this.tag) throw new Error("Tag must be a positive integer: " + this.tag)
        }
        toString() {
          return `${this.tag}(${JSON.stringify(this.value)})`
        }
        encodeCBOR(e) {
          return e._pushTag(this.tag), e.pushAny(this.value)
        }
        convert(e) {
          var t, i;
          if (i = e != null ? e[this.tag] : void 0, typeof i != "function" && (i = qy["_tag" + this.tag], typeof i != "function")) return this;
          try {
            return i.call(qy, this.value)
          } catch (n) {
            return t = n, this.err = t, this
          }
        }
      };
      Yz.exports = qy
    });
    var g8 = y((Evt, Jz) => {
      l();
      "use strict";
      var Xz = self.location ? self.location.protocol + "//" + self.location.host : "",
        y8 = self.URL,
        Zz = class {
          constructor(e = "", t = Xz) {
            this.super = new y8(e, t), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null
          }
          get hash() {
            return this.super.hash
          }
          get host() {
            return this.super.host
          }
          get hostname() {
            return this.super.hostname
          }
          get href() {
            return this.super.href
          }
          get origin() {
            return this.super.origin
          }
          get password() {
            return this.super.password
          }
          get pathname() {
            return this.super.pathname
          }
          get port() {
            return this.super.port
          }
          get protocol() {
            return this.super.protocol
          }
          get search() {
            return this.super.search
          }
          get searchParams() {
            return this.super.searchParams
          }
          get username() {
            return this.super.username
          }
          set hash(e) {
            this.super.hash = e
          }
          set host(e) {
            this.super.host = e
          }
          set hostname(e) {
            this.super.hostname = e
          }
          set href(e) {
            this.super.href = e
          }
          set origin(e) {
            this.super.origin = e
          }
          set password(e) {
            this.super.password = e
          }
          set pathname(e) {
            this.super.pathname = e
          }
          set port(e) {
            this.super.port = e
          }
          set protocol(e) {
            this.super.protocol = e
          }
          set search(e) {
            this.super.search = e
          }
          set searchParams(e) {
            this.super.searchParams = e
          }
          set username(e) {
            this.super.username = e
          }
          createObjectURL(e) {
            return this.super.createObjectURL(e)
          }
          revokeObjectURL(e) {
            this.super.revokeObjectURL(e)
          }
          toJSON() {
            return this.super.toJSON()
          }
          toString() {
            return this.super.toString()
          }
          format() {
            return this.toString()
          }
        };

      function tCe(r) {
        if (typeof r == "string") return new y8(r).toString();
        if (!(r instanceof y8)) {
          let e = r.username && r.password ? `${r.username}:${r.password}@` : "",
            t = r.auth ? r.auth + "@" : "",
            i = r.port ? ":" + r.port : "",
            n = r.protocol ? r.protocol + "//" : "",
            s = r.host || "",
            o = r.hostname || "",
            a = r.search || (r.query ? "?" + r.query : ""),
            c = r.hash || "",
            u = r.pathname || "",
            f = r.path || u + a;
          return `${n}${e || t}${s || o + i}${f}${c}`
        }
      }
      Jz.exports = {
        URLWithLegacySupport: Zz,
        URLSearchParams: self.URLSearchParams,
        defaultBase: Xz,
        format: tCe
      }
    });
    var tj = y((Svt, Qz) => {
      l();
      "use strict";
      var {
        URLWithLegacySupport: ej,
        format: rCe
      } = g8();
      Qz.exports = (r, e = {}, t = {}, i) => {
        let n = e.protocol ? e.protocol.replace(":", "") : "http";
        n = (t[n] || i || n) + ":";
        let s;
        try {
          s = new ej(r)
        } catch (a) {
          s = {}
        }
        let o = Object.assign({}, e, {
          protocol: n || s.protocol,
          host: e.host || s.host
        });
        return new ej(r, rCe(o)).toString()
      }
    });
    var b8 = y((xvt, rj) => {
      l();
      "use strict";
      var {
        URLWithLegacySupport: iCe,
        format: nCe,
        URLSearchParams: sCe,
        defaultBase: oCe
      } = g8(), aCe = tj();
      rj.exports = {
        URL: iCe,
        URLSearchParams: sCe,
        format: nCe,
        relative: aCe,
        defaultBase: oCe
      }
    });
    var m8 = y((Avt, ij) => {
      l();
      "use strict";
      var {
        Buffer: Qd
      } = Cy(), nj = x1(), cCe = tc().BigNumber, uCe = Vz(), Gn = Ev(), gr = Oy(), fCe = d8(), lCe = p8(), {
        URL: hCe
      } = b8(), kl = class {
        constructor(e) {
          e = e || {}, !e.size || e.size < 65536 ? e.size = 65536 : e.size = Gn.nextPowerOf2(e.size), this._heap = new ArrayBuffer(e.size), this._heap8 = new Uint8Array(this._heap), this._buffer = Qd.from(this._heap), this._reset(), this._knownTags = Object.assign({
            0: t => new Date(t),
            1: t => new Date(t * 1e3),
            2: t => Gn.arrayBufferToBignumber(t),
            3: t => gr.NEG_ONE.minus(Gn.arrayBufferToBignumber(t)),
            4: t => gr.TEN.pow(t[0]).times(t[1]),
            5: t => gr.TWO.pow(t[0]).times(t[1]),
            32: t => new hCe(t),
            35: t => new RegExp(t)
          }, e.tags), this.parser = uCe(globalThis, {
            log: console.log.bind(console),
            pushInt: this.pushInt.bind(this),
            pushInt32: this.pushInt32.bind(this),
            pushInt32Neg: this.pushInt32Neg.bind(this),
            pushInt64: this.pushInt64.bind(this),
            pushInt64Neg: this.pushInt64Neg.bind(this),
            pushFloat: this.pushFloat.bind(this),
            pushFloatSingle: this.pushFloatSingle.bind(this),
            pushFloatDouble: this.pushFloatDouble.bind(this),
            pushTrue: this.pushTrue.bind(this),
            pushFalse: this.pushFalse.bind(this),
            pushUndefined: this.pushUndefined.bind(this),
            pushNull: this.pushNull.bind(this),
            pushInfinity: this.pushInfinity.bind(this),
            pushInfinityNeg: this.pushInfinityNeg.bind(this),
            pushNaN: this.pushNaN.bind(this),
            pushNaNNeg: this.pushNaNNeg.bind(this),
            pushArrayStart: this.pushArrayStart.bind(this),
            pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
            pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
            pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
            pushObjectStart: this.pushObjectStart.bind(this),
            pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
            pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
            pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
            pushByteString: this.pushByteString.bind(this),
            pushByteStringStart: this.pushByteStringStart.bind(this),
            pushUtf8String: this.pushUtf8String.bind(this),
            pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
            pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
            pushTagUnassigned: this.pushTagUnassigned.bind(this),
            pushTagStart: this.pushTagStart.bind(this),
            pushTagStart4: this.pushTagStart4.bind(this),
            pushTagStart8: this.pushTagStart8.bind(this),
            pushBreak: this.pushBreak.bind(this)
          }, this._heap)
        }
        get _depth() {
          return this._parents.length
        }
        get _currentParent() {
          return this._parents[this._depth - 1]
        }
        get _ref() {
          return this._currentParent.ref
        }
        _closeParent() {
          var e = this._parents.pop();
          if (e.length > 0) throw new Error(`Missing ${e.length} elements`);
          switch (e.type) {
            case gr.PARENT.TAG:
              this._push(this.createTag(e.ref[0], e.ref[1]));
              break;
            case gr.PARENT.BYTE_STRING:
              this._push(this.createByteString(e.ref, e.length));
              break;
            case gr.PARENT.UTF8_STRING:
              this._push(this.createUtf8String(e.ref, e.length));
              break;
            case gr.PARENT.MAP:
              if (e.values % 2 > 0) throw new Error("Odd number of elements in the map");
              this._push(this.createMap(e.ref, e.length));
              break;
            case gr.PARENT.OBJECT:
              if (e.values % 2 > 0) throw new Error("Odd number of elements in the map");
              this._push(this.createObject(e.ref, e.length));
              break;
            case gr.PARENT.ARRAY:
              this._push(this.createArray(e.ref, e.length));
              break;
            default:
              break
          }
          this._currentParent && this._currentParent.type === gr.PARENT.TAG && this._dec()
        }
        _dec() {
          let e = this._currentParent;
          e.length < 0 || (e.length--, e.length === 0 && this._closeParent())
        }
        _push(e, t) {
          let i = this._currentParent;
          switch (i.values++, i.type) {
            case gr.PARENT.ARRAY:
            case gr.PARENT.BYTE_STRING:
            case gr.PARENT.UTF8_STRING:
              i.length > -1 ? this._ref[this._ref.length - i.length] = e : this._ref.push(e), this._dec();
              break;
            case gr.PARENT.OBJECT:
              i.tmpKey != null ? (this._ref[i.tmpKey] = e, i.tmpKey = null, this._dec()) : (i.tmpKey = e, typeof i.tmpKey != "string" && (i.type = gr.PARENT.MAP, i.ref = Gn.buildMap(i.ref)));
              break;
            case gr.PARENT.MAP:
              i.tmpKey != null ? (this._ref.set(i.tmpKey, e), i.tmpKey = null, this._dec()) : i.tmpKey = e;
              break;
            case gr.PARENT.TAG:
              this._ref.push(e), t || this._dec();
              break;
            default:
              throw new Error("Unknown parent type")
          }
        }
        _createParent(e, t, i) {
          this._parents[this._depth] = {
            type: t,
            length: i,
            ref: e,
            values: 0,
            tmpKey: null
          }
        }
        _reset() {
          this._res = [], this._parents = [{
            type: gr.PARENT.ARRAY,
            length: -1,
            ref: this._res,
            values: 0,
            tmpKey: null
          }]
        }
        createTag(e, t) {
          let i = this._knownTags[e];
          return i ? i(t) : new lCe(e, t)
        }
        createMap(e, t) {
          return e
        }
        createObject(e, t) {
          return e
        }
        createArray(e, t) {
          return e
        }
        createByteString(e, t) {
          return Qd.concat(e)
        }
        createByteStringFromHeap(e, t) {
          return e === t ? Qd.alloc(0) : Qd.from(this._heap.slice(e, t))
        }
        createInt(e) {
          return e
        }
        createInt32(e, t) {
          return Gn.buildInt32(e, t)
        }
        createInt64(e, t, i, n) {
          return Gn.buildInt64(e, t, i, n)
        }
        createFloat(e) {
          return e
        }
        createFloatSingle(e, t, i, n) {
          return nj.read([e, t, i, n], 0, !1, 23, 4)
        }
        createFloatDouble(e, t, i, n, s, o, a, c) {
          return nj.read([e, t, i, n, s, o, a, c], 0, !1, 52, 8)
        }
        createInt32Neg(e, t) {
          return -1 - Gn.buildInt32(e, t)
        }
        createInt64Neg(e, t, i, n) {
          let s = Gn.buildInt32(e, t),
            o = Gn.buildInt32(i, n);
          return s > gr.MAX_SAFE_HIGH ? gr.NEG_ONE.minus(new cCe(s).times(gr.SHIFT32).plus(o)) : -1 - (s * gr.SHIFT32 + o)
        }
        createTrue() {
          return !0
        }
        createFalse() {
          return !1
        }
        createNull() {
          return null
        }
        createUndefined() { }
        createInfinity() {
          return Infinity
        }
        createInfinityNeg() {
          return -Infinity
        }
        createNaN() {
          return NaN
        }
        createNaNNeg() {
          return NaN
        }
        createUtf8String(e, t) {
          return e.join("")
        }
        createUtf8StringFromHeap(e, t) {
          return e === t ? "" : this._buffer.toString("utf8", e, t)
        }
        createSimpleUnassigned(e) {
          return new fCe(e)
        }
        pushInt(e) {
          this._push(this.createInt(e))
        }
        pushInt32(e, t) {
          this._push(this.createInt32(e, t))
        }
        pushInt64(e, t, i, n) {
          this._push(this.createInt64(e, t, i, n))
        }
        pushFloat(e) {
          this._push(this.createFloat(e))
        }
        pushFloatSingle(e, t, i, n) {
          this._push(this.createFloatSingle(e, t, i, n))
        }
        pushFloatDouble(e, t, i, n, s, o, a, c) {
          this._push(this.createFloatDouble(e, t, i, n, s, o, a, c))
        }
        pushInt32Neg(e, t) {
          this._push(this.createInt32Neg(e, t))
        }
        pushInt64Neg(e, t, i, n) {
          this._push(this.createInt64Neg(e, t, i, n))
        }
        pushTrue() {
          this._push(this.createTrue())
        }
        pushFalse() {
          this._push(this.createFalse())
        }
        pushNull() {
          this._push(this.createNull())
        }
        pushUndefined() {
          this._push(this.createUndefined())
        }
        pushInfinity() {
          this._push(this.createInfinity())
        }
        pushInfinityNeg() {
          this._push(this.createInfinityNeg())
        }
        pushNaN() {
          this._push(this.createNaN())
        }
        pushNaNNeg() {
          this._push(this.createNaNNeg())
        }
        pushArrayStart() {
          this._createParent([], gr.PARENT.ARRAY, -1)
        }
        pushArrayStartFixed(e) {
          this._createArrayStartFixed(e)
        }
        pushArrayStartFixed32(e, t) {
          let i = Gn.buildInt32(e, t);
          this._createArrayStartFixed(i)
        }
        pushArrayStartFixed64(e, t, i, n) {
          let s = Gn.buildInt64(e, t, i, n);
          this._createArrayStartFixed(s)
        }
        pushObjectStart() {
          this._createObjectStartFixed(-1)
        }
        pushObjectStartFixed(e) {
          this._createObjectStartFixed(e)
        }
        pushObjectStartFixed32(e, t) {
          let i = Gn.buildInt32(e, t);
          this._createObjectStartFixed(i)
        }
        pushObjectStartFixed64(e, t, i, n) {
          let s = Gn.buildInt64(e, t, i, n);
          this._createObjectStartFixed(s)
        }
        pushByteStringStart() {
          this._parents[this._depth] = {
            type: gr.PARENT.BYTE_STRING,
            length: -1,
            ref: [],
            values: 0,
            tmpKey: null
          }
        }
        pushByteString(e, t) {
          this._push(this.createByteStringFromHeap(e, t))
        }
        pushUtf8StringStart() {
          this._parents[this._depth] = {
            type: gr.PARENT.UTF8_STRING,
            length: -1,
            ref: [],
            values: 0,
            tmpKey: null
          }
        }
        pushUtf8String(e, t) {
          this._push(this.createUtf8StringFromHeap(e, t))
        }
        pushSimpleUnassigned(e) {
          this._push(this.createSimpleUnassigned(e))
        }
        pushTagStart(e) {
          this._parents[this._depth] = {
            type: gr.PARENT.TAG,
            length: 1,
            ref: [e]
          }
        }
        pushTagStart4(e, t) {
          this.pushTagStart(Gn.buildInt32(e, t))
        }
        pushTagStart8(e, t, i, n) {
          this.pushTagStart(Gn.buildInt64(e, t, i, n))
        }
        pushTagUnassigned(e) {
          this._push(this.createTag(e))
        }
        pushBreak() {
          if (this._currentParent.length > -1) throw new Error("Unexpected break");
          this._closeParent()
        }
        _createObjectStartFixed(e) {
          if (e === 0) {
            this._push(this.createObject({}));
            return
          }
          this._createParent({}, gr.PARENT.OBJECT, e)
        }
        _createArrayStartFixed(e) {
          if (e === 0) {
            this._push(this.createArray([]));
            return
          }
          this._createParent(new Array(e), gr.PARENT.ARRAY, e)
        }
        _decode(e) {
          if (e.byteLength === 0) throw new Error("Input too short");
          this._reset(), this._heap8.set(e);
          let t = this.parser.parse(e.byteLength);
          if (this._depth > 1) {
            for (; this._currentParent.length === 0;) this._closeParent();
            if (this._depth > 1) throw new Error("Undeterminated nesting")
          }
          if (t > 0) throw new Error("Failed to parse");
          if (this._res.length === 0) throw new Error("No valid result")
        }
        decodeFirst(e) {
          return this._decode(e), this._res[0]
        }
        decodeAll(e) {
          return this._decode(e), this._res
        }
        static decode(e, t) {
          return typeof e == "string" && (e = Qd.from(e, t || "hex")), new kl({
            size: e.length
          }).decodeFirst(e)
        }
        static decodeAll(e, t) {
          return typeof e == "string" && (e = Qd.from(e, t || "hex")), new kl({
            size: e.length
          }).decodeAll(e)
        }
      };
      kl.decodeFirst = kl.decode;
      ij.exports = kl
    });
    var aj = y((Ivt, sj) => {
      l();
      "use strict";
      var {
        Buffer: v8
      } = Cy(), dCe = m8(), pCe = Ev(), xv = class extends dCe {
        createTag(e, t) {
          return `${e}(${t})`
        }
        createInt(e) {
          return super.createInt(e).toString()
        }
        createInt32(e, t) {
          return super.createInt32(e, t).toString()
        }
        createInt64(e, t, i, n) {
          return super.createInt64(e, t, i, n).toString()
        }
        createInt32Neg(e, t) {
          return super.createInt32Neg(e, t).toString()
        }
        createInt64Neg(e, t, i, n) {
          return super.createInt64Neg(e, t, i, n).toString()
        }
        createTrue() {
          return "true"
        }
        createFalse() {
          return "false"
        }
        createFloat(e) {
          let t = super.createFloat(e);
          return pCe.isNegativeZero(e) ? "-0_1" : `${t}_1`
        }
        createFloatSingle(e, t, i, n) {
          return `${super.createFloatSingle(e, t, i, n)}_2`
        }
        createFloatDouble(e, t, i, n, s, o, a, c) {
          return `${super.createFloatDouble(e, t, i, n, s, o, a, c)}_3`
        }
        createByteString(e, t) {
          let i = e.join(", ");
          return t === -1 ? `(_ ${i})` : `h'${i}`
        }
        createByteStringFromHeap(e, t) {
          return `h'${v8.from(super.createByteStringFromHeap(e, t)).toString("hex")}'`
        }
        createInfinity() {
          return "Infinity_1"
        }
        createInfinityNeg() {
          return "-Infinity_1"
        }
        createNaN() {
          return "NaN_1"
        }
        createNaNNeg() {
          return "-NaN_1"
        }
        createNull() {
          return "null"
        }
        createUndefined() {
          return "undefined"
        }
        createSimpleUnassigned(e) {
          return `simple(${e})`
        }
        createArray(e, t) {
          let i = super.createArray(e, t);
          return t === -1 ? `[_ ${i.join(", ")}]` : `[${i.join(", ")}]`
        }
        createMap(e, t) {
          let i = super.createMap(e),
            n = Array.from(i.keys()).reduce(oj(i), "");
          return t === -1 ? `{_ ${n}}` : `{${n}}`
        }
        createObject(e, t) {
          let i = super.createObject(e),
            n = Object.keys(i).reduce(oj(i), "");
          return t === -1 ? `{_ ${n}}` : `{${n}}`
        }
        createUtf8String(e, t) {
          let i = e.join(", ");
          return t === -1 ? `(_ ${i})` : `"${i}"`
        }
        createUtf8StringFromHeap(e, t) {
          return `"${v8.from(super.createUtf8StringFromHeap(e, t)).toString("utf8")}"`
        }
        static diagnose(e, t) {
          return typeof e == "string" && (e = v8.from(e, t || "hex")), new xv().decodeFirst(e)
        }
      };
      sj.exports = xv;

      function oj(r) {
        return (e, t) => e ? `${e}, ${t}: ${r[t]}` : `${t}: ${r[t]}`
      }
    });
    var hj = y((Tvt, cj) => {
      l();
      "use strict";
      var {
        Buffer: rc
      } = Cy(), {
        URL: yCe
      } = b8(), w8 = tc().BigNumber, _8 = Ev(), Ti = Oy(), Xo = Ti.MT, Av = Ti.NUMBYTES, uj = Ti.SHIFT32, fj = Ti.SYMS, e0 = Ti.TAG, gCe = Ti.MT.SIMPLE_FLOAT << 5 | Ti.NUMBYTES.TWO, bCe = Ti.MT.SIMPLE_FLOAT << 5 | Ti.NUMBYTES.FOUR, mCe = Ti.MT.SIMPLE_FLOAT << 5 | Ti.NUMBYTES.EIGHT, vCe = Ti.MT.SIMPLE_FLOAT << 5 | Ti.SIMPLE.TRUE, wCe = Ti.MT.SIMPLE_FLOAT << 5 | Ti.SIMPLE.FALSE, _Ce = Ti.MT.SIMPLE_FLOAT << 5 | Ti.SIMPLE.UNDEFINED, lj = Ti.MT.SIMPLE_FLOAT << 5 | Ti.SIMPLE.NULL, ECe = new w8("0x20000000000000"), SCe = rc.from("f97e00", "hex"), xCe = rc.from("f9fc00", "hex"), ACe = rc.from("f97c00", "hex");

      function ICe(r) {
        return {}.toString.call(r).slice(8, -1)
      }
      var My = class {
        constructor(e) {
          e = e || {}, this.streaming = typeof e.stream == "function", this.onData = e.stream, this.semanticTypes = [
            [yCe, this._pushUrl],
            [w8, this._pushBigNumber]
          ];
          let t = e.genTypes || [],
            i = t.length;
          for (let n = 0; n < i; n++) this.addSemanticType(t[n][0], t[n][1]);
          this._reset()
        }
        addSemanticType(e, t) {
          let i = this.semanticTypes.length;
          for (let n = 0; n < i; n++)
            if (this.semanticTypes[n][0] === e) {
              let o = this.semanticTypes[n][1];
              return this.semanticTypes[n][1] = t, o
            } return this.semanticTypes.push([e, t]), null
        }
        push(e) {
          return e && (this.result[this.offset] = e, this.resultMethod[this.offset] = 0, this.resultLength[this.offset] = e.length, this.offset++, this.streaming && this.onData(this.finalize())), !0
        }
        pushWrite(e, t, i) {
          return this.result[this.offset] = e, this.resultMethod[this.offset] = t, this.resultLength[this.offset] = i, this.offset++, this.streaming && this.onData(this.finalize()), !0
        }
        _pushUInt8(e) {
          return this.pushWrite(e, 1, 1)
        }
        _pushUInt16BE(e) {
          return this.pushWrite(e, 2, 2)
        }
        _pushUInt32BE(e) {
          return this.pushWrite(e, 3, 4)
        }
        _pushDoubleBE(e) {
          return this.pushWrite(e, 4, 8)
        }
        _pushNaN() {
          return this.push(SCe)
        }
        _pushInfinity(e) {
          let t = e < 0 ? xCe : ACe;
          return this.push(t)
        }
        _pushFloat(e) {
          let t = rc.allocUnsafe(2);
          if (_8.writeHalf(t, e) && _8.parseHalf(t) === e) return this._pushUInt8(gCe) && this.push(t);
          let i = rc.allocUnsafe(4);
          return i.writeFloatBE(e, 0), i.readFloatBE(0) === e ? this._pushUInt8(bCe) && this.push(i) : this._pushUInt8(mCe) && this._pushDoubleBE(e)
        }
        _pushInt(e, t, i) {
          let n = t << 5;
          return e < 24 ? this._pushUInt8(n | e) : e <= 255 ? this._pushUInt8(n | Av.ONE) && this._pushUInt8(e) : e <= 65535 ? this._pushUInt8(n | Av.TWO) && this._pushUInt16BE(e) : e <= 4294967295 ? this._pushUInt8(n | Av.FOUR) && this._pushUInt32BE(e) : e <= Number.MAX_SAFE_INTEGER ? this._pushUInt8(n | Av.EIGHT) && this._pushUInt32BE(Math.floor(e / uj)) && this._pushUInt32BE(e % uj) : t === Xo.NEG_INT ? this._pushFloat(i) : this._pushFloat(e)
        }
        _pushIntNum(e) {
          return e < 0 ? this._pushInt(-e - 1, Xo.NEG_INT, e) : this._pushInt(e, Xo.POS_INT)
        }
        _pushNumber(e) {
          switch (!1) {
            case e === e:
              return this._pushNaN(e);
            case isFinite(e):
              return this._pushInfinity(e);
            case e % 1 != 0:
              return this._pushIntNum(e);
            default:
              return this._pushFloat(e)
          }
        }
        _pushString(e) {
          let t = rc.byteLength(e, "utf8");
          return this._pushInt(t, Xo.UTF8_STRING) && this.pushWrite(e, 5, t)
        }
        _pushBoolean(e) {
          return this._pushUInt8(e ? vCe : wCe)
        }
        _pushUndefined(e) {
          return this._pushUInt8(_Ce)
        }
        _pushArray(e, t) {
          let i = t.length;
          if (!e._pushInt(i, Xo.ARRAY)) return !1;
          for (let n = 0; n < i; n++)
            if (!e.pushAny(t[n])) return !1;
          return !0
        }
        _pushTag(e) {
          return this._pushInt(e, Xo.TAG)
        }
        _pushDate(e, t) {
          return e._pushTag(e0.DATE_EPOCH) && e.pushAny(Math.round(t / 1e3))
        }
        _pushBuffer(e, t) {
          return e._pushInt(t.length, Xo.BYTE_STRING) && e.push(t)
        }
        _pushNoFilter(e, t) {
          return e._pushBuffer(e, t.slice())
        }
        _pushRegexp(e, t) {
          return e._pushTag(e0.REGEXP) && e.pushAny(t.source)
        }
        _pushSet(e, t) {
          if (!e._pushInt(t.size, Xo.ARRAY)) return !1;
          for (let i of t)
            if (!e.pushAny(i)) return !1;
          return !0
        }
        _pushUrl(e, t) {
          return e._pushTag(e0.URI) && e.pushAny(t.format())
        }
        _pushBigint(e) {
          let t = e0.POS_BIGINT;
          e.isNegative() && (e = e.negated().minus(1), t = e0.NEG_BIGINT);
          let i = e.toString(16);
          i.length % 2 && (i = "0" + i);
          let n = rc.from(i, "hex");
          return this._pushTag(t) && this._pushBuffer(this, n)
        }
        _pushBigNumber(e, t) {
          if (t.isNaN()) return e._pushNaN();
          if (!t.isFinite()) return e._pushInfinity(t.isNegative() ? -Infinity : Infinity);
          if (t.isInteger()) return e._pushBigint(t);
          if (!(e._pushTag(e0.DECIMAL_FRAC) && e._pushInt(2, Xo.ARRAY))) return !1;
          let i = t.decimalPlaces(),
            n = t.multipliedBy(new w8(10).pow(i));
          return e._pushIntNum(-i) ? n.abs().isLessThan(ECe) ? e._pushIntNum(n.toNumber()) : e._pushBigint(n) : !1
        }
        _pushMap(e, t) {
          return e._pushInt(t.size, Xo.MAP) ? this._pushRawMap(t.size, Array.from(t)) : !1
        }
        _pushObject(e) {
          if (!e) return this._pushUInt8(lj);
          for (var t = this.semanticTypes.length, i = 0; i < t; i++)
            if (e instanceof this.semanticTypes[i][0]) return this.semanticTypes[i][1].call(e, this, e);
          var n = e.encodeCBOR;
          if (typeof n == "function") return n.call(e, this);
          var s = Object.keys(e),
            o = s.length;
          return this._pushInt(o, Xo.MAP) ? this._pushRawMap(o, s.map(a => [a, e[a]])) : !1
        }
        _pushRawMap(e, t) {
          t = t.map(function (n) {
            return n[0] = My.encode(n[0]), n
          }).sort(_8.keySorter);
          for (var i = 0; i < e; i++)
            if (!this.push(t[i][0]) || !this.pushAny(t[i][1])) return !1;
          return !0
        }
        write(e) {
          return this.pushAny(e)
        }
        pushAny(e) {
          var t = ICe(e);
          switch (t) {
            case "Number":
              return this._pushNumber(e);
            case "String":
              return this._pushString(e);
            case "Boolean":
              return this._pushBoolean(e);
            case "Object":
              return this._pushObject(e);
            case "Array":
              return this._pushArray(this, e);
            case "Uint8Array":
              return this._pushBuffer(this, rc.isBuffer(e) ? e : rc.from(e));
            case "Null":
              return this._pushUInt8(lj);
            case "Undefined":
              return this._pushUndefined(e);
            case "Map":
              return this._pushMap(this, e);
            case "Set":
              return this._pushSet(this, e);
            case "URL":
              return this._pushUrl(this, e);
            case "BigNumber":
              return this._pushBigNumber(this, e);
            case "Date":
              return this._pushDate(this, e);
            case "RegExp":
              return this._pushRegexp(this, e);
            case "Symbol":
              switch (e) {
                case fj.NULL:
                  return this._pushObject(null);
                case fj.UNDEFINED:
                  return this._pushUndefined(void 0);
                default:
                  throw new Error("Unknown symbol: " + e.toString())
              }
            default:
              throw new Error("Unknown type: " + typeof e + ", " + (e ? e.toString() : ""))
          }
        }
        finalize() {
          if (this.offset === 0) return null;
          for (var e = this.result, t = this.resultLength, i = this.resultMethod, n = this.offset, s = 0, o = 0; o < n; o++) s += t[o];
          var a = rc.allocUnsafe(s),
            c = 0,
            u = 0;
          for (o = 0; o < n; o++) {
            switch (u = t[o], i[o]) {
              case 0:
                e[o].copy(a, c);
                break;
              case 1:
                a.writeUInt8(e[o], c, !0);
                break;
              case 2:
                a.writeUInt16BE(e[o], c, !0);
                break;
              case 3:
                a.writeUInt32BE(e[o], c, !0);
                break;
              case 4:
                a.writeDoubleBE(e[o], c, !0);
                break;
              case 5:
                a.write(e[o], c, u, "utf8");
                break;
              default:
                throw new Error("unkown method")
            }
            c += u
          }
          var f = a;
          return this._reset(), f
        }
        _reset() {
          this.result = [], this.resultMethod = [], this.resultLength = [], this.offset = 0
        }
        static encode(e) {
          let t = new My;
          if (!t.pushAny(e)) throw new Error("Failed to encode input");
          return t.finalize()
        }
      };
      cj.exports = My
    });
    var dj = y(Ri => {
      l();
      "use strict";
      Ri.Diagnose = aj();
      Ri.Decoder = m8();
      Ri.Encoder = hj();
      Ri.Simple = d8();
      Ri.Tagged = p8();
      Ri.decodeAll = Ri.Decoder.decodeAll;
      Ri.decodeFirst = Ri.Decoder.decodeFirst;
      Ri.diagnose = Ri.Diagnose.diagnose;
      Ri.encode = Ri.Encoder.encode;
      Ri.decode = Ri.Decoder.decode;
      Ri.leveldb = {
        decode: Ri.Decoder.decodeAll,
        encode: Ri.Encoder.encode,
        buffer: !0,
        name: "cbor"
      }
    });
    var gj = y((kvt, pj) => {
      l();
      pj.exports = yj;

      function yj(r, e) {
        this.value = r, this.next = e
      }
      yj.prototype.contains = function (r) {
        for (var e = this; e;) {
          if (e.value === r) return !0;
          e = e.next
        }
        return !1
      }
    });
    var E8 = y((Pvt, bj) => {
      l();
      var TCe = gj();
      bj.exports = RCe;

      function RCe(r) {
        if (!(r instanceof Object)) throw new TypeError('"obj" must be an object (or inherit from it)');
        return mj(r)
      }

      function mj(r, e) {
        e = new TCe(r, e);
        for (var t in r) {
          var i = r[t];
          if (i instanceof Object && (e.contains(i) || mj(i, e))) return !0
        }
        return !1
      }
    });
    var T8 = y((Cvt, vj) => {
      l();
      "use strict";
      var S8 = dj(),
        x8 = Jr(),
        kCe = cr(),
        By = at(),
        PCe = E8(),
        CCe = xi(),
        OCe = gt(),
        wj = 42;

      function NCe(r) {
        return typeof r == "string" ? r = new By(r).bytes : By.isCID(r) && (r = r.bytes), new S8.Tagged(wj, CCe([OCe("00", "base16"), r], 1 + r.length))
      }

      function qCe(r) {
        let e;
        try {
          e = PCe(r)
        } catch (i) {
          e = !1
        }
        if (e) throw new Error("The object passed has circular references");

        function t(i) {
          if (!i || i instanceof Uint8Array || typeof i == "string") return i;
          if (Array.isArray(i)) return i.map(t);
          if (By.isCID(i)) return NCe(i);
          let n = Object.keys(i);
          if (n.length > 0) {
            let s = {};
            return n.forEach(o => {
              typeof i[o] == "object" ? s[o] = t(i[o]) : s[o] = i[o]
            }), s
          } else return i
        }
        return t(r)
      }
      var _j = x8.DAG_CBOR,
        Ej = x8.SHA2_256,
        Sj = {
          [wj]: r => (r = r.slice(1), new By(r))
        },
        xj = 64 * 1024,
        t0 = xj,
        Aj = 64 * 1024 * 1024,
        A8 = Aj,
        Ij = null;

      function I8(r) {
        let e = Sj;
        r ? (typeof r.size == "number" && (t0 = r.size), typeof r.maxSize == "number" && (A8 = r.maxSize), r.tags && (e = Object.assign({}, Sj, r && r.tags))) : (t0 = xj, A8 = Aj);
        let t = {
          tags: e,
          size: t0
        };
        Ij = new S8.Decoder(t), t0 = t.size
      }
      I8();

      function MCe(r) {
        let e = qCe(r);
        return S8.encode(e)
      }

      function BCe(r) {
        if (r.length > t0 && r.length <= A8 && I8({
          size: r.length
        }), r.length > t0) throw new Error("Data is too large to deserialize with current decoder");
        let e = Ij.decodeAll(r);
        if (e.length !== 1) throw new Error("Extraneous CBOR data found beyond initial top-level object");
        return e[0]
      }
      async function DCe(r, e) {
        let i = Object.assign({
          cidVersion: 1,
          hashAlg: Ej
        }, e),
          n = await kCe(r, i.hashAlg),
          s = x8.getNameFromCode(_j);
        return new By(i.cidVersion, s, n)
      }
      vj.exports = {
        codec: _j,
        defaultHashAlg: Ej,
        configureDecoder: I8,
        serialize: MCe,
        deserialize: BCe,
        cid: DCe
      }
    });
    var Pj = y(R8 => {
      l();
      "use strict";
      var Tj = at(),
        Rj = T8();
      R8.resolve = (r, e) => {
        let t = Rj.deserialize(r),
          i = e.split("/").filter(Boolean);
        for (; i.length;) {
          let n = i.shift();
          if (t[n] === void 0) throw new Error(`Object has no property '${n}'`);
          if (t = t[n], Tj.isCID(t)) return {
            value: t,
            remainderPath: i.join("/")
          }
        }
        return {
          value: t,
          remainderPath: ""
        }
      };
      var kj = function* (r, e) {
        if (!(r instanceof Uint8Array || Tj.isCID(r) || typeof r == "string" || r === null))
          for (let t of Object.keys(r)) {
            let i = e === void 0 ? t : e + "/" + t;
            yield i, yield* kj(r[t], i)
          }
      };
      R8.tree = function* (r) {
        let e = Rj.deserialize(r);
        yield* kj(e)
      }
    });
    var Cj = y(Pl => {
      l();
      "use strict";
      Pl.util = T8();
      Pl.resolver = Pj();
      Pl.codec = Pl.util.codec;
      Pl.defaultHashAlg = Pl.util.defaultHashAlg
    });
    var qj = y((qvt, Oj) => {
      l();
      var LCe = Cj().util,
        Nj = at(),
        k8 = (r, e = [], t = !0) => (t && Buffer.isBuffer(r) && (r = LCe.deserialize(r)), function* () {
          for (let i of Object.keys(r)) {
            let n = e.slice();
            n.push(i);
            let s = r[i];
            if (s && typeof s == "object")
              if (Array.isArray(s))
                for (let o = 0; o < s.length; o++) {
                  let a = n.slice();
                  a.push(o);
                  let c = s[o];
                  Nj.isCID(c) ? yield [a.join("/"), c] : typeof c == "object" && (yield* k8(c, n, !1))
                } else Nj.isCID(s) ? yield [n.join("/"), s] : yield* k8(s, n, !1)
          }
        }());
      Oj.exports = k8
    });
    var r0 = y((Mvt, Mj) => {
      l();
      "use strict";
      var FCe = async r => {
        for await (let e of r) return e
      };
      Mj.exports = FCe
    });

    function Bj(r) {
      if (r === null) return "null";
      if (r === void 0) return "undefined";
      if (r === !0 || r === !1) return "boolean";
      let e = typeof r;
      if (UCe.includes(e)) return e;
      if (e === "function") return "Function";
      if (Array.isArray(r)) return "Array";
      if (zCe(r)) return "Buffer";
      let t = jCe(r);
      return t || "Object"
    }

    function zCe(r) {
      return r && r.constructor && r.constructor.isBuffer && r.constructor.isBuffer.call(null, r)
    }

    function jCe(r) {
      let e = Object.prototype.toString.call(r).slice(8, -1);
      if (KCe.includes(e)) return e
    }
    var UCe, KCe, Dj = gi(() => {
      l();
      UCe = ["string", "number", "bigint", "symbol"], KCe = ["Function", "Generator", "AsyncGenerator", "GeneratorFunction", "AsyncGeneratorFunction", "AsyncFunction", "Observable", "Array", "Buffer", "Object", "RegExp", "Date", "Error", "Map", "Set", "WeakMap", "WeakSet", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Promise", "URL", "HTMLElement", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array"]
    });
    var Ae, it, Os = gi(() => {
      l();
      Ae = class {
        constructor(e, t, i) {
          this.major = e, this.majorEncoded = e << 5, this.name = t, this.terminal = i
        }
        toString() {
          return `Type[${this.major}].${this.name}`
        }
        compare(e) {
          return this.major < e.major ? -1 : this.major > e.major ? 1 : 0
        }
      };
      Ae.uint = new Ae(0, "uint", !0);
      Ae.negint = new Ae(1, "negint", !0);
      Ae.bytes = new Ae(2, "bytes", !0);
      Ae.string = new Ae(3, "string", !0);
      Ae.array = new Ae(4, "array", !1);
      Ae.map = new Ae(5, "map", !1);
      Ae.tag = new Ae(6, "tag", !1);
      Ae.float = new Ae(7, "float", !0);
      Ae.false = new Ae(7, "false", !0);
      Ae.true = new Ae(7, "true", !0);
      Ae.null = new Ae(7, "null", !0);
      Ae.undefined = new Ae(7, "undefined", !0);
      Ae.break = new Ae(7, "break", !0);
      it = class {
        constructor(e, t, i) {
          this.type = e, this.value = t, this.encodedLength = i, this.encodedBytes = void 0
        }
        toString() {
          return `Token[${this.type}].${this.value}`
        }
      }
    });

    function Iv(r) {
      return i0 && globalThis.Buffer.isBuffer(r)
    }

    function P8(r) {
      return r instanceof Uint8Array ? Iv(r) ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r : Uint8Array.from(r)
    }

    function Vj(r, e) {
      if (Iv(r) && Iv(e)) return r.compare(e);
      for (let t = 0; t < r.length; t++)
        if (r[t] !== e[t]) return r[t] < e[t] ? -1 : 1;
      return 0
    }

    function Uj(r, e = Infinity) {
      let t, i = r.length,
        n = null,
        s = [];
      for (let o = 0; o < i; ++o) {
        if (t = r.charCodeAt(o), t > 55295 && t < 57344) {
          if (!n) {
            if (t > 56319) {
              (e -= 3) > -1 && s.push(239, 191, 189);
              continue
            } else if (o + 1 === i) {
              (e -= 3) > -1 && s.push(239, 191, 189);
              continue
            }
            n = t;
            continue
          }
          if (t < 56320) {
            (e -= 3) > -1 && s.push(239, 191, 189), n = t;
            continue
          }
          t = (n - 55296 << 10 | t - 56320) + 65536
        } else n && (e -= 3) > -1 && s.push(239, 191, 189);
        if (n = null, t < 128) {
          if ((e -= 1) < 0) break;
          s.push(t)
        } else if (t < 2048) {
          if ((e -= 2) < 0) break;
          s.push(t >> 6 | 192, t & 63 | 128)
        } else if (t < 65536) {
          if ((e -= 3) < 0) break;
          s.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128)
        } else if (t < 1114112) {
          if ((e -= 4) < 0) break;
          s.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128)
        } else throw new Error("Invalid code point")
      }
      return s
    }

    function Lj(r, e, t) {
      let i = [];
      for (; e < t;) {
        let n = r[e],
          s = null,
          o = n > 239 ? 4 : n > 223 ? 3 : n > 191 ? 2 : 1;
        if (e + o <= t) {
          let a, c, u, f;
          switch (o) {
            case 1:
              n < 128 && (s = n);
              break;
            case 2:
              a = r[e + 1], (a & 192) == 128 && (f = (n & 31) << 6 | a & 63, f > 127 && (s = f));
              break;
            case 3:
              a = r[e + 1], c = r[e + 2], (a & 192) == 128 && (c & 192) == 128 && (f = (n & 15) << 12 | (a & 63) << 6 | c & 63, f > 2047 && (f < 55296 || f > 57343) && (s = f));
              break;
            case 4:
              a = r[e + 1], c = r[e + 2], u = r[e + 3], (a & 192) == 128 && (c & 192) == 128 && (u & 192) == 128 && (f = (n & 15) << 18 | (a & 63) << 12 | (c & 63) << 6 | u & 63, f > 65535 && f < 1114112 && (s = f))
          }
        }
        s === null ? (s = 65533, o = 1) : s > 65535 && (s -= 65536, i.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), i.push(s), e += o
      }
      return GCe(i)
    }

    function GCe(r) {
      let e = r.length;
      if (e <= Hj) return String.fromCharCode.apply(String, r);
      let t = "",
        i = 0;
      for (; i < e;) t += String.fromCharCode.apply(String, r.slice(i, i += Hj));
      return t
    }
    var i0, VCe, HCe, Fj, Kj, ic, Tv, zj, jj, Hj, n0 = gi(() => {
      l();
      i0 = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer == "function", VCe = new TextDecoder, HCe = new TextEncoder;
      Fj = i0 ? (r, e, t) => t - e > 64 ? globalThis.Buffer.from(r.subarray(e, t)).toString("utf8") : Lj(r, e, t) : (r, e, t) => t - e > 64 ? VCe.decode(r.subarray(e, t)) : Lj(r, e, t), Kj = i0 ? r => r.length > 64 ? globalThis.Buffer.from(r) : Uj(r) : r => r.length > 64 ? HCe.encode(r) : Uj(r), ic = r => Uint8Array.from(r), Tv = i0 ? (r, e, t) => Iv(r) ? new Uint8Array(r.subarray(e, t)) : r.slice(e, t) : (r, e, t) => r.slice(e, t), zj = i0 ? (r, e) => (r = r.map(t => t instanceof Uint8Array ? t : globalThis.Buffer.from(t)), P8(globalThis.Buffer.concat(r, e))) : (r, e) => {
        let t = new Uint8Array(e),
          i = 0;
        for (let n of r) i + n.length > t.length && (n = n.subarray(0, t.length - i)), t.set(n, i), i += n.length;
        return t
      }, jj = i0 ? r => globalThis.Buffer.allocUnsafe(r) : r => new Uint8Array(r);
      Hj = 4096
    });
    var $Ce, Rv, Gj = gi(() => {
      l();
      n0();
      $Ce = 256, Rv = class {
        constructor(e = $Ce) {
          this.chunkSize = e, this.cursor = 0, this.maxCursor = -1, this.chunks = [], this._initReuseChunk = null
        }
        reset() {
          this.chunks = [], this.cursor = 0, this.maxCursor = -1, this._initReuseChunk !== null && (this.chunks.push(this._initReuseChunk), this.maxCursor = this._initReuseChunk.length - 1)
        }
        push(e) {
          let t = this.chunks[this.chunks.length - 1];
          if (this.cursor + e.length <= this.maxCursor + 1) {
            let n = t.length - (this.maxCursor - this.cursor) - 1;
            t.set(e, n)
          } else {
            if (t) {
              let n = t.length - (this.maxCursor - this.cursor) - 1;
              n < t.length && (this.chunks[this.chunks.length - 1] = t.subarray(0, n), this.maxCursor = this.cursor - 1)
            }
            e.length < 64 && e.length < this.chunkSize ? (t = jj(this.chunkSize), this.chunks.push(t), this.maxCursor += t.length, this._initReuseChunk === null && (this._initReuseChunk = t), t.set(e, 0)) : (this.chunks.push(e), this.maxCursor += e.length)
          }
          this.cursor += e.length
        }
        toBytes(e = !1) {
          let t;
          if (this.chunks.length === 1) {
            let i = this.chunks[0];
            e && this.cursor > i.length / 2 ? (t = this.cursor === i.length ? i : i.subarray(0, this.cursor), this._initReuseChunk = null, this.chunks = []) : t = Tv(i, 0, this.cursor)
          } else t = zj(this.chunks, this.cursor);
          return e && this.reset(), t
        }
      }
    });

    function Jc(r, e, t) {
      if (r.length - e < t) throw new Error(`${mt} not enough data for type`)
    }
    var mt, C8, Dy, Zo = gi(() => {
      l();
      mt = "CBOR decode error:", C8 = "CBOR encode error:", Dy = [];
      Dy[23] = 1;
      Dy[24] = 2;
      Dy[25] = 3;
      Dy[26] = 5;
      Dy[27] = 9
    });

    function Ns(r, e, t) {
      Jc(r, e, 1);
      let i = r[e];
      if (t.strict === !0 && i < Qi[0]) throw new Error(`${mt} integer encoded in more bytes than necessary (strict decode)`);
      return i
    }

    function qs(r, e, t) {
      Jc(r, e, 2);
      let i = r[e] << 8 | r[e + 1];
      if (t.strict === !0 && i < Qi[1]) throw new Error(`${mt} integer encoded in more bytes than necessary (strict decode)`);
      return i
    }

    function Ms(r, e, t) {
      Jc(r, e, 4);
      let i = r[e] * 16777216 + (r[e + 1] << 16) + (r[e + 2] << 8) + r[e + 3];
      if (t.strict === !0 && i < Qi[2]) throw new Error(`${mt} integer encoded in more bytes than necessary (strict decode)`);
      return i
    }

    function Bs(r, e, t) {
      Jc(r, e, 8);
      let i = r[e] * 16777216 + (r[e + 1] << 16) + (r[e + 2] << 8) + r[e + 3],
        n = r[e + 4] * 16777216 + (r[e + 5] << 16) + (r[e + 6] << 8) + r[e + 7],
        s = (BigInt(i) << BigInt(32)) + BigInt(n);
      if (t.strict === !0 && s < Qi[3]) throw new Error(`${mt} integer encoded in more bytes than necessary (strict decode)`);
      if (s <= Number.MAX_SAFE_INTEGER) return Number(s);
      if (t.allowBigInt === !0) return s;
      throw new Error(`${mt} integers outside of the safe integer range are not supported`)
    }

    function $j(r, e, t, i) {
      return new it(Ae.uint, Ns(r, e + 1, i), 2)
    }

    function Wj(r, e, t, i) {
      return new it(Ae.uint, qs(r, e + 1, i), 3)
    }

    function Yj(r, e, t, i) {
      return new it(Ae.uint, Ms(r, e + 1, i), 5)
    }

    function Jj(r, e, t, i) {
      return new it(Ae.uint, Bs(r, e + 1, i), 9)
    }

    function fo(r, e) {
      return ms(r, 0, e.value)
    }

    function ms(r, e, t) {
      if (t < Qi[0]) {
        let i = Number(t);
        r.push([e | i])
      } else if (t < Qi[1]) {
        let i = Number(t);
        r.push([e | 24, i])
      } else if (t < Qi[2]) {
        let i = Number(t);
        r.push([e | 25, i >>> 8, i & 255])
      } else if (t < Qi[3]) {
        let i = Number(t);
        r.push([e | 26, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, i & 255])
      } else {
        let i = BigInt(t);
        if (i < Qi[4]) {
          let n = [e | 27, 0, 0, 0, 0, 0, 0, 0],
            s = Number(i & BigInt(4294967295)),
            o = Number(i >> BigInt(32) & BigInt(4294967295));
          n[8] = s & 255, s = s >> 8, n[7] = s & 255, s = s >> 8, n[6] = s & 255, s = s >> 8, n[5] = s & 255, n[4] = o & 255, o = o >> 8, n[3] = o & 255, o = o >> 8, n[2] = o & 255, o = o >> 8, n[1] = o & 255, r.push(n)
        } else throw new Error(`${mt} encountered BigInt larger than allowable range`)
      }
    }
    var Qi, nc = gi(() => {
      l();
      Os();
      Zo();
      Qi = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
      fo.encodedSize = function (e) {
        return ms.encodedSize(e.value)
      };
      ms.encodedSize = function (e) {
        return e < Qi[0] ? 1 : e < Qi[1] ? 2 : e < Qi[2] ? 3 : e < Qi[3] ? 5 : 9
      };
      fo.compareTokens = function (e, t) {
        return e.value < t.value ? -1 : e.value > t.value ? 1 : 0
      }
    });

    function Xj(r, e, t, i) {
      return new it(Ae.negint, -1 - Ns(r, e + 1, i), 2)
    }

    function Zj(r, e, t, i) {
      return new it(Ae.negint, -1 - qs(r, e + 1, i), 3)
    }

    function Qj(r, e, t, i) {
      return new it(Ae.negint, -1 - Ms(r, e + 1, i), 5)
    }

    function tV(r, e, t, i) {
      let n = Bs(r, e + 1, i);
      if (typeof n != "bigint") {
        let s = -1 - n;
        if (s >= Number.MIN_SAFE_INTEGER) return new it(Ae.negint, s, 9)
      }
      if (i.allowBigInt !== !0) throw new Error(`${mt} integers outside of the safe integer range are not supported`);
      return new it(Ae.negint, O8 - BigInt(n), 9)
    }

    function kv(r, e) {
      let t = e.value,
        i = typeof t == "bigint" ? t * O8 - eV : t * -1 - 1;
      ms(r, e.type.majorEncoded, i)
    }
    var O8, eV, N8 = gi(() => {
      l();
      Os();
      nc();
      Zo();
      O8 = BigInt(-1), eV = BigInt(1);
      kv.encodedSize = function (e) {
        let t = e.value,
          i = typeof t == "bigint" ? t * O8 - eV : t * -1 - 1;
        return i < Qi[0] ? 1 : i < Qi[1] ? 2 : i < Qi[2] ? 3 : i < Qi[3] ? 5 : 9
      };
      kv.compareTokens = function (e, t) {
        return e.value < t.value ? 1 : e.value > t.value ? -1 : 0
      }
    });

    function Ly(r, e, t, i) {
      Jc(r, e, t + i);
      let n = Tv(r, e + t, e + t + i);
      return new it(Ae.bytes, n, t + i)
    }

    function rV(r, e, t, i) {
      return Ly(r, e, 1, t)
    }

    function iV(r, e, t, i) {
      return Ly(r, e, 2, Ns(r, e + 1, i))
    }

    function nV(r, e, t, i) {
      return Ly(r, e, 3, qs(r, e + 1, i))
    }

    function sV(r, e, t, i) {
      return Ly(r, e, 5, Ms(r, e + 1, i))
    }

    function oV(r, e, t, i) {
      let n = Bs(r, e + 1, i);
      if (typeof n == "bigint") throw new Error(`${mt} 64-bit integer bytes lengths not supported`);
      return Ly(r, e, 9, n)
    }

    function Pv(r) {
      return r.encodedBytes === void 0 && (r.encodedBytes = r.type === Ae.string ? Kj(r.value) : r.value), r.encodedBytes
    }

    function s0(r, e) {
      let t = Pv(e);
      ms(r, e.type.majorEncoded, t.length), r.push(t)
    }

    function WCe(r, e) {
      return r.length < e.length ? -1 : r.length > e.length ? 1 : Vj(r, e)
    }
    var Cv = gi(() => {
      l();
      Os();
      Zo();
      nc();
      n0();
      s0.encodedSize = function (e) {
        let t = Pv(e);
        return ms.encodedSize(t.length) + t.length
      };
      s0.compareTokens = function (e, t) {
        return WCe(Pv(e), Pv(t))
      }
    });

    function Fy(r, e, t, i) {
      let n = t + i;
      return Jc(r, e, n), new it(Ae.string, Fj(r, e + t, e + n), n)
    }

    function aV(r, e, t, i) {
      return Fy(r, e, 1, t)
    }

    function cV(r, e, t, i) {
      return Fy(r, e, 2, Ns(r, e + 1, i))
    }

    function uV(r, e, t, i) {
      return Fy(r, e, 3, qs(r, e + 1, i))
    }

    function fV(r, e, t, i) {
      return Fy(r, e, 5, Ms(r, e + 1, i))
    }

    function lV(r, e, t, i) {
      let n = Bs(r, e + 1, i);
      if (typeof n == "bigint") throw new Error(`${mt} 64-bit integer string lengths not supported`);
      return Fy(r, e, 9, n)
    }
    var hV, q8 = gi(() => {
      l();
      Os();
      Zo();
      nc();
      Cv();
      n0();
      hV = s0
    });

    function o0(r, e, t, i) {
      return new it(Ae.array, i, t)
    }

    function dV(r, e, t, i) {
      return o0(r, e, 1, t)
    }

    function pV(r, e, t, i) {
      return o0(r, e, 2, Ns(r, e + 1, i))
    }

    function yV(r, e, t, i) {
      return o0(r, e, 3, qs(r, e + 1, i))
    }

    function gV(r, e, t, i) {
      return o0(r, e, 5, Ms(r, e + 1, i))
    }

    function bV(r, e, t, i) {
      let n = Bs(r, e + 1, i);
      if (typeof n == "bigint") throw new Error(`${mt} 64-bit integer array lengths not supported`);
      return o0(r, e, 9, n)
    }

    function mV(r, e, t, i) {
      if (i.allowIndefinite === !1) throw new Error(`${mt} indefinite length items not allowed`);
      return o0(r, e, 1, Infinity)
    }

    function M8(r, e) {
      ms(r, Ae.array.majorEncoded, e.value)
    }
    var B8 = gi(() => {
      l();
      Os();
      nc();
      Zo();
      M8.compareTokens = fo.compareTokens
    });

    function a0(r, e, t, i) {
      return new it(Ae.map, i, t)
    }

    function vV(r, e, t, i) {
      return a0(r, e, 1, t)
    }

    function wV(r, e, t, i) {
      return a0(r, e, 2, Ns(r, e + 1, i))
    }

    function _V(r, e, t, i) {
      return a0(r, e, 3, qs(r, e + 1, i))
    }

    function EV(r, e, t, i) {
      return a0(r, e, 5, Ms(r, e + 1, i))
    }

    function SV(r, e, t, i) {
      let n = Bs(r, e + 1, i);
      if (typeof n == "bigint") throw new Error(`${mt} 64-bit integer map lengths not supported`);
      return a0(r, e, 9, n)
    }

    function xV(r, e, t, i) {
      if (i.allowIndefinite === !1) throw new Error(`${mt} indefinite length items not allowed`);
      return a0(r, e, 1, Infinity)
    }

    function D8(r, e) {
      ms(r, Ae.map.majorEncoded, e.value)
    }
    var L8 = gi(() => {
      l();
      Os();
      nc();
      Zo();
      D8.compareTokens = fo.compareTokens
    });

    function AV(r, e, t, i) {
      return new it(Ae.tag, t, 1)
    }

    function IV(r, e, t, i) {
      return new it(Ae.tag, Ns(r, e + 1, i), 2)
    }

    function TV(r, e, t, i) {
      return new it(Ae.tag, qs(r, e + 1, i), 3)
    }

    function RV(r, e, t, i) {
      return new it(Ae.tag, Ms(r, e + 1, i), 5)
    }

    function kV(r, e, t, i) {
      return new it(Ae.tag, Bs(r, e + 1, i), 9)
    }

    function F8(r, e) {
      ms(r, Ae.tag.majorEncoded, e.value)
    }
    var U8 = gi(() => {
      l();
      Os();
      nc();
      F8.compareTokens = fo.compareTokens
    });

    function PV(r, e, t, i) {
      if (i.allowUndefined === !1) throw new Error(`${mt} undefined values are not supported`);
      return new it(Ae.undefined, void 0, 1)
    }

    function CV(r, e, t, i) {
      if (i.allowIndefinite === !1) throw new Error(`${mt} indefinite length items not allowed`);
      return new it(Ae.break, void 0, 1)
    }

    function K8(r, e, t) {
      if (t) {
        if (t.allowNaN === !1 && Number.isNaN(r)) throw new Error(`${mt} NaN values are not supported`);
        if (t.allowInfinity === !1 && (r === Infinity || r === -Infinity)) throw new Error(`${mt} Infinity values are not supported`)
      }
      return new it(Ae.float, r, e)
    }

    function OV(r, e, t, i) {
      return K8(z8(r, e + 1), 3, i)
    }

    function NV(r, e, t, i) {
      return K8(j8(r, e + 1), 5, i)
    }

    function MV(r, e, t, i) {
      return K8(qV(r, e + 1), 9, i)
    }

    function Ov(r, e, t) {
      let i = e.value;
      if (i === !1) r.push([Ae.float.majorEncoded | YCe]);
      else if (i === !0) r.push([Ae.float.majorEncoded | JCe]);
      else if (i === null) r.push([Ae.float.majorEncoded | XCe]);
      else if (i === void 0) r.push([Ae.float.majorEncoded | ZCe]);
      else {
        let n, s = !1;
        (!t || t.float64 !== !0) && (BV(i), n = z8(Qo, 1), i === n || Number.isNaN(i) ? (Qo[0] = 249, r.push(Qo.slice(0, 3)), s = !0) : (DV(i), n = j8(Qo, 1), i === n && (Qo[0] = 250, r.push(Qo.slice(0, 5)), s = !0))), s || (QCe(i), n = qV(Qo, 1), Qo[0] = 251, r.push(Qo.slice(0, 9)))
      }
    }

    function BV(r) {
      if (r === Infinity) lo.setUint16(0, 31744, !1);
      else if (r === -Infinity) lo.setUint16(0, 64512, !1);
      else if (Number.isNaN(r)) lo.setUint16(0, 32256, !1);
      else {
        lo.setFloat32(0, r);
        let e = lo.getUint32(0),
          t = (e & 2139095040) >> 23,
          i = e & 8388607;
        if (t === 255) lo.setUint16(0, 31744, !1);
        else if (t === 0) lo.setUint16(0, (r & 2147483648) >> 16 | i >> 13, !1);
        else {
          let n = t - 127;
          n < -24 ? lo.setUint16(0, 0) : n < -14 ? lo.setUint16(0, (e & 2147483648) >> 16 | 1 << 24 + n, !1) : lo.setUint16(0, (e & 2147483648) >> 16 | n + 15 << 10 | i >> 13, !1)
        }
      }
    }

    function z8(r, e) {
      if (r.length - e < 2) throw new Error(`${mt} not enough data for float16`);
      let t = (r[e] << 8) + r[e + 1];
      if (t === 31744) return Infinity;
      if (t === 64512) return -Infinity;
      if (t === 32256) return NaN;
      let i = t >> 10 & 31,
        n = t & 1023,
        s;
      return i === 0 ? s = n * 2 ** -24 : i !== 31 ? s = (n + 1024) * 2 ** (i - 25) : s = n === 0 ? Infinity : NaN, t & 32768 ? -s : s
    }

    function DV(r) {
      lo.setFloat32(0, r, !1)
    }

    function j8(r, e) {
      if (r.length - e < 4) throw new Error(`${mt} not enough data for float32`);
      let t = (r.byteOffset || 0) + e;
      return new DataView(r.buffer, t, 4).getFloat32(0, !1)
    }

    function QCe(r) {
      lo.setFloat64(0, r, !1)
    }

    function qV(r, e) {
      if (r.length - e < 8) throw new Error(`${mt} not enough data for float64`);
      let t = (r.byteOffset || 0) + e;
      return new DataView(r.buffer, t, 8).getFloat64(0, !1)
    }
    var YCe, JCe, XCe, ZCe, LV, lo, Qo, V8 = gi(() => {
      l();
      Os();
      Zo();
      nc();
      YCe = 20, JCe = 21, XCe = 22, ZCe = 23;
      Ov.encodedSize = function (e, t) {
        let i = e.value;
        if (i === !1 || i === !0 || i === null || i === void 0) return 1;
        let n;
        if (!t || t.float64 !== !0) {
          if (BV(i), n = z8(Qo, 1), i === n || Number.isNaN(i)) return 3;
          if (DV(i), n = j8(Qo, 1), i === n) return 5
        }
        return 9
      };
      LV = new ArrayBuffer(9), lo = new DataView(LV, 1), Qo = new Uint8Array(LV, 0);
      Ov.compareTokens = fo.compareTokens
    });

    function rr(r, e, t) {
      throw new Error(`${mt} encountered invalid minor (${t}) for major ${r[e] >>> 5}`)
    }

    function Nv(r) {
      return () => {
        throw new Error(`${mt} ${r}`)
      }
    }

    function FV(r) {
      switch (r.type) {
        case Ae.false:
          return ic([244]);
        case Ae.true:
          return ic([245]);
        case Ae.null:
          return ic([246]);
        case Ae.bytes:
          return r.value.length ? void 0 : ic([64]);
        case Ae.string:
          return r.value === "" ? ic([96]) : void 0;
        case Ae.array:
          return r.value === 0 ? ic([128]) : void 0;
        case Ae.map:
          return r.value === 0 ? ic([160]) : void 0;
        case Ae.uint:
          return r.value < 24 ? ic([Number(r.value)]) : void 0;
        case Ae.negint:
          if (r.value >= -24) return ic([31 - Number(r.value)])
      }
    }
    var je, ea, H8 = gi(() => {
      l();
      Os();
      nc();
      N8();
      Cv();
      q8();
      B8();
      L8();
      U8();
      V8();
      Zo();
      n0();
      je = [];
      for (let r = 0; r <= 23; r++) je[r] = rr;
      je[24] = $j;
      je[25] = Wj;
      je[26] = Yj;
      je[27] = Jj;
      je[28] = rr;
      je[29] = rr;
      je[30] = rr;
      je[31] = rr;
      for (let r = 32; r <= 55; r++) je[r] = rr;
      je[56] = Xj;
      je[57] = Zj;
      je[58] = Qj;
      je[59] = tV;
      je[60] = rr;
      je[61] = rr;
      je[62] = rr;
      je[63] = rr;
      for (let r = 64; r <= 87; r++) je[r] = rV;
      je[88] = iV;
      je[89] = nV;
      je[90] = sV;
      je[91] = oV;
      je[92] = rr;
      je[93] = rr;
      je[94] = rr;
      je[95] = Nv("indefinite length bytes/strings are not supported");
      for (let r = 96; r <= 119; r++) je[r] = aV;
      je[120] = cV;
      je[121] = uV;
      je[122] = fV;
      je[123] = lV;
      je[124] = rr;
      je[125] = rr;
      je[126] = rr;
      je[127] = Nv("indefinite length bytes/strings are not supported");
      for (let r = 128; r <= 151; r++) je[r] = dV;
      je[152] = pV;
      je[153] = yV;
      je[154] = gV;
      je[155] = bV;
      je[156] = rr;
      je[157] = rr;
      je[158] = rr;
      je[159] = mV;
      for (let r = 160; r <= 183; r++) je[r] = vV;
      je[184] = wV;
      je[185] = _V;
      je[186] = EV;
      je[187] = SV;
      je[188] = rr;
      je[189] = rr;
      je[190] = rr;
      je[191] = xV;
      for (let r = 192; r <= 215; r++) je[r] = AV;
      je[216] = IV;
      je[217] = TV;
      je[218] = RV;
      je[219] = kV;
      je[220] = rr;
      je[221] = rr;
      je[222] = rr;
      je[223] = rr;
      for (let r = 224; r <= 243; r++) je[r] = Nv("simple values are not supported");
      je[244] = rr;
      je[245] = rr;
      je[246] = rr;
      je[247] = PV;
      je[248] = Nv("simple values are not supported");
      je[249] = OV;
      je[250] = NV;
      je[251] = MV;
      je[252] = rr;
      je[253] = rr;
      je[254] = rr;
      je[255] = CV;
      ea = [];
      for (let r = 0; r < 24; r++) ea[r] = new it(Ae.uint, r, 1);
      for (let r = -1; r >= -24; r--) ea[31 - r] = new it(Ae.negint, r, 1);
      ea[64] = new it(Ae.bytes, new Uint8Array(0), 1);
      ea[96] = new it(Ae.string, "", 1);
      ea[128] = new it(Ae.array, 0, 1);
      ea[160] = new it(Ae.map, 0, 1);
      ea[244] = new it(Ae.false, !1, 1);
      ea[245] = new it(Ae.true, !0, 1);
      ea[246] = new it(Ae.null, null, 1)
    });

    function qv(r, e = {}, t) {
      let i = Bj(r),
        n = e && e.typeEncoders && e.typeEncoders[i] || cf[i];
      if (typeof n == "function") {
        let o = n(r, i, e, t);
        if (o != null) return o
      }
      let s = cf[i];
      if (!s) throw new Error(`${C8} unsupported type: ${i}`);
      return s(r, i, e, t)
    }

    function rOe(r, e) {
      e.mapSorter && r.sort(e.mapSorter)
    }

    function eOe(r, e) {
      let t = Array.isArray(r[0]) ? r[0][0] : r[0],
        i = Array.isArray(e[0]) ? e[0][0] : e[0];
      if (t.type !== i.type) return t.type.compare(i.type);
      let n = t.type.major,
        s = sc[n].compareTokens(t, i);
      return s === 0 && console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"), s
    }

    function KV(r, e, t, i) {
      if (Array.isArray(e))
        for (let n of e) KV(r, n, t, i);
      else t[e.type.major](r, e, i)
    }

    function iOe(r, e, t) {
      let i = qv(r, t);
      if (!Array.isArray(i) && t.quickEncodeToken) {
        let n = t.quickEncodeToken(i);
        if (n) return n;
        let s = e[i.type.major];
        if (s.encodedSize) {
          let o = s.encodedSize(i, t),
            a = new Rv(o);
          if (s(a, i, t), a.chunks.length !== 1) throw new Error(`Unexpected error: pre-calculated length for ${i} was wrong`);
          return P8(a.chunks[0])
        }
      }
      return KV(UV, i, e, t), UV.toBytes(!0)
    }

    function zV(r, e) {
      return e = Object.assign({}, tOe, e), iOe(r, sc, e)
    }
    var tOe, sc, UV, Uy, af, cf, jV = gi(() => {
      l();
      Dj();
      Os();
      Gj();
      Zo();
      H8();
      n0();
      nc();
      N8();
      Cv();
      q8();
      B8();
      L8();
      U8();
      V8();
      tOe = {
        float64: !1,
        mapSorter: eOe,
        quickEncodeToken: FV
      }, sc = [];
      sc[Ae.uint.major] = fo;
      sc[Ae.negint.major] = kv;
      sc[Ae.bytes.major] = s0;
      sc[Ae.string.major] = hV;
      sc[Ae.array.major] = M8;
      sc[Ae.map.major] = D8;
      sc[Ae.tag.major] = F8;
      sc[Ae.float.major] = Ov;
      UV = new Rv, Uy = class {
        constructor(e, t) {
          this.obj = e, this.parent = t
        }
        includes(e) {
          let t = this;
          do
            if (t.obj === e) return !0; while (t = t.parent);
          return !1
        }
        static createCheck(e, t) {
          if (e && e.includes(t)) throw new Error(`${C8} object contains circular references`);
          return new Uy(t, e)
        }
      }, af = {
        null: new it(Ae.null, null),
        undefined: new it(Ae.undefined, void 0),
        true: new it(Ae.true, !0),
        false: new it(Ae.false, !1),
        emptyArray: new it(Ae.array, 0),
        emptyMap: new it(Ae.map, 0)
      }, cf = {
        number(r, e, t, i) {
          return !Number.isInteger(r) || !Number.isSafeInteger(r) ? new it(Ae.float, r) : r >= 0 ? new it(Ae.uint, r) : new it(Ae.negint, r)
        },
        bigint(r, e, t, i) {
          return r >= BigInt(0) ? new it(Ae.uint, r) : new it(Ae.negint, r)
        },
        Uint8Array(r, e, t, i) {
          return new it(Ae.bytes, r)
        },
        string(r, e, t, i) {
          return new it(Ae.string, r)
        },
        boolean(r, e, t, i) {
          return r ? af.true : af.false
        },
        null(r, e, t, i) {
          return af.null
        },
        undefined(r, e, t, i) {
          return af.undefined
        },
        ArrayBuffer(r, e, t, i) {
          return new it(Ae.bytes, new Uint8Array(r))
        },
        DataView(r, e, t, i) {
          return new it(Ae.bytes, new Uint8Array(r.buffer, r.byteOffset, r.byteLength))
        },
        Array(r, e, t, i) {
          if (!r.length) return t.addBreakTokens === !0 ? [af.emptyArray, new it(Ae.break)] : af.emptyArray;
          i = Uy.createCheck(i, r);
          let n = [],
            s = 0;
          for (let o of r) n[s++] = qv(o, t, i);
          return t.addBreakTokens ? [new it(Ae.array, r.length), n, new it(Ae.break)] : [new it(Ae.array, r.length), n]
        },
        Object(r, e, t, i) {
          let n = e !== "Object",
            s = n ? r.keys() : Object.keys(r),
            o = n ? r.size : s.length;
          if (!o) return t.addBreakTokens === !0 ? [af.emptyMap, new it(Ae.break)] : af.emptyMap;
          i = Uy.createCheck(i, r);
          let a = [],
            c = 0;
          for (let u of s) a[c++] = [qv(u, t, i), qv(n ? r.get(u) : r[u], t, i)];
          return rOe(a, t), t.addBreakTokens ? [new it(Ae.map, o), a, new it(Ae.break)] : [new it(Ae.map, o), a]
        }
      };
      cf.Map = cf.Object;
      cf.Buffer = cf.Uint8Array;
      for (let r of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) cf[`${r}Array`] = cf.DataView
    });

    function sOe(r, e, t) {
      let i = [];
      for (let n = 0; n < r.value; n++) {
        let s = zy(e, t);
        if (s === Mv) {
          if (r.value === Infinity) break;
          throw new Error(`${mt} got unexpected break to lengthed array`)
        }
        if (s === Ky) throw new Error(`${mt} found array but not enough entries (got ${n}, expected ${r.value})`);
        i[n] = s
      }
      return i
    }

    function oOe(r, e, t) {
      let i = t.useMaps === !0,
        n = i ? void 0 : {},
        s = i ? new Map : void 0;
      for (let o = 0; o < r.value; o++) {
        let a = zy(e, t);
        if (a === Mv) {
          if (r.value === Infinity) break;
          throw new Error(`${mt} got unexpected break to lengthed map`)
        }
        if (a === Ky) throw new Error(`${mt} found map but not enough entries (got ${o} [no key], expected ${r.value})`);
        if (i !== !0 && typeof a != "string") throw new Error(`${mt} non-string keys not supported (got ${typeof a})`);
        let c = zy(e, t);
        if (c === Ky) throw new Error(`${mt} found map but not enough entries (got ${o} [no value], expected ${r.value})`);
        i ? s.set(a, c) : n[a] = c
      }
      return i ? s : n
    }

    function zy(r, e) {
      if (r.done()) return Ky;
      let t = r.next();
      if (t.type === Ae.break) return Mv;
      if (t.type.terminal) return t.value;
      if (t.type === Ae.array) return sOe(t, r, e);
      if (t.type === Ae.map) return oOe(t, r, e);
      if (t.type === Ae.tag) {
        if (e.tags && typeof e.tags[t.value] == "function") {
          let i = zy(r, e);
          return e.tags[t.value](i)
        }
        throw new Error(`${mt} tag not supported (${t.value})`)
      }
      throw new Error("unsupported")
    }

    function HV(r, e) {
      if (!(r instanceof Uint8Array)) throw new Error(`${mt} data to decode must be a Uint8Array`);
      e = Object.assign({}, nOe, e);
      let t = e.tokenizer || new VV(r, e),
        i = zy(t, e);
      if (i === Ky) throw new Error(`${mt} did not find any content to decode`);
      if (i === Mv) throw new Error(`${mt} got unexpected break`);
      if (!t.done()) throw new Error(`${mt} too many terminals, data makes no sense`);
      return i
    }
    var nOe, VV, Ky, Mv, GV = gi(() => {
      l();
      Zo();
      Os();
      H8();
      nOe = {
        strict: !1,
        allowIndefinite: !0,
        allowUndefined: !0,
        allowBigInt: !0
      }, VV = class {
        constructor(e, t = {}) {
          this.pos = 0, this.data = e, this.options = t
        }
        done() {
          return this.pos >= this.data.length
        }
        next() {
          let e = this.data[this.pos],
            t = ea[e];
          if (t === void 0) {
            let i = je[e];
            if (!i) throw new Error(`${mt} no decoder for major type ${e >>> 5} (byte 0x${e.toString(16).padStart(2, "0")})`);
            let n = e & 31;
            t = i(this.data, this.pos, n, this.options)
          }
          return this.pos += t.encodedLength, t
        }
      }, Ky = Symbol.for("DONE"), Mv = Symbol.for("BREAK")
    });
    var G8 = {};
    vP(G8, {
      Token: () => it,
      Type: () => Ae,
      decode: () => HV,
      encode: () => zV
    });
    var $8 = gi(() => {
      l();
      jV();
      GV();
      Os()
    });
    var c0 = y((t3t, $V) => {
      l();
      "use strict";
      var WV = at(),
        aOe = xe(),
        cOe = qj(),
        uOe = Oe(),
        YV = r0(),
        fOe = vy(),
        uf = ($8(), G8),
        lOe = ln(),
        Bv = Jr(),
        {
          Key: hOe
        } = fr();

      function dOe(r) {
        let e = `Invalid type '${r}', must be one of {direct, indirect, recursive, all}`;
        return aOe(new Error(e), "ERR_INVALID_PIN_TYPE")
      }
      var JV = lOe.encoding("base32upper");

      function Dv(r) {
        return new hOe(`/${JV.encode(r.multihash)}`)
      }

      function XV(r) {
        return JV.decode(r.toString().slice(1))
      }
      var ho = {
        direct: "direct",
        recursive: "recursive",
        indirect: "indirect",
        all: "all"
      },
        W8 = class {
          constructor({
            repo: e,
            ipld: t
          }) {
            this.repo = e, this.ipld = t, this.log = uOe("ipfs:pin"), this.directPins = new Set, this.recursivePins = new Set
          }
          async *_walkDag(e, t) {
            let i = await this.ipld.get(e, t);
            if (e.codec === "dag-pb")
              for (let n of i.Links) yield n.Hash, yield* this._walkDag(n.Hash, t);
            else if (e.codec === "dag-cbor")
              for (let [, n] of cOe(i)) yield n, yield* this._walkDag(n, t)
          }
          async pinDirectly(e, t = {}) {
            await this.ipld.get(e, t);
            let i = {
              depth: 0
            };
            return e.version !== 0 && (i.version = e.version), e.codec !== "dag-pb" && (i.codec = Bv.getNumber(e.codec)), t.metadata && (i.metadata = t.metadata), this.repo.pins.put(Dv(e), uf.encode(i))
          }
          async unpin(e, t) {
            return this.repo.pins.delete(Dv(e))
          }
          async pinRecursively(e, t = {}) {
            await this.fetchCompleteDag(e, t);
            let i = {
              depth: Infinity
            };
            e.version !== 0 && (i.version = e.version), e.codec !== "dag-pb" && (i.codec = Bv.getNumber(e.codec)), t.metadata && (i.metadata = t.metadata), await this.repo.pins.put(Dv(e), uf.encode(i))
          }
          async *directKeys(e) {
            for await (let t of this.repo.pins.query({
              filters: [i => uf.decode(i.value).depth === 0]
            })) {
              let i = uf.decode(t.value),
                n = i.version || 0,
                s = i.codec ? Bv.getName(i.codec) : "dag-pb",
                o = XV(t.key);
              yield {
                cid: new WV(n, s, o),
                metadata: i.metadata
              }
            }
          }
          async *recursiveKeys(e) {
            for await (let t of this.repo.pins.query({
              filters: [i => uf.decode(i.value).depth === Infinity]
            })) {
              let i = uf.decode(t.value),
                n = i.version || 0,
                s = i.codec ? Bv.getName(i.codec) : "dag-pb",
                o = XV(t.key);
              yield {
                cid: new WV(n, s, o),
                metadata: i.metadata
              }
            }
          }
          async *indirectKeys(e) {
            for await (let {
              cid: t
            } of this.recursiveKeys()) for await (let i of this._walkDag(t, e)) {
              let n = [ho.recursive];
              (await this.isPinnedWithType(i, n)).pinned || (yield i)
            }
          }
          async isPinnedWithType(e, t, i) {
            Array.isArray(t) || (t = [t]);
            let n = t.includes(ho.all),
              s = t.includes(ho.direct),
              o = t.includes(ho.recursive),
              a = t.includes(ho.indirect);
            if (o || s || n) {
              let f = await YV(this.repo.pins.query({
                prefix: Dv(e).toString(),
                filters: [h => {
                  if (n) return !0;
                  let d = uf.decode(h.value);
                  return t.includes(d.depth === 0 ? ho.direct : ho.recursive)
                }],
                limit: 1
              }));
              if (f) {
                let h = uf.decode(f.value);
                return {
                  cid: e,
                  pinned: !0,
                  reason: h.depth === 0 ? ho.direct : ho.recursive,
                  metadata: h.metadata
                }
              }
            }
            let c = this;
            async function* u(f, h) {
              for await (let {
                cid: d
              } of h) for await (let p of c._walkDag(d)) if (p.equals(f)) {
                yield d;
                return
              }
            }
            if (n || a) {
              let f = await YV(u(e, this.recursiveKeys()));
              if (f) return {
                cid: e,
                pinned: !0,
                reason: ho.indirect,
                parent: f
              }
            }
            return {
              cid: e,
              pinned: !1
            }
          }
          async fetchCompleteDag(e, t) {
            await fOe(this._walkDag(e, t))
          }
          static checkPinType(e) {
            if (typeof e != "string" || !Object.keys(ho).includes(e)) throw dOe(e);
            return !0
          }
        };
      W8.PinTypes = ho;
      $V.exports = W8
    });
    var Lv = y((r3t, ZV) => {
      l();
      "use strict";
      var jy = xe(),
        Y8 = at();
      ZV.exports = async function* (e) {
        if (e == null) throw jy(new Error(`Unexpected input: ${e}`), "ERR_UNEXPECTED_INPUT");
        if (Y8.isCID(e)) {
          yield ta({
            cid: e
          });
          return
        }
        if (e instanceof String || typeof e == "string") {
          yield ta({
            path: e
          });
          return
        }
        if (e.cid != null || e.path != null) return yield ta(e);
        if (Symbol.iterator in e) {
          let t = e[Symbol.iterator](),
            i = t.next();
          if (i.done) return t;
          if (Y8.isCID(i.value) || i.value instanceof String || typeof i.value == "string") {
            yield ta({
              cid: i.value
            });
            for (let n of t) yield ta({
              cid: n
            });
            return
          }
          if (i.value.cid != null || i.value.path != null) {
            yield ta(i.value);
            for (let n of t) yield ta(n);
            return
          }
          throw jy(new Error("Unexpected input: " + typeof e), "ERR_UNEXPECTED_INPUT")
        }
        if (Symbol.asyncIterator in e) {
          let t = e[Symbol.asyncIterator](),
            i = await t.next();
          if (i.done) return t;
          if (Y8.isCID(i.value) || i.value instanceof String || typeof i.value == "string") {
            yield ta({
              cid: i.value
            });
            for await (let n of t) yield ta({
              cid: n
            });
            return
          }
          if (i.value.cid != null || i.value.path != null) {
            yield ta(i.value);
            for await (let n of t) yield ta(n);
            return
          }
          throw jy(new Error("Unexpected input: " + typeof e), "ERR_UNEXPECTED_INPUT")
        }
        throw jy(new Error("Unexpected input: " + typeof e), "ERR_UNEXPECTED_INPUT")
      };

      function ta(r) {
        let e = r.cid || `${r.path}`;
        if (!e) throw jy(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
        let t = {
          path: e,
          recursive: r.recursive !== !1
        };
        return r.metadata != null && (t.metadata = r.metadata), t
      }
    });
    var tH = y((i3t, QV) => {
      l();
      "use strict";
      var {
        resolvePath: pOe
      } = Ji(), yOe = c0(), {
        PinTypes: eH
      } = yOe, gOe = ze(), bOe = Lv();
      QV.exports = ({
        pinManager: r,
        gcLock: e,
        ipld: t
      }) => {
        async function* i(n, s = {}) {
          let o = async function* () {
            for await (let {
              path: u,
              recursive: f,
              metadata: h
            } of bOe(n)) {
              let d = await pOe(t, u),
                {
                  reason: p
                } = await r.isPinnedWithType(d, [eH.recursive, eH.direct]);
              if (p === "recursive" && !f) throw new Error(`${d} already pinned recursively`);
              f ? await r.pinRecursively(d, {
                metadata: h
              }) : await r.pinDirectly(d, {
                metadata: h
              }), yield d
            }
          };
          if (!Boolean(s.lock)) {
            yield* o();
            return
          }
          let c = await e.readLock();
          try {
            yield* o()
          } finally {
            c()
          }
        }
        return gOe(i)
      }
    });
    var nH = y((n3t, rH) => {
      l();
      "use strict";
      var iH = c0(),
        {
          PinTypes: Ds
        } = iH,
        mOe = Lv(),
        {
          resolvePath: vOe
        } = Ji(),
        wOe = ze();

      function Vy(r, e, t) {
        let i = {
          type: r,
          cid: e
        };
        return t && (i.metadata = t), i
      }
      rH.exports = ({
        pinManager: r,
        ipld: e
      }) => {
        async function* t(i = {}) {
          let n = Ds.all;
          if (i.type && (n = i.type, iH.checkPinType(n)), i.paths) {
            let s = !1;
            for await (let {
              path: o
            } of mOe(i.paths)) {
              let a = await vOe(e, o),
                {
                  reason: c,
                  pinned: u,
                  parent: f,
                  metadata: h
                } = await r.isPinnedWithType(a, n);
              if (!u) throw new Error(`path '${o}' is not pinned`);
              switch (c) {
                case Ds.direct:
                case Ds.recursive:
                  s = !0, yield Vy(c, a, h);
                  break;
                default:
                  s = !0, yield Vy(`${Ds.indirect} through ${f}`, a, h)
              }
            }
            if (!s) throw new Error("No match found");
            return
          }
          if (n === Ds.recursive || n === Ds.all)
            for await (let {
              cid: s,
              metadata: o
            } of r.recursiveKeys()) yield Vy(Ds.recursive, s, o);
          if (n === Ds.indirect || n === Ds.all)
            for await (let s of r.indirectKeys(i)) yield Vy(Ds.indirect, s);
          if (n === Ds.direct || n === Ds.all)
            for await (let {
              cid: s,
              metadata: o
            } of r.directKeys()) yield Vy(Ds.direct, s, o)
        }
        return wOe(t)
      }
    });
    var oH = y((s3t, sH) => {
      l();
      "use strict";
      var _Oe = Qa();
      sH.exports = ({
        rmAll: r
      }) => (e, t = {}) => _Oe(r([{
        path: e,
        ...t
      }], t))
    });
    var cH = y((o3t, aH) => {
      l();
      "use strict";
      var EOe = Lv(),
        {
          resolvePath: SOe
        } = Ji(),
        xOe = ze(),
        {
          PinTypes: J8
        } = c0();
      aH.exports = ({
        pinManager: r,
        gcLock: e,
        ipld: t
      }) => {
        async function* i(n, s = {}) {
          let o = await e.readLock();
          try {
            for await (let {
              path: a,
              recursive: c
            } of EOe(n)) {
              let u = await SOe(t, a),
                {
                  pinned: f,
                  reason: h
                } = await r.isPinnedWithType(u, J8.all);
              if (!f) throw new Error(`${u} is not pinned`);
              switch (h) {
                case J8.recursive:
                  if (!c) throw new Error(`${u} is pinned recursively`);
                  await r.unpin(u), yield u;
                  break;
                case J8.direct:
                  await r.unpin(u), yield u;
                  break;
                default:
                  throw new Error(`${u} is pinned indirectly under ${h}`)
              }
            }
          } finally {
            o()
          }
        }
        return xOe(i)
      }
    });
    var lH = y((a3t, uH) => {
      l();
      "use strict";
      var AOe = kz(),
        IOe = tH(),
        TOe = nH(),
        ROe = oH(),
        kOe = cH(),
        fH = class {
          constructor({
            gcLock: e,
            ipld: t,
            pinManager: i
          }) {
            let n = IOe({
              gcLock: e,
              ipld: t,
              pinManager: i
            });
            this.addAll = n, this.add = AOe({
              addAll: n
            });
            let s = kOe({
              gcLock: e,
              ipld: t,
              pinManager: i
            });
            this.rmAll = s, this.rm = ROe({
              rmAll: s
            }), this.ls = TOe({
              ipld: t,
              pinManager: i
            }), this.remote = {
              add: (o, a = {}) => Promise.reject(new Error("Not implemented")),
              ls: async function* (o, a = {}) {
                return Promise.reject(new Error("Not implemented"))
              },
              rm: (o, a = {}) => Promise.reject(new Error("Not implemented")),
              rmAll: (o, a = {}) => Promise.reject(new Error("Not implemented")),
              service: {
                add: (o, a) => Promise.reject(new Error("Not implemented")),
                rm: (o, a = {}) => Promise.reject(new Error("Not implemented")),
                ls: (o = {}) => Promise.reject(new Error("Not implemented"))
              }
            }
          }
        };
      uH.exports = fH
    });
    var hH = y((u3t, X8) => {
      l();
      var c3t = function () {
        typeof X8 != "undefined" && (X8.exports = w);
        var r = 24 * 3600,
          e = 3200,
          t = (365 * 400 + 97) * e / 400,
          i = r * t,
          n = i * 1e3,
          s = 1e3 * 1e4 * 1e4 * r,
          o = 16777216,
          a = 65536 * 65536,
          c = 1e3 * 1e3,
          u = 1e3 * 1e3 * 1e3,
          f = "000000000",
          h = Math.trunc || V,
          d = w.prototype;
        w.fromDate = oe, w.fromInt64BE = ee(0, 1, 2, 3, 0, 4), w.fromInt64LE = ee(3, 2, 1, 0, 4, 0), w.fromString = ae, w.fromTimeT = U, d.year = 0, d.time = 0, d.nano = 0, d.addNano = H, d.getNano = te, d.getTimeT = _, d.getYear = O, d.toDate = J, d.toJSON = R, d.toString = D, d.writeInt64BE = K(0, 1, 2, 3, 0, 4), d.writeInt64LE = K(3, 2, 1, 0, 4, 0);
        var p = "%Y-%m-%dT%H:%M:%S.%NZ",
          g = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          m = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          E = {
            "%": "%",
            F: "%Y-%m-%d",
            n: `
`,
            R: "%H:%M",
            T: "%H:%M:%S",
            t: "	",
            X: "%T",
            Z: "GMT",
            z: "+0000"
          };
        return w;

        function w(Q, ve, x) {
          var I = this;
          if (!(I instanceof w)) return new w(Q, ve, x);
          I.time = +Q || 0, I.nano = +ve || 0, I.year = +x || 0, q(I)
        }

        function O() {
          var Q = this.toDate().getUTCFullYear();
          return Q + this.year
        }

        function q(Q) {
          var ve = Q.year,
            x = Q.time,
            I = Q.nano,
            le, he;
          if (I < 0 || c <= I) {
            var S = Math.floor(I / c);
            I -= S * c, x += S, le = 1
          }
          var T = ve % e;
          if (x < -s || s < x || T) {
            he = h(x / n), he && (ve += he * e, x -= he * n);
            var j = Z(x);
            j.setUTCFullYear(T + j.getUTCFullYear()), ve -= T, x = +j, he = h(ve / e);
            var G = x + he * n;
            he && -s <= G && G <= s && (ve -= he * e, x = G), le = 1
          }
          return le && (Q.year = ve, Q.time = x, Q.nano = I), Q
        }

        function J() {
          var Q = q(this);
          return Z(Q.time)
        }

        function Z(Q) {
          var ve = new Date(0);
          return ve.setTime(Q), ve
        }

        function H(Q) {
          return this.nano += +Q || 0, this
        }

        function te() {
          var Q = q(this);
          return (Q.time % 1e3 * c + +Q.nano + u) % u
        }

        function ae(Q) {
          var ve, x = new w;
          Q += "";
          var I = Q.replace(/^\s*[+\-]?\d+/, function (le) {
            var he = +le,
              S = 1970 + (he - 1970) % 400;
            return x.year = he - S, S
          }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function (le, he, S) {
            return he < 0 && (S *= -1), ve = (+he * 60 + +S) * 6e4, ""
          }).replace(/\.\d+$/, function (le) {
            return x.nano = +(le + f).substr(1, 9), ""
          }).split(/\D+/);
          if (I.length > 1 ? I[1]-- : I[1] = 0, x.time = ve = Date.UTC.apply(Date, I) - (ve || 0), isNaN(ve)) throw new TypeError("Invalid Date");
          return q(x)
        }

        function oe(Q) {
          return new w(+Q)
        }

        function U(Q) {
          return b(Q, 0)
        }

        function b(Q, ve) {
          ve |= 0, ve *= a, Q = +Q || 0;
          var x = h(ve / i) + h(Q / i),
            I = ve % i + Q % i,
            le = h(I / i);
          return le && (x += le, I -= le * i), new w(I * 1e3, 0, x * e)
        }

        function _() {
          var Q = q(this),
            ve = Math.floor(Q.time / 1e3),
            x = Q.year;
          return x && (ve += x * t * r / e), ve
        }

        function R() {
          return this.toString().replace(/0{1,6}Z$/, "Z")
        }

        function D(Q) {
          var ve = this,
            x = ve.toDate(),
            I = {
              H: G,
              L: B,
              M: k,
              N: L,
              S: F,
              Y: he,
              a: $,
              b: ie,
              d: T,
              e: j,
              m: S
            };
          return le(Q || p);

          function le(ne) {
            return ne.replace(/%./g, function (pe) {
              var be = pe[1],
                de = E[be],
                Ne = I[be];
              return de ? le(de) : Ne ? Ne() : pe
            })
          }

          function he() {
            var ne = ve.getYear();
            return ne > 999999 ? "+" + ne : ne > 9999 ? "+" + Se(ne, 6) : ne >= 0 ? Se(ne, 4) : ne >= -999999 ? "-" + Se(-ne, 6) : ne
          }

          function S() {
            return Y(x.getUTCMonth() + 1)
          }

          function T() {
            return Y(x.getUTCDate())
          }

          function j() {
            return v(x.getUTCDate())
          }

          function G() {
            return Y(x.getUTCHours())
          }

          function k() {
            return Y(x.getUTCMinutes())
          }

          function F() {
            return Y(x.getUTCSeconds())
          }

          function B() {
            return Se(x.getUTCMilliseconds(), 3)
          }

          function L() {
            return Se(ve.getNano(), 9)
          }

          function $() {
            return m[x.getUTCDay()]
          }

          function ie() {
            return g[x.getUTCMonth()]
          }
        }

        function K(Q, ve, x, I, le, he) {
          return S;

          function S(j, G) {
            var k = q(this);
            j || (j = new Array(8)), re(j, G |= 0);
            var F = Math.floor(k.time / 1e3),
              B = k.year * (t * r / e),
              L = h(B / a) + h(F / a),
              $ = B % a + F % a,
              ie = Math.floor($ / a);
            return ie && (L += ie, $ -= ie * a), T(j, G + le, L), T(j, G + he, $), j
          }

          function T(j, G, k) {
            j[G + Q] = k >> 24 & 255, j[G + ve] = k >> 16 & 255, j[G + x] = k >> 8 & 255, j[G + I] = k & 255
          }
        }

        function ee(Q, ve, x, I, le, he) {
          return S;

          function S(j, G) {
            re(j, G |= 0);
            var k = T(j, G + le),
              F = T(j, G + he);
            return b(F, k)
          }

          function T(j, G) {
            return j[G + Q] * o + (j[G + ve] << 16 | j[G + x] << 8 | j[G + I])
          }
        }

        function re(Q, ve) {
          var x = Q && Q.length;
          if (x == null) throw new TypeError("Invalid Buffer");
          if (x < ve + 8) throw new RangeError("Out of range")
        }

        function V(Q) {
          var ve = Q - Q % 1;
          return ve === 0 && (Q < 0 || Q === 0 && 1 / Q != 1 / 0) ? -0 : ve
        }

        function v(Q) {
          return (Q > 9 ? "" : " ") + (Q | 0)
        }

        function Y(Q) {
          return (Q > 9 ? "" : "0") + (Q | 0)
        }

        function Se(Q, ve) {
          return (f + (Q | 0)).substr(-ve)
        }
      }()
    });
    var yH = y((f3t, dH) => {
      l();
      "use strict";
      var u0 = bi(),
        pH = u0.Reader,
        POe = u0.Writer,
        vt = u0.util,
        f0 = u0.roots["ipfs-ipns"] || (u0.roots["ipfs-ipns"] = {});
      f0.IpnsEntry = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.value = vt.newBuffer([]), r.prototype.signature = vt.newBuffer([]), r.prototype.validityType = 0, r.prototype.validity = vt.newBuffer([]), r.prototype.sequence = vt.Long ? vt.Long.fromBits(0, 0, !0) : 0, r.prototype.ttl = vt.Long ? vt.Long.fromBits(0, 0, !0) : 0, r.prototype.pubKey = vt.newBuffer([]), r.encode = function (t, i) {
          return i || (i = POe.create()), i.uint32(10).bytes(t.value), i.uint32(18).bytes(t.signature), t.validityType != null && Object.hasOwnProperty.call(t, "validityType") && i.uint32(24).int32(t.validityType), t.validity != null && Object.hasOwnProperty.call(t, "validity") && i.uint32(34).bytes(t.validity), t.sequence != null && Object.hasOwnProperty.call(t, "sequence") && i.uint32(40).uint64(t.sequence), t.ttl != null && Object.hasOwnProperty.call(t, "ttl") && i.uint32(48).uint64(t.ttl), t.pubKey != null && Object.hasOwnProperty.call(t, "pubKey") && i.uint32(58).bytes(t.pubKey), i
        }, r.decode = function (t, i) {
          t instanceof pH || (t = pH.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new f0.IpnsEntry; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.value = t.bytes();
                break;
              case 2:
                s.signature = t.bytes();
                break;
              case 3:
                s.validityType = t.int32();
                break;
              case 4:
                s.validity = t.bytes();
                break;
              case 5:
                s.sequence = t.uint64();
                break;
              case 6:
                s.ttl = t.uint64();
                break;
              case 7:
                s.pubKey = t.bytes();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          if (!s.hasOwnProperty("value")) throw vt.ProtocolError("missing required 'value'", {
            instance: s
          });
          if (!s.hasOwnProperty("signature")) throw vt.ProtocolError("missing required 'signature'", {
            instance: s
          });
          return s
        }, r.fromObject = function (t) {
          if (t instanceof f0.IpnsEntry) return t;
          var i = new f0.IpnsEntry;
          switch (t.value != null && (typeof t.value == "string" ? vt.base64.decode(t.value, i.value = vt.newBuffer(vt.base64.length(t.value)), 0) : t.value.length && (i.value = t.value)), t.signature != null && (typeof t.signature == "string" ? vt.base64.decode(t.signature, i.signature = vt.newBuffer(vt.base64.length(t.signature)), 0) : t.signature.length && (i.signature = t.signature)), t.validityType) {
            case "EOL":
            case 0:
              i.validityType = 0;
              break
          }
          return t.validity != null && (typeof t.validity == "string" ? vt.base64.decode(t.validity, i.validity = vt.newBuffer(vt.base64.length(t.validity)), 0) : t.validity.length && (i.validity = t.validity)), t.sequence != null && (vt.Long ? (i.sequence = vt.Long.fromValue(t.sequence)).unsigned = !0 : typeof t.sequence == "string" ? i.sequence = parseInt(t.sequence, 10) : typeof t.sequence == "number" ? i.sequence = t.sequence : typeof t.sequence == "object" && (i.sequence = new vt.LongBits(t.sequence.low >>> 0, t.sequence.high >>> 0).toNumber(!0))), t.ttl != null && (vt.Long ? (i.ttl = vt.Long.fromValue(t.ttl)).unsigned = !0 : typeof t.ttl == "string" ? i.ttl = parseInt(t.ttl, 10) : typeof t.ttl == "number" ? i.ttl = t.ttl : typeof t.ttl == "object" && (i.ttl = new vt.LongBits(t.ttl.low >>> 0, t.ttl.high >>> 0).toNumber(!0))), t.pubKey != null && (typeof t.pubKey == "string" ? vt.base64.decode(t.pubKey, i.pubKey = vt.newBuffer(vt.base64.length(t.pubKey)), 0) : t.pubKey.length && (i.pubKey = t.pubKey)), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if (i.defaults) {
            if (i.bytes === String ? n.value = "" : (n.value = [], i.bytes !== Array && (n.value = vt.newBuffer(n.value))), i.bytes === String ? n.signature = "" : (n.signature = [], i.bytes !== Array && (n.signature = vt.newBuffer(n.signature))), n.validityType = i.enums === String ? "EOL" : 0, i.bytes === String ? n.validity = "" : (n.validity = [], i.bytes !== Array && (n.validity = vt.newBuffer(n.validity))), vt.Long) {
              var s = new vt.Long(0, 0, !0);
              n.sequence = i.longs === String ? s.toString() : i.longs === Number ? s.toNumber() : s
            } else n.sequence = i.longs === String ? "0" : 0;
            if (vt.Long) {
              var s = new vt.Long(0, 0, !0);
              n.ttl = i.longs === String ? s.toString() : i.longs === Number ? s.toNumber() : s
            } else n.ttl = i.longs === String ? "0" : 0;
            i.bytes === String ? n.pubKey = "" : (n.pubKey = [], i.bytes !== Array && (n.pubKey = vt.newBuffer(n.pubKey)))
          }
          return t.value != null && t.hasOwnProperty("value") && (n.value = i.bytes === String ? vt.base64.encode(t.value, 0, t.value.length) : i.bytes === Array ? Array.prototype.slice.call(t.value) : t.value), t.signature != null && t.hasOwnProperty("signature") && (n.signature = i.bytes === String ? vt.base64.encode(t.signature, 0, t.signature.length) : i.bytes === Array ? Array.prototype.slice.call(t.signature) : t.signature), t.validityType != null && t.hasOwnProperty("validityType") && (n.validityType = i.enums === String ? f0.IpnsEntry.ValidityType[t.validityType] : t.validityType), t.validity != null && t.hasOwnProperty("validity") && (n.validity = i.bytes === String ? vt.base64.encode(t.validity, 0, t.validity.length) : i.bytes === Array ? Array.prototype.slice.call(t.validity) : t.validity), t.sequence != null && t.hasOwnProperty("sequence") && (typeof t.sequence == "number" ? n.sequence = i.longs === String ? String(t.sequence) : t.sequence : n.sequence = i.longs === String ? vt.Long.prototype.toString.call(t.sequence) : i.longs === Number ? new vt.LongBits(t.sequence.low >>> 0, t.sequence.high >>> 0).toNumber(!0) : t.sequence), t.ttl != null && t.hasOwnProperty("ttl") && (typeof t.ttl == "number" ? n.ttl = i.longs === String ? String(t.ttl) : t.ttl : n.ttl = i.longs === String ? vt.Long.prototype.toString.call(t.ttl) : i.longs === Number ? new vt.LongBits(t.ttl.low >>> 0, t.ttl.high >>> 0).toNumber(!0) : t.ttl), t.pubKey != null && t.hasOwnProperty("pubKey") && (n.pubKey = i.bytes === String ? vt.base64.encode(t.pubKey, 0, t.pubKey.length) : i.bytes === Array ? Array.prototype.slice.call(t.pubKey) : t.pubKey), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, u0.util.toJSONOptions)
        }, r.ValidityType = function () {
          var e = {},
            t = Object.create(e);
          return t[e[0] = "EOL"] = 0, t
        }(), r
      }();
      dH.exports = f0
    });
    var gH = y((l3t, Z8) => {
      l();
      "use strict";
      Z8.exports.toRFC3339 = r => {
        let e = r.getUTCFullYear(),
          t = String(r.getUTCMonth() + 1).padStart(2, "0"),
          i = String(r.getUTCDate()).padStart(2, "0"),
          n = String(r.getUTCHours()).padStart(2, "0"),
          s = String(r.getUTCMinutes()).padStart(2, "0"),
          o = String(r.getUTCSeconds()).padStart(2, "0"),
          c = r.getUTCMilliseconds() * 1e3 * 1e3;
        return `${e}-${t}-${i}T${n}:${s}:${o}.${c}Z`
      };
      Z8.exports.parseRFC3339 = r => {
        let e = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"),
          t = String(r).trim().match(e);
        if (!t) throw new Error("Invalid format");
        let i = parseInt(t[1], 10),
          n = parseInt(t[2], 10) - 1,
          s = parseInt(t[3], 10),
          o = parseInt(t[4], 10),
          a = parseInt(t[5], 10),
          c = parseInt(t[6], 10),
          u = parseInt(t[7].slice(0, -6), 10);
        return new Date(Date.UTC(i, n, s, o, a, c, u))
      }
    });
    var bH = y(Xc => {
      l();
      "use strict";
      Xc.ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
      Xc.ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
      Xc.ERR_SIGNATURE_CREATION = "ERR_SIGNATURE_CREATION";
      Xc.ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
      Xc.ERR_UNRECOGNIZED_FORMAT = "ERR_UNRECOGNIZED_FORMAT";
      Xc.ERR_PEER_ID_FROM_PUBLIC_KEY = "ERR_PEER_ID_FROM_PUBLIC_KEY";
      Xc.ERR_PUBLIC_KEY_FROM_ID = "ERR_PUBLIC_KEY_FROM_ID";
      Xc.ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER"
    });
    var h0 = y((d3t, mH) => {
      l();
      "use strict";
      var COe = hH(),
        {
          Key: Hy
        } = fr(),
        Q8 = Ja(),
        vH = Et(),
        wH = Do(),
        oc = xe(),
        OOe = ln(),
        Gy = gt(),
        _H = ct(),
        $y = xi(),
        EH = Oe(),
        Ls = Object.assign(EH("jsipns"), {
          error: EH("jsipns:error")
        }),
        {
          IpnsEntry: l0
        } = yH(),
        {
          parseRFC3339: NOe
        } = gH(),
        ra = bH(),
        qOe = wH.names.identity,
        SH = "/ipns/",
        MOe = (r, e, t, i) => {
          let n = new COe(Date.now() + Number(i)).toString(),
            s = l0.ValidityType.EOL;
          return xH(r, e, t, Gy(n), s)
        },
        BOe = (r, e, t, i) => {
          let n = l0.ValidityType.EOL;
          return xH(r, e, t, Gy(i), n)
        },
        xH = async (r, e, t, i, n) => {
          let s = await DOe(r, e, n, i),
            o = {
              value: e,
              signature: s,
              validityType: n,
              validity: i,
              sequence: t
            };
          return Ls(`ipns entry for ${e} created`), o
        }, IH = async (r, e) => {
          let {
            value: t,
            validityType: i,
            validity: n
          } = e, s = AH(t, i, n), o;
          try {
            o = await r.verify(s, e.signature)
          } catch (a) {
            o = !1
          }
          if (!o) throw Ls.error("record signature verification failed"), oc(new Error("record signature verification failed"), ra.ERR_SIGNATURE_VERIFICATION);
          if (i === l0.ValidityType.EOL) {
            let a;
            try {
              a = NOe(_H(n))
            } catch (c) {
              throw Ls.error("unrecognized validity format (not an rfc3339 format)"), oc(new Error("unrecognized validity format (not an rfc3339 format)"), ra.ERR_UNRECOGNIZED_FORMAT)
            }
            if (a.getTime() < Date.now()) throw Ls.error("record has expired"), oc(new Error("record has expired"), ra.ERR_IPNS_EXPIRED_RECORD)
          } else if (i) throw Ls.error("unrecognized validity type"), oc(new Error("unrecognized validity type"), ra.ERR_UNRECOGNIZED_VALIDITY);
          Ls(`ipns entry for ${t} is valid`)
        }, FOe = async (r, e) => {
          if (!r || !r.bytes || !e) {
            let n = new Error("one or more of the provided parameters are not defined");
            throw Ls.error(n), oc(n, ra.ERR_UNDEFINED_PARAMETER)
          }
          let t;
          try {
            t = await vH.createFromPubKey(r.bytes)
          } catch (n) {
            throw oc(n, ra.ERR_PEER_ID_FROM_PUBLIC_KEY)
          }
          let i;
          try {
            i = LOe(t)
          } catch (n) {
            throw Ls.error(n), oc(n, ra.ERR_PUBLIC_KEY_FROM_ID)
          }
          if (i) return null;
          try {
            e.pubKey = Q8.keys.marshalPublicKey(r)
          } catch (n) {
            throw Ls.error(n), n
          }
          return e
        }, TH = (r, e) => {
          if (!e || !r) {
            let t = new Error("one or more of the provided parameters are not defined");
            throw Ls.error(t), oc(t, ra.ERR_UNDEFINED_PARAMETER)
          }
          if (e.pubKey) {
            let t;
            try {
              t = Q8.keys.unmarshalPublicKey(e.pubKey)
            } catch (i) {
              throw Ls.error(i), i
            }
            return t
          }
          if (r.pubKey) return r.pubKey;
          throw Object.assign(new Error("no public key is available"), {
            code: ra.ERR_UNDEFINED_PARAMETER
          })
        }, ex = r => _H(OOe.encode("base32", r)).slice(1).toUpperCase(), UOe = r => new Hy(`/ipns/${ex(r)}`), KOe = r => {
          let e = Gy("/pk/"),
            t = Gy("/ipns/");
          return {
            routingPubKey: new Hy($y([e, r]), !1),
            pkKey: new Hy(ex($y([e, r]))),
            routingKey: new Hy($y([t, r]), !1),
            ipnsKey: new Hy(ex($y([t, r])))
          }
        }, DOe = (r, e, t, i) => {
          try {
            let n = AH(e, t, i);
            return r.sign(n)
          } catch (n) {
            throw Ls.error("record signature creation failed"), oc(new Error("record signature creation failed: " + n.message), ra.ERR_SIGNATURE_CREATION)
          }
        }, zOe = r => {
          if (r.toString() === "0") return "EOL";
          let e = new Error(`unrecognized validity type ${r.toString()}`);
          throw Ls.error(e), oc(e, ra.ERR_UNRECOGNIZED_VALIDITY)
        }, AH = (r, e, t) => {
          let i = Gy(zOe(e));
          return $y([r, t, i])
        }, LOe = r => {
          let e = wH.decode(r.id);
          return e.code !== qOe ? null : Q8.keys.unmarshalPublicKey(e.digest)
        }, jOe = r => l0.encode(r).finish(), Fv = r => {
          let e = l0.decode(r),
            t = l0.toObject(e, {
              defaults: !1,
              arrays: !0,
              longs: Number,
              objects: !1
            });
          return {
            value: t.value,
            signature: t.signature,
            validityType: t.validityType,
            validity: t.validity,
            sequence: t.sequence,
            pubKey: t.pubKey
          }
        }, VOe = {
          validate: async (r, e) => {
            let t = Fv(r),
              i = e.slice("/ipns/".length),
              n = vH.createFromBytes(i),
              s = TH(n, t);
            await IH(s, t)
          },
          select: (r, e) => {
            let t = Fv(r),
              i = Fv(e);
            return t.sequence > i.sequence ? 0 : 1
          }
        };
      mH.exports = {
        create: MOe,
        createWithExpiration: BOe,
        validate: IH,
        embedPublicKey: FOe,
        extractPublicKey: TH,
        getLocalKey: UOe,
        getIdKeys: KOe,
        marshal: jOe,
        unmarshal: Fv,
        validator: VOe,
        namespace: SH,
        namespaceLength: SH.length
      }
    });
    var qH = y((RH, kH) => {
      l();
      "use strict";
      var Uv = Et(),
        {
          Key: PH,
          Errors: HOe
        } = fr(),
        $n = xe(),
        CH = Oe(),
        ki = Object.assign(CH("ipfs:ipns:publisher"), {
          error: CH("ipfs:ipns:publisher:error")
        }),
        Wy = ct(),
        GOe = Lr(),
        Zc = h0(),
        OH = HOe.notFoundError().code,
        NH = 60 * 60 * 1e3,
        tx = class {
          constructor(e, t) {
            this._routing = e, this._datastore = t
          }
          async publishWithEOL(e, t, i) {
            if (!e || !e.bytes) throw $n(new Error("invalid private key"), "ERR_INVALID_PRIVATE_KEY");
            let n = await Uv.createFromPrivKey(e.bytes),
              s = await this._updateOrCreateRecord(e, t, i, n);
            return this._putRecordToRouting(s, n)
          }
          publish(e, t) {
            return this.publishWithEOL(e, t, NH)
          }
          async _putRecordToRouting(e, t) {
            if (!Uv.isPeerId(t)) {
              let o = "peerId received is not valid";
              throw ki.error(o), $n(new Error(o), "ERR_INVALID_PEER_ID")
            }
            let i = t._pubKey,
              n = await Zc.embedPublicKey(i, e),
              s = Zc.getIdKeys(t.toBytes());
            return await this._publishEntry(s.routingKey, n || e), await this._publishPublicKey(s.routingPubKey, i), n || e
          }
          async _publishEntry(e, t) {
            if (!PH.isKey(e)) {
              let n = "datastore key does not have a valid format";
              throw ki.error(n), $n(new Error(n), "ERR_INVALID_DATASTORE_KEY")
            }
            let i;
            try {
              i = Zc.marshal(t)
            } catch (n) {
              throw ki.error(n), n
            }
            try {
              let n = await this._routing.put(e.uint8Array(), i);
              return ki(`ipns record for ${Wy(e.uint8Array(), "base64")} was stored in the routing`), n
            } catch (n) {
              let s = `ipns record for ${Wy(e.uint8Array(), "base64")} could not be stored in the routing`;
              throw ki.error(s), ki.error(n), $n(new Error(s), "ERR_PUTTING_TO_ROUTING")
            }
          }
          async _publishPublicKey(e, t) {
            if (!PH.isKey(e)) {
              let i = "datastore key does not have a valid format";
              throw ki.error(i), $n(new Error(i), "ERR_INVALID_DATASTORE_KEY")
            }
            if (!t || !t.bytes) {
              let i = "one or more of the provided parameters are not defined";
              throw ki.error(i), $n(new Error(i), "ERR_UNDEFINED_PARAMETER")
            }
            try {
              let i = await this._routing.put(e.uint8Array(), t.bytes);
              return ki(`public key for ${Wy(e.uint8Array(), "base64")} was stored in the routing`), i
            } catch (i) {
              let n = `public key for ${Wy(e.uint8Array(), "base64")} could not be stored in the routing`;
              throw ki.error(n), ki.error(i), $n(new Error(n), "ERR_PUTTING_TO_ROUTING")
            }
          }
          async _getPublished(e, t = {}) {
            if (!Uv.isPeerId(e)) {
              let n = "peerId received is not valid";
              throw ki.error(n), $n(new Error(n), "ERR_INVALID_PEER_ID")
            }
            let i = t.checkRouting !== !1;
            try {
              let n = await this._datastore.get(Zc.getLocalKey(e.id));
              return this._unmarshalData(n)
            } catch (n) {
              if (n.code !== OH) {
                let s = `unexpected error getting the ipns record ${e.id} from datastore`;
                throw ki.error(s), $n(new Error(s), "ERR_UNEXPECTED_DATASTORE_RESPONSE")
              }
              if (!i) throw $n(n, "ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");
              try {
                let s = Zc.getIdKeys(e.toBytes()),
                  o = await this._routing.get(s.routingKey.uint8Array());
                return this._unmarshalData(o)
              } catch (s) {
                throw ki.error(s), s
              }
            }
          }
          _unmarshalData(e) {
            try {
              return Zc.unmarshal(e)
            } catch (t) {
              throw $n(t, "ERR_INVALID_RECORD_DATA")
            }
          }
          async _updateOrCreateRecord(e, t, i, n) {
            if (!Uv.isPeerId(n)) {
              let u = "peerId received is not valid";
              throw ki.error(u), $n(new Error(u), "ERR_INVALID_PEER_ID")
            }
            let s = {
              checkRouting: !0
            },
              o;
            try {
              o = await this._getPublished(n, s)
            } catch (u) {
              if (u.code !== OH) {
                let f = `unexpected error when determining the last published IPNS record for ${n.id} ${u.stack}`;
                throw ki.error(f), $n(new Error(f), "ERR_DETERMINING_PUBLISHED_RECORD")
              }
            }
            let a = 0;
            o && o.sequence !== void 0 && (a = GOe(o.value, t) ? o.sequence : o.sequence + 1);
            let c;
            try {
              c = await Zc.create(e, t, a, i)
            } catch (u) {
              let f = `ipns record for ${t} could not be created`;
              throw ki.error(u), $n(new Error(f), "ERR_CREATING_IPNS_RECORD")
            }
            try {
              let u = Zc.marshal(c);
              return await this._datastore.put(Zc.getLocalKey(n.id), u), ki(`ipns record for ${Wy(t, "base32")} was stored in the datastore`), c
            } catch (u) {
              let f = `ipns record for ${t} could not be stored in the datastore`;
              throw ki.error(f), $n(new Error(f), "ERR_STORING_IN_DATASTORE")
            }
          }
        };
      tx.defaultRecordLifetime = NH;
      RH = kH.exports = tx
    });
    var jH = y((MH, BH) => {
      l();
      "use strict";
      var DH = h0(),
        $Oe = Ja(),
        LH = Et(),
        Cl = xe(),
        FH = Oe(),
        Kv = Object.assign(FH("ipfs:ipns:republisher"), {
          error: FH("ipfs:ipns:republisher:error")
        }),
        UH = 60 * 1e3,
        KH = 60 * UH,
        WOe = 4 * KH,
        YOe = 24 * KH,
        zH = class {
          constructor(e, t, i, n, s = {
            pass: ""
          }) {
            this._publisher = e, this._datastore = t, this._peerId = i, this._keychain = n, this._options = s, this._republishHandle = null
          }
          async start() {
            if (this._republishHandle) throw Cl(new Error("republisher is already running"), "ERR_REPUBLISH_ALREADY_RUNNING");
            let e = {
              _task: null,
              _inflightTask: null,
              _timeoutId: null,
              runPeriodically: s => {
                e._timeoutId = setTimeout(async () => {
                  e._timeoutId = null;
                  try {
                    e._inflightTask = e._task(), await e._inflightTask, e._task && e.runPeriodically(s)
                  } catch (o) {
                    Kv.error(o)
                  }
                }, s())
              },
              cancel: async () => {
                e._timeoutId != null && clearTimeout(e._timeoutId), e._task = null, await e._inflightTask
              }
            },
              {
                privKey: t
              } = this._peerId,
              {
                pass: i
              } = this._options,
              n = !0;
            e._task = () => this._republishEntries(t, i), e.runPeriodically(() => n ? (n = !1, this._options.initialBroadcastInterval || UH) : this._options.broadcastInterval || WOe), this._republishHandle = e
          }
          async stop() {
            let e = this._republishHandle;
            if (!e) throw Cl(new Error("republisher is not running"), "ERR_REPUBLISH_NOT_RUNNING");
            this._republishHandle = null, await e.cancel()
          }
          async _republishEntries(e, t) {
            try {
              await this._republishEntry(e)
            } catch (i) {
              let n = "cannot republish entry for the node's private key";
              Kv.error(n);
              return
            }
            if (t) try {
              let i = await this._keychain.listKeys();
              for (let n of i) {
                if (n.name === "self") continue;
                let s = await this._keychain.exportKey(n.name, t),
                  o = await $Oe.keys.import(s, t);
                await this._republishEntry(o)
              }
            } catch (i) {
              Kv.error(i)
            }
          }
          async _republishEntry(e) {
            if (!e || !e.bytes) throw Cl(new Error("invalid private key"), "ERR_INVALID_PRIVATE_KEY");
            try {
              let t = await LH.createFromPrivKey(e.bytes),
                i = await this._getPreviousValue(t);
              await this._publisher.publishWithEOL(e, i, YOe)
            } catch (t) {
              if (t.code === "ERR_NO_ENTRY_FOUND") return;
              throw t
            }
          }
          async _getPreviousValue(e) {
            if (!LH.isPeerId(e)) throw Cl(new Error("invalid peer ID"), "ERR_INVALID_PEER_ID");
            try {
              let t = await this._datastore.get(DH.getLocalKey(e.id));
              if (!(t instanceof Uint8Array)) throw Cl(new Error("found ipns record that we couldn't process"), "ERR_INVALID_IPNS_RECORD");
              try {
                return DH.unmarshal(t).value
              } catch (i) {
                throw Kv.error(i), Cl(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_IPNS_RECORD")
              }
            } catch (t) {
              throw t && t.notFound ? Cl(new Error(`no previous entry for record with id: ${e.id}`), "ERR_NO_ENTRY_FOUND") : t
            }
          }
        };
      MH = BH.exports = zH
    });
    var YH = y((VH, HH) => {
      l();
      "use strict";
      var zv = h0(),
        JOe = Et(),
        d0 = xe(),
        GH = Oe(),
        jv = Object.assign(GH("ipfs:ipns:resolver"), {
          error: GH("ipfs:ipns:resolver:error")
        }),
        XOe = ct(),
        {
          Errors: ZOe
        } = fr(),
        QOe = ZOe.notFoundError().code,
        $H = 32,
        WH = class {
          constructor(e) {
            this._routing = e
          }
          async resolve(e, t = {}) {
            if (typeof e != "string") throw d0(new Error("invalid name"), "ERR_INVALID_NAME");
            let i = t.recursive && t.recursive.toString() === "true",
              n = e.split("/");
            if (n.length !== 3 || n[0] !== "") throw d0(new Error("invalid name"), "ERR_INVALID_NAME");
            let s = n[2],
              o = Infinity;
            i && (o = $H);
            let a = await this.resolver(s, o);
            return jv(`${e} was locally resolved correctly`), a
          }
          async resolver(e, t) {
            if (t === 0) {
              let s = `could not resolve name (recursion limit of ${$H} exceeded)`;
              throw jv.error(s), d0(new Error(s), "ERR_RESOLVE_RECURSION_LIMIT")
            }
            let i = await this._resolveName(e),
              n = i.split("/");
            return n[1] === "ipfs" || !t ? i : this.resolver(n[2], t - 1)
          }
          async _resolveName(e) {
            let t = JOe.createFromCID(e),
              {
                routingKey: i
              } = zv.getIdKeys(t.toBytes()),
              n;
            try {
              n = await this._routing.get(i.uint8Array())
            } catch (o) {
              throw jv.error("could not get record from routing", o), o.code === QOe ? d0(new Error(`record requested for ${e} was not found in the network`), "ERR_NO_RECORD_FOUND") : d0(new Error(`unexpected error getting the ipns record ${t.toString()}`), "ERR_UNEXPECTED_ERROR_GETTING_RECORD")
            }
            let s;
            try {
              s = zv.unmarshal(n)
            } catch (o) {
              throw jv.error("could not unmarshal record", o), d0(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_RECORD_RECEIVED")
            }
            return this._validateRecord(t, s)
          }
          async _validateRecord(e, t) {
            let i = await zv.extractPublicKey(e, t);
            return await zv.validate(i, t), XOe(t.value)
          }
        };
      VH = HH.exports = WH
    });
    var tG = y((p3t, JH) => {
      l();
      "use strict";
      var {
        createFromPrivKey: eNe
      } = Et(), tNe = xe(), XH = Oe(), Yy = Object.assign(XH("ipfs:ipns"), {
        error: XH("ipfs:ipns:error")
      }), rx = qH(), rNe = jH(), iNe = YH(), nNe = Y5(), ZH = 60 * 1e3, QH = ct(), eG = class {
        constructor(e, t, i, n, s) {
          this.publisher = new rx(e, t), this.republisher = new rNe(this.publisher, t, i, n, s), this.resolver = new iNe(e), this.cache = new nNe(1e3), this.routing = e
        }
        async publish(e, t, i = rx.defaultRecordLifetime) {
          try {
            let n = await eNe(e.bytes);
            await this.publisher.publishWithEOL(e, t, i), Yy(`IPNS value ${QH(t, "base32")} was published correctly`);
            let s = n.toB58String(),
              o = parseFloat(i),
              a = o < ZH ? o : ZH;
            return this.cache.set(s, t, a), Yy(`IPNS value ${QH(t, "base32")} was cached correctly`), {
              name: s,
              value: t
            }
          } catch (n) {
            throw Yy.error(n), n
          }
        }
        async resolve(e, t = {}) {
          if (typeof e != "string") throw tNe(new Error("name received is not valid"), "ERR_INVALID_NAME");
          if (!t.nocache && !t.recursive) {
            let i = e.split("/")[2],
              n = this.cache.get(i);
            if (n) return n
          }
          try {
            let i = await this.resolver.resolve(e, t);
            return Yy(`IPNS record from ${e} was resolved correctly`), i
          } catch (i) {
            throw Yy.error(i), i
          }
        }
        async initializeKeyspace(e, t) {
          return this.publish(e, t, rx.defaultRecordLifetime)
        }
      };
      JH.exports = eG
    });
    var Qc = y((y3t, rG) => {
      l();
      "use strict";
      var sNe = async function* (r, e) {
        for await (let t of r) yield e(t)
      };
      rG.exports = sNe
    });
    var Jy = y((g3t, iG) => {
      l();
      "use strict";
      var {
        Adapter: oNe
      } = fr(), nG = Qc(), sG = class extends oNe {
        constructor(e, t) {
          super();
          this.child = e, this.transform = t
        }
        open() {
          return this.child.open()
        }
        put(e, t, i) {
          return this.child.put(this.transform.convert(e), t, i)
        }
        get(e, t) {
          return this.child.get(this.transform.convert(e), t)
        }
        has(e, t) {
          return this.child.has(this.transform.convert(e), t)
        }
        delete(e, t) {
          return this.child.delete(this.transform.convert(e), t)
        }
        batch() {
          let e = this.child.batch();
          return {
            put: (t, i) => {
              e.put(this.transform.convert(t), i)
            },
            delete: t => {
              e.delete(this.transform.convert(t))
            },
            commit: t => e.commit(t)
          }
        }
        query(e, t) {
          return nG(this.child.query(e, t), ({
            key: i,
            value: n
          }) => ({
            key: this.transform.invert(i),
            value: n
          }))
        }
        queryKeys(e, t) {
          return nG(this.child.queryKeys(e, t), i => this.transform.invert(i))
        }
        close() {
          return this.child.close()
        }
      };
      iG.exports = sG
    });
    var aG = y((b3t, oG) => {
      l();
      "use strict";
      oG.exports = `This is a repository of IPLD objects. Each IPLD object is in a single file,
named <base32 encoding of cid>.data. Where <base32 encoding of cid> is the
"base32" encoding of the CID (as specified in
https://github.com/multiformats/multibase) without the 'B' prefix.
All the object files are placed in a tree of directories, based on a
function of the CID. This is a form of sharding similar to
the objects directory in git repositories. Previously, we used
prefixes, we now use the next-to-last two charters.
  func NextToLast(base32cid string) {
    nextToLastLen := 2
    offset := len(base32cid) - nextToLastLen - 1
    return str[offset : offset+nextToLastLen]
  }
For example, an object with a base58 CIDv1 of
  zb2rhYSxw4ZjuzgCnWSt19Q94ERaeFhu9uSqRgjSdx9bsgM6f
has a base32 CIDv1 of
  BAFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA
and will be placed at
  SC/AFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA.data
with 'SC' being the last-to-next two characters and the 'B' at the
beginning of the CIDv1 string is the multibase prefix that is not
stored in the filename.
`
    });
    var ox = y((m3t, cG) => {
      l();
      "use strict";
      var {
        Key: uG
      } = fr(), aNe = aG(), Vv = "/repo/flatfs/shard/", fG = "SHARDING", cNe = "_README", Hv = class {
        constructor(e) {
          this.param = e, this.name = "base", this._padding = ""
        }
        fun(e) {
          return "implement me"
        }
        toString() {
          return `${Vv}v1/${this.name}/${this.param}`
        }
      }, ix = class extends Hv {
        constructor(e) {
          super(e);
          this._padding = "".padStart(e, "_"), this.name = "prefix"
        }
        fun(e) {
          return (e + this._padding).slice(0, this.param)
        }
      }, nx = class extends Hv {
        constructor(e) {
          super(e);
          this._padding = "".padStart(e, "_"), this.name = "suffix"
        }
        fun(e) {
          let t = this._padding + e;
          return t.slice(t.length - this.param)
        }
      }, sx = class extends Hv {
        constructor(e) {
          super(e);
          this._padding = "".padStart(e + 1, "_"), this.name = "next-to-last"
        }
        fun(e) {
          let t = this._padding + e,
            i = t.length - this.param - 1;
          return t.slice(i, i + this.param)
        }
      };

      function lG(r) {
        if (r = r.trim(), r.length === 0) throw new Error("empty shard string");
        if (!r.startsWith(Vv)) throw new Error(`invalid or no path prefix: ${r}`);
        let e = r.slice(Vv.length).split("/"),
          t = e[0];
        if (t !== "v1") throw new Error(`expect 'v1' version, got '${t}'`);
        let i = e[1];
        if (!e[2]) throw new Error("missing param");
        let n = parseInt(e[2], 10);
        switch (i) {
          case "prefix":
            return new ix(n);
          case "suffix":
            return new nx(n);
          case "next-to-last":
            return new sx(n);
          default:
            throw new Error(`unkown sharding function: ${i}`)
        }
      }
      var uNe = async (r, e) => {
        let t = new uG(r).child(new uG(fG)),
          n = await (typeof e.getRaw == "function" ? e.getRaw.bind(e) : e.get.bind(e))(t);
        return lG(new TextDecoder().decode(n || "").trim())
      };
      cG.exports = {
        readme: aNe,
        parseShardFun: lG,
        readShardFun: uNe,
        Prefix: ix,
        Suffix: nx,
        NextToLast: sx,
        README_FN: cNe,
        SHARDING_FN: fG,
        PREFIX: Vv
      }
    });
    var dG = y((v3t, hG) => {
      l();
      "use strict";
      var {
        Adapter: fNe,
        Key: Gv,
        Errors: lNe
      } = fr(), Xy = ox(), hNe = Jy(), p0 = new Gv(Xy.SHARDING_FN), Zy = new Gv(Xy.README_FN), Ol = class extends fNe {
        constructor(e, t) {
          super();
          this.child = new hNe(e, {
            convert: this._convertKey.bind(this),
            invert: this._invertKey.bind(this)
          }), this.shard = t
        }
        async open() {
          await this.child.open(), this.shard = await Ol.create(this.child, this.shard)
        }
        _convertKey(e) {
          let t = e.toString();
          return t === p0.toString() || t === Zy.toString() ? e : new Gv(this.shard.fun(t)).child(e)
        }
        _invertKey(e) {
          let t = e.toString();
          return t === p0.toString() || t === Zy.toString() ? e : Gv.withNamespaces(e.list().slice(1))
        }
        static async createOrOpen(e, t) {
          try {
            await Ol.create(e, t)
          } catch (i) {
            if (i && i.message !== "datastore exists") throw i
          }
          return Ol.open(e)
        }
        static async open(e) {
          let t = await Xy.readShardFun("/", e);
          return new Ol(e, t)
        }
        static async create(e, t) {
          let i = await e.has(p0);
          if (!i && !t) throw lNe.dbOpenFailedError(Error("Shard is required when datastore doesn't have a shard key already."));
          if (!i) {
            let a = typeof e.putRaw == "function" ? e.putRaw.bind(e) : e.put.bind(e);
            return await Promise.all([a(p0, new TextEncoder().encode(t.toString() + `
`)), a(Zy, new TextEncoder().encode(Xy.readme))]), t
          }
          let n = await Xy.readShardFun("/", e),
            s = (n || "").toString(),
            o = t.toString();
          if (s !== o) throw new Error(`specified fun ${o} does not match repo shard fun ${s}`);
          return n
        }
        put(e, t, i) {
          return this.child.put(e, t, i)
        }
        get(e, t) {
          return this.child.get(e, t)
        }
        has(e, t) {
          return this.child.has(e, t)
        }
        delete(e, t) {
          return this.child.delete(e, t)
        }
        batch() {
          return this.child.batch()
        }
        query(e, t) {
          let i = {
            offset: e.offset,
            limit: e.limit,
            orders: [],
            filters: [s => s.key.toString() !== p0.toString(), s => s.key.toString() !== Zy.toString()]
          },
            {
              prefix: n
            } = e;
          if (n != null && i.filters.push(s => this._invertKey(s.key).toString().startsWith(n)), e.filters != null) {
            let s = e.filters.map(o => ({
              key: c,
              value: u
            }) => o({
              key: this._invertKey(c),
              value: u
            }));
            i.filters = i.filters.concat(s)
          }
          return e.orders != null && (i.orders = e.orders.map(s => (a, c) => s({
            key: this._invertKey(a.key),
            value: a.value
          }, {
            key: this._invertKey(c.key),
            value: c.value
          }))), this.child.query(i, t)
        }
        queryKeys(e, t) {
          let i = {
            offset: e.offset,
            limit: e.limit,
            orders: [],
            filters: [s => s.toString() !== p0.toString(), s => s.toString() !== Zy.toString()]
          },
            {
              prefix: n
            } = e;
          if (n != null && i.filters.push(s => this._invertKey(s).toString().startsWith(n)), e.filters != null) {
            let s = e.filters.map(o => c => o(this._invertKey(c)));
            i.filters = i.filters.concat(s)
          }
          return e.orders != null && (i.orders = e.orders.map(s => (a, c) => s(this._invertKey(a), this._invertKey(c)))), this.child.queryKeys(i, t)
        }
        close() {
          return this.child.close()
        }
      };
      hG.exports = Ol
    });
    var yG = y((_3t, pG) => {
      l();
      pG.exports = class {
        constructor(e) {
          if (!(e > 0) || (e - 1 & e) != 0) throw new Error("Max size for a FixedFIFO should be a power of two");
          this.buffer = new Array(e), this.mask = e - 1, this.top = 0, this.btm = 0, this.next = null
        }
        push(e) {
          return this.buffer[this.top] !== void 0 ? !1 : (this.buffer[this.top] = e, this.top = this.top + 1 & this.mask, !0)
        }
        shift() {
          let e = this.buffer[this.btm];
          if (e !== void 0) return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, e
        }
        isEmpty() {
          return this.buffer[this.btm] === void 0
        }
      }
    });
    var ax = y((S3t, gG) => {
      l();
      var bG = yG();
      gG.exports = class {
        constructor(e) {
          this.hwm = e || 16, this.head = new bG(this.hwm), this.tail = this.head
        }
        push(e) {
          if (!this.head.push(e)) {
            let t = this.head;
            this.head = t.next = new bG(2 * this.head.buffer.length), this.head.push(e)
          }
        }
        shift() {
          let e = this.tail.shift();
          if (e === void 0 && this.tail.next) {
            let t = this.tail.next;
            return this.tail.next = null, this.tail = t, this.tail.shift()
          }
          return e
        }
        isEmpty() {
          return this.head.isEmpty()
        }
      }
    });
    var eu = y((x3t, mG) => {
      l();
      var cx = ax();
      mG.exports = r => {
        r = r || {};
        let e;
        typeof r == "function" ? (e = r, r = {}) : e = r.onEnd;
        let t = new cx,
          i, n, s, o = () => {
            if (!t.isEmpty()) {
              if (r.writev) {
                let m, E = [];
                for (; !t.isEmpty();) {
                  if (m = t.shift(), m.error) throw m.error;
                  E.push(m.value)
                }
                return {
                  done: m.done,
                  value: E
                }
              }
              let g = t.shift();
              if (g.error) throw g.error;
              return g
            }
            return s ? {
              done: !0
            } : new Promise((g, m) => {
              n = E => (n = null, E.error ? m(E.error) : r.writev && !E.done ? g({
                done: E.done,
                value: [E.value]
              }) : g(E), i)
            })
          },
          a = g => n ? n(g) : (t.push(g), i),
          c = g => (t = new cx, n ? n({
            error: g
          }) : (t.push({
            error: g
          }), i)),
          u = g => s ? i : a({
            done: !1,
            value: g
          }),
          f = g => s ? i : (s = !0, g ? c(g) : a({
            done: !0
          })),
          h = () => (t = new cx, f(), {
            done: !0
          }),
          d = g => (f(g), {
            done: !0
          });
        if (i = {
          [Symbol.asyncIterator]() {
            return this
          },
          next: o,
          return: h,
          throw: d,
          push: u,
          end: f
        }, !e) return i;
        let p = i;
        return i = {
          [Symbol.asyncIterator]() {
            return this
          },
          next() {
            return p.next()
          },
          throw(g) {
            return p.throw(g), e && (e(g), e = null), {
              done: !0
            }
          },
          return() {
            return p.return(), e && (e(), e = null), {
              done: !0
            }
          },
          push: u,
          end(g) {
            return p.end(g), e && (e(g), e = null), i
          }
        }, i
      }
    });
    var wG = y((A3t, vG) => {
      l();
      "use strict";
      var dNe = eu(),
        pNe = async function* (...r) {
          let e = dNe();
          setTimeout(async () => {
            try {
              await Promise.all(r.map(async t => {
                for await (let i of t) e.push(i)
              })), e.end()
            } catch (t) {
              e.end(t)
            }
          }, 0), yield* e
        };
      vG.exports = pNe
    });
    var TG = y((I3t, _G) => {
      l();
      "use strict";
      var {
        Adapter: yNe,
        Key: gNe,
        Errors: ux,
        utils: {
          sortAll: EG,
          replaceStartWith: fx
        }
      } = fr(), $v = xl(), SG = ov(), xG = wG(), AG = Jy(), IG = class extends yNe {
        constructor(e) {
          super();
          this.mounts = e.slice()
        }
        async open() {
          await Promise.all(this.mounts.map(e => e.datastore.open()))
        }
        _lookup(e) {
          for (let t of this.mounts)
            if (t.prefix.toString() === e.toString() || t.prefix.isAncestorOf(e)) {
              let i = fx(e.toString(), t.prefix.toString());
              return {
                datastore: t.datastore,
                mountpoint: t.prefix,
                rest: new gNe(i)
              }
            }
        }
        put(e, t, i) {
          let n = this._lookup(e);
          if (n == null) throw ux.dbWriteFailedError(new Error("No datastore mounted for this key"));
          return n.datastore.put(n.rest, t, i)
        }
        get(e, t) {
          let i = this._lookup(e);
          if (i == null) throw ux.notFoundError(new Error("No datastore mounted for this key"));
          return i.datastore.get(i.rest, t)
        }
        has(e, t) {
          let i = this._lookup(e);
          return i == null ? Promise.resolve(!1) : i.datastore.has(i.rest, t)
        }
        delete(e, t) {
          let i = this._lookup(e);
          if (i == null) throw ux.dbDeleteFailedError(new Error("No datastore mounted for this key"));
          return i.datastore.delete(i.rest, t)
        }
        async close() {
          await Promise.all(this.mounts.map(e => e.datastore.close()))
        }
        batch() {
          let e = {},
            t = i => {
              let n = this._lookup(i);
              if (n == null) throw new Error("No datastore mounted for this key");
              let s = n.mountpoint.toString();
              return e[s] == null && (e[s] = n.datastore.batch()), {
                batch: e[s],
                rest: n.rest
              }
            };
          return {
            put: (i, n) => {
              let s = t(i);
              s.batch.put(s.rest, n)
            },
            delete: i => {
              let n = t(i);
              n.batch.delete(n.rest)
            },
            commit: async i => {
              await Promise.all(Object.keys(e).map(n => e[n].commit(i)))
            }
          }
        }
        query(e, t) {
          let i = this.mounts.map(s => {
            let o = new AG(s.datastore, {
              convert: c => {
                throw new Error("should never be called")
              },
              invert: c => s.prefix.child(c)
            }),
              a;
            return e.prefix != null && (a = fx(e.prefix, s.prefix.toString())), o.query({
              prefix: a,
              filters: e.filters
            }, t)
          }),
            n = xG(...i);
          if (e.filters && e.filters.forEach(s => {
            n = $v(n, s)
          }), e.orders && e.orders.forEach(s => {
            n = EG(n, s)
          }), e.offset != null) {
            let s = 0;
            n = $v(n, () => s++ >= e.offset)
          }
          return e.limit != null && (n = SG(n, e.limit)), n
        }
        queryKeys(e, t) {
          let i = this.mounts.map(s => {
            let o = new AG(s.datastore, {
              convert: c => {
                throw new Error("should never be called")
              },
              invert: c => s.prefix.child(c)
            }),
              a;
            return e.prefix != null && (a = fx(e.prefix, s.prefix.toString())), o.queryKeys({
              prefix: a,
              filters: e.filters
            }, t)
          }),
            n = xG(...i);
          if (e.filters && e.filters.forEach(s => {
            n = $v(n, s)
          }), e.orders && e.orders.forEach(s => {
            n = EG(n, s)
          }), e.offset != null) {
            let s = 0;
            n = $v(n, () => s++ >= e.offset)
          }
          return e.limit != null && (n = SG(n, e.limit)), n
        }
      };
      _G.exports = IG
    });
    var PG = y((T3t, RG) => {
      l();
      "use strict";
      var {
        Adapter: bNe,
        Errors: Wv
      } = fr(), mNe = Oe()("datastore:core:tiered"), kG = class extends bNe {
        constructor(e) {
          super();
          this.stores = e.slice()
        }
        async open() {
          try {
            await Promise.all(this.stores.map(e => e.open()))
          } catch (e) {
            throw Wv.dbOpenFailedError()
          }
        }
        async put(e, t) {
          try {
            await Promise.all(this.stores.map(i => i.put(e, t)))
          } catch (i) {
            throw Wv.dbWriteFailedError()
          }
        }
        async get(e, t) {
          for (let i of this.stores) try {
            let n = await i.get(e, t);
            if (n) return n
          } catch (n) {
            mNe(n)
          }
          throw Wv.notFoundError()
        }
        async has(e, t) {
          for (let i of this.stores)
            if (await i.has(e, t)) return !0;
          return !1
        }
        async delete(e, t) {
          try {
            await Promise.all(this.stores.map(i => i.delete(e, t)))
          } catch (i) {
            throw Wv.dbDeleteFailedError()
          }
        }
        async close() {
          await Promise.all(this.stores.map(e => e.close()))
        }
        batch() {
          let e = this.stores.map(t => t.batch());
          return {
            put: (t, i) => {
              e.forEach(n => n.put(t, i))
            },
            delete: t => {
              e.forEach(i => i.delete(t))
            },
            commit: async t => {
              for (let i of e) await i.commit(t)
            }
          }
        }
        query(e, t) {
          return this.stores[this.stores.length - 1].query(e, t)
        }
        queryKeys(e, t) {
          return this.stores[this.stores.length - 1].queryKeys(e, t)
        }
      };
      RG.exports = kG
    });
    var NG = y((R3t, CG) => {
      l();
      "use strict";
      var lx = fr().Key,
        vNe = Jy(),
        OG = class extends vNe {
          constructor(e, t) {
            super(e, {
              convert(i) {
                return t.child(i)
              },
              invert(i) {
                if (t.toString() === "/") return i;
                if (!t.isAncestorOf(i)) throw new Error(`Expected prefix: (${t.toString()}) in key: ${i.toString()}`);
                return new lx(i.toString().slice(t.toString().length), !1)
              }
            });
            this.prefix = t
          }
          query(e, t) {
            return e.prefix && this.prefix.toString() !== "/" ? super.query(Object.assign({}, e, {
              prefix: this.prefix.child(new lx(e.prefix)).toString()
            })) : super.query(e, t)
          }
          queryKeys(e, t) {
            return e.prefix && this.prefix.toString() !== "/" ? super.queryKeys(Object.assign({}, e, {
              prefix: this.prefix.child(new lx(e.prefix)).toString()
            })) : super.queryKeys(e, t)
          }
        };
      CG.exports = OG
    });
    var Yv = y((k3t, qG) => {
      l();
      "use strict";
      var wNe = Jy(),
        _Ne = dG(),
        ENe = TG(),
        SNe = PG(),
        xNe = NG(),
        ANe = ox();
      qG.exports = {
        KeytransformDatastore: wNe,
        ShardingDatastore: _Ne,
        MountDatastore: ENe,
        TieredDatastore: SNe,
        NamespaceDatastore: xNe,
        shard: ANe
      }
    });
    var Qy = y((hx, dx) => {
      l();
      (function (r, e) {
        typeof hx == "object" && typeof dx != "undefined" ? dx.exports = function (t, i, n, s, o) {
          for (i = i.split ? i.split(".") : i, s = 0; s < i.length; s++) t = t ? t[i[s]] : o;
          return t === o ? n : t
        } : typeof define == "function" && define.amd ? define(function () {
          return function (t, i, n, s, o) {
            for (i = i.split ? i.split(".") : i, s = 0; s < i.length; s++) t = t ? t[i[s]] : o;
            return t === o ? n : t
          }
        }) : r.dlv = function (t, i, n, s, o) {
          for (i = i.split ? i.split(".") : i, s = 0; s < i.length; s++) t = t ? t[i[s]] : o;
          return t === o ? n : t
        }
      })(hx)
    });
    var LG = y((P3t, MG) => {
      l();
      "use strict";
      var INe = xe(),
        BG = ct(),
        DG = gt(),
        Jv = "/record/";

      function TNe(r) {
        return BG(r, "base32")
      }

      function RNe(r) {
        (typeof r == "string" || r instanceof String) && (r = DG(r.toString()));
        let e = BG(r, "base64url");
        return `${Jv}${e}`
      }

      function kNe(r) {
        if (r.substring(0, Jv.length) !== Jv) throw INe(new Error("topic received is not from a record"), "ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");
        let e = r.substring(Jv.length);
        return DG(e, "base64url")
      }
      MG.exports = {
        encodeBase32: TNe,
        keyToTopic: RNe,
        topicToKey: kNe
      }
    });
    var VG = y((FG, UG) => {
      l();
      "use strict";
      var {
        Key: px,
        Adapter: PNe
      } = fr(), {
        encodeBase32: KG,
        keyToTopic: Xv,
        topicToKey: CNe
      } = LG(), ONe = Lr(), po = xe(), zG = Oe(), kn = Object.assign(zG("datastore-pubsub:publisher"), {
        error: zG("datastore-pubsub:publisher:error")
      }), jG = class extends PNe {
        constructor(e, t, i, n, s) {
          super();
          if (!n) throw po(new TypeError("missing validator"), "ERR_INVALID_PARAMETERS");
          if (typeof n.validate != "function") throw po(new TypeError("missing validate function"), "ERR_INVALID_PARAMETERS");
          if (typeof n.select != "function") throw po(new TypeError("missing select function"), "ERR_INVALID_PARAMETERS");
          if (s && typeof s != "function") throw po(new TypeError("invalid subscriptionKeyFn received"), "ERR_INVALID_PARAMETERS");
          this._pubsub = e, this._datastore = t, this._peerId = i, this._validator = n, this._handleSubscriptionKeyFn = s, this._onMessage = this._onMessage.bind(this)
        }
        async put(e, t) {
          if (!(e instanceof Uint8Array)) {
            let n = "datastore key does not have a valid format";
            throw kn.error(n), po(new Error(n), "ERR_INVALID_DATASTORE_KEY")
          }
          if (!(t instanceof Uint8Array)) {
            let n = "received value is not a Uint8Array";
            throw kn.error(n), po(new Error(n), "ERR_INVALID_VALUE_RECEIVED")
          }
          let i = Xv(e);
          kn(`publish value for topic ${i}`), await this._pubsub.publish(i, t)
        }
        async get(e) {
          if (!(e instanceof Uint8Array)) {
            let n = "datastore key does not have a valid format";
            throw kn.error(n), po(new Error(n), "ERR_INVALID_DATASTORE_KEY")
          }
          let t = Xv(e),
            i = await this._pubsub.getTopics();
          if (i && Array.isArray(i) && i.indexOf(t) > -1) return this._getLocal(e);
          try {
            this._pubsub.on(t, this._onMessage), await this._pubsub.subscribe(t)
          } catch (n) {
            let s = `cannot subscribe topic ${t}`;
            throw kn.error(s), po(new Error(s), "ERR_SUBSCRIBING_TOPIC")
          }
          return kn(`subscribed values for key ${t}`), this._getLocal(e)
        }
        unsubscribe(e) {
          let t = Xv(e);
          return this._pubsub.removeListener(t, this._onMessage), this._pubsub.unsubscribe(t)
        }
        async _getLocal(e) {
          let t = new px("/" + KG(e), !1),
            i;
          try {
            i = await this._datastore.get(t)
          } catch (n) {
            if (n.code !== "ERR_NOT_FOUND") {
              let o = `unexpected error getting the ipns record for ${t.toString()}`;
              throw kn.error(o), po(new Error(o), "ERR_UNEXPECTED_ERROR_GETTING_RECORD")
            }
            let s = `local record requested was not found for ${t.toString()}`;
            throw kn.error(s), po(new Error(s), "ERR_NOT_FOUND")
          }
          if (!(i instanceof Uint8Array)) {
            let n = "found record that we couldn't convert to a value";
            throw kn.error(n), po(new Error(n), "ERR_INVALID_RECORD_RECEIVED")
          }
          return i
        }
        async _onMessage(e) {
          let {
            data: t,
            from: i,
            topicIDs: n
          } = e, s;
          try {
            s = CNe(n[0])
          } catch (o) {
            kn.error(o);
            return
          }
          if (kn(`message received for topic ${n[0]}`), i === this._peerId.toB58String()) {
            kn("message discarded as it is from the same peer");
            return
          }
          if (this._handleSubscriptionKeyFn) {
            let o;
            try {
              o = await this._handleSubscriptionKeyFn(s)
            } catch (a) {
              kn.error("message discarded by the subscriptionKeyFn");
              return
            }
            s = o
          }
          try {
            await this._storeIfSubscriptionIsBetter(s, t)
          } catch (o) {
            kn.error(o)
          }
        }
        async _storeIfSubscriptionIsBetter(e, t) {
          let i = !1;
          try {
            i = await this._isBetter(e, t)
          } catch (n) {
            if (n.code !== "ERR_NOT_VALID_RECORD") throw n
          }
          i && await this._storeRecord(e, t)
        }
        async _validateRecord(e, t) {
          return this._validator.validate(e, t)
        }
        async _selectRecord(e, t) {
          return await this._validator.select(e, t) === 0
        }
        async _isBetter(e, t) {
          try {
            await this._validateRecord(t, e)
          } catch (s) {
            let o = "record received through pubsub is not valid";
            throw kn.error(o), po(new Error(o), "ERR_NOT_VALID_RECORD")
          }
          let i = new px(e),
            n;
          try {
            n = await this._getLocal(i.uint8Array())
          } catch (s) {
            return !0
          }
          return ONe(n, t) ? !1 : this._selectRecord(e, [n, t])
        }
        async _storeRecord(e, t) {
          let i = new px("/" + KG(e), !1);
          await this._datastore.put(i, t), kn(`record for ${Xv(e)} was stored in the datastore`)
        }
      };
      FG = UG.exports = jG
    });
    var gx = y((C3t, HG) => {
      l();
      "use strict";
      var ff = h0(),
        {
          toB58String: GG
        } = cr().multihash,
        NNe = VG(),
        $G = ct(),
        WG = gt(),
        YG = xe(),
        JG = Oe(),
        yx = Object.assign(JG("ipfs:ipns:pubsub"), {
          error: JG("ipfs:ipns:pubsub:error")
        }),
        XG = class {
          constructor(e, t, i) {
            this._subscriptions = {}, this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this), this._pubsubDs = new NNe(e, t, i, ff.validator, this._handleSubscriptionKey)
          }
          put(e, t) {
            return this._pubsubDs.put(e, t)
          }
          async get(e) {
            let t, i;
            try {
              t = await this._pubsubDs.get(e)
            } catch (s) {
              i = s
            }
            let n = e.slice(0, ff.namespaceLength);
            if ($G(n) === ff.namespace) {
              let s = GG(e),
                o = GG(e.slice(ff.namespaceLength));
              this._subscriptions[s] = o, yx(`subscribed to pubsub topic ${s}, id ${o}`)
            }
            if (i) throw i;
            return t
          }
          _handleSubscriptionKey(e) {
            e instanceof Uint8Array && (e = $G(e, "base58btc"));
            let t = this._subscriptions[e];
            if (!t) throw YG(new Error(`key ${e} does not correspond to a subscription`), "ERR_INVALID_KEY");
            let i;
            try {
              i = ff.getIdKeys(WG(t, "base58btc"))
            } catch (n) {
              throw yx.error(n), n
            }
            return i.routingKey.uint8Array()
          }
          getSubscriptions() {
            return Object.values(this._subscriptions).filter(Boolean).map(t => `${ff.namespace}${t}`)
          }
          async cancel(e) {
            if (typeof e != "string") throw YG(new Error("invalid subscription name"), "ERR_INVALID_SUBSCRIPTION_NAME");
            e.startsWith(ff.namespace) && (e = e.substring(ff.namespaceLength));
            let t = Object.keys(this._subscriptions).find(n => this._subscriptions[n] === e);
            if (!t) return {
              canceled: !1
            };
            let i = WG(t);
            return this._pubsubDs.unsubscribe(i), delete this._subscriptions[t], yx(`unsubscribed pubsub ${t}: ${e}`), {
              canceled: !0
            }
          }
        };
      HG.exports = XG
    });
    var e$ = y((O3t, ZG) => {
      l();
      "use strict";
      var y0 = bi(),
        QG = y0.Reader,
        qNe = y0.Writer,
        yo = y0.util,
        eg = y0.roots["libp2p-record"] || (y0.roots["libp2p-record"] = {});
      eg.Record = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.key = yo.newBuffer([]), r.prototype.value = yo.newBuffer([]), r.prototype.timeReceived = "", r.encode = function (t, i) {
          return i || (i = qNe.create()), t.key != null && Object.hasOwnProperty.call(t, "key") && i.uint32(10).bytes(t.key), t.value != null && Object.hasOwnProperty.call(t, "value") && i.uint32(18).bytes(t.value), t.timeReceived != null && Object.hasOwnProperty.call(t, "timeReceived") && i.uint32(42).string(t.timeReceived), i
        }, r.decode = function (t, i) {
          t instanceof QG || (t = QG.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new eg.Record; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.key = t.bytes();
                break;
              case 2:
                s.value = t.bytes();
                break;
              case 5:
                s.timeReceived = t.string();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof eg.Record) return t;
          var i = new eg.Record;
          return t.key != null && (typeof t.key == "string" ? yo.base64.decode(t.key, i.key = yo.newBuffer(yo.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.value != null && (typeof t.value == "string" ? yo.base64.decode(t.value, i.value = yo.newBuffer(yo.base64.length(t.value)), 0) : t.value.length && (i.value = t.value)), t.timeReceived != null && (i.timeReceived = String(t.timeReceived)), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          return i.defaults && (i.bytes === String ? n.key = "" : (n.key = [], i.bytes !== Array && (n.key = yo.newBuffer(n.key))), i.bytes === String ? n.value = "" : (n.value = [], i.bytes !== Array && (n.value = yo.newBuffer(n.value))), n.timeReceived = ""), t.key != null && t.hasOwnProperty("key") && (n.key = i.bytes === String ? yo.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.value != null && t.hasOwnProperty("value") && (n.value = i.bytes === String ? yo.base64.encode(t.value, 0, t.value.length) : i.bytes === Array ? Array.prototype.slice.call(t.value) : t.value), t.timeReceived != null && t.hasOwnProperty("timeReceived") && (n.timeReceived = t.timeReceived), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, y0.util.toJSONOptions)
        }, r
      }();
      ZG.exports = eg
    });
    var t$ = y((N3t, bx) => {
      l();
      "use strict";
      bx.exports.toRFC3339 = r => {
        let e = r.getUTCFullYear(),
          t = String(r.getUTCMonth() + 1).padStart(2, "0"),
          i = String(r.getUTCDate()).padStart(2, "0"),
          n = String(r.getUTCHours()).padStart(2, "0"),
          s = String(r.getUTCMinutes()).padStart(2, "0"),
          o = String(r.getUTCSeconds()).padStart(2, "0"),
          c = r.getUTCMilliseconds() * 1e3 * 1e3;
        return `${e}-${t}-${i}T${n}:${s}:${o}.${c}Z`
      };
      bx.exports.parseRFC3339 = r => {
        let e = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"),
          t = String(r).trim().match(e);
        if (!t) throw new Error("Invalid format");
        let i = parseInt(t[1], 10),
          n = parseInt(t[2], 10) - 1,
          s = parseInt(t[3], 10),
          o = parseInt(t[4], 10),
          a = parseInt(t[5], 10),
          c = parseInt(t[6], 10),
          u = parseInt(t[7].slice(0, -6), 10);
        return new Date(Date.UTC(i, n, s, o, a, c, u))
      }
    });
    var n$ = y((q3t, r$) => {
      l();
      "use strict";
      var {
        Record: mx
      } = e$(), i$ = t$(), tg = class {
        constructor(e, t, i) {
          if (!(e instanceof Uint8Array)) throw new Error("key must be a Uint8Array");
          if (!(t instanceof Uint8Array)) throw new Error("value must be a Uint8Array");
          this.key = e, this.value = t, this.timeReceived = i
        }
        serialize() {
          return mx.encode(this.prepareSerialize()).finish()
        }
        prepareSerialize() {
          return {
            key: this.key,
            value: this.value,
            timeReceived: this.timeReceived && i$.toRFC3339(this.timeReceived)
          }
        }
        static deserialize(e) {
          let t = mx.decode(e);
          return tg.fromDeserialized(mx.toObject(t, {
            defaults: !1,
            arrays: !0,
            longs: Number,
            objects: !1
          }))
        }
        static fromDeserialized(e) {
          let t;
          return e.timeReceived && (t = i$.parseRFC3339(e.timeReceived)), new tg(e.key, e.value, t)
        }
      };
      r$.exports = tg
    });
    var o$ = y((M3t, s$) => {
      l();
      "use strict";
      var MNe = cr(),
        Zv = xe(),
        BNe = ct(),
        DNe = Lr(),
        LNe = async (r, e) => {
          if (!(r instanceof Uint8Array)) throw Zv(new Error('"key" must be a Uint8Array'), "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
          if (r.byteLength < 5) throw Zv(new Error("invalid public key record"), "ERR_INVALID_RECORD_KEY_TOO_SHORT");
          if (BNe(r.subarray(0, 4)) !== "/pk/") throw Zv(new Error("key was not prefixed with /pk/"), "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
          let i = r.slice(4),
            n = await MNe(e, "sha2-256");
          if (!DNe(i, n)) throw Zv(new Error("public key does not match passed in key"), "ERR_INVALID_RECORD_HASH_MISMATCH")
        };
      s$.exports = {
        func: LNe,
        sign: !1
      }
    });
    var c$ = y((B3t, a$) => {
      l();
      "use strict";
      a$.exports = {
        pk: o$()
      }
    });
    var f$ = y((D3t, u$) => {
      l();
      "use strict";
      var FNe = xe(),
        UNe = ct(),
        KNe = (r, e) => {
          let t = e.key,
            n = UNe(t).split("/");
          if (n.length < 3) return;
          let s = r[n[1].toString()];
          if (!s) {
            let o = "Invalid record keytype";
            throw FNe(new Error(o), "ERR_INVALID_RECORD_KEY_TYPE")
          }
          return s.func(t, e.value)
        };
      u$.exports = {
        verifyRecord: KNe,
        validators: c$()
      }
    });
    var h$ = y((L3t, l$) => {
      l();
      "use strict";
      var zNe = (r, e) => 0;
      l$.exports = zNe
    });
    var p$ = y((F3t, d$) => {
      l();
      "use strict";
      d$.exports = {
        pk: h$()
      }
    });
    var g$ = y((U3t, y$) => {
      l();
      "use strict";
      var vx = xe(),
        jNe = ct(),
        VNe = (r, e, t) => {
          if (t.length === 0) {
            let o = "No records given";
            throw vx(new Error(o), "ERR_NO_RECORDS_RECEIVED")
          }
          let n = jNe(e).split("/");
          if (n.length < 3) {
            let o = "Record key does not have a selector function";
            throw vx(new Error(o), "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY")
          }
          let s = r[n[1].toString()];
          if (!s) {
            let o = `Unrecognized key prefix: ${n[1]}`;
            throw vx(new Error(o), "ERR_UNRECOGNIZED_KEY_PREFIX")
          }
          return s(e, t)
        };
      y$.exports = {
        bestRecord: VNe,
        selectors: p$()
      }
    });
    var Nl = y((K3t, b$) => {
      l();
      "use strict";
      b$.exports = {
        Record: n$(),
        validator: f$(),
        selection: g$()
      }
    });
    var wx = y((z3t, m$) => {
      l();
      "use strict";
      var v$ = h0(),
        HNe = ct();
      m$.exports = {
        encodeBase32: r => HNe(r, "base32upper"),
        validator: {
          func: (r, e) => v$.validator.validate(e, r)
        },
        selector: (r, e) => v$.validator.select(e[0], e[1])
      }
    });
    var Ex = y((w$, _$) => {
      l();
      "use strict";
      var {
        Key: GNe
      } = fr(), {
        Record: E$
      } = Nl(), {
        encodeBase32: $Ne
      } = wx(), rg = xe(), S$ = Oe(), _x = Object.assign(S$("ipfs:ipns:offline-datastore"), {
        error: S$("ipfs:ipns:offline-datastore:error")
      }), x$ = class {
        constructor(e) {
          this._repo = e, this.stores = []
        }
        async put(e, t) {
          if (!(e instanceof Uint8Array)) throw rg(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
          if (!(t instanceof Uint8Array)) throw rg(new Error("Offline datastore value must be a Uint8Array"), "ERR_INVALID_VALUE");
          let i;
          try {
            i = this._routingKey(e)
          } catch (s) {
            throw _x.error(s), rg(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY")
          }
          let n = new E$(e, t);
          return this._repo.datastore.put(i, n.serialize())
        }
        async get(e) {
          if (!(e instanceof Uint8Array)) throw rg(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
          let t;
          try {
            t = this._routingKey(e)
          } catch (s) {
            throw _x.error(s), rg(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY")
          }
          let i = await this._repo.datastore.get(t),
            n;
          try {
            n = E$.deserialize(i)
          } catch (s) {
            throw _x.error(s), s
          }
          return n.value
        }
        _routingKey(e) {
          return new GNe("/" + $Ne(e), !1)
        }
      };
      w$ = _$.exports = x$
    });
    var I$ = y((j3t, A$) => {
      l();
      "use strict";
      var {
        TieredDatastore: WNe
      } = Yv(), Sx = Qy(), YNe = gx(), JNe = Ex();
      A$.exports = ({
        libp2p: r,
        repo: e,
        peerId: t,
        options: i
      }) => {
        let n = [],
          s;
        if (Sx(i, "EXPERIMENTAL.ipnsPubsub", !1)) {
          let o = r.pubsub,
            a = e.datastore;
          s = new YNe(o, a, t), n.push(s)
        }
        if (Sx(i, "offline") || !Sx(i, "libp2p.config.dht.enabled", !1)) {
          let o = new JNe(e);
          n.push(o)
        } else n.push(r._dht);
        return new WNe(n)
      }
    });
    var C$ = y((V3t, T$) => {
      l();
      "use strict";
      var R$ = tG(),
        XNe = I$(),
        ZNe = Ex(),
        {
          NotInitializedError: QNe,
          AlreadyInitializedError: k$
        } = of(),
        eqe = Oe()("ipfs:components:ipns"),
        P$ = class {
          constructor(e = {
            pass: ""
          }) {
            this.options = e, this.offline = null, this.online = null
          }
          getIPNS() {
            let e = this.online || this.offline;
            if (e) return e;
            throw new QNe
          }
          get routing() {
            return this.getIPNS().routing
          }
          startOffline({
            repo: e,
            peerId: t,
            keychain: i
          }) {
            if (this.offline != null) throw new k$;
            eqe("initializing IPNS keyspace");
            let n = new ZNe(e),
              s = new R$(n, e.datastore, t, i, this.options);
            this.offline = s
          }
          async startOnline({
            libp2p: e,
            repo: t,
            peerId: i,
            keychain: n
          }) {
            if (this.online != null) throw new k$;
            let s = XNe({
              libp2p: e,
              repo: t,
              peerId: i,
              options: this.options
            }),
              o = new R$(s, t.datastore, i, n, this.options);
            await o.republisher.start(), this.online = o
          }
          async stop() {
            let e = this.online;
            e && (await e.republisher.stop(), this.online = null)
          }
          publish(e, t, i) {
            return this.getIPNS().publish(e, t, i)
          }
          resolve(e, t) {
            return this.getIPNS().resolve(e, t)
          }
          initializeKeyspace(e, t) {
            return this.getIPNS().initializeKeyspace(e, t)
          }
        };
      T$.exports = P$
    });
    var N$ = y(O$ => {
      l();
      "use strict";
      var tqe = Sl(),
        rqe = Sy(),
        iqe = Vd();
      O$.resolvePath = async ({
        ipns: r,
        ipld: e
      }, t) => {
        if (tqe.ipnsPath(t)) return r.resolve(t);
        let {
          cid: i,
          path: n
        } = rqe(t);
        await iqe(e.resolve(i, n || ""))
      }
    });
    var D$ = y((G3t, q$) => {
      l();
      "use strict";
      var M$ = Oe(),
        {
          default: nqe
        } = av(),
        sqe = Ja(),
        B$ = xe(),
        oqe = gt(),
        aqe = ct(),
        xx = Object.assign(M$("ipfs:name:publish"), {
          error: M$("ipfs:name:publish:error")
        }),
        {
          OFFLINE_ERROR: cqe,
          normalizePath: uqe
        } = Ji(),
        fqe = ze(),
        {
          resolvePath: lqe
        } = N$();
      q$.exports = ({
        ipns: r,
        ipld: e,
        peerId: t,
        isOnline: i,
        keychain: n
      }) => {
        let s = async a => {
          if (a === "self") return t.privKey;
          try {
            let c = await n.exportKey(a, "temp");
            return await sqe.keys.import(c, "temp")
          } catch (c) {
            throw xx.error(c), B$(c, "ERR_CANNOT_GET_KEY")
          }
        };
        async function o(a, c = {}) {
          let u = c.resolve !== !1,
            f = c.lifetime || "24h",
            h = c.key || "self";
          if (!i()) throw B$(new Error(cqe), "OFFLINE_ERROR");
          try {
            a = uqe(a)
          } catch (E) {
            throw xx.error(E), E
          }
          let d = 0;
          try {
            d = nqe(f) || 0, d = parseFloat(d.toFixed(6))
          } catch (E) {
            throw xx.error(E), E
          }
          let p = await Promise.all([s(h), u ? lqe({
            ipns: r,
            ipld: e
          }, a) : Promise.resolve()]),
            g = oqe(a),
            m = await r.publish(p[0], g, d);
          return {
            name: m.name,
            value: aqe(m.value)
          }
        }
        return fqe(o)
      }
    });
    var F$ = y(($3t, L$) => {
      l();
      "use strict";
      var hqe = /^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;
      L$.exports = function (e, t) {
        if (t == null && (t = !1), e.length < 2 || e.length > 255) return !1;
        var i = e[e.length - 1];
        if (t) {
          if (i !== ".") return !1
        } else if (i === ".") return !1;
        return hqe.test(e)
      }
    });
    var j$ = y((W3t, U$) => {
      l();
      "use strict";
      var K$ = Oe(),
        Ax = xe(),
        {
          mergeOptions: dqe
        } = Ji(),
        pqe = at(),
        yqe = F$(),
        gqe = ct(),
        bqe = Object.assign(K$("ipfs:name:resolve"), {
          error: K$("ipfs:name:resolve:error")
        }),
        {
          OFFLINE_ERROR: mqe
        } = Ji(),
        vqe = ze(),
        z$ = (r, e) => e.length > 0 ? r + "/" + e.join("/") : r;
      U$.exports = ({
        dns: r,
        ipns: e,
        peerId: t,
        isOnline: i,
        options: {
          offline: n
        }
      }) => {
        async function* s(o, a = {}) {
          if (a = dqe({
            nocache: !1,
            recursive: !0
          }, a), n && a && a.nocache) throw Ax(new Error("cannot specify both offline and nocache"), "ERR_NOCACHE_AND_OFFLINE");
          o || (o = t.toB58String()), o.startsWith("/ipns/") || (o = `/ipns/${o}`);
          let [c, u, ...f] = o.slice(1).split("/");
          try {
            new pqe(u)
          } catch (d) {
            if (yqe(u)) {
              yield z$(await r(u, a), f);
              return
            }
            throw bqe.error(d), Ax(new Error("Invalid IPNS name"), "ERR_IPNS_INVALID_NAME")
          }
          if (!i() && !n) throw Ax(new Error(mqe), "OFFLINE_ERROR");
          let h = await e.resolve(`/${c}/${u}`, a);
          yield z$(h instanceof Uint8Array ? gqe(h) : h, f)
        }
        return vqe(s)
      }
    });
    var Qv = y(V$ => {
      l();
      "use strict";
      var H$ = gx(),
        G$ = xe();
      V$.getPubsubRouting = (r, e) => {
        if (!r || !(e && e.ipnsPubsub)) throw G$(new Error("IPNS pubsub subsystem is not enabled"), "ERR_IPNS_PUBSUB_NOT_ENABLED");
        if (r.routing instanceof H$) return r.routing;
        let t = (r.routing.stores || []).find(i => i instanceof H$);
        if (!t) throw G$(new Error("IPNS pubsub datastore not found"), "ERR_PUBSUB_DATASTORE_NOT_FOUND");
        return t
      }
    });
    var W$ = y((J3t, $$) => {
      l();
      "use strict";
      var {
        getPubsubRouting: wqe
      } = Qv(), _qe = ze();
      $$.exports = ({
        ipns: r,
        options: e
      }) => {
        let t = e.EXPERIMENTAL;
        async function i(n, s = {}) {
          return wqe(r, t).cancel(n, s)
        }
        return _qe(i)
      }
    });
    var J$ = y((X3t, Y$) => {
      l();
      "use strict";
      var {
        getPubsubRouting: Eqe
      } = Qv(), Sqe = ze();
      Y$.exports = ({
        ipns: r,
        options: e
      }) => {
        let t = e.EXPERIMENTAL;
        async function i(n = {}) {
          try {
            return {
              enabled: Boolean(Eqe(r, t))
            }
          } catch (s) {
            return {
              enabled: !1
            }
          }
        }
        return Sqe(i)
      }
    });
    var Z$ = y((Z3t, X$) => {
      l();
      "use strict";
      var {
        getPubsubRouting: xqe
      } = Qv(), Aqe = ze();
      X$.exports = ({
        ipns: r,
        options: e
      }) => {
        let t = e.EXPERIMENTAL;
        async function i(n = {}) {
          return xqe(r, t).getSubscriptions(n)
        }
        return Aqe(i)
      }
    });
    var tW = y((Q3t, Q$) => {
      l();
      "use strict";
      var Iqe = W$(),
        Tqe = J$(),
        Rqe = Z$(),
        eW = class {
          constructor({
            ipns: e,
            options: t
          }) {
            this.cancel = Iqe({
              ipns: e,
              options: t
            }), this.state = Tqe({
              ipns: e,
              options: t
            }), this.subs = Rqe({
              ipns: e,
              options: t
            })
          }
        };
      Q$.exports = eW
    });
    var nW = y((e_t, rW) => {
      l();
      "use strict";
      var kqe = D$(),
        Pqe = j$(),
        Cqe = tW(),
        iW = class {
          constructor({
            dns: e,
            ipns: t,
            ipld: i,
            peerId: n,
            isOnline: s,
            keychain: o,
            options: a
          }) {
            this.publish = kqe({
              ipns: t,
              ipld: i,
              peerId: n,
              isOnline: s,
              keychain: o
            }), this.resolve = Pqe({
              dns: e,
              ipns: t,
              peerId: n,
              isOnline: s,
              options: a
            }), this.pubsub = new Cqe({
              ipns: t,
              options: a
            })
          }
        };
      rW.exports = iW
    });
    var aW = y((t_t, Ix) => {
      l();
      "use strict";
      var Oqe = at(),
        {
          DAGNode: Nqe
        } = Mr(),
        {
          Errors: qqe
        } = fr(),
        Mqe = qqe.notFoundError().code,
        Bqe = ze(),
        sW = Sy(),
        ew = {
          default: "<dst>",
          edges: "<src> -> <dst>"
        };
      Ix.exports = function ({
        ipld: r,
        resolve: e,
        preload: t
      }) {
        async function* i(n, s = {}) {
          if (s.maxDepth === 0) return;
          if (s.edges && s.format && s.format !== ew.default) throw new Error("Cannot set edges to true and also specify format");
          s.format = s.edges ? ew.edges : s.format, typeof s.maxDepth != "number" && (s.maxDepth = s.recursive ? Infinity : 1);
          let a = (Array.isArray(n) ? n : [n]).map(c => Dqe(t, c, s));
          for (let c of a) yield* Lqe(e, r, c, s)
        }
        return Bqe(i)
      };
      Ix.exports.Format = ew;

      function Dqe(r, e, t) {
        let {
          cid: i,
          path: n
        } = sW(e);
        return t.preload !== !1 && r(i), `/ipfs/${i}${n || ""}`
      }
      async function* Lqe(r, e, t, i) {
        let n = await r(t),
          {
            cid: s
          } = sW(n),
          o = i.maxDepth != null ? i.maxDepth : Infinity,
          a = i.unique || !1;
        for await (let c of Uqe(e, s, o, a)) !c.parent || c.isDuplicate || (yield {
          ref: Fqe(c.parent.cid, c.node.cid, c.node.name, i.format)
        })
      }

      function Fqe(r, e, t = "", i = ew.default) {
        let n = i.replace(/<src>/g, r.toString());
        return n = n.replace(/<dst>/g, e.toString()), n = n.replace(/<linkname>/g, t), n
      }
      async function* Uqe(r, e, t, i) {
        let n = new Set;
        async function* s(o, a) {
          let c = a + 1;
          if (!(c > t)) try {
            for (let u of await Kqe(r, o.cid)) yield {
              parent: o,
              node: u,
              isDuplicate: i && n.has(u.cid.toString())
            }, i && n.add(u.cid.toString()), yield* s(u, c)
          } catch (u) {
            throw u.code === Mqe && (u.message = `Could not find object with CID: ${o.cid}`), u
          }
        }
        yield* s({
          cid: e
        }, 0)
      }
      async function Kqe(r, e) {
        let t = await r.get(e);
        if (t instanceof Nqe) {
          let i = ({
            Name: n,
            Hash: s
          }) => ({
            name: n,
            cid: s
          });
          return t.Links.map(i)
        }
        return oW(t)
      }

      function oW(r, e = "") {
        let t = [];
        for (let [i, n] of Object.entries(r)) Oqe.isCID(n) ? t.push({
          name: e + i,
          cid: n
        }) : typeof n == "object" && (t = t.concat(oW(n, e + i + "/")));
        return t
      }
    });
    var uW = y((r_t, cW) => {
      l();
      "use strict";
      var zqe = ze();
      cW.exports = function ({
        repo: r
      }) {
        async function* e(t = {}) {
          for await (let i of r.blocks.queryKeys({}, {
            signal: t.signal
          })) yield {
            ref: i.toString()
          }
        }
        return zqe(e)
      }
    });
    var lW = y((i_t, fW) => {
      l();
      "use strict";
      var jqe = ze();
      fW.exports = ({
        network: r
      }) => {
        async function e(t = {}) {
          let {
            bitswap: i
          } = await r.use(t), n = i.getWantlist();
          return Array.from(n).map(s => s[1].cid)
        }
        return jqe(e)
      }
    });
    var dW = y((n_t, hW) => {
      l();
      "use strict";
      var Vqe = Et(),
        Hqe = ze();
      hW.exports = ({
        network: r
      }) => {
        async function e(t, i = {}) {
          let {
            bitswap: n
          } = await r.use(i), s = n.wantlistForPeer(Vqe.createFromCID(t), i);
          return Array.from(s).map(o => o[1].cid)
        }
        return Hqe(e)
      }
    });
    var yW = y((s_t, pW) => {
      l();
      "use strict";
      var Gqe = at(),
        $qe = xe(),
        Wqe = ze();
      pW.exports = ({
        network: r
      }) => {
        async function e(t, i = {}) {
          let {
            bitswap: n
          } = await r.use(i);
          Array.isArray(t) || (t = [t]);
          try {
            t = t.map(s => new Gqe(s))
          } catch (s) {
            throw $qe(s, "ERR_INVALID_CID")
          }
          return n.unwant(t)
        }
        return Wqe(e)
      }
    });
    var Tx = y((o_t, gW) => {
      l();
      "use strict";
      var Yqe = ze();
      gW.exports = ({
        network: r
      }) => {
        async function e(t = {}) {
          let i = (await r.use(t)).bitswap,
            n = i.stat().snapshot;
          return {
            provideBufLen: parseInt(n.providesBufferLength.toString()),
            blocksReceived: BigInt(n.blocksReceived.toString()),
            wantlist: Array.from(i.getWantlist()).map(s => s[1].cid),
            peers: i.peers().map(s => s.toB58String()),
            dupBlksReceived: BigInt(n.dupBlksReceived.toString()),
            dupDataReceived: BigInt(n.dupDataReceived.toString()),
            dataReceived: BigInt(n.dataReceived.toString()),
            blocksSent: BigInt(n.blocksSent.toString()),
            dataSent: BigInt(n.dataSent.toString())
          }
        }
        return Yqe(e)
      }
    });
    var vW = y((a_t, bW) => {
      l();
      "use strict";
      var Jqe = lW(),
        Xqe = dW(),
        Zqe = yW(),
        Qqe = Tx(),
        mW = class {
          constructor({
            network: e
          }) {
            this.wantlist = Jqe({
              network: e
            }), this.wantlistForPeer = Xqe({
              network: e
            }), this.unwant = Zqe({
              network: e
            }), this.stat = Qqe({
              network: e
            })
          }
        };
      bW.exports = mW
    });
    var Rx = y(wW => {
      l();
      "use strict";
      var eMe = El().IPFS.matches;
      wW.isValidMultiaddr = r => {
        try {
          return eMe(r)
        } catch (e) {
          return !1
        }
      }
    });
    var EW = y((u_t, _W) => {
      l();
      "use strict";
      var {
        isValidMultiaddr: tMe
      } = Rx(), rMe = ze();
      _W.exports = ({
        repo: r
      }) => {
        async function e(t, i = {}) {
          if (!tMe(t)) throw new Error(`${t} is not a valid Multiaddr`);
          let n = await r.config.getAll(i),
            s = n.Bootstrap || [];
          return s.push(t.toString()), n.Bootstrap = Array.from(new Set(s)).sort((o, a) => o.localeCompare(a)), await r.config.replace(n), {
            Peers: [t]
          }
        }
        return rMe(e)
      }
    });
    var xW = y((f_t, SW) => {
      l();
      "use strict";
      var iMe = ze(),
        {
          Multiaddr: nMe
        } = pr();
      SW.exports = ({
        repo: r
      }) => {
        async function e(t = {}) {
          let i = await r.config.getAll(t),
            n = i.Bootstrap || [];
          return i.Bootstrap = [], await r.config.replace(i), {
            Peers: n.map(s => new nMe(s))
          }
        }
        return iMe(e)
      }
    });
    var IW = y((l_t, AW) => {
      l();
      "use strict";
      var sMe = ze(),
        {
          Multiaddr: oMe
        } = pr();
      AW.exports = ({
        repo: r
      }) => {
        async function e(t = {}) {
          return {
            Peers: (await r.config.get("Bootstrap", t) || []).map(n => new oMe(n))
          }
        }
        return sMe(e)
      }
    });
    var tw = y((h_t, TW) => {
      l();
      "use strict";
      TW.exports = () => ({
        Addresses: {
          Swarm: [],
          Announce: [],
          NoAnnounce: [],
          API: "",
          Gateway: "",
          RPC: "",
          Delegates: ["/dns4/node0.delegate.ipfs.io/tcp/443/https", "/dns4/node1.delegate.ipfs.io/tcp/443/https", "/dns4/node2.delegate.ipfs.io/tcp/443/https", "/dns4/node3.delegate.ipfs.io/tcp/443/https"]
        },
        Discovery: {
          MDNS: {
            Enabled: !1,
            Interval: 10
          },
          webRTCStar: {
            Enabled: !0
          }
        },
        Bootstrap: ["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN", "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb", "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp", "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa", "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt", "/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic", "/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6", "/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS", "/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"],
        Pubsub: {
          Enabled: !0
        },
        Swarm: {
          ConnMgr: {
            LowWater: 200,
            HighWater: 500
          },
          DisableNatPortMap: !0
        },
        Routing: {
          Type: "none"
        }
      })
    });
    var PW = y((d_t, RW) => {
      l();
      "use strict";
      var kW = tw(),
        aMe = ze(),
        {
          Multiaddr: cMe
        } = pr();
      RW.exports = ({
        repo: r
      }) => {
        async function e(t = {}) {
          let i = await r.config.getAll(t);
          return i.Bootstrap = kW().Bootstrap, await r.config.replace(i), {
            Peers: kW().Bootstrap.map(n => new cMe(n))
          }
        }
        return aMe(e)
      }
    });
    var OW = y((p_t, CW) => {
      l();
      "use strict";
      var {
        isValidMultiaddr: uMe
      } = Rx(), fMe = ze();
      CW.exports = ({
        repo: r
      }) => {
        async function e(t, i = {}) {
          if (!uMe(t)) throw new Error(`${t} is not a valid Multiaddr`);
          let n = await r.config.getAll(i);
          return n.Bootstrap = (n.Bootstrap || []).filter(s => s.toString() !== t.toString()), await r.config.replace(n), {
            Peers: [t]
          }
        }
        return fMe(e)
      }
    });
    var MW = y((y_t, NW) => {
      l();
      "use strict";
      var lMe = EW(),
        hMe = xW(),
        dMe = IW(),
        pMe = PW(),
        yMe = OW(),
        qW = class {
          constructor({
            repo: e
          }) {
            this.add = lMe({
              repo: e
            }), this.list = dMe({
              repo: e
            }), this.rm = yMe({
              repo: e
            }), this.clear = hMe({
              repo: e
            }), this.reset = pMe({
              repo: e
            })
          }
        };
      NW.exports = qW
    });
    var rw = y(BW => {
      l();
      "use strict";
      var DW = at(),
        gMe = xe();
      BW.cleanCid = r => {
        if (DW.isCID(r)) return r;
        try {
          return new DW(r)
        } catch (e) {
          throw gMe(e, "ERR_INVALID_CID")
        }
      }
    });
    var FW = y((b_t, LW) => {
      l();
      "use strict";
      var {
        cleanCid: bMe
      } = rw(), mMe = ze();
      LW.exports = ({
        blockService: r,
        preload: e
      }) => {
        async function t(i, n = {}) {
          return i = bMe(i), n.preload !== !1 && e(i), r.get(i, n)
        }
        return mMe(t)
      }
    });
    var KW = y((m_t, UW) => {
      UW.exports = {
        _args: [
          ["ipld-block@0.11.1", "/Users/alex/Documents/Workspaces/ipfs/js-ipfs"]
        ],
        _from: "ipld-block@0.11.1",
        _id: "ipld-block@0.11.1",
        _inBundle: !1,
        _integrity: "sha512-sDqqLqD5qh4QzGq6ssxLHUCnH4emCf/8F8IwjQM2cjEEIEHMUj57XhNYgmGbemdYPznUhffxFGEHsruh5+HQRw==",
        _location: "/ipld-block",
        _phantomChildren: {},
        _requested: {
          type: "version",
          registry: !0,
          raw: "ipld-block@0.11.1",
          name: "ipld-block",
          escapedName: "ipld-block",
          rawSpec: "0.11.1",
          saveSpec: null,
          fetchSpec: "0.11.1"
        },
        _requiredBy: ["/", "/ipfs-bitswap", "/ipfs-repo", "/ipld"],
        _resolved: "https://registry.npmjs.org/ipld-block/-/ipld-block-0.11.1.tgz",
        _spec: "0.11.1",
        _where: "/Users/alex/Documents/Workspaces/ipfs/js-ipfs",
        bugs: {
          url: "https://github.com/ipld/js-ipld-block/issues"
        },
        contributors: [{
          name: "David Dias",
          email: "daviddias.p@gmail.com"
        }, {
          name: "Volker Mische",
          email: "volker.mische@gmail.com"
        }, {
          name: "Friedel Ziegelmayer",
          email: "dignifiedquire@gmail.com"
        }, {
          name: "Irakli Gozalishvili",
          email: "contact@gozala.io"
        }, {
          name: "achingbrain",
          email: "alex@achingbrain.net"
        }, {
          name: "\u1D20\u026A\u1D04\u1D1B\u1D0F\u0280 \u0299\u1D0A\u1D07\u029F\u1D0B\u029C\u1D0F\u029F\u1D0D",
          email: "victorbjelkholm@gmail.com"
        }, {
          name: "Alan Shaw",
          email: "alan.shaw@protocol.ai"
        }, {
          name: "Charlie",
          email: "the_charlie_daly@hotmail.co.uk"
        }, {
          name: "Diogo Silva",
          email: "fsdiogo@gmail.com"
        }, {
          name: "Hugo Dias",
          email: "hugomrdias@gmail.com"
        }, {
          name: "Mikeal Rogers",
          email: "mikeal.rogers@gmail.com"
        }, {
          name: "Richard Littauer",
          email: "richard.littauer@gmail.com"
        }, {
          name: "Richard Schneider",
          email: "makaretu@gmail.com"
        }, {
          name: "Xmader",
          email: "xmader@outlook.com"
        }],
        dependencies: {
          cids: "^1.0.0"
        },
        description: "JavaScript Implementation of IPLD Block",
        devDependencies: {
          aegir: "^31.0.4",
          uint8arrays: "^2.1.3"
        },
        engines: {
          node: ">=6.0.0",
          npm: ">=3.0.0"
        },
        homepage: "https://github.com/ipld/js-ipld-block#readme",
        keywords: ["IPLD"],
        leadMaintainer: "Volker Mische <volker.mische@gmail.com>",
        license: "MIT",
        main: "src/index.js",
        name: "ipld-block",
        "pre-push": ["lint", "test"],
        repository: {
          type: "git",
          url: "git+https://github.com/ipld/js-ipld-block.git"
        },
        scripts: {
          check: "tsc --noEmit --noErrorTruncation",
          coverage: "aegir coverage",
          "coverage-publish": "aegir coverage --provider coveralls",
          docs: "aegir docs",
          lint: "aegir lint",
          prepare: "aegir build --no-bundle",
          prepublishOnly: "aegir build",
          release: "aegir release --docs",
          "release-major": "aegir release --type major --docs",
          "release-minor": "aegir release --type minor --docs",
          test: "aegir test",
          "test:browser": "aegir test --target browser",
          "test:node": "aegir test --target node"
        },
        types: "dist/src/index.d.ts",
        version: "0.11.1"
      }
    });
    var ql = y((v_t, zW) => {
      l();
      "use strict";
      var vMe = at(),
        {
          version: wMe
        } = KW(),
        jW = Symbol.for("@ipld/js-ipld-block/block"),
        VW = {
          writable: !1,
          configurable: !1,
          enumerable: !0
        },
        HW = class {
          constructor(e, t) {
            if (!e || !(e instanceof Uint8Array)) throw new Error("first argument  must be a Uint8Array");
            if (!t || !vMe.isCID(t)) throw new Error("second argument must be a CID");
            this.data = e, this.cid = t, Object.defineProperties(this, {
              data: VW,
              cid: VW
            })
          }
          get _data() {
            return EMe(), this.data
          }
          get _cid() {
            return _Me(), this.cid
          }
          get [Symbol.toStringTag]() {
            return "Block"
          }
          get [jW]() {
            return !0
          }
          static isBlock(e) {
            return Boolean(e && e[jW])
          }
        },
        GW = (r, e) => {
          let t = !1;
          return () => {
            if (r.test(wMe)) t || (t = !0, console.warn(e));
            else throw new Error(e)
          }
        },
        _Me = GW(/^0\.10|^0\.11/, "block._cid is deprecated and will be removed in 0.12 release. Please use block.cid instead"),
        EMe = GW(/^0\.10|^0.11/, "block._data is deprecated and will be removed in 0.12 release. Please use block.data instead");
      zW.exports = HW
    });
    var WW = y((w_t, $W) => {
      l();
      "use strict";
      var kx = ql(),
        SMe = cr(),
        Px = at(),
        xMe = Sl(),
        AMe = ze();
      $W.exports = ({
        blockService: r,
        pin: e,
        gcLock: t,
        preload: i
      }) => {
        async function n(s, o = {}) {
          if (Array.isArray(s)) throw new Error("Array is not supported");
          if (!kx.isBlock(s)) {
            let c = s;
            if (o.cid && xMe.cid(o.cid)) {
              let u = Px.isCID(o.cid) ? o.cid : new Px(o.cid);
              s = new kx(c, u)
            } else {
              let u = o.mhtype || "sha2-256",
                f = o.format || "dag-pb",
                h = 1;
              o.version == null ? h = u === "sha2-256" && f === "dag-pb" ? 0 : 1 : h = o.version;
              let d = await SMe(c, u),
                p = new Px(h, f, d);
              s = new kx(c, p)
            }
          }
          let a = await t.readLock();
          try {
            return await r.put(s, {
              signal: o.signal
            }), o.preload !== !1 && i(s.cid), o.pin === !0 && await e.add(s.cid, {
              recursive: !0,
              signal: o.signal
            }), s
          } finally {
            a()
          }
        }
        return AMe(n)
      }
    });
    var Ml = y((iw, YW) => {
      l();
      (function (r, e) {
        typeof iw == "object" && typeof YW != "undefined" ? e(iw) : typeof define == "function" && define.amd ? define(["exports"], e) : (r = typeof globalThis != "undefined" ? globalThis : r || self, e(r.streamingIterables = {}))
      })(iw, function (r) {
        "use strict";
        async function* e(k, F) {
          let B = [];
          for await (let L of F) B.push(L), B.length === k && (yield B, B = []);
          B.length > 0 && (yield B)
        }

        function* t(k, F) {
          let B = [];
          for (let L of F) B.push(L), B.length === k && (yield B, B = []);
          B.length > 0 && (yield B)
        }

        function i(k, F) {
          return F === void 0 ? B => i(k, B) : F[Symbol.asyncIterator] ? e(k, F) : t(k, F)
        }

        function n(k) {
          if (typeof k.next == "function") return k;
          if (typeof k[Symbol.iterator] == "function") return k[Symbol.iterator]();
          if (typeof k[Symbol.asyncIterator] == "function") return k[Symbol.asyncIterator]();
          throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols')
        }

        function s() {
          let k, F;
          return {
            promise: new Promise((L, $) => {
              F = L, k = $
            }),
            reject: k,
            resolve: F
          }
        }

        function o(k, F) {
          let B = n(F),
            L = [],
            $ = [],
            ie = !1,
            ne = !1;

          function pe() {
            for (; $.length > 0 && L.length > 0;) {
              let Re = $.shift(),
                {
                  error: $e,
                  value: Ke
                } = L.shift();
              $e ? Re.reject($e) : Re.resolve({
                done: !1,
                value: Ke
              })
            }
            for (; $.length > 0 && ne;) {
              let {
                resolve: Re
              } = $.shift();
              Re({
                done: !0,
                value: void 0
              })
            }
          }
          async function be() {
            if (!ne && !ie && !(L.length >= k)) {
              ie = !0;
              try {
                let {
                  done: Re,
                  value: $e
                } = await B.next();
                Re ? ne = !0 : L.push({
                  value: $e
                })
              } catch (Re) {
                ne = !0, L.push({
                  error: Re
                })
              }
              pe(), ie = !1, be()
            }
          }
          async function de() {
            if (L.length > 0) {
              let {
                error: $e,
                value: Ke
              } = L.shift();
              if ($e) throw $e;
              return be(), {
                done: !1,
                value: Ke
              }
            }
            if (ne) return {
              done: !0,
              value: void 0
            };
            let Re = s();
            return $.push(Re), be(), Re.promise
          }
          let Ne = {
            next: de,
            [Symbol.asyncIterator]: () => Ne
          };
          return Ne
        }

        function* a(k, F) {
          let B = [],
            L;
          try {
            for (let $ of F) B.push($), !(B.length <= k) && (yield B.shift())
          } catch ($) {
            L = $
          }
          for (let $ of B) yield $;
          if (L) throw L
        }

        function c(k, F) {
          return F === void 0 ? B => c(k, B) : k === 0 ? F : F[Symbol.asyncIterator] ? o(k, F) : a(k, F)
        }
        async function u(k) {
          let F = [];
          for await (let B of k) F.push(B);
          return F
        }

        function f(k) {
          return k[Symbol.asyncIterator] ? u(k) : Array.from(k)
        }
        async function* h(k) {
          for await (let F of k) yield* F
        }

        function* d(k) {
          for (let F of k) yield* F
        }

        function p(...k) {
          return k.find(B => B[Symbol.asyncIterator] !== void 0) ? h(k) : d(k)
        }
        async function g(k) {
          for await (let F of k);
        }

        function m(k) {
          if (k[Symbol.asyncIterator]) return g(k);
          for (let F of k);
        }
        async function* E(k, F) {
          for await (let B of F) await k(B) && (yield B)
        }

        function w(k, F) {
          return F === void 0 ? B => E(k, B) : E(k, F)
        }
        async function* O(k) {
          for await (let F of k) F && typeof F != "string" && (F[Symbol.iterator] || F[Symbol.asyncIterator]) ? yield* O(F) : yield F
        }
        async function* q(k, F) {
          for await (let B of F) yield await k(B)
        }

        function J(k, F) {
          return F === void 0 ? B => q(k, B) : q(k, F)
        }

        function Z(k, F) {
          return F === void 0 ? B => Z(k, B) : w(B => B != null, O(J(k, F)))
        }

        function H(k, F, B) {
          let L = n(B),
            $ = [],
            ie = [],
            ne = !1,
            pe = !1,
            be = 0,
            de = null;

          function Ne() {
            for (; ie.length > 0 && $.length > 0;) {
              let {
                resolve: Ie
              } = ie.shift(), tt = $.shift();
              Ie({
                done: !1,
                value: tt
              })
            }
            for (; ie.length > 0 && be === 0 && ne;) {
              let {
                resolve: Ie,
                reject: tt
              } = ie.shift();
              de ? (tt(de), de = null) : Ie({
                done: !0,
                value: void 0
              })
            }
          }
          async function Re() {
            if (ne) {
              Ne();
              return
            }
            if (!pe && !(be + $.length >= k)) {
              pe = !0, be++;
              try {
                let {
                  done: Ie,
                  value: tt
                } = await L.next();
                Ie ? (ne = !0, be--, Ne()) : $e(tt)
              } catch (Ie) {
                ne = !0, be--, de = Ie, Ne()
              }
              pe = !1, Re()
            }
          }
          async function $e(Ie) {
            try {
              let tt = await F(Ie);
              if (tt && tt[Symbol.asyncIterator])
                for await (let nt of tt) $.push(nt);
              else $.push(tt)
            } catch (tt) {
              ne = !0, de = tt
            }
            be--, Ne(), Re()
          }
          async function Ke() {
            if ($.length === 0) {
              let tt = s();
              return ie.push(tt), Re(), tt.promise
            }
            let Ie = $.shift();
            return Re(), {
              done: !1,
              value: Ie
            }
          }
          let Me = {
            next: Ke,
            [Symbol.asyncIterator]: () => Me
          };
          return Me
        }

        function te(k, F, B) {
          return F === void 0 ? (L, $) => $ ? te(k, L, $) : te(k, L) : B === void 0 ? L => te(k, F, L) : w(L => L != null, O(H(k, F, B)))
        }
        async function ae(k) {
          return new Promise(F => {
            k.once("readable", () => {
              F()
            })
          })
        }
        async function* oe(k) {
          for (; ;) {
            let F = k.read();
            if (F !== null) {
              yield F;
              continue
            }
            if (k._readableState.ended) break;
            await ae(k)
          }
        }

        function U(k) {
          return typeof k[Symbol.asyncIterator] == "function" ? k : oe(k)
        }
        async function* b(...k) {
          let F = new Set(k.map(n));
          for (; F.size > 0;)
            for (let B of F) {
              let L = await B.next();
              L.done ? F.delete(B) : yield L.value
            }
        }

        function _(k, ...F) {
          let B = k();
          for (let L of F) B = L(B);
          return B
        }
        async function* R(k, F, B) {
          let L = null,
            $ = be => ({
              value: F(be)
            }),
            ie = async function* (be) {
              for await (let de of be) {
                if (L) return;
                yield de
              }
            }, ne = _(() => B, c(1), ie, J($), c(k - 1)), pe = n(ne);
          for (; ;) {
            let {
              value: be,
              done: de
            } = await pe.next();
            if (de) break;
            try {
              let Ne = await be.value;
              L || (yield Ne)
            } catch (Ne) {
              L = Ne
            }
          }
          if (L) throw L
        }

        function D(k, F, B) {
          return F === void 0 ? (L, $) => D(k, L, $) : B === void 0 ? L => D(k, F, L) : k === 1 ? J(F, B) : R(k, F, B)
        }

        function K(k, F, B) {
          return F === void 0 ? (L, $) => $ ? K(k, L, $) : K(k, L) : B === void 0 ? L => K(k, F, L) : w(L => L != null, O(D(k, F, B)))
        }
        async function* ee(...k) {
          let F = k.map(n),
            B = new Set,
            L = new Map,
            $ = null,
            ie = null,
            ne = null,
            pe = Re => {
              $ = Re, ie && ie(Re)
            },
            be = Re => {
              ne && ne(Re)
            },
            de = () => new Promise((Re, $e) => {
              if ($ && $e($), L.size > 0) return Re();
              ne = Re, ie = $e
            }),
            Ne = Re => {
              let $e = Promise.resolve(Re.next()).then(async ({
                done: Ke,
                value: Me
              }) => {
                Ke || L.set(Re, Me), B.delete($e)
              });
              B.add($e), $e.then(be, pe)
            };
          for (let Re of F) Ne(Re);
          for (; ;) {
            if (B.size === 0 && L.size === 0) return;
            await de();
            for (let [Re, $e] of L) L.delete(Re), yield $e, Ne(Re)
          }
        }
        async function re(k, F, B) {
          let L = F;
          for await (let $ of B) L = await k(L, $);
          return L
        }

        function V(k, F, B) {
          return F === void 0 ? (L, $) => $ ? re(k, L, $) : V(k, L) : B === void 0 ? L => V(k, F, L) : re(k, F, B)
        }
        async function* v(k, F) {
          let B = 0;
          for await (let L of F) if (yield await L, B++, B >= k) break
        }

        function* Y(k, F) {
          let B = 0;
          for (let L of F)
            if (yield L, B++, B >= k) break
        }

        function Se(k, F) {
          return F === void 0 ? B => Se(k, B) : F[Symbol.asyncIterator] ? v(k, F) : Y(k, F)
        }
        async function* Q(k, F) {
          for await (let B of F) await k(B), yield B
        }

        function ve(k, F) {
          return F === void 0 ? B => Q(k, B) : Q(k, F)
        }

        function x(k, F) {
          let B = k[0] + F[0],
            L = k[1] + F[1];
          if (L >= 1e9) {
            let $ = L % 1e9;
            B += (L - $) / 1e9, L = $
          }
          return [B, L]
        }
        async function* I(k, F) {
          let B = F[Symbol.asyncIterator](),
            L = [0, 0];
          for (; ;) {
            let $ = process.hrtime(),
              {
                value: ie,
                done: ne
              } = await B.next(),
              pe = process.hrtime($);
            if (L = x(L, pe), k.progress && k.progress(pe, L), ne) return k.total && k.total(L), ie;
            yield ie
          }
        }

        function* le(k, F) {
          let B = F[Symbol.iterator](),
            L = [0, 0];
          for (; ;) {
            let $ = process.hrtime(),
              {
                value: ie,
                done: ne
              } = B.next(),
              pe = process.hrtime($);
            if (L = x(L, pe), k.progress && k.progress(pe, L), ne) return k.total && k.total(L), ie;
            yield ie
          }
        }

        function he(k = {}, F) {
          return F === void 0 ? B => he(k, B) : F[Symbol.asyncIterator] !== void 0 ? I(k, F) : le(k, F)
        }

        function S(k, F, B) {
          let L = n(B),
            $ = [],
            ie = [],
            ne = !1,
            pe = !1,
            be = 0,
            de = null;

          function Ne() {
            for (; ie.length > 0 && $.length > 0;) {
              let {
                resolve: Ie
              } = ie.shift(), tt = $.shift();
              Ie({
                done: !1,
                value: tt
              })
            }
            for (; ie.length > 0 && be === 0 && ne;) {
              let {
                resolve: Ie,
                reject: tt
              } = ie.shift();
              de ? (tt(de), de = null) : Ie({
                done: !0,
                value: void 0
              })
            }
          }
          async function Re() {
            if (ne) {
              Ne();
              return
            }
            if (!pe && !(be + $.length >= k)) {
              pe = !0, be++;
              try {
                let {
                  done: Ie,
                  value: tt
                } = await L.next();
                Ie ? (ne = !0, be--, Ne()) : $e(tt)
              } catch (Ie) {
                ne = !0, be--, de = Ie, Ne()
              }
              pe = !1, Re()
            }
          }
          async function $e(Ie) {
            try {
              let tt = await F(Ie);
              $.push(tt)
            } catch (tt) {
              ne = !0, de = tt
            }
            be--, Ne(), Re()
          }
          async function Ke() {
            if ($.length === 0) {
              let tt = s();
              return ie.push(tt), Re(), tt.promise
            }
            let Ie = $.shift();
            return Re(), {
              done: !1,
              value: Ie
            }
          }
          let Me = {
            next: Ke,
            [Symbol.asyncIterator]: () => Me
          };
          return Me
        }

        function T(k, F, B) {
          return F === void 0 ? (L, $) => $ ? T(k, L, $) : T(k, L) : B === void 0 ? L => T(k, F, L) : S(k, F, B)
        }
        async function j(k, F) {
          let B = null,
            L = null,
            $ = null,
            ie = de => {
              B = de, L && L(de)
            },
            ne = () => {
              $ && $()
            },
            pe = () => {
              k.removeListener("error", ie), k.removeListener("drain", ne)
            };
          k.once("error", ie);
          let be = () => new Promise((de, Ne) => {
            if (B) return Ne(B);
            k.once("drain", ne), $ = de, L = Ne
          });
          for await (let de of F) if (k.write(de) === !1 && await be(), B) break;
          if (pe(), B) throw B
        }

        function G(k, F) {
          return F === void 0 ? B => j(k, B) : j(k, F)
        }
        r.batch = i, r.buffer = c, r.collect = f, r.concat = p, r.consume = m, r.filter = w, r.flatMap = Z, r.flatTransform = te, r.flatten = O, r.fromStream = U, r.getIterator = n, r.map = J, r.merge = b, r.parallelFlatMap = K, r.parallelMap = D, r.parallelMerge = ee, r.pipeline = _, r.reduce = V, r.take = Se, r.tap = ve, r.time = he, r.transform = T, r.writeToStream = G, Object.defineProperty(r, "__esModule", {
          value: !0
        })
      })
    });
    var vi = y((__t, g0) => {
      l();
      var JW = (...r) => {
        let e;
        for (; r.length;) e = r.shift()(e);
        return e
      },
        Cx = r => r && (typeof r[Symbol.asyncIterator] == "function" || typeof r[Symbol.iterator] == "function" || typeof r.next == "function"),
        nw = r => r && typeof r.sink == "function" && Cx(r.source),
        IMe = r => e => (r.sink(e), r.source),
        XW = (...r) => {
          if (nw(r[0])) {
            let e = r[0];
            r[0] = () => e.source
          } else if (Cx(r[0])) {
            let e = r[0];
            r[0] = () => e
          }
          if (r.length > 1 && nw(r[r.length - 1]) && (r[r.length - 1] = r[r.length - 1].sink), r.length > 2)
            for (let e = 1; e < r.length - 1; e++) nw(r[e]) && (r[e] = IMe(r[e]));
          return JW(...r)
        };
      g0.exports = XW;
      g0.exports.pipe = XW;
      g0.exports.rawPipe = JW;
      g0.exports.isIterable = Cx;
      g0.exports.isDuplex = nw
    });
    var QW = y((E_t, ZW) => {
      l();
      "use strict";
      var TMe = at(),
        Ox = xe(),
        {
          parallelMap: RMe,
          filter: kMe
        } = Ml(),
        {
          pipe: PMe
        } = vi(),
        {
          PinTypes: CMe
        } = c0(),
        {
          cleanCid: OMe
        } = rw(),
        NMe = ze(),
        qMe = 8;
      ZW.exports = ({
        blockService: r,
        gcLock: e,
        pinManager: t
      }) => {
        async function* i(n, s = {}) {
          Array.isArray(n) || (n = [n]);
          let o = await e.writeLock();
          try {
            yield* PMe(n, RMe(qMe, async a => {
              a = OMe(a);
              let c = {
                cid: a
              };
              try {
                let u = await t.isPinnedWithType(a, CMe.all);
                if (u.pinned) throw TMe.isCID(u.reason) ? Ox(new Error(`pinned via ${u.reason}`), "ERR_BLOCK_PINNED") : Ox(new Error(`pinned: ${u.reason}`), "ERR_BLOCK_PINNED");
                if (!await r._repo.blocks.has(a)) throw Ox(new Error("block not found"), "ERR_BLOCK_NOT_FOUND");
                await r.delete(a)
              } catch (u) {
                s.force || (u.message = `cannot remove ${a}: ${u.message}`, c.error = u)
              }
              return c
            }), kMe(() => !s.quiet))
          } finally {
            o()
          }
        }
        return NMe(i)
      }
    });
    var tY = y((S_t, eY) => {
      l();
      "use strict";
      var {
        cleanCid: MMe
      } = rw(), BMe = ze();
      eY.exports = ({
        blockService: r,
        preload: e
      }) => {
        async function t(i, n = {}) {
          i = MMe(i), n.preload !== !1 && e(i);
          let s = await r.get(i);
          return {
            cid: i,
            size: s.data.length
          }
        }
        return BMe(t)
      }
    });
    var nY = y((x_t, rY) => {
      l();
      "use strict";
      var DMe = FW(),
        LMe = WW(),
        FMe = QW(),
        UMe = tY(),
        iY = class {
          constructor({
            blockService: e,
            preload: t,
            gcLock: i,
            pinManager: n,
            pin: s
          }) {
            this.get = DMe({
              blockService: e,
              preload: t
            }), this.put = LMe({
              blockService: e,
              preload: t,
              gcLock: i,
              pin: s
            }), this.rm = FMe({
              blockService: e,
              gcLock: i,
              pinManager: n
            }), this.stat = UMe({
              blockService: e,
              preload: t
            })
          }
        };
      rY.exports = iY
    });
    var oY = y((A_t, sY) => {
      l();
      "use strict";
      var KMe = Qa();
      sY.exports = ({
        addAll: r
      }) => {
        async function e(t, i = {}) {
          let n = await KMe(r(t, i));
          if (n == null) throw Error("Failed to add a file, if you see this please report a bug");
          return n
        }
        return e
      }
    });
    var sw = y((I_t, aY) => {
      l();
      "use strict";
      async function* zMe(r, e = 1) {
        let t = [];
        e < 1 && (e = 1);
        for await (let i of r) for (t.push(i); t.length >= e;) yield t.slice(0, e), t = t.slice(e);
        for (; t.length;) yield t.slice(0, e), t = t.slice(e)
      }
      aY.exports = zMe
    });
    var Nx = y((T_t, cY) => {
      l();
      "use strict";
      var jMe = sw();
      async function* VMe(r, e = 1) {
        for await (let t of jMe(r, e)) {
          let i = t.map(n => n().then(s => ({
            ok: !0,
            value: s
          }), s => ({
            ok: !1,
            err: s
          })));
          for (let n = 0; n < i.length; n++) {
            let s = await i[n];
            if (s.ok) yield s.value;
            else throw s.err
          }
        }
      }
      cY.exports = VMe
    });
    var ow = y((R_t, uY) => {
      l();
      "use strict";
      var HMe = Yr().bind({
        ignoreUndefined: !0
      }),
        GMe = cr();
      async function $Me(r) {
        let t = (await GMe(r, "murmur3-128")).slice(2, 10),
          i = t.length,
          n = new Uint8Array(i);
        for (let s = 0; s < i; s++) n[i - s - 1] = t[s];
        return n
      }
      var WMe = {
        chunker: "fixed",
        strategy: "balanced",
        rawLeaves: !1,
        onlyHash: !1,
        reduceSingleLeafToSelf: !0,
        hashAlg: "sha2-256",
        leafType: "file",
        cidVersion: 0,
        progress: () => () => { },
        shardSplitThreshold: 1e3,
        fileImportConcurrency: 50,
        blockWriteConcurrency: 10,
        minChunkSize: 262144,
        maxChunkSize: 262144,
        avgChunkSize: 262144,
        window: 16,
        polynomial: 17437180132763652,
        maxChildrenPerNode: 174,
        layerRepeat: 4,
        wrapWithDirectory: !1,
        pin: !1,
        recursive: !1,
        hidden: !1,
        preload: !1,
        timeout: void 0,
        hamtHashFn: $Me,
        hamtHashCode: 34,
        hamtBucketBits: 8
      };
      uY.exports = function (r = {}) {
        return HMe(WMe, r)
      }
    });
    var Bl = y((k_t, fY) => {
      l();
      "use strict";
      var YMe = cr(),
        JMe = at(),
        XMe = async (r, e, t) => {
          t.codec || (t.codec = "dag-pb"), t.cidVersion || (t.cidVersion = 0), t.hashAlg || (t.hashAlg = "sha2-256"), t.hashAlg !== "sha2-256" && (t.cidVersion = 1);
          let i = await YMe(r, t.hashAlg),
            n = new JMe(t.cidVersion, t.codec, i);
          return t.onlyHash || await e.put(r, {
            pin: t.pin,
            preload: t.preload,
            timeout: t.timeout,
            cid: n
          }), n
        };
      fY.exports = XMe
    });
    var hY = y((P_t, lY) => {
      l();
      "use strict";
      var {
        UnixFS: ZMe
      } = Ii(), QMe = Bl(), {
        DAGNode: eBe
      } = Mr(), tBe = async (r, e, t) => {
        let i = new ZMe({
          type: "directory",
          mtime: r.mtime,
          mode: r.mode
        }),
          n = new eBe(i.marshal()).serialize(),
          s = await QMe(n, e, t),
          o = r.path;
        return {
          cid: s,
          path: o,
          unixfs: i,
          size: n.length
        }
      };
      lY.exports = tBe
    });
    var pY = y((C_t, dY) => {
      l();
      "use strict";
      var rBe = vy();
      dY.exports = async function (r, e) {
        return e(await rBe(r))
      }
    });
    var bY = y((O_t, yY) => {
      l();
      "use strict";
      var iBe = sw();

      function nBe(r, e, t) {
        return gY(r, e, t)
      }
      async function gY(r, e, t) {
        let i = [];
        for await (let n of iBe(r, t.maxChildrenPerNode)) i.push(await e(n));
        return i.length > 1 ? gY(i, e, t) : i[0]
      }
      yY.exports = nBe
    });
    var wY = y((N_t, mY) => {
      l();
      "use strict";
      var sBe = sw();
      mY.exports = async function (e, t, i) {
        let n = new vY(i.layerRepeat),
          s = 0,
          o = 1,
          a = n;
        for await (let c of sBe(e, i.maxChildrenPerNode)) a.isFull() && (a !== n && n.addChild(await a.reduce(t)), s && s % i.layerRepeat == 0 && o++, a = new qx(o, i.layerRepeat, s), s++), a.append(c);
        return a && a !== n && n.addChild(await a.reduce(t)), n.reduce(t)
      };
      var qx = class {
        constructor(e, t, i = 0) {
          this.maxDepth = e, this.layerRepeat = t, this.currentDepth = 1, this.iteration = i, this.root = this.node = this.parent = {
            children: [],
            depth: this.currentDepth,
            maxDepth: e,
            maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
          }
        }
        isFull() {
          if (!this.root.data) return !1;
          if (this.currentDepth < this.maxDepth && this.node.maxChildren) return this._addNextNodeToParent(this.node), !1;
          let e = this._findParent(this.node, this.currentDepth);
          return e ? (this._addNextNodeToParent(e), !1) : !0
        }
        _addNextNodeToParent(e) {
          this.parent = e;
          let t = {
            children: [],
            depth: e.depth + 1,
            parent: e,
            maxDepth: this.maxDepth,
            maxChildren: Math.floor(e.children.length / this.layerRepeat) * this.layerRepeat
          };
          e.children.push(t), this.currentDepth = t.depth, this.node = t
        }
        append(e) {
          this.node.data = e
        }
        reduce(e) {
          return this._reduce(this.root, e)
        }
        async _reduce(e, t) {
          let i = [];
          return e.children.length && (i = await Promise.all(e.children.filter(n => n.data).map(n => this._reduce(n, t)))), t((e.data || []).concat(i))
        }
        _findParent(e, t) {
          let i = e.parent;
          if (!(!i || i.depth === 0)) return i.children.length === i.maxChildren || !i.maxChildren ? this._findParent(i, t) : i
        }
      },
        vY = class extends qx {
          constructor(e) {
            super(0, e);
            this.root.depth = 0, this.currentDepth = 1
          }
          addChild(e) {
            this.root.children.push(e)
          }
          reduce(e) {
            return e((this.root.data || []).concat(this.root.children))
          }
        }
    });
    var EY = y((q_t, _Y) => {
      l();
      "use strict";
      var {
        UnixFS: oBe
      } = Ii(), aBe = Bl(), {
        DAGNode: cBe
      } = Mr();
      async function* uBe(r, e, t) {
        for await (let i of r.content) yield async () => {
          t.progress(i.length, r.path);
          let n, s = {
            codec: "dag-pb",
            cidVersion: t.cidVersion,
            hashAlg: t.hashAlg,
            onlyHash: t.onlyHash
          };
          return t.rawLeaves ? (s.codec = "raw", s.cidVersion = 1) : (n = new oBe({
            type: t.leafType,
            data: i,
            mtime: r.mtime,
            mode: r.mode
          }), i = new cBe(n.marshal()).serialize()), {
            cid: await aBe(i, e, s),
            unixfs: n,
            size: i.length
          }
        }
      }
      _Y.exports = uBe
    });
    var RY = y((M_t, SY) => {
      l();
      "use strict";
      var fBe = xe(),
        {
          UnixFS: xY
        } = Ii(),
        AY = Bl(),
        {
          DAGNode: IY,
          DAGLink: TY
        } = Mr(),
        lBe = Nx(),
        hBe = cr().multihash,
        dBe = {
          flat: pY(),
          balanced: bY(),
          trickle: wY()
        };
      async function* pBe(r, e, t) {
        let i = -1,
          n, s;
        typeof t.bufferImporter == "function" ? s = t.bufferImporter : s = EY();
        for await (let o of lBe(s(r, e, t), t.blockWriteConcurrency)) {
          if (i++, i === 0) {
            n = o;
            continue
          } else i === 1 && n && (yield n, n = null);
          yield o
        }
        n && (n.single = !0, yield n)
      }
      var yBe = (r, e, t) => {
        async function i(n) {
          if (n.length === 1 && n[0].single && t.reduceSingleLeafToSelf) {
            let f = n[0];
            if (f.cid.codec === "raw" && (r.mtime !== void 0 || r.mode !== void 0)) {
              let {
                data: h
              } = await e.get(f.cid, t);
              f.unixfs = new xY({
                type: "file",
                mtime: r.mtime,
                mode: r.mode,
                data: h
              });
              let d = hBe.decode(f.cid.multihash);
              h = new IY(f.unixfs.marshal()).serialize(), f.cid = await AY(h, e, {
                ...t,
                codec: "dag-pb",
                hashAlg: d.name,
                cidVersion: t.cidVersion
              }), f.size = h.length
            }
            return {
              cid: f.cid,
              path: r.path,
              unixfs: f.unixfs,
              size: f.size
            }
          }
          let s = new xY({
            type: "file",
            mtime: r.mtime,
            mode: r.mode
          }),
            o = n.filter(f => f.cid.codec === "raw" && f.size || f.unixfs && !f.unixfs.data && f.unixfs.fileSize() ? !0 : Boolean(f.unixfs && f.unixfs.data && f.unixfs.data.length)).map(f => f.cid.codec === "raw" ? (s.addBlockSize(f.size), new TY("", f.size, f.cid)) : (!f.unixfs || !f.unixfs.data ? s.addBlockSize(f.unixfs && f.unixfs.fileSize() || 0) : s.addBlockSize(f.unixfs.data.length), new TY("", f.size, f.cid))),
            a = new IY(s.marshal(), o),
            c = a.serialize();
          return {
            cid: await AY(c, e, t),
            path: r.path,
            unixfs: s,
            size: c.length + a.Links.reduce((f, h) => f + h.Tsize, 0)
          }
        }
        return i
      };

      function gBe(r, e, t) {
        let i = dBe[t.strategy];
        if (!i) throw fBe(new Error(`Unknown importer build strategy name: ${t.strategy}`), "ERR_BAD_STRATEGY");
        return i(pBe(r, e, t), yBe(r, e, t), t)
      }
      SY.exports = gBe
    });
    var go = y((B_t, kY) => {
      l();
      "use strict";
      var {
        Buffer: ia
      } = Wt(), PY = Symbol.for("BufferList");

      function kr(r) {
        if (!(this instanceof kr)) return new kr(r);
        kr._init.call(this, r)
      }
      kr._init = function (e) {
        Object.defineProperty(this, PY, {
          value: !0
        }), this._bufs = [], this.length = 0, e && this.append(e)
      };
      kr.prototype._new = function (e) {
        return new kr(e)
      };
      kr.prototype._offset = function (e) {
        if (e === 0) return [0, 0];
        let t = 0;
        for (let i = 0; i < this._bufs.length; i++) {
          let n = t + this._bufs[i].length;
          if (e < n || i === this._bufs.length - 1) return [i, e - t];
          t = n
        }
      };
      kr.prototype._reverseOffset = function (r) {
        let e = r[0],
          t = r[1];
        for (let i = 0; i < e; i++) t += this._bufs[i].length;
        return t
      };
      kr.prototype.get = function (e) {
        if (e > this.length || e < 0) return;
        let t = this._offset(e);
        return this._bufs[t[0]][t[1]]
      };
      kr.prototype.slice = function (e, t) {
        return typeof e == "number" && e < 0 && (e += this.length), typeof t == "number" && t < 0 && (t += this.length), this.copy(null, 0, e, t)
      };
      kr.prototype.copy = function (e, t, i, n) {
        if ((typeof i != "number" || i < 0) && (i = 0), (typeof n != "number" || n > this.length) && (n = this.length), i >= this.length || n <= 0) return e || ia.alloc(0);
        let s = !!e,
          o = this._offset(i),
          a = n - i,
          c = a,
          u = s && t || 0,
          f = o[1];
        if (i === 0 && n === this.length) {
          if (!s) return this._bufs.length === 1 ? this._bufs[0] : ia.concat(this._bufs, this.length);
          for (let h = 0; h < this._bufs.length; h++) this._bufs[h].copy(e, u), u += this._bufs[h].length;
          return e
        }
        if (c <= this._bufs[o[0]].length - f) return s ? this._bufs[o[0]].copy(e, t, f, f + c) : this._bufs[o[0]].slice(f, f + c);
        s || (e = ia.allocUnsafe(a));
        for (let h = o[0]; h < this._bufs.length; h++) {
          let d = this._bufs[h].length - f;
          if (c > d) this._bufs[h].copy(e, u, f), u += d;
          else {
            this._bufs[h].copy(e, u, f, f + c), u += d;
            break
          }
          c -= d, f && (f = 0)
        }
        return e.length > u ? e.slice(0, u) : e
      };
      kr.prototype.shallowSlice = function (e, t) {
        if (e = e || 0, t = typeof t != "number" ? this.length : t, e < 0 && (e += this.length), t < 0 && (t += this.length), e === t) return this._new();
        let i = this._offset(e),
          n = this._offset(t),
          s = this._bufs.slice(i[0], n[0] + 1);
        return n[1] === 0 ? s.pop() : s[s.length - 1] = s[s.length - 1].slice(0, n[1]), i[1] !== 0 && (s[0] = s[0].slice(i[1])), this._new(s)
      };
      kr.prototype.toString = function (e, t, i) {
        return this.slice(t, i).toString(e)
      };
      kr.prototype.consume = function (e) {
        if (e = Math.trunc(e), Number.isNaN(e) || e <= 0) return this;
        for (; this._bufs.length;)
          if (e >= this._bufs[0].length) e -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
          else {
            this._bufs[0] = this._bufs[0].slice(e), this.length -= e;
            break
          } return this
      };
      kr.prototype.duplicate = function () {
        let e = this._new();
        for (let t = 0; t < this._bufs.length; t++) e.append(this._bufs[t]);
        return e
      };
      kr.prototype.append = function (e) {
        if (e == null) return this;
        if (e.buffer) this._appendBuffer(ia.from(e.buffer, e.byteOffset, e.byteLength));
        else if (Array.isArray(e))
          for (let t = 0; t < e.length; t++) this.append(e[t]);
        else if (this._isBufferList(e))
          for (let t = 0; t < e._bufs.length; t++) this.append(e._bufs[t]);
        else typeof e == "number" && (e = e.toString()), this._appendBuffer(ia.from(e));
        return this
      };
      kr.prototype._appendBuffer = function (e) {
        this._bufs.push(e), this.length += e.length
      };
      kr.prototype.indexOf = function (r, e, t) {
        if (t === void 0 && typeof e == "string" && (t = e, e = void 0), typeof r == "function" || Array.isArray(r)) throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
        if (typeof r == "number" ? r = ia.from([r]) : typeof r == "string" ? r = ia.from(r, t) : this._isBufferList(r) ? r = r.slice() : Array.isArray(r.buffer) ? r = ia.from(r.buffer, r.byteOffset, r.byteLength) : ia.isBuffer(r) || (r = ia.from(r)), e = Number(e || 0), isNaN(e) && (e = 0), e < 0 && (e = this.length + e), e < 0 && (e = 0), r.length === 0) return e > this.length ? this.length : e;
        let i = this._offset(e),
          n = i[0],
          s = i[1];
        for (; n < this._bufs.length; n++) {
          let o = this._bufs[n];
          for (; s < o.length;)
            if (o.length - s >= r.length) {
              let c = o.indexOf(r, s);
              if (c !== -1) return this._reverseOffset([n, c]);
              s = o.length - r.length + 1
            } else {
              let c = this._reverseOffset([n, s]);
              if (this._match(c, r)) return c;
              s++
            } s = 0
        }
        return -1
      };
      kr.prototype._match = function (r, e) {
        if (this.length - r < e.length) return !1;
        for (let t = 0; t < e.length; t++)
          if (this.get(r + t) !== e[t]) return !1;
        return !0
      };
      (function () {
        let r = {
          readDoubleBE: 8,
          readDoubleLE: 8,
          readFloatBE: 4,
          readFloatLE: 4,
          readInt32BE: 4,
          readInt32LE: 4,
          readUInt32BE: 4,
          readUInt32LE: 4,
          readInt16BE: 2,
          readInt16LE: 2,
          readUInt16BE: 2,
          readUInt16LE: 2,
          readInt8: 1,
          readUInt8: 1,
          readIntBE: null,
          readIntLE: null,
          readUIntBE: null,
          readUIntLE: null
        };
        for (let e in r) (function (t) {
          r[t] === null ? kr.prototype[t] = function (i, n) {
            return this.slice(i, i + n)[t](0, n)
          } : kr.prototype[t] = function (i = 0) {
            return this.slice(i, i + r[t])[t](0)
          }
        })(e)
      })();
      kr.prototype._isBufferList = function (e) {
        return e instanceof kr || kr.isBufferList(e)
      };
      kr.isBufferList = function (e) {
        return e != null && e[PY]
      };
      kY.exports = kr
    });
    var NY = y((D_t, CY) => {
      l();
      var OY = class {
        constructor(e, t = 12, i = 8 * 1024, n = 32 * 1024, s = 64, o) {
          this.bits = t, this.min = i, this.max = n, this.asModule = e, this.rabin = new e.Rabin(t, i, n, s, o), this.polynomial = o
        }
        fingerprint(e) {
          let {
            __retain: t,
            __release: i,
            __allocArray: n,
            __getInt32Array: s,
            Int32Array_ID: o,
            Uint8Array_ID: a
          } = this.asModule, c = new Int32Array(Math.ceil(e.length / this.min)), u = t(n(o, c)), f = t(n(a, e)), h = this.rabin.fingerprint(f, u), d = s(h);
          i(f), i(u);
          let p = d.indexOf(0);
          return p >= 0 ? d.subarray(0, p) : d
        }
      };
      CY.exports = OY
    });
    var GY = y(ig => {
      l();
      "use strict";
      var Mx = -8,
        aw = -4,
        bBe = 0,
        qY = 1,
        MY = 1 << 0,
        cw = 1 << 1,
        L_t = 1 << 2,
        F_t = 1 << 3,
        BY = 5,
        U_t = 1 << BY,
        DY = 1 << 10,
        LY = 1 << 11,
        K_t = 1 << 12,
        mBe = 1 << 13,
        FY = 14,
        z_t = 1 << FY,
        j_t = 1 << 19,
        V_t = 1 << 20,
        H_t = 1 << 21,
        G_t = 1 << 22,
        vBe = 0,
        Bx = 4,
        wBe = 8,
        _Be = 12,
        UY = 12,
        EBe = 16,
        SBe = typeof BigUint64Array != "undefined",
        ng = Symbol(),
        sg = 1024;

      function KY(r, e) {
        let t = new Uint32Array(r),
          i = new Uint16Array(r);
        var n = t[e + aw >>> 2] >>> 1,
          s = e >>> 1;
        if (n <= sg) return String.fromCharCode.apply(String, i.subarray(s, s + n));
        let o = [];
        do {
          let a = i[s + sg - 1],
            c = a >= 55296 && a < 56320 ? sg - 1 : sg;
          o.push(String.fromCharCode.apply(String, i.subarray(s, s += c))), n -= c
        } while (n > sg);
        return o.join("") + String.fromCharCode.apply(String, i.subarray(s, s + n))
      }

      function Dx(r) {
        let e = {};

        function t(n, s) {
          return n ? KY(n.buffer, s) : "<yet unknown>"
        }
        let i = r.env = r.env || {};
        return i.abort = i.abort || function (s, o, a, c) {
          let u = e.memory || i.memory;
          throw Error("abort: " + t(u, s) + " at " + t(u, o) + ":" + a + ":" + c)
        }, i.trace = i.trace || function (s, o) {
          let a = e.memory || i.memory;
          console.log("trace: " + t(a, s) + (o ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + o).join(", "))
        }, r.Math = r.Math || Math, r.Date = r.Date || Date, e
      }

      function Lx(r, e) {
        let t = e.exports,
          i = t.memory,
          n = t.table,
          s = t.__alloc,
          o = t.__retain,
          a = t.__rtti_base || ~0;

        function c(H) {
          let te = new Uint32Array(i.buffer),
            ae = te[a >>> 2];
          if ((H >>>= 0) >= ae) throw Error("invalid id: " + H);
          return te[(a + 4 >>> 2) + H * 2]
        }

        function u(H) {
          let te = new Uint32Array(i.buffer),
            ae = te[a >>> 2];
          if ((H >>>= 0) >= ae) throw Error("invalid id: " + H);
          return te[(a + 4 >>> 2) + H * 2 + 1]
        }

        function f(H) {
          return 31 - Math.clz32(H >>> BY & 31)
        }

        function h(H) {
          return 31 - Math.clz32(H >>> FY & 31)
        }

        function d(H) {
          let te = H.length,
            ae = s(te << 1, qY),
            oe = new Uint16Array(i.buffer);
          for (var U = 0, b = ae >>> 1; U < te; ++U) oe[b + U] = H.charCodeAt(U);
          return ae
        }
        r.__allocString = d;

        function p(H) {
          let te = i.buffer;
          if (new Uint32Array(te)[H + Mx >>> 2] !== qY) throw Error("not a string: " + H);
          return KY(te, H)
        }
        r.__getString = p;

        function g(H, te, ae) {
          let oe = i.buffer;
          if (ae) switch (H) {
            case 2:
              return new Float32Array(oe);
            case 3:
              return new Float64Array(oe)
          } else switch (H) {
            case 0:
              return new (te ? Int8Array : Uint8Array)(oe);
            case 1:
              return new (te ? Int16Array : Uint16Array)(oe);
            case 2:
              return new (te ? Int32Array : Uint32Array)(oe);
            case 3:
              return new (te ? BigInt64Array : BigUint64Array)(oe)
          }
          throw Error("unsupported align: " + H)
        }

        function m(H, te) {
          let ae = c(H);
          if (!(ae & (MY | cw))) throw Error("not an array: " + H + " @ " + ae);
          let oe = f(ae),
            U = te.length,
            b = s(U << oe, bBe),
            _ = s(ae & cw ? EBe : _Be, H),
            R = new Uint32Array(i.buffer);
          R[_ + vBe >>> 2] = o(b), R[_ + Bx >>> 2] = b, R[_ + wBe >>> 2] = U << oe, ae & cw && (R[_ + UY >>> 2] = U);
          let D = g(oe, ae & DY, ae & LY);
          if (ae & mBe)
            for (let K = 0; K < U; ++K) D[(b >>> oe) + K] = o(te[K]);
          else D.set(te, b >>> oe);
          return _
        }
        r.__allocArray = m;

        function E(H) {
          let te = new Uint32Array(i.buffer),
            ae = te[H + Mx >>> 2],
            oe = c(ae);
          if (!(oe & MY)) throw Error("not an array: " + ae);
          let U = f(oe);
          var b = te[H + Bx >>> 2];
          let _ = oe & cw ? te[H + UY >>> 2] : te[b + aw >>> 2] >>> U;
          return g(U, oe & DY, oe & LY).subarray(b >>>= U, b + _)
        }
        r.__getArrayView = E;

        function w(H) {
          let te = E(H),
            ae = te.length,
            oe = new Array(ae);
          for (let U = 0; U < ae; U++) oe[U] = te[U];
          return oe
        }
        r.__getArray = w;

        function O(H) {
          let te = i.buffer,
            ae = new Uint32Array(te)[H + aw >>> 2];
          return te.slice(H, H + ae)
        }
        r.__getArrayBuffer = O;

        function q(H, te, ae) {
          return new H(J(H, te, ae))
        }

        function J(H, te, ae) {
          let oe = i.buffer,
            U = new Uint32Array(oe),
            b = U[ae + Bx >>> 2];
          return new H(oe, b, U[b + aw >>> 2] >>> te)
        }
        r.__getInt8Array = q.bind(null, Int8Array, 0), r.__getInt8ArrayView = J.bind(null, Int8Array, 0), r.__getUint8Array = q.bind(null, Uint8Array, 0), r.__getUint8ArrayView = J.bind(null, Uint8Array, 0), r.__getUint8ClampedArray = q.bind(null, Uint8ClampedArray, 0), r.__getUint8ClampedArrayView = J.bind(null, Uint8ClampedArray, 0), r.__getInt16Array = q.bind(null, Int16Array, 1), r.__getInt16ArrayView = J.bind(null, Int16Array, 1), r.__getUint16Array = q.bind(null, Uint16Array, 1), r.__getUint16ArrayView = J.bind(null, Uint16Array, 1), r.__getInt32Array = q.bind(null, Int32Array, 2), r.__getInt32ArrayView = J.bind(null, Int32Array, 2), r.__getUint32Array = q.bind(null, Uint32Array, 2), r.__getUint32ArrayView = J.bind(null, Uint32Array, 2), SBe && (r.__getInt64Array = q.bind(null, BigInt64Array, 3), r.__getInt64ArrayView = J.bind(null, BigInt64Array, 3), r.__getUint64Array = q.bind(null, BigUint64Array, 3), r.__getUint64ArrayView = J.bind(null, BigUint64Array, 3)), r.__getFloat32Array = q.bind(null, Float32Array, 2), r.__getFloat32ArrayView = J.bind(null, Float32Array, 2), r.__getFloat64Array = q.bind(null, Float64Array, 3), r.__getFloat64ArrayView = J.bind(null, Float64Array, 3);

        function Z(H, te) {
          let ae = new Uint32Array(i.buffer);
          var oe = ae[H + Mx >>> 2];
          if (oe <= ae[a >>> 2])
            do
              if (oe == te) return !0; while (oe = u(oe));
          return !1
        }
        return r.__instanceof = Z, r.memory = r.memory || i, r.table = r.table || n, zY(t, r)
      }

      function jY(r) {
        return typeof Response != "undefined" && r instanceof Response
      }
      async function HY(r, e) {
        return jY(r = await r) ? VY(r, e) : Lx(Dx(e || (e = {})), await WebAssembly.instantiate(r instanceof WebAssembly.Module ? r : await WebAssembly.compile(r), e))
      }
      ig.instantiate = HY;

      function xBe(r, e) {
        return Lx(Dx(e || (e = {})), new WebAssembly.Instance(r instanceof WebAssembly.Module ? r : new WebAssembly.Module(r), e))
      }
      ig.instantiateSync = xBe;
      async function VY(r, e) {
        return WebAssembly.instantiateStreaming ? Lx(Dx(e || (e = {})), (await WebAssembly.instantiateStreaming(r, e)).instance) : HY(jY(r = await r) ? r.arrayBuffer() : r, e)
      }
      ig.instantiateStreaming = VY;

      function zY(r, e) {
        var t = e ? Object.create(e) : {},
          i = r.__argumentsLength ? function (n) {
            r.__argumentsLength.value = n
          } : r.__setArgumentsLength || r.__setargc || function () { };
        for (let n in r) {
          if (!Object.prototype.hasOwnProperty.call(r, n)) continue;
          let s = r[n],
            o = n.split("."),
            a = t;
          for (; o.length > 1;) {
            let f = o.shift();
            Object.prototype.hasOwnProperty.call(a, f) || (a[f] = {}), a = a[f]
          }
          let c = o[0],
            u = c.indexOf("#");
          if (u >= 0) {
            let f = c.substring(0, u),
              h = a[f];
            if (typeof h == "undefined" || !h.prototype) {
              let d = function (...p) {
                return d.wrap(d.prototype.constructor(0, ...p))
              };
              d.prototype = {
                valueOf: function () {
                  return this[ng]
                }
              }, d.wrap = function (p) {
                return Object.create(d.prototype, {
                  [ng]: {
                    value: p,
                    writable: !1
                  }
                })
              }, h && Object.getOwnPropertyNames(h).forEach(p => Object.defineProperty(d, p, Object.getOwnPropertyDescriptor(h, p))), a[f] = d
            }
            if (c = c.substring(u + 1), a = a[f].prototype, /^(get|set):/.test(c)) {
              if (!Object.prototype.hasOwnProperty.call(a, c = c.substring(4))) {
                let d = r[n.replace("set:", "get:")],
                  p = r[n.replace("get:", "set:")];
                Object.defineProperty(a, c, {
                  get: function () {
                    return d(this[ng])
                  },
                  set: function (g) {
                    p(this[ng], g)
                  },
                  enumerable: !0
                })
              }
            } else c === "constructor" ? (a[c] = (...d) => (i(d.length), s(...d))).original = s : (a[c] = function (...d) {
              return i(d.length), s(this[ng], ...d)
            }).original = s
          } else /^(get|set):/.test(c) ? Object.prototype.hasOwnProperty.call(a, c = c.substring(4)) || Object.defineProperty(a, c, {
            get: r[n.replace("set:", "get:")],
            set: r[n.replace("get:", "set:")],
            enumerable: !0
          }) : typeof s == "function" && s !== i ? (a[c] = (...f) => (i(f.length), s(...f))).original = s : a[c] = s
        }
        return t
      }
      ig.demangle = zY
    });
    var WY = y((W_t, $Y) => {
      l();
      var {
        instantiate: ABe
      } = GY();
      Fx.supported = typeof WebAssembly != "undefined";

      function Fx(r = {}) {
        if (!Fx.supported) return null;
        var e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
        return ABe(new Response(new Blob([e], {
          type: "application/wasm"
        })), r)
      }
      $Y.exports = Fx
    });
    var XY = y((Y_t, YY) => {
      l();
      var JY = NY(),
        IBe = WY(),
        TBe = async (r, e, t, i, n) => {
          let s = await IBe();
          return new JY(s, r, e, t, i, n)
        };
      YY.exports = {
        Rabin: JY,
        create: TBe
      }
    });
    var eJ = y((J_t, ZY) => {
      l();
      "use strict";
      var RBe = go(),
        {
          create: kBe
        } = XY(),
        QY = xe();
      ZY.exports = async function* (e, t) {
        let i, n, s;
        if (t.minChunkSize && t.maxChunkSize && t.avgChunkSize) s = t.avgChunkSize, i = t.minChunkSize, n = t.maxChunkSize;
        else if (t.avgChunkSize) s = t.avgChunkSize, i = s / 3, n = s + s / 2;
        else throw QY(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
        if (i < 16) throw QY(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
        n < i && (n = i), s < i && (s = i);
        let o = Math.floor(Math.log2(s));
        for await (let a of PBe(e, {
          min: i,
          max: n,
          bits: o,
          window: t.window,
          polynomial: t.polynomial
        })) yield a
      };
      async function* PBe(r, e) {
        let t = await kBe(e.bits, e.min, e.max, e.window),
          i = new RBe;
        for await (let n of r) {
          i.append(n);
          let s = t.fingerprint(n);
          for (let o = 0; o < s.length; o++) {
            let a = s[o],
              c = i.slice(0, a);
            i.consume(a), yield c
          }
        }
        i.length && (yield i.slice(0))
      }
    });
    var rJ = y((X_t, tJ) => {
      l();
      "use strict";
      var Ux = go();
      tJ.exports = async function* (e, t) {
        let i = new Ux,
          n = 0,
          s = !1,
          o = t.maxChunkSize;
        for await (let a of e) for (i.append(a), n += a.length; n >= o;)
          if (yield i.slice(0, o), s = !0, o === i.length) i = new Ux, n = 0;
          else {
            let c = new Ux;
            c.append(i.shallowSlice(o)), i = c, n -= o
          } (!s || n) && (yield i.slice(0, n))
      }
    });
    var sJ = y((Z_t, iJ) => {
      l();
      "use strict";
      var nJ = xe(),
        CBe = gt();
      async function* OBe(r) {
        for await (let e of r) {
          if (e.length === void 0) throw nJ(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
          if (typeof e == "string" || e instanceof String) yield CBe(e.toString());
          else if (Array.isArray(e)) yield Uint8Array.from(e);
          else if (e instanceof Uint8Array) yield e;
          else throw nJ(new Error("Content was invalid"), "ERR_INVALID_CONTENT")
        }
      }
      iJ.exports = OBe
    });
    var cJ = y((Q_t, oJ) => {
      l();
      "use strict";
      var NBe = hY(),
        qBe = RY(),
        aJ = xe();

      function MBe(r) {
        return Symbol.iterator in r
      }

      function BBe(r) {
        return Symbol.asyncIterator in r
      }

      function DBe(r) {
        try {
          if (r instanceof Uint8Array) return async function* () {
            yield r
          }();
          if (MBe(r)) return async function* () {
            yield* r
          }();
          if (BBe(r)) return r
        } catch {
          throw aJ(new Error("Content was invalid"), "ERR_INVALID_CONTENT")
        }
        throw aJ(new Error("Content was invalid"), "ERR_INVALID_CONTENT")
      }
      async function* LBe(r, e, t) {
        for await (let i of r) if (i.path && (i.path.substring(0, 2) === "./" && (t.wrapWithDirectory = !0), i.path = i.path.split("/").filter(n => n && n !== ".").join("/")), i.content) {
          let n;
          typeof t.chunker == "function" ? n = t.chunker : t.chunker === "rabin" ? n = eJ() : n = rJ();
          let s;
          typeof t.chunkValidator == "function" ? s = t.chunkValidator : s = sJ();
          let o = {
            path: i.path,
            mtime: i.mtime,
            mode: i.mode,
            content: n(s(DBe(i.content), t), t)
          };
          yield () => qBe(o, e, t)
        } else if (i.path) {
          let n = {
            path: i.path,
            mtime: i.mtime,
            mode: i.mode
          };
          yield () => NBe(n, e, t)
        } else throw new Error("Import candidate must have content or path or both")
      }
      oJ.exports = LBe
    });
    var uw = y((e6t, uJ) => {
      l();
      "use strict";
      var fJ = class {
        constructor(e, t) {
          this.options = t || {}, this.root = e.root, this.dir = e.dir, this.path = e.path, this.dirty = e.dirty, this.flat = e.flat, this.parent = e.parent, this.parentKey = e.parentKey, this.unixfs = e.unixfs, this.mode = e.mode, this.mtime = e.mtime, this.cid = void 0, this.size = void 0
        }
        async put(e, t) { }
        get(e) {
          return Promise.resolve(this)
        }
        async *eachChildSeries() { }
        async *flush(e) { }
      };
      uJ.exports = fJ
    });
    var Kx = y((t6t, lJ) => {
      l();
      "use strict";
      var {
        DAGLink: FBe,
        DAGNode: UBe
      } = Mr(), {
        UnixFS: KBe
      } = Ii(), hJ = uw(), zBe = Bl(), dJ = class extends hJ {
        constructor(e, t) {
          super(e, t);
          this._children = {}
        }
        async put(e, t) {
          this.cid = void 0, this.size = void 0, this._children[e] = t
        }
        get(e) {
          return Promise.resolve(this._children[e])
        }
        childCount() {
          return Object.keys(this._children).length
        }
        directChildrenCount() {
          return this.childCount()
        }
        onlyChild() {
          return this._children[Object.keys(this._children)[0]]
        }
        async *eachChildSeries() {
          let e = Object.keys(this._children);
          for (let t = 0; t < e.length; t++) {
            let i = e[t];
            yield {
              key: i,
              child: this._children[i]
            }
          }
        }
        async *flush(e) {
          let t = Object.keys(this._children),
            i = [];
          for (let u = 0; u < t.length; u++) {
            let f = this._children[t[u]];
            if (f instanceof hJ)
              for await (let h of f.flush(e)) f = h, yield f;
            f.size != null && f.cid && i.push(new FBe(t[u], f.size, f.cid))
          }
          let n = new KBe({
            type: "directory",
            mtime: this.mtime,
            mode: this.mode
          }),
            s = new UBe(n.marshal(), i),
            o = s.serialize(),
            a = await zBe(o, e, this.options),
            c = o.length + s.Links.reduce((u, f) => u + f.Tsize, 0);
          this.cid = a, this.size = c, yield {
            cid: a,
            unixfs: n,
            path: this.path,
            size: c
          }
        }
      };
      lJ.exports = dJ
    });
    var gJ = y((i6t, pJ) => {
      l();
      "use strict";
      var fw = 7;
      pJ.exports = class {
        constructor() {
          this._bitArrays = [], this._data = [], this._length = 0, this._changedLength = !1, this._changedData = !1
        }
        set(e, t) {
          let i = this._internalPositionFor(e, !1);
          if (t === void 0) i !== -1 && (this._unsetInternalPos(i), this._unsetBit(e), this._changedLength = !0, this._changedData = !0);
          else {
            let n = !1;
            i === -1 ? (i = this._data.length, this._setBit(e), this._changedData = !0) : n = !0, this._setInternalPos(i, e, t, n), this._changedLength = !0
          }
        }
        unset(e) {
          this.set(e, void 0)
        }
        get(e) {
          this._sortData();
          let t = this._internalPositionFor(e, !0);
          if (t !== -1) return this._data[t][1]
        }
        push(e) {
          return this.set(this.length, e), this.length
        }
        get length() {
          if (this._sortData(), this._changedLength) {
            let e = this._data[this._data.length - 1];
            this._length = e ? e[0] + 1 : 0, this._changedLength = !1
          }
          return this._length
        }
        forEach(e) {
          let t = 0;
          for (; t < this.length;) e(this.get(t), t, this), t++
        }
        map(e) {
          let t = 0,
            i = new Array(this.length);
          for (; t < this.length;) i[t] = e(this.get(t), t, this), t++;
          return i
        }
        reduce(e, t) {
          let i = 0,
            n = t;
          for (; i < this.length;) {
            let s = this.get(i);
            n = e(n, s, i), i++
          }
          return n
        }
        find(e) {
          let t = 0,
            i, n;
          for (; t < this.length && !i;) n = this.get(t), i = e(n), t++;
          return i ? n : void 0
        }
        _internalPositionFor(e, t) {
          let i = this._bytePosFor(e, t);
          if (i >= this._bitArrays.length) return -1;
          let n = this._bitArrays[i],
            s = e - i * fw;
          if (!((n & 1 << s) > 0)) return -1;
          let a = this._bitArrays.slice(0, i).reduce(jBe, 0),
            c = ~(4294967295 << s + 1),
            u = yJ(n & c);
          return a + u - 1
        }
        _bytePosFor(e, t) {
          let i = Math.floor(e / fw),
            n = i + 1;
          for (; !t && this._bitArrays.length < n;) this._bitArrays.push(0);
          return i
        }
        _setBit(e) {
          let t = this._bytePosFor(e, !1);
          this._bitArrays[t] |= 1 << e - t * fw
        }
        _unsetBit(e) {
          let t = this._bytePosFor(e, !1);
          this._bitArrays[t] &= ~(1 << e - t * fw)
        }
        _setInternalPos(e, t, i, n) {
          let s = this._data,
            o = [t, i];
          if (n) this._sortData(), s[e] = o;
          else {
            if (s.length)
              if (s[s.length - 1][0] >= t) s.push(o);
              else if (s[0][0] <= t) s.unshift(o);
              else {
                let a = Math.round(s.length / 2);
                this._data = s.slice(0, a).concat(o).concat(s.slice(a))
              } else this._data.push(o);
            this._changedData = !0, this._changedLength = !0
          }
        }
        _unsetInternalPos(e) {
          this._data.splice(e, 1)
        }
        _sortData() {
          this._changedData && this._data.sort(VBe), this._changedData = !1
        }
        bitField() {
          let e = [],
            t = 8,
            i = 0,
            n = 0,
            s, o = this._bitArrays.slice();
          for (; o.length || i;) {
            i === 0 && (s = o.shift(), i = 7);
            let c = Math.min(i, t),
              u = ~(255 << c);
            n |= (s & u) << 8 - t, s = s >>> c, i -= c, t -= c, (!t || !i && !o.length) && (e.push(n), n = 0, t = 8)
          }
          for (var a = e.length - 1; a > 0 && e[a] === 0; a--) e.pop();
          return e
        }
        compactArray() {
          return this._sortData(), this._data.map(HBe)
        }
      };

      function jBe(r, e) {
        return r + yJ(e)
      }

      function yJ(r) {
        let e = r;
        return e = e - (e >> 1 & 1431655765), e = (e & 858993459) + (e >> 2 & 858993459), (e + (e >> 4) & 252645135) * 16843009 >> 24
      }

      function VBe(r, e) {
        return r[0] - e[0]
      }

      function HBe(r) {
        return r[1]
      }
    });
    var vJ = y((n6t, bJ) => {
      l();
      "use strict";
      var GBe = gJ(),
        $Be = gt(),
        na = class {
          constructor(e, t, i = 0) {
            this._options = e, this._popCount = 0, this._parent = t, this._posAtParent = i, this._children = new GBe, this.key = null
          }
          async put(e, t) {
            let i = await this._findNewBucketAndPos(e);
            await i.bucket._putAt(i, e, t)
          }
          async get(e) {
            let t = await this._findChild(e);
            if (t) return t.value
          }
          async del(e) {
            let t = await this._findPlace(e),
              i = t.bucket._at(t.pos);
            i && i.key === e && t.bucket._delAt(t.pos)
          }
          leafCount() {
            return this._children.compactArray().reduce((t, i) => i instanceof na ? t + i.leafCount() : t + 1, 0)
          }
          childrenCount() {
            return this._children.length
          }
          onlyChild() {
            return this._children.get(0)
          } * eachLeafSeries() {
            let e = this._children.compactArray();
            for (let t of e) t instanceof na ? yield* t.eachLeafSeries() : yield t;
            return []
          }
          serialize(e, t) {
            let i = [];
            return t(this._children.reduce((n, s, o) => (s && (s instanceof na ? n.push(s.serialize(e, t)) : n.push(e(s, o))), n), i))
          }
          asyncTransform(e, t) {
            return mJ(this, e, t)
          }
          toJSON() {
            return this.serialize(YBe, JBe)
          }
          prettyPrint() {
            return JSON.stringify(this.toJSON(), null, "  ")
          }
          tableSize() {
            return Math.pow(2, this._options.bits)
          }
          async _findChild(e) {
            let t = await this._findPlace(e),
              i = t.bucket._at(t.pos);
            if (!(i instanceof na) && i && i.key === e) return i
          }
          async _findPlace(e) {
            let t = this._options.hash(typeof e == "string" ? $Be(e) : e),
              i = await t.take(this._options.bits),
              n = this._children.get(i);
            return n instanceof na ? n._findPlace(t) : {
              bucket: this,
              pos: i,
              hash: t,
              existingChild: n
            }
          }
          async _findNewBucketAndPos(e) {
            let t = await this._findPlace(e);
            if (t.existingChild && t.existingChild.key !== e) {
              let i = new na(this._options, t.bucket, t.pos);
              t.bucket._putObjectAt(t.pos, i);
              let n = await i._findPlace(t.existingChild.hash);
              return n.bucket._putAt(n, t.existingChild.key, t.existingChild.value), i._findNewBucketAndPos(t.hash)
            }
            return t
          }
          _putAt(e, t, i) {
            this._putObjectAt(e.pos, {
              key: t,
              value: i,
              hash: e.hash
            })
          }
          _putObjectAt(e, t) {
            this._children.get(e) || this._popCount++, this._children.set(e, t)
          }
          _delAt(e) {
            if (e === -1) throw new Error("Invalid position");
            this._children.get(e) && this._popCount--, this._children.unset(e), this._level()
          }
          _level() {
            if (this._parent && this._popCount <= 1)
              if (this._popCount === 1) {
                let e = this._children.find(WBe);
                if (e && !(e instanceof na)) {
                  let t = e.hash;
                  t.untake(this._options.bits);
                  let i = {
                    pos: this._posAtParent,
                    hash: t,
                    bucket: this._parent
                  };
                  this._parent._putAt(i, e.key, e.value)
                }
              } else this._parent._delAt(this._posAtParent)
          }
          _at(e) {
            return this._children.get(e)
          }
        };

      function WBe(r) {
        return Boolean(r)
      }

      function YBe(r, e) {
        return r.key
      }

      function JBe(r) {
        return r
      }
      async function mJ(r, e, t) {
        let i = [];
        for (let n of r._children.compactArray())
          if (n instanceof na) await mJ(n, e, t);
          else {
            let s = await e(n);
            i.push({
              bitField: r._children.bitField(),
              children: s
            })
          } return t(i)
      }
      bJ.exports = na
    });
    var _J = y((o6t, wJ) => {
      l();
      "use strict";
      var XBe = [255, 254, 252, 248, 240, 224, 192, 128],
        ZBe = [1, 3, 7, 15, 31, 63, 127, 255];
      wJ.exports = class {
        constructor(e) {
          this._value = e, this._currentBytePos = e.length - 1, this._currentBitPos = 7
        }
        availableBits() {
          return this._currentBitPos + 1 + this._currentBytePos * 8
        }
        totalBits() {
          return this._value.length * 8
        }
        take(e) {
          let t = e,
            i = 0;
          for (; t && this._haveBits();) {
            let n = this._value[this._currentBytePos],
              s = this._currentBitPos + 1,
              o = Math.min(s, t),
              a = QBe(n, s - o, o);
            i = (i << o) + a, t -= o, this._currentBitPos -= o, this._currentBitPos < 0 && (this._currentBitPos = 7, this._currentBytePos--)
          }
          return i
        }
        untake(e) {
          for (this._currentBitPos += e; this._currentBitPos > 7;) this._currentBitPos -= 8, this._currentBytePos += 1
        }
        _haveBits() {
          return this._currentBytePos >= 0
        }
      };

      function QBe(r, e, t) {
        let i = eDe(e, t);
        return (r & i) >>> e
      }

      function eDe(r, e) {
        return XBe[r] & ZBe[Math.min(e + r - 1, 7)]
      }
    });
    var EJ = y((a6t, zx) => {
      l();
      "use strict";
      var tDe = _J(),
        rDe = xi();

      function iDe(r) {
        function e(t) {
          return t instanceof lw ? t : new lw(t, r)
        }
        return e
      }
      var lw = class {
        constructor(e, t) {
          if (!(e instanceof Uint8Array)) throw new Error("can only hash Uint8Arrays");
          this._value = e, this._hashFn = t, this._depth = -1, this._availableBits = 0, this._currentBufferIndex = 0, this._buffers = []
        }
        async take(e) {
          let t = e;
          for (; this._availableBits < t;) await this._produceMoreBits();
          let i = 0;
          for (; t > 0;) {
            let n = this._buffers[this._currentBufferIndex],
              s = Math.min(n.availableBits(), t),
              o = n.take(s);
            i = (i << s) + o, t -= s, this._availableBits -= s, n.availableBits() === 0 && this._currentBufferIndex++
          }
          return i
        }
        untake(e) {
          let t = e;
          for (; t > 0;) {
            let i = this._buffers[this._currentBufferIndex],
              n = Math.min(i.totalBits() - i.availableBits(), t);
            i.untake(n), t -= n, this._availableBits += n, this._currentBufferIndex > 0 && i.totalBits() === i.availableBits() && (this._depth--, this._currentBufferIndex--)
          }
        }
        async _produceMoreBits() {
          this._depth++;
          let e = this._depth ? rDe([this._value, Uint8Array.from([this._depth])]) : this._value,
            t = await this._hashFn(e),
            i = new tDe(t);
          this._buffers.push(i), this._availableBits += i.availableBits()
        }
      };
      zx.exports = iDe;
      zx.exports.InfiniteHash = lw
    });
    var hw = y((c6t, SJ) => {
      l();
      "use strict";
      var xJ = vJ(),
        nDe = EJ();

      function sDe(r) {
        if (!r || !r.hashFn) throw new Error("please define an options.hashFn");
        let e = {
          bits: r.bits || 8,
          hash: nDe(r.hashFn)
        };
        return new xJ(e)
      }
      SJ.exports = {
        createHAMT: sDe,
        Bucket: xJ
      }
    });
    var dw = y((u6t, AJ) => {
      l();
      "use strict";
      var {
        DAGLink: jx,
        DAGNode: oDe
      } = Mr(), {
        UnixFS: aDe
      } = Ii(), cDe = uw(), uDe = Bl(), {
        createHAMT: fDe,
        Bucket: lDe
      } = hw(), IJ = class extends cDe {
        constructor(e, t) {
          super(e, t);
          this._bucket = fDe({
            hashFn: t.hamtHashFn,
            bits: t.hamtBucketBits
          })
        }
        async put(e, t) {
          await this._bucket.put(e, t)
        }
        get(e) {
          return this._bucket.get(e)
        }
        childCount() {
          return this._bucket.leafCount()
        }
        directChildrenCount() {
          return this._bucket.childrenCount()
        }
        onlyChild() {
          return this._bucket.onlyChild()
        }
        async *eachChildSeries() {
          for await (let {
            key: e,
            value: t
          } of this._bucket.eachLeafSeries()) yield {
            key: e,
            child: t
          }
        }
        async *flush(e) {
          for await (let t of TJ(this._bucket, e, this, this.options)) yield {
            ...t,
            path: this.path
          }
        }
      };
      AJ.exports = IJ;
      async function* TJ(r, e, t, i) {
        let n = r._children,
          s = [],
          o = 0;
        for (let p = 0; p < n.length; p++) {
          let g = n.get(p);
          if (!g) continue;
          let m = p.toString(16).toUpperCase().padStart(2, "0");
          if (g instanceof lDe) {
            let E;
            for await (let w of await TJ(g, e, null, i)) E = w;
            if (!E) throw new Error("Could not flush sharded directory, no subshard found");
            s.push(new jx(m, E.size, E.cid)), o += E.size
          } else if (typeof g.value.flush == "function") {
            let E = g.value,
              w;
            for await (let q of E.flush(e)) w = q, yield w;
            let O = m + g.key;
            s.push(new jx(O, w.size, w.cid)), o += w.size
          } else {
            let E = g.value;
            if (!E.cid) continue;
            let w = m + g.key,
              O = E.size;
            s.push(new jx(w, O, E.cid)), o += O
          }
        }
        let a = Uint8Array.from(n.bitField().reverse()),
          c = new aDe({
            type: "hamt-sharded-directory",
            data: a,
            fanout: r.tableSize(),
            hashType: i.hamtHashCode,
            mtime: t && t.mtime,
            mode: t && t.mode
          }),
          f = new oDe(c.marshal(), s).serialize(),
          h = await uDe(f, e, i),
          d = f.length + o;
        yield {
          cid: h,
          unixfs: c,
          size: d
        }
      }
    });
    var kJ = y((f6t, RJ) => {
      l();
      "use strict";
      var hDe = dw(),
        dDe = Kx();
      RJ.exports = async function r(e, t, i, n) {
        let s = t;
        t instanceof dDe && t.directChildrenCount() >= i && (s = await pDe(t, n));
        let o = s.parent;
        if (o) {
          if (s !== t) {
            if (e && (e.parent = s), !s.parentKey) throw new Error("No parent key found");
            await o.put(s.parentKey, s)
          }
          return r(s, o, i, n)
        }
        return s
      };
      async function pDe(r, e) {
        let t = new hDe({
          root: r.root,
          dir: !0,
          parent: r.parent,
          parentKey: r.parentKey,
          path: r.path,
          dirty: r.dirty,
          flat: !1,
          mtime: r.mtime,
          mode: r.mode
        }, e);
        for await (let {
          key: i,
          child: n
        } of r.eachChildSeries()) await t.put(i, n);
        return t
      }
    });
    var CJ = y((l6t, PJ) => {
      l();
      "use strict";
      var yDe = (r = "") => (r.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
      PJ.exports = yDe
    });
    var BJ = y((h6t, OJ) => {
      l();
      "use strict";
      var NJ = Kx(),
        gDe = kJ(),
        qJ = uw(),
        bDe = CJ();
      async function mDe(r, e, t) {
        let i = bDe(r.path || ""),
          n = i.length - 1,
          s = e,
          o = "";
        for (let a = 0; a < i.length; a++) {
          let c = i[a];
          o += `${o ? "/" : ""}${c}`;
          let u = a === n;
          if (s.dirty = !0, s.cid = void 0, s.size = void 0, u) await s.put(c, r), e = await gDe(null, s, t.shardSplitThreshold, t);
          else {
            let f = await s.get(c);
            (!f || !(f instanceof qJ)) && (f = new NJ({
              root: !1,
              dir: !0,
              parent: s,
              parentKey: c,
              path: o,
              dirty: !0,
              flat: !0,
              mtime: f && f.unixfs && f.unixfs.mtime,
              mode: f && f.unixfs && f.unixfs.mode
            }, t)), await s.put(c, f), s = f
          }
        }
        return e
      }
      async function* MJ(r, e) {
        if (!(r instanceof qJ)) {
          r && r.unixfs && r.unixfs.isDirectory() && (yield r);
          return
        }
        yield* r.flush(e)
      }
      async function* vDe(r, e, t) {
        let i = new NJ({
          root: !0,
          dir: !0,
          path: "",
          dirty: !0,
          flat: !0
        }, t);
        for await (let n of r) !n || (i = await mDe(n, i, t), (!n.unixfs || !n.unixfs.isDirectory()) && (yield n));
        if (t.wrapWithDirectory) yield* MJ(i, e);
        else
          for await (let n of i.eachChildSeries()) !n || (yield* MJ(n.child, e))
      }
      OJ.exports = vDe
    });
    var pw = y((d6t, DJ) => {
      l();
      "use strict";
      var wDe = Nx(),
        _De = ow();
      async function* EDe(r, e, t = {}) {
        let i = _De(t),
          n;
        typeof t.dagBuilder == "function" ? n = t.dagBuilder : n = cJ();
        let s;
        typeof t.treeBuilder == "function" ? s = t.treeBuilder : s = BJ();
        let o;
        Symbol.asyncIterator in r || Symbol.iterator in r ? o = r : o = [r];
        for await (let a of s(wDe(n(o, e, i), i.fileImportConcurrency), e, i)) yield {
          cid: a.cid,
          path: a.path,
          unixfs: a.unixfs,
          size: a.size
        }
      }
      DJ.exports = {
        importer: EDe
      }
    });
    var yw = y((p6t, LJ) => {
      l();
      "use strict";
      async function* SDe(r, e = {}) {
        let t = r.getReader();
        try {
          for (; ;) {
            let i = await t.read();
            if (i.done) return;
            yield i.value
          }
        } finally {
          e.preventCancel !== !0 && t.cancel(), t.releaseLock()
        }
      }
      LJ.exports = SDe
    });
    var KJ = y((y6t, FJ) => {
      l();
      "use strict";
      var UJ = yw();

      function xDe(r) {
        return typeof r.stream == "function" ? UJ(r.stream()) : UJ(new Response(r).body)
      }
      FJ.exports = xDe
    });
    var Vx = y((g6t, zJ) => {
      l();
      "use strict";

      function ADe(r) {
        let [e, t] = r[Symbol.asyncIterator] ? [r[Symbol.asyncIterator](), Symbol.asyncIterator] : [r[Symbol.iterator](), Symbol.iterator], i = [];
        return {
          peek: () => e.next(),
          push: n => {
            i.push(n)
          },
          next: () => i.length ? {
            done: !1,
            value: i.shift()
          } : e.next(),
          [t]() {
            return this
          }
        }
      }
      zJ.exports = ADe
    });
    var Hx = y((b6t, jJ) => {
      l();
      "use strict";
      var {
        Blob: VJ
      } = globalThis;

      function IDe(r) {
        return ArrayBuffer.isView(r) || r instanceof ArrayBuffer
      }

      function TDe(r) {
        return typeof VJ != "undefined" && r instanceof VJ
      }

      function RDe(r) {
        return typeof r == "object" && (r.path || r.content)
      }
      var kDe = r => r && typeof r.getReader == "function";
      jJ.exports = {
        isBytes: IDe,
        isBlob: TDe,
        isFileObject: RDe,
        isReadableStream: kDe
      }
    });
    var $J = y((m6t, HJ) => {
      l();
      "use strict";
      var PDe = xe(),
        CDe = gt(),
        ODe = yw(),
        NDe = KJ(),
        qDe = Vx(),
        MDe = vy(),
        BDe = Qc(),
        {
          isBytes: GJ,
          isReadableStream: DDe,
          isBlob: LDe
        } = Hx();
      async function* FDe(r) {
        if (GJ(r)) {
          yield Gx(r);
          return
        }
        if (typeof r == "string" || r instanceof String) {
          yield Gx(r.toString());
          return
        }
        if (LDe(r)) {
          yield* NDe(r);
          return
        }
        if (DDe(r) && (r = ODe(r)), Symbol.iterator in r || Symbol.asyncIterator in r) {
          let e = qDe(r),
            {
              value: t,
              done: i
            } = await e.peek();
          if (i) {
            yield* [];
            return
          }
          if (e.push(t), Number.isInteger(t)) {
            yield Uint8Array.from(await MDe(e));
            return
          }
          if (GJ(t) || typeof t == "string" || t instanceof String) {
            yield* BDe(e, Gx);
            return
          }
        }
        throw PDe(new Error(`Unexpected input: ${r}`), "ERR_UNEXPECTED_INPUT")
      }

      function Gx(r) {
        return r instanceof Uint8Array ? r : ArrayBuffer.isView(r) ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r instanceof ArrayBuffer ? new Uint8Array(r) : Array.isArray(r) ? Uint8Array.from(r) : CDe(r.toString())
      }
      HJ.exports = FDe
    });
    var eX = y((v6t, WJ) => {
      l();
      "use strict";
      var UDe = xe(),
        KDe = yw(),
        zDe = Vx(),
        YJ = Qc(),
        {
          isBytes: JJ,
          isBlob: XJ,
          isReadableStream: ZJ,
          isFileObject: QJ
        } = Hx(),
        {
          parseMtime: jDe,
          parseMode: VDe
        } = Ii();
      WJ.exports = async function* (e, t) {
        if (e != null) {
          if (typeof e == "string" || e instanceof String) {
            yield b0(e.toString(), t);
            return
          }
          if (JJ(e) || XJ(e)) {
            yield b0(e, t);
            return
          }
          if (ZJ(e) && (e = KDe(e)), Symbol.iterator in e || Symbol.asyncIterator in e) {
            let i = zDe(e),
              {
                value: n,
                done: s
              } = await i.peek();
            if (s) {
              yield* [];
              return
            }
            if (i.push(n), Number.isInteger(n) || JJ(n)) {
              yield b0(i, t);
              return
            }
            if (QJ(n) || XJ(n) || typeof n == "string" || n instanceof String) {
              yield* YJ(i, o => b0(o, t));
              return
            }
            if (n[Symbol.iterator] || n[Symbol.asyncIterator] || ZJ(n)) {
              yield* YJ(i, o => b0(o, t));
              return
            }
          }
          if (QJ(e)) {
            yield b0(e, t);
            return
          }
          throw UDe(new Error("Unexpected input: " + typeof e), "ERR_UNEXPECTED_INPUT")
        }
      };
      async function b0(r, e) {
        let {
          path: t,
          mode: i,
          mtime: n,
          content: s
        } = r, o = {
          path: t || "",
          mode: VDe(i),
          mtime: jDe(n)
        };
        return s ? o.content = await e(s) : t || (o.content = await e(r)), o
      }
    });
    var rX = y((w6t, tX) => {
      l();
      "use strict";
      var HDe = $J(),
        GDe = eX();
      tX.exports = r => GDe(r, HDe)
    });
    var sX = y((_6t, iX) => {
      l();
      "use strict";
      var $De = r => {
        if (r)
          if (r.startsWith("size-")) {
            let e = r.split("-")[1],
              t = parseInt(e);
            if (isNaN(t)) throw new Error("Chunker parameter size must be an integer");
            return {
              chunker: "fixed",
              maxChunkSize: t
            }
          } else {
            if (r.startsWith("rabin")) return {
              chunker: "rabin",
              ...nX(r)
            };
            throw new Error(`Unrecognized chunker option: ${r}`)
          }
        else return {
          chunker: "fixed"
        }
      },
        nX = r => {
          let e = {},
            t = r.split("-");
          switch (t.length) {
            case 1:
              e.avgChunkSize = 262144;
              break;
            case 2:
              e.avgChunkSize = og(t[1], "avg");
              break;
            case 4:
              e.minChunkSize = og(t[1], "min"), e.avgChunkSize = og(t[2], "avg"), e.maxChunkSize = og(t[3], "max");
              break;
            default:
              throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"')
          }
          return e
        },
        og = (r, e) => {
          let t = parseInt(r);
          if (isNaN(t)) throw new Error(`Chunker parameter ${e} must be an integer`);
          return t
        };
      iX.exports = {
        parseChunkSize: og,
        parseRabinString: nX,
        parseChunkerString: $De
      }
    });
    var aX = y((E6t, oX) => {
      l();
      "use strict";
      var {
        importer: WDe
      } = pw(), YDe = rX(), {
        parseChunkerString: JDe
      } = sX(), {
        pipe: XDe
      } = vi(), ZDe = ze(), QDe = Yr().bind({
        ignoreUndefined: !0
      });
      oX.exports = ({
        block: r,
        gcLock: e,
        preload: t,
        pin: i,
        options: n
      }) => {
        let s = n && n.sharding;
        async function* o(a, c = {}) {
          let u = QDe({
            shardSplitThreshold: s ? 1e3 : Infinity,
            strategy: "balanced"
          }, c, {
            ...JDe(c.chunker)
          });
          u.hashAlg && u.hashAlg !== "sha2-256" && u.cidVersion !== 1 && (u.cidVersion = 1), u.trickle && (u.strategy = "trickle"), u.strategy === "trickle" && (u.leafType = "raw", u.reduceSingleLeafToSelf = !1), u.cidVersion > 0 && u.rawLeaves === void 0 && (u.rawLeaves = !0), u.hashAlg !== void 0 && u.rawLeaves === void 0 && (u.rawLeaves = !0), delete u.trickle;
          let f = {};
          if (u.progress) {
            let p = u.progress;
            u.progress = (g, m) => {
              f[m] || (f[m] = 0), f[m] += g, p(f[m], m)
            }
          }
          let h = XDe(YDe(a), p => WDe(p, r, {
            ...u,
            pin: !1
          }), eLe(u), tLe(t, u), rLe(i, u)),
            d = await e.readLock();
          try {
            for await (let p of h) delete f[p.path], yield p
          } finally {
            d()
          }
        }
        return ZDe(o)
      };

      function eLe(r) {
        async function* e(t) {
          for await (let i of t) {
            let n = i.cid;
            r.cidVersion === 1 && (n = n.toV1());
            let s = i.path ? i.path : n.toString();
            r.wrapWithDirectory && !i.path && (s = ""), yield {
              path: s,
              cid: n,
              size: i.size,
              mode: i.unixfs && i.unixfs.mode,
              mtime: i.unixfs && i.unixfs.mtime
            }
          }
        }
        return e
      }

      function tLe(r, e) {
        async function* t(i) {
          for await (let n of i) (!n.path || e.wrapWithDirectory ? n.path === "" : !n.path.includes("/")) && !e.onlyHash && e.preload !== !1 && r(n.cid), yield n
        }
        return t
      }

      function rLe(r, e) {
        async function* t(i) {
          for await (let n of i) {
            let s = !(n.path && n.path.includes("/"));
            (e.pin == null ? !0 : e.pin) && s && !e.onlyHash && await r.add(n.cid, {
              preload: !1,
              lock: !1
            }), yield n
          }
        }
        return t
      }
    });
    var lX = y((S6t, cX) => {
      l();
      "use strict";
      var {
        Bucket: iLe,
        createHAMT: nLe
      } = hw(), sLe = cr(), oLe = async function (r) {
        let t = (await sLe(r, "murmur3-128")).slice(2, 10),
          i = t.length,
          n = new Uint8Array(i);
        for (let s = 0; s < i; s++) n[i - s - 1] = t[s];
        return n
      }, aLe = (r, e, t) => Promise.all(r.map(i => {
        if (i.Name.length === 2) {
          let n = parseInt(i.Name, 16);
          return e._putObjectAt(n, new iLe({
            hash: t._options.hash,
            bits: t._options.bits
          }, e, n))
        }
        return t.put(i.Name.substring(2), !0)
      })), uX = r => r.toString(16).toUpperCase().padStart(2, "0").substring(0, 2), cLe = r => {
        let e = r.bucket,
          t = [];
        for (; e._parent;) t.push(e), e = e._parent;
        return t.push(e), t.reverse()
      }, fX = async (r, e, t, i, n) => {
        if (!i) {
          let u = nLe({
            hashFn: oLe
          });
          i = {
            rootBucket: u,
            hamtDepth: 1,
            lastBucket: u
          }
        }
        await aLe(r.Links, i.lastBucket, i.rootBucket);
        let s = await i.rootBucket._findNewBucketAndPos(e),
          o = uX(s.pos),
          a = cLe(s);
        a.length > i.hamtDepth && (i.lastBucket = a[i.hamtDepth], o = uX(i.lastBucket._posAtParent));
        let c = r.Links.find(u => {
          let f = u.Name.substring(0, 2),
            h = u.Name.substring(2);
          return !(f !== o || h && h !== e)
        });
        return c ? c.Name.substring(2) === e ? c.Hash : (i.hamtDepth++, r = await t.get(c.Hash, n), fX(r, e, t, i, n)) : null
      };
      cX.exports = fX
    });
    var gw = y((x6t, hX) => {
      l();
      "use strict";
      hX.exports = function (e, t, i, n) {
        let s = e.length,
          o = t + s;
        return i >= o || n < t ? new Uint8Array(0) : (n >= t && n < o && (e = e.slice(0, n - t)), i >= t && i < o && (e = e.slice(i - t)), e)
      }
    });
    var bw = y((A6t, dX) => {
      l();
      "use strict";
      var $x = xe(),
        uLe = (r, e, t) => {
          if (e || (e = 0), e < 0) throw $x(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
          if (e > r) throw $x(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
          if (!t && t !== 0 && (t = r - e), t < 0) throw $x(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
          return e + t > r && (t = r - e), {
            offset: e,
            length: t
          }
        };
      dX.exports = uLe
    });
    var Wx = y((I6t, pX) => {
      l();
      "use strict";
      var yX = gw(),
        fLe = bw(),
        {
          UnixFS: lLe
        } = Ii(),
        hLe = xe();
      async function* gX(r, e, t, i, n = 0, s) {
        if (e instanceof Uint8Array) {
          let c = yX(e, n, t, i);
          return c.length && (yield c), n += c.length, n
        }
        let o;
        try {
          o = lLe.unmarshal(e.Data)
        } catch (c) {
          throw hLe(c, "ERR_NOT_UNIXFS")
        }
        if (o.data && o.data.length) {
          let c = yX(o.data, n, t, i);
          c.length && (yield c), n += o.data.length
        }
        let a = n;
        for (let c = 0; c < e.Links.length; c++) {
          let u = e.Links[c],
            f = n + o.blockSizes[c];
          if (t >= a && t < f || i > a && i <= f || t < a && i > f) {
            let h = await r.get(u.Hash, {
              signal: s.signal
            });
            for await (let d of gX(r, h, t, i, n, s)) n += d.length, yield d
          }
          n = f, a = f + 1
        }
      }
      var dLe = (r, e, t, i, n, s, o) => {
        function a(c = {}) {
          let u = t.fileSize();
          if (u === void 0) throw new Error("File was a directory");
          let {
            offset: f,
            length: h
          } = fLe(u, c.offset, c.length), d = f, p = f + h;
          return gX(o, e, d, p, 0, c)
        }
        return a
      };
      pX.exports = dLe
    });
    var mX = y((T6t, bX) => {
      l();
      "use strict";
      var pLe = (r, e, t, i, n, s, o) => {
        async function* a(c = {}) {
          let u = c.offset || 0,
            f = c.length || e.Links.length,
            h = e.Links.slice(u, f);
          for (let d of h) {
            let p = await n(d.Hash, d.Name, `${i}/${d.Name}`, [], s + 1, o, c);
            p.entry && (yield p.entry)
          }
        }
        return a
      };
      bX.exports = pLe
    });
    var _X = y((R6t, vX) => {
      l();
      "use strict";
      var yLe = (r, e, t, i, n, s, o) => {
        function a(c = {}) {
          return wX(e, i, n, s, o, c)
        }
        return a
      };
      async function* wX(r, e, t, i, n, s) {
        let o = r.Links;
        for (let a of o) {
          let c = a.Name.substring(2);
          if (c) yield (await t(a.Hash, c, `${e}/${c}`, [], i + 1, n, s)).entry;
          else {
            r = await n.get(a.Hash);
            for await (let u of wX(r, e, t, i, n, s)) yield u
          }
        }
      }
      vX.exports = yLe
    });
    var xX = y((k6t, EX) => {
      l();
      "use strict";
      var SX = xe(),
        {
          UnixFS: gLe
        } = Ii(),
        bLe = lX(),
        mLe = (r, e) => {
          let t = r.Links.find(i => i.Name === e);
          return t && t.Hash
        },
        vLe = {
          raw: Wx(),
          file: Wx(),
          directory: mX(),
          "hamt-sharded-directory": _X(),
          metadata: (r, e, t, i, n, s, o) => () => [],
          symlink: (r, e, t, i, n, s, o) => () => []
        },
        wLe = async (r, e, t, i, n, s, o, a) => {
          let c = await o.get(r, a),
            u, f;
          e || (e = r.toString());
          try {
            u = gLe.unmarshal(c.Data)
          } catch (h) {
            throw SX(h, "ERR_NOT_UNIXFS")
          }
          if (t || (t = e), i.length) {
            let h;
            if (u && u.type === "hamt-sharded-directory" ? h = await bLe(c, i[0], o) : h = mLe(c, i[0]), !h) throw SX(new Error("file does not exist"), "ERR_NOT_FOUND");
            let d = i.shift(),
              p = `${t}/${d}`;
            f = {
              cid: h,
              toResolve: i,
              name: d || "",
              path: p
            }
          }
          return {
            entry: {
              type: u.isDirectory() ? "directory" : "file",
              name: e,
              path: t,
              cid: r,
              content: vLe[u.type](r, c, u, t, n, s, o),
              unixfs: u,
              depth: s,
              node: c,
              size: u.fileSize()
            },
            next: f
          }
        };
      EX.exports = wLe
    });
    var IX = y((P6t, AX) => {
      l();
      "use strict";
      var _Le = xe(),
        ELe = gw(),
        SLe = bw(),
        xLe = r => {
          async function* e(t = {}) {
            let {
              offset: i,
              length: n
            } = SLe(r.length, t.offset, t.length);
            yield ELe(r, 0, i, i + n)
          }
          return e
        },
        ALe = async (r, e, t, i, n, s, o, a) => {
          if (i.length) throw _Le(new Error(`No link named ${t} found in raw node ${r}`), "ERR_NOT_FOUND");
          let c = await o.get(r, a);
          return {
            entry: {
              type: "raw",
              name: e,
              path: t,
              cid: r,
              content: xLe(c),
              depth: s,
              size: c.length,
              node: c
            }
          }
        };
      AX.exports = ALe
    });
    var kX = y((C6t, TX) => {
      l();
      "use strict";
      var RX = at(),
        ILe = xe(),
        TLe = async (r, e, t, i, n, s, o, a) => {
          let c = await o.get(r, a),
            u = await o.get(new RX(1, "raw", r.multihash)),
            f = c,
            h = t;
          for (; i.length;) {
            let d = i[0];
            if (d in f) {
              if (i.shift(), h = `${h}/${d}`, RX.isCID(f[d])) return {
                entry: {
                  type: "object",
                  name: e,
                  path: t,
                  cid: r,
                  node: u,
                  depth: s,
                  size: u.length,
                  content: async function* () {
                    yield c
                  }
                },
                next: {
                  cid: f[d],
                  name: d,
                  path: h,
                  toResolve: i
                }
              };
              f = f[d]
            } else throw ILe(new Error(`No property named ${d} found in cbor node ${r}`), "ERR_NO_PROP")
          }
          return {
            entry: {
              type: "object",
              name: e,
              path: t,
              cid: r,
              node: u,
              depth: s,
              size: u.length,
              content: async function* () {
                yield c
              }
            }
          }
        };
      TX.exports = TLe
    });
    var CX = y((O6t, PX) => {
      l();
      "use strict";
      var RLe = xe(),
        kLe = gw(),
        PLe = bw(),
        CLe = cr().multihash,
        OLe = r => {
          async function* e(t = {}) {
            let {
              offset: i,
              length: n
            } = PLe(r.length, t.offset, t.length);
            yield kLe(r, 0, i, i + n)
          }
          return e
        },
        NLe = async (r, e, t, i, n, s, o, a) => {
          if (i.length) throw RLe(new Error(`No link named ${t} found in raw node ${r}`), "ERR_NOT_FOUND");
          let c = await CLe.decode(r.multihash);
          return {
            entry: {
              type: "identity",
              name: e,
              path: t,
              cid: r,
              content: OLe(c.digest),
              depth: s,
              size: c.length,
              node: c.digest
            }
          }
        };
      PX.exports = NLe
    });
    var qX = y((N6t, OX) => {
      l();
      "use strict";
      var qLe = xe(),
        MLe = {
          "dag-pb": xX(),
          raw: IX(),
          "dag-cbor": kX(),
          identity: CX()
        };

      function NX(r, e, t, i, n, s, o) {
        let a = MLe[r.codec];
        if (!a) throw qLe(new Error(`No resolver for codec ${r.codec}`), "ERR_NO_RESOLVER");
        return a(r, e, t, i, NX, n, s, o)
      }
      OX.exports = NX
    });
    var sa = y((q6t, MX) => {
      l();
      "use strict";
      var Yx = xe(),
        Jx = at(),
        BLe = qX(),
        DLe = Qa(),
        LLe = (r = "") => (r.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean),
        FLe = r => {
          if (r instanceof Uint8Array) return {
            cid: new Jx(r),
            toResolve: []
          };
          if (Jx.isCID(r)) return {
            cid: r,
            toResolve: []
          };
          if (typeof r == "string") {
            r.indexOf("/ipfs/") === 0 && (r = r.substring(6));
            let e = LLe(r);
            return {
              cid: new Jx(e[0]),
              toResolve: e.slice(1)
            }
          }
          throw Yx(new Error(`Unknown path type ${r}`), "ERR_BAD_PATH")
        };
      async function* BX(r, e, t = {}) {
        let {
          cid: i,
          toResolve: n
        } = FLe(r), s = i.toString(), o = s, a = n.length;
        for (; ;) {
          let c = await BLe(i, s, o, n, a, e, t);
          if (!c.entry && !c.next) throw Yx(new Error(`Could not resolve ${r}`), "ERR_NOT_FOUND");
          if (c.entry && (yield c.entry), !c.next) return;
          n = c.next.toResolve, i = c.next.cid, s = c.next.name, o = c.next.path
        }
      }
      async function DX(r, e, t = {}) {
        let i = await DLe(BX(r, e, t));
        if (!i) throw Yx(new Error(`Could not resolve ${r}`), "ERR_NOT_FOUND");
        return i
      }
      async function* ULe(r, e, t = {}) {
        let i = await DX(r, e, t);
        if (!i) return;
        if (yield i, i.type === "directory")
          for await (let s of n(i, t)) yield s;
        async function* n(s, o) {
          for await (let a of s.content(o)) yield a, !(a instanceof Uint8Array) && a.type === "directory" && (yield* n(a, o))
        }
      }
      MX.exports = {
        exporter: DX,
        walkPath: BX,
        recursive: ULe
      }
    });
    var FX = y((M6t, LX) => {
      l();
      "use strict";
      var {
        exporter: KLe
      } = sa(), {
        normalizeCidPath: zLe
      } = Ji(), jLe = ze(), VLe = at();
      LX.exports = function ({
        ipld: r,
        preload: e
      }) {
        async function* t(i, n = {}) {
          if (i = zLe(i), n.preload !== !1) {
            let o = i.split("/");
            e(new VLe(o[0]))
          }
          let s = await KLe(i, r, n);
          if (s.type === "directory") throw new Error("this dag node is a directory");
          if (!s.content) throw new Error("this dag node has no content");
          yield* s.content(n)
        }
        return jLe(t)
      }
    });
    var KX = y((B6t, UX) => {
      l();
      "use strict";
      var HLe = sa(),
        GLe = xe(),
        {
          normalizeCidPath: $Le,
          mapFile: WLe
        } = Ji(),
        YLe = ze(),
        JLe = at();
      UX.exports = function ({
        ipld: r,
        preload: e
      }) {
        async function* t(i, n = {}) {
          if (n.preload !== !1) {
            let s;
            try {
              s = $Le(i).split("/")
            } catch (o) {
              throw GLe(o, "ERR_INVALID_PATH")
            }
            e(new JLe(s[0]))
          }
          for await (let s of HLe.recursive(i, r, n)) yield WLe(s, {
            ...n,
            includeContent: !0
          })
        }
        return YLe(t)
      }
    });
    var jX = y((D6t, zX) => {
      l();
      "use strict";
      var {
        exporter: XLe,
        recursive: ZLe
      } = sa(), QLe = xe(), {
        normalizeCidPath: eFe,
        mapFile: Xx
      } = Ji(), tFe = ze(), rFe = at();
      zX.exports = function ({
        ipld: r,
        preload: e
      }) {
        async function* t(i, n = {}) {
          let o = eFe(i).split("/");
          n.preload !== !1 && e(new rFe(o[0]));
          let a = await XLe(i, r, n);
          if (a.type === "file") {
            yield Xx(a, n);
            return
          }
          if (a.type === "directory") {
            if (n.recursive) {
              for await (let c of ZLe(a.cid, r, n)) a.cid.toBaseEncodedString() !== c.cid.toBaseEncodedString() && (yield Xx(c, n));
              return
            }
            for await (let c of a.content()) {
              let u = Xx(c, n);
              u.depth--, yield u
            }
            return
          }
          throw QLe(new Error(`Unknown UnixFS type ${a.type}`), "ERR_UNKNOWN_UNIXFS_TYPE")
        }
        return tFe(t)
      }
    });
    var GX = y((L6t, VX) => {
      l();
      "use strict";
      var iFe = oY(),
        nFe = aX(),
        sFe = FX(),
        oFe = KX(),
        aFe = jX(),
        HX = class {
          constructor({
            preload: e,
            gcLock: t,
            pin: i,
            block: n,
            ipld: s,
            options: o
          }) {
            let a = nFe({
              preload: e,
              gcLock: t,
              block: n,
              pin: i,
              options: o
            });
            this.addAll = a, this.add = iFe({
              addAll: a
            }), this.cat = sFe({
              ipld: s,
              preload: e
            }), this.get = oFe({
              ipld: s,
              preload: e
            }), this.ls = aFe({
              ipld: s,
              preload: e
            })
          }
        };
      VX.exports = HX
    });
    var mw = y((F6t, $X) => {
      $X.exports = {
        name: "ipfs-core",
        version: "0.7.0",
        description: "JavaScript implementation of the IPFS specification",
        keywords: ["IPFS"],
        homepage: "https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs-core#readme",
        bugs: "https://github.com/ipfs/js-ipfs/issues",
        license: "(Apache-2.0 OR MIT)",
        leadMaintainer: "Alex Potsides <alex@achingbrain.net>",
        main: "src/index.js",
        types: "dist/src/index.d.ts",
        files: ["src", "dist", "!dist/*.tsbuildinfo"],
        browser: {
          "./src/runtime/init-assets-nodejs.js": "./src/runtime/init-assets-browser.js",
          "./src/runtime/config-nodejs.js": "./src/runtime/config-browser.js",
          "./src/runtime/dns-nodejs.js": "./src/runtime/dns-browser.js",
          "./src/runtime/libp2p-nodejs.js": "./src/runtime/libp2p-browser.js",
          "./src/runtime/libp2p-pubsub-routers-nodejs.js": "./src/runtime/libp2p-pubsub-routers-browser.js",
          "./src/runtime/preload-nodejs.js": "./src/runtime/preload-browser.js",
          "./src/runtime/repo-nodejs.js": "./src/runtime/repo-browser.js",
          "./test/utils/create-repo-nodejs.js": "./test/utils/create-repo-browser.js",
          "ipfs-utils/src/files/glob-source": !1
        },
        typesVersions: {
          "*": {
            "src/*": ["dist/src/*", "dist/src/*/index"],
            "src/": ["dist/src/index"]
          }
        },
        repository: {
          type: "git",
          url: "git+https://github.com/ipfs/js-ipfs.git"
        },
        scripts: {
          build: "aegir build",
          lint: "aegir lint",
          test: "aegir test",
          "test:node": "aegir test -t node",
          "test:browser": "aegir test -t browser",
          "test:webworker": "aegir test -t webworker",
          "test:electron-main": "aegir test -t electron-main",
          "test:electron-renderer": "aegir test -t electron-renderer",
          "test:bootstrapers": "IPFS_TEST=bootstrapers aegir test -t browser -f test/bootstrapers.js",
          coverage: "nyc --reporter=text --reporter=lcov npm run test:node",
          clean: "rimraf ./dist",
          "dep-check": "aegir dep-check -i interface-ipfs-core -i ipfs-core-types -i abort-controller"
        },
        dependencies: {
          "abort-controller": "^3.0.0",
          "array-shuffle": "^2.0.0",
          cborg: "^1.2.1",
          cids: "^1.1.6",
          "dag-cbor-links": "^2.0.0",
          "datastore-core": "^4.0.0",
          "datastore-pubsub": "^0.6.1",
          debug: "^4.1.1",
          dlv: "^1.1.3",
          "err-code": "^3.0.1",
          "hamt-sharding": "^2.0.0",
          hashlru: "^2.3.0",
          "interface-datastore": "^4.0.0",
          "ipfs-bitswap": "^5.0.3",
          "ipfs-block-service": "^0.19.0",
          "ipfs-core-types": "^0.5.0",
          "ipfs-core-utils": "^0.8.1",
          "ipfs-repo": "^9.1.6",
          "ipfs-unixfs": "^4.0.3",
          "ipfs-unixfs-exporter": "^5.0.3",
          "ipfs-unixfs-importer": "^7.0.3",
          "ipfs-utils": "^8.1.2",
          ipld: "^0.30.0",
          "ipld-block": "^0.11.0",
          "ipld-dag-cbor": "^1.0.0",
          "ipld-dag-pb": "^0.22.1",
          "ipld-raw": "^7.0.0",
          ipns: "^0.11.0",
          "is-domain-name": "^1.0.1",
          "is-ipfs": "^5.0.0",
          "it-all": "^1.0.4",
          "it-drain": "^1.0.3",
          "it-first": "^1.0.4",
          "it-last": "^1.0.4",
          "it-map": "^1.0.4",
          "it-pipe": "^1.1.0",
          "just-safe-set": "^2.2.1",
          libp2p: "^0.31.6",
          "libp2p-bootstrap": "^0.12.3",
          "libp2p-crypto": "^0.19.3",
          "libp2p-floodsub": "^0.25.1",
          "libp2p-gossipsub": "^0.9.2",
          "libp2p-kad-dht": "^0.22.0",
          "libp2p-mdns": "^0.16.0",
          "libp2p-mplex": "^0.10.2",
          "libp2p-noise": "^3.0.0",
          "libp2p-record": "^0.10.3",
          "libp2p-tcp": "^0.15.4",
          "libp2p-webrtc-star": "^0.22.2",
          "libp2p-websockets": "^0.15.6",
          mafmt: "^9.0.0",
          "merge-options": "^3.0.4",
          mortice: "^2.0.0",
          multiaddr: "^9.0.1",
          "multiaddr-to-uri": "^7.0.0",
          multibase: "^4.0.2",
          multicodec: "^3.0.1",
          "multihashing-async": "^2.1.2",
          "native-abort-controller": "^1.0.3",
          "p-queue": "^6.6.1",
          "parse-duration": "^1.0.0",
          "peer-id": "^0.14.1",
          "streaming-iterables": "^5.0.2",
          uint8arrays: "^2.1.3"
        },
        devDependencies: {
          "@types/dlv": "^1.1.2",
          aegir: "^33.0.0",
          delay: "^5.0.0",
          "go-ipfs": "0.8.0",
          "interface-ipfs-core": "^0.146.0",
          "ipfsd-ctl": "^8.0.1",
          "ipld-git": "^0.6.1",
          "iso-url": "^1.0.0",
          nanoid: "^3.1.12",
          rimraf: "^3.0.2",
          sinon: "^10.0.1"
        }
      }
    });
    var YX = y((U6t, WX) => {
      l();
      "use strict";
      var Zx = mw(),
        cFe = ze();
      WX.exports = ({
        repo: r
      }) => {
        async function e(t = {}) {
          let i = await r.version.get();
          return {
            version: Zx.version,
            repo: `${i}`,
            commit: Zx.gitHead || "",
            "interface-ipfs-core": Zx.devDependencies["interface-ipfs-core"]
          }
        }
        return cFe(e)
      }
    });
    var XX = y((K6t, JX) => {
      l();
      "use strict";
      var uFe = mw().version,
        {
          Multiaddr: fFe
        } = pr(),
        lFe = ze(),
        vw = ct(),
        hFe = Et(),
        {
          NotStartedError: dFe
        } = of();
      JX.exports = ({
        peerId: r,
        network: e
      }) => {
        async function t(i = {}) {
          i.peerId === r.toB58String() && delete i.peerId;
          let n = e.try();
          if (!n) {
            if (i.peerId) throw new dFe;
            return {
              id: r.toB58String(),
              publicKey: vw(r.pubKey.bytes, "base64pad"),
              addresses: [],
              agentVersion: `js-ipfs/${uFe}`,
              protocolVersion: "9000",
              protocols: []
            }
          }
          let s = i.peerId ? hFe.createFromB58String(i.peerId.toString()) : r,
            {
              libp2p: o
            } = n,
            a = i.peerId ? o.peerStore.keyBook.get(s) : s.pubKey,
            c = i.peerId ? o.peerStore.addressBook.getMultiaddrsForPeer(s) : o.multiaddrs,
            u = i.peerId ? o.peerStore.protoBook.get(s) : Array.from(o.upgrader.protocols.keys()),
            f = vw(o.peerStore.metadataBook.getValue(s, "AgentVersion") || new Uint8Array),
            h = vw(o.peerStore.metadataBook.getValue(s, "ProtocolVersion") || new Uint8Array),
            d = s.toB58String();
          return {
            id: d,
            publicKey: vw(a.bytes, "base64pad"),
            addresses: (c || []).map(p => {
              let g = p.toString();
              return g.endsWith(`/p2p/${d}`) ? g : `${g}/p2p/${d}`
            }).sort().map(p => new fFe(p)),
            agentVersion: f,
            protocolVersion: h,
            protocols: (u || []).sort()
          }
        }
        return lFe(t)
      }
    });
    var Qx = y((z6t, ZX) => {
      l();
      ZX.exports = pFe;

      function pFe(r, e, t) {
        typeof e == "string" && (e = e.split(".")), typeof e == "symbol" && (e = [e]);
        var i = e.pop();
        if (!i) return !1;
        for (var n; n = e.shift();)
          if (typeof r[n] == "undefined" && (r[n] = {}), r = r[n], !r || typeof r != "object") return !1;
        return r[i] = t, !0
      }
    });
    var rA = y((j6t, eA) => {
      l();
      "use strict";
      var fi = Qx(),
        tA = tw(),
        m0 = ze(),
        yFe = Oe()("ipfs:core:config");
      eA.exports = ({
        repo: r
      }) => {
        return {
          getAll: m0(e),
          get: m0(t),
          set: m0(i),
          replace: m0(n),
          profiles: {
            apply: m0(s),
            list: m0(gFe)
          }
        };
        async function e(o = {}) {
          return r.config.getAll(o)
        }
        async function t(o, a) {
          return o ? r.config.get(o, a) : Promise.reject(new Error("key argument is required"))
        }
        async function i(o, a, c) {
          return r.config.set(o, a, c)
        }
        async function n(o, a) {
          return r.config.replace(o, a)
        }
        async function s(o, a = {
          dryRun: !1
        }) {
          let {
            dryRun: c
          } = a, u = ww[o];
          if (!u) throw new Error(`No profile with name '${o}' exists`);
          try {
            let f = await r.config.getAll(a),
              h = JSON.parse(JSON.stringify(f));
            return h = u.transform(h), c || await r.config.replace(h, a), delete f.Identity.PrivKey, delete h.Identity.PrivKey, {
              original: f,
              updated: h
            }
          } catch (f) {
            throw yFe(f), new Error(`Could not apply profile '${o}' to config: ${f.message}`)
          }
        }
      };
      async function gFe(r) {
        return Object.keys(ww).map(e => ({
          name: e,
          description: ww[e].description
        }))
      }
      var ww = {
        server: {
          description: "Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",
          transform: r => (fi(r, "Discovery.MDNS.Enabled", !1), fi(r, "Discovery.webRTCStar.Enabled", !1), r.Swarm = {
            ...r.Swarm || {},
            DisableNatPortMap: !0
          }, r)
        },
        "local-discovery": {
          description: "Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",
          transform: r => (fi(r, "Discovery.MDNS.Enabled", !0), fi(r, "Discovery.webRTCStar.Enabled", !0), fi(r, "Swarm", {
            ...r.Swarm || {},
            DisableNatPortMap: !1
          }), r)
        },
        test: {
          description: "Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",
          transform: r => {
            let e = tA();
            return fi(r, "Addresses.API", e.Addresses.API ? "/ip4/127.0.0.1/tcp/0" : ""), fi(r, "Addresses.Gateway", e.Addresses.Gateway ? "/ip4/127.0.0.1/tcp/0" : ""), fi(r, "Addresses.Swarm", e.Addresses.Swarm.length ? ["/ip4/127.0.0.1/tcp/0"] : []), fi(r, "Addresses.Delegates", []), fi(r, "Bootstrap", []), fi(r, "Discovery.MDNS.Enabled", !1), fi(r, "Discovery.webRTCStar.Enabled", !1), fi(r, "Swarm", {
              ...r.Swarm || {},
              DisableNatPortMap: !0
            }), r
          }
        },
        "default-networking": {
          description: "Restores default network settings. Inverse profile of the `test` profile.",
          transform: r => {
            let e = tA();
            return fi(r, "Addresses.API", e.Addresses.API), fi(r, "Addresses.Gateway", e.Addresses.Gateway), fi(r, "Addresses.Swarm", e.Addresses.Swarm), fi(r, "Addresses.Delegates", e.Addresses.Delegates), fi(r, "Bootstrap", e.Bootstrap), fi(r, "Discovery.MDNS.Enabled", e.Discovery.MDNS.Enabled), fi(r, "Discovery.webRTCStar.Enabled", e.Discovery.webRTCStar.Enabled), fi(r, "Swarm", {
              ...r.Swarm || {},
              DisableNatPortMap: !1
            }), r
          }
        },
        lowpower: {
          description: "Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",
          transform: r => {
            let e = r.Swarm || {},
              t = e.ConnMgr || {};
            return t.LowWater = 20, t.HighWater = 40, e.ConnMgr = t, r.Swarm = e, r
          }
        },
        "default-power": {
          description: 'Inverse of "lowpower" profile.',
          transform: r => {
            let e = tA();
            return r.Swarm = e.Swarm, r
          }
        }
      };
      eA.exports.profiles = ww
    });
    var eZ = y((V6t, QX) => {
      l();
      "use strict";
      var bFe = ze(),
        mFe = r0(),
        vFe = Qa();
      QX.exports = ({
        ipld: r,
        preload: e
      }) => bFe(async function (n, s = {}) {
        return s.preload !== !1 && e(n), s.path ? s.localResolve ? await mFe(r.resolve(n, s.path)) : await vFe(r.resolve(n, s.path)) : {
          value: await r.get(n, s),
          remainderPath: ""
        }
      })
    });
    var rZ = y((H6t, tZ) => {
      l();
      "use strict";
      var wFe = ze(),
        _Fe = Sy();
      tZ.exports = ({
        ipld: r,
        preload: e
      }) => {
        async function* t(i, n = {}) {
          let {
            cid: s,
            path: o
          } = _Fe(i);
          o && (n.path = o), n.preload !== !1 && e(s), yield* r.tree(s, n.path, n)
        }
        return wFe(t)
      }
    });
    var sZ = y((G6t, iZ) => {
      l();
      "use strict";
      var _w = Jr(),
        nZ = cr().multihash,
        EFe = r => _w.getCodeFromName(r),
        SFe = r => nZ.names[r],
        xFe = ze();
      iZ.exports = ({
        ipld: r,
        pin: e,
        gcLock: t,
        preload: i
      }) => {
        async function n(s, o = {}) {
          let {
            cidVersion: a,
            format: c,
            hashAlg: u
          } = AFe(o), f = o.pin ? await t.readLock() : null;
          try {
            let h = await r.put(s, c, {
              hashAlg: u,
              cidVersion: a,
              signal: o.signal
            });
            return o.pin && await e.add(h, {
              lock: !1
            }), o.preload !== !1 && i(h), h
          } finally {
            f && f()
          }
        }
        return xFe(n)
      };
      var AFe = r => {
        if (r.cid && (r.format || r.hashAlg)) throw new Error("Can't put dag node. Please provide either `cid` OR `format` and `hashAlg` options.");
        if (r.format && !r.hashAlg || !r.format && r.hashAlg) throw new Error("Can't put dag node. Please provide `format` AND `hashAlg` options.");
        let {
          hashAlg: e,
          format: t
        } = r.cid != null ? {
          format: r.cid.code,
          hashAlg: void 0
        } : IFe({
          ...RFe,
          ...r
        });
        return {
          cidVersion: TFe({
            ...r,
            format: t,
            hashAlg: e
          }),
          format: t,
          hashAlg: e
        }
      },
        IFe = ({
          format: r,
          hashAlg: e
        }) => ({
          format: typeof r == "string" ? EFe(r) : r,
          hashAlg: typeof e == "string" ? SFe(e) : e
        }),
        TFe = ({
          version: r,
          cid: e,
          format: t,
          hashAlg: i
        }) => typeof r == "number" ? r : e ? e.version : t === _w.DAG_PB && i === _w.SHA2_256 ? 0 : 1,
        RFe = {
          format: _w.getCodeFromName("dag-cbor"),
          hashAlg: nZ.names["sha2-256"]
        }
    });
    var cZ = y(($6t, oZ) => {
      l();
      "use strict";
      var kFe = eZ(),
        PFe = O5(),
        CFe = rZ(),
        OFe = sZ(),
        aZ = class {
          constructor({
            ipld: e,
            pin: t,
            preload: i,
            gcLock: n
          }) {
            this.get = kFe({
              ipld: e,
              preload: i
            }), this.resolve = PFe({
              ipld: e,
              preload: i
            }), this.tree = CFe({
              ipld: e,
              preload: i
            }), this.put = OFe({
              ipld: e,
              preload: i,
              pin: t,
              gcLock: n
            })
          }
        };
      oZ.exports = aZ
    });
    var iA = y((W6t, uZ) => {
      l();
      var {
        Multiaddr: NFe
      } = pr(), Ew = (r, e) => e, qFe = (r, e, t, i) => {
        if (i && i.assumeHttp === !1) return `tcp://${r}:${e}`;
        let n = "tcp",
          s = `:${e}`;
        return t[t.length - 1].protocol === "tcp" && (n = e === "443" ? "https" : "http", s = e === "443" || e === "80" ? "" : s), `${n}://${r}${s}`
      }, MFe = {
        ip4: Ew,
        ip6: (r, e, t, i) => i.length === 1 && i[0].protocol === "ip6" ? e : `[${e}]`,
        tcp: (r, e, t, i, n) => i.some(s => ["http", "https", "ws", "wss"].includes(s.protocol)) ? `${r}:${e}` : qFe(r, e, i, n),
        udp: (r, e) => `udp://${r}:${e}`,
        dnsaddr: Ew,
        dns4: Ew,
        dns6: Ew,
        ipfs: (r, e) => `${r}/ipfs/${e}`,
        p2p: (r, e) => `${r}/p2p/${e}`,
        http: r => `http://${r}`,
        https: r => `https://${r}`,
        ws: r => `ws://${r}`,
        wss: r => `wss://${r}`,
        "p2p-websocket-star": r => `${r}/p2p-websocket-star`,
        "p2p-webrtc-star": r => `${r}/p2p-webrtc-star`,
        "p2p-webrtc-direct": r => `${r}/p2p-webrtc-direct`
      };
      uZ.exports = (r, e) => {
        let t = new NFe(r),
          i = r.toString().split("/").slice(1);
        return t.tuples().map(n => ({
          protocol: i.shift(),
          content: n[1] ? i.shift() : null
        })).reduce((n, s, o, a) => {
          let c = MFe[s.protocol];
          if (!c) throw new Error(`Unsupported protocol ${s.protocol}`);
          return c(n, s.content, o, a, e)
        }, "")
      }
    });
    var lZ = y((Y6t, fZ) => {
      l();
      "use strict";
      fZ.exports = r => {
        if (!Array.isArray(r)) throw new TypeError(`Expected an array, got ${typeof r}`);
        r = [...r];
        for (let e = r.length - 1; e > 0; e--) {
          let t = Math.floor(Math.random() * (e + 1));
          [r[e], r[t]] = [r[t], r[e]]
        }
        return r
      }
    });
    var pZ = y((J6t, hZ) => {
      l();
      "use strict";
      var {
        default: BFe
      } = Tl(), DFe = Mm(), dZ = Oe(), LFe = Object.assign(dZ("ipfs:preload"), {
        error: dZ("ipfs:preload:error")
      }), FFe = new BFe({
        concurrency: 4
      });
      hZ.exports = function (e, t = {}) {
        return LFe(e), FFe.add(async () => {
          let n = (await DFe.post(e, {
            signal: t.signal
          })).body.getReader();
          try {
            for (; ;) {
              let {
                done: s
              } = await n.read();
              if (s) return
            }
          } finally {
            n.releaseLock()
          }
        })
      }
    });
    var bZ = y((X6t, yZ) => {
      l();
      "use strict";
      var UFe = iA(),
        gZ = Oe(),
        KFe = lZ(),
        {
          AbortController: zFe
        } = k1(),
        jFe = pZ(),
        VFe = ky(),
        ag = Object.assign(gZ("ipfs:preload"), {
          error: gZ("ipfs:preload:error")
        }),
        HFe = (r = {}) => {
          if (r.enabled = Boolean(r.enabled), r.addresses = r.addresses || [], r.cache = r.cache || 1e3, !r.enabled || !r.addresses.length) return ag("preload disabled"), Object.assign(() => { }, {
            start: () => { },
            stop: () => { }
          });
          let e = !0,
            t = [],
            i = r.addresses.map(UFe),
            n = VFe(r.cache),
            s = async o => {
              try {
                if (e) throw new Error(`preload ${o} but preloader is not started`);
                let a = o.toString();
                if (n.has(a)) return;
                n.set(a, !0);
                let c = KFe(i),
                  u = !1,
                  f = Date.now();
                for (let h of c) {
                  if (e) throw new Error(`preload aborted for ${a}`);
                  let d;
                  try {
                    d = new zFe, t = t.concat(d), await jFe(`${h}/api/v0/refs?r=true&arg=${encodeURIComponent(a)}`, {
                      signal: d.signal
                    }), u = !0
                  } catch (p) {
                    p.type !== "aborted" && ag.error(p)
                  } finally {
                    t = t.filter(p => p !== d)
                  }
                  if (u) break
                }
                ag(`${u ? "" : "un"}successfully preloaded ${a} in ${Date.now() - f}ms`)
              } catch (a) {
                ag.error(a)
              }
            };
          return s.start = () => {
            e = !1
          }, s.stop = () => {
            e = !0, ag(`aborting ${t.length} pending preload request(s)`), t.forEach(o => o.abort()), t = []
          }, s
        };
      yZ.exports = HFe
    });
    var _Z = y((Z6t, mZ) => {
      l();
      "use strict";
      var vZ = Oe(),
        {
          cidToString: wZ
        } = r8(),
        Sw = Object.assign(vZ("ipfs:mfs-preload"), {
          error: vZ("ipfs:mfs-preload:error")
        });
      mZ.exports = ({
        preload: r,
        files: e,
        options: t = {}
      }) => {
        if (t.interval = t.interval || 30 * 1e3, !t.enabled) {
          Sw("MFS preload disabled");
          let o = async () => { };
          return {
            start: o,
            stop: o
          }
        }
        let i = "",
          n, s = async () => {
            try {
              let o = await e.stat("/"),
                a = wZ(o.cid, {
                  base: "base32"
                });
              i !== a && (Sw(`preloading updated MFS root ${i} -> ${o.cid}`), await r(o.cid), i = a)
            } catch (o) {
              Sw.error("failed to preload MFS root", o)
            } finally {
              n = setTimeout(s, t.interval)
            }
          };
        return {
          async start() {
            let o = await e.stat("/");
            i = wZ(o.cid, {
              base: "base32"
            }), Sw(`monitoring MFS root ${o.cid}`), n = setTimeout(s, t.interval)
          },
          stop() {
            clearTimeout(n)
          }
        }
      }
    });
    var Br = y((Q6t, nA) => {
      l();
      "use strict";
      var v0 = typeof Reflect == "object" ? Reflect : null,
        EZ = v0 && typeof v0.apply == "function" ? v0.apply : function (e, t, i) {
          return Function.prototype.apply.call(e, t, i)
        },
        xw;
      v0 && typeof v0.ownKeys == "function" ? xw = v0.ownKeys : Object.getOwnPropertySymbols ? xw = function (e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
      } : xw = function (e) {
        return Object.getOwnPropertyNames(e)
      };

      function GFe(r) {
        console && console.warn && console.warn(r)
      }
      var SZ = Number.isNaN || function (e) {
        return e !== e
      };

      function br() {
        br.init.call(this)
      }
      nA.exports = br;
      nA.exports.once = $Fe;
      br.EventEmitter = br;
      br.prototype._events = void 0;
      br.prototype._eventsCount = 0;
      br.prototype._maxListeners = void 0;
      var xZ = 10;

      function Aw(r) {
        if (typeof r != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r)
      }
      Object.defineProperty(br, "defaultMaxListeners", {
        enumerable: !0,
        get: function () {
          return xZ
        },
        set: function (r) {
          if (typeof r != "number" || r < 0 || SZ(r)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r + ".");
          xZ = r
        }
      });
      br.init = function () {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
      };
      br.prototype.setMaxListeners = function (e) {
        if (typeof e != "number" || e < 0 || SZ(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
        return this._maxListeners = e, this
      };

      function AZ(r) {
        return r._maxListeners === void 0 ? br.defaultMaxListeners : r._maxListeners
      }
      br.prototype.getMaxListeners = function () {
        return AZ(this)
      };
      br.prototype.emit = function (e) {
        for (var t = [], i = 1; i < arguments.length; i++) t.push(arguments[i]);
        var n = e === "error",
          s = this._events;
        if (s !== void 0) n = n && s.error === void 0;
        else if (!n) return !1;
        if (n) {
          var o;
          if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
          var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
          throw a.context = o, a
        }
        var c = s[e];
        if (c === void 0) return !1;
        if (typeof c == "function") EZ(c, this, t);
        else
          for (var u = c.length, f = IZ(c, u), i = 0; i < u; ++i) EZ(f[i], this, t);
        return !0
      };

      function TZ(r, e, t, i) {
        var n, s, o;
        if (Aw(t), s = r._events, s === void 0 ? (s = r._events = Object.create(null), r._eventsCount = 0) : (s.newListener !== void 0 && (r.emit("newListener", e, t.listener ? t.listener : t), s = r._events), o = s[e]), o === void 0) o = s[e] = t, ++r._eventsCount;
        else if (typeof o == "function" ? o = s[e] = i ? [t, o] : [o, t] : i ? o.unshift(t) : o.push(t), n = AZ(r), n > 0 && o.length > n && !o.warned) {
          o.warned = !0;
          var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          a.name = "MaxListenersExceededWarning", a.emitter = r, a.type = e, a.count = o.length, GFe(a)
        }
        return r
      }
      br.prototype.addListener = function (e, t) {
        return TZ(this, e, t, !1)
      };
      br.prototype.on = br.prototype.addListener;
      br.prototype.prependListener = function (e, t) {
        return TZ(this, e, t, !0)
      };

      function WFe() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
      }

      function RZ(r, e, t) {
        var i = {
          fired: !1,
          wrapFn: void 0,
          target: r,
          type: e,
          listener: t
        },
          n = WFe.bind(i);
        return n.listener = t, i.wrapFn = n, n
      }
      br.prototype.once = function (e, t) {
        return Aw(t), this.on(e, RZ(this, e, t)), this
      };
      br.prototype.prependOnceListener = function (e, t) {
        return Aw(t), this.prependListener(e, RZ(this, e, t)), this
      };
      br.prototype.removeListener = function (e, t) {
        var i, n, s, o, a;
        if (Aw(t), n = this._events, n === void 0) return this;
        if (i = n[e], i === void 0) return this;
        if (i === t || i.listener === t) --this._eventsCount == 0 ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, i.listener || t));
        else if (typeof i != "function") {
          for (s = -1, o = i.length - 1; o >= 0; o--)
            if (i[o] === t || i[o].listener === t) {
              a = i[o].listener, s = o;
              break
            } if (s < 0) return this;
          s === 0 ? i.shift() : YFe(i, s), i.length === 1 && (n[e] = i[0]), n.removeListener !== void 0 && this.emit("removeListener", e, a || t)
        }
        return this
      };
      br.prototype.off = br.prototype.removeListener;
      br.prototype.removeAllListeners = function (e) {
        var t, i, n;
        if (i = this._events, i === void 0) return this;
        if (i.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : i[e] !== void 0 && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete i[e]), this;
        if (arguments.length === 0) {
          var s = Object.keys(i),
            o;
          for (n = 0; n < s.length; ++n) o = s[n], o !== "removeListener" && this.removeAllListeners(o);
          return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
        }
        if (t = i[e], typeof t == "function") this.removeListener(e, t);
        else if (t !== void 0)
          for (n = t.length - 1; n >= 0; n--) this.removeListener(e, t[n]);
        return this
      };

      function kZ(r, e, t) {
        var i = r._events;
        if (i === void 0) return [];
        var n = i[e];
        return n === void 0 ? [] : typeof n == "function" ? t ? [n.listener || n] : [n] : t ? JFe(n) : IZ(n, n.length)
      }
      br.prototype.listeners = function (e) {
        return kZ(this, e, !0)
      };
      br.prototype.rawListeners = function (e) {
        return kZ(this, e, !1)
      };
      br.listenerCount = function (r, e) {
        return typeof r.listenerCount == "function" ? r.listenerCount(e) : PZ.call(r, e)
      };
      br.prototype.listenerCount = PZ;

      function PZ(r) {
        var e = this._events;
        if (e !== void 0) {
          var t = e[r];
          if (typeof t == "function") return 1;
          if (t !== void 0) return t.length
        }
        return 0
      }
      br.prototype.eventNames = function () {
        return this._eventsCount > 0 ? xw(this._events) : []
      };

      function IZ(r, e) {
        for (var t = new Array(e), i = 0; i < e; ++i) t[i] = r[i];
        return t
      }

      function YFe(r, e) {
        for (; e + 1 < r.length; e++) r[e] = r[e + 1];
        r.pop()
      }

      function JFe(r) {
        for (var e = new Array(r.length), t = 0; t < e.length; ++t) e[t] = r[t].listener || r[t];
        return e
      }

      function $Fe(r, e) {
        return new Promise(function (t, i) {
          function n(o) {
            r.removeListener(e, s), i(o)
          }

          function s() {
            typeof r.removeListener == "function" && r.removeListener("error", n), t([].slice.call(arguments))
          }
          CZ(r, e, s, {
            once: !0
          }), e !== "error" && XFe(r, n, {
            once: !0
          })
        })
      }

      function XFe(r, e, t) {
        typeof r.on == "function" && CZ(r, "error", e, t)
      }

      function CZ(r, e, t, i) {
        if (typeof r.on == "function") i.once ? r.once(e, t) : r.on(e, t);
        else if (typeof r.addEventListener == "function") r.addEventListener(e, function n(s) {
          i.once && r.removeEventListener(e, n), t(s)
        });
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r)
      }
    });
    var sA = y((e4t, OZ) => {
      l();
      OZ.exports = {
        WORKER_REQUEST_READ_LOCK: "lock:worker:request-read",
        WORKER_RELEASE_READ_LOCK: "lock:worker:release-read",
        MASTER_GRANT_READ_LOCK: "lock:master:grant-read",
        WORKER_REQUEST_WRITE_LOCK: "lock:worker:request-write",
        WORKER_RELEASE_WRITE_LOCK: "lock:worker:release-write",
        MASTER_GRANT_WRITE_LOCK: "lock:master:grant-write"
      }
    });
    var NZ = y(() => {
      l()
    });
    var jZ = y((i4t, qZ) => {
      l();
      var ZFe = Br().EventEmitter,
        {
          nanoid: QFe
        } = (my(), by),
        {
          WORKER_REQUEST_READ_LOCK: MZ,
          WORKER_RELEASE_READ_LOCK: BZ,
          MASTER_GRANT_READ_LOCK: DZ,
          WORKER_REQUEST_WRITE_LOCK: LZ,
          WORKER_RELEASE_WRITE_LOCK: FZ,
          MASTER_GRANT_WRITE_LOCK: UZ
        } = sA(),
        cg, KZ = (r, e, t, i, n) => (s, o) => {
          o && o.type === t && r.emit(e, o.name, () => (s.send({
            type: n,
            name: o.name,
            identifier: o.identifier
          }), new Promise(a => {
            let c = u => {
              u && u.type === i && u.identifier === o.identifier && (s.removeListener("message", c), a())
            };
            s.on("message", c)
          })))
        },
        zZ = (r, e, t, i) => () => {
          let n = QFe();
          return process.send({
            type: e,
            identifier: n,
            name: r
          }), new Promise(s => {
            let o = a => {
              a && a.type === t && a.identifier === n && (process.removeListener("message", o), s(() => {
                process.send({
                  type: i,
                  identifier: n,
                  name: r
                })
              }))
            };
            process.on("message", o)
          })
        };
      qZ.exports = r => {
        try {
          if (cg = NZ(), !Object.keys(cg).length) return
        } catch (e) {
          return
        }
        if (cg.isMaster || r.singleProcess) {
          let e = new ZFe;
          return cg.on("message", KZ(e, "requestReadLock", MZ, BZ, DZ)), cg.on("message", KZ(e, "requestWriteLock", LZ, FZ, UZ)), e
        }
        return {
          isWorker: !0,
          readLock: e => zZ(e, MZ, DZ, BZ),
          writeLock: e => zZ(e, LZ, UZ, FZ)
        }
      }
    });
    var oA = y((n4t, VZ) => {
      l();
      var lf = {},
        w0 = r => {
          r.addEventListener("message", e => {
            w0.dispatchEvent("message", r, e)
          }), r.port && r.port.addEventListener("message", e => {
            w0.dispatchEvent("message", r, e)
          })
        };
      w0.addEventListener = (r, e) => {
        lf[r] || (lf[r] = []), lf[r].push(e)
      };
      w0.removeEventListener = (r, e) => {
        !lf[r] || (lf[r] = lf[r].filter(t => t === e))
      };
      w0.dispatchEvent = function () {
        let r = Array.prototype.slice.call(arguments),
          e = r.shift();
        !lf[e] || lf[e].forEach(t => t.apply(null, r))
      };
      VZ.exports = w0
    });
    var tQ = y((s4t, HZ) => {
      l();
      var eUe = Br().EventEmitter,
        {
          nanoid: tUe
        } = (my(), by),
        {
          WORKER_REQUEST_READ_LOCK: GZ,
          WORKER_RELEASE_READ_LOCK: $Z,
          MASTER_GRANT_READ_LOCK: WZ,
          WORKER_REQUEST_WRITE_LOCK: YZ,
          WORKER_RELEASE_WRITE_LOCK: JZ,
          MASTER_GRANT_WRITE_LOCK: XZ
        } = sA(),
        ZZ = oA(),
        QZ = (r, e, t, i, n) => (s, o) => {
          if (!o || !o.data || o.data.type !== t) return;
          let a = {
            type: o.data.type,
            name: o.data.name,
            identifier: o.data.identifier
          };
          r.emit(e, a.name, () => (s.postMessage({
            type: n,
            name: a.name,
            identifier: a.identifier
          }), new Promise(c => {
            let u = f => {
              if (!f || !f.data) return;
              let h = {
                type: f.data.type,
                name: f.data.name,
                identifier: f.data.identifier
              };
              h && h.type === i && h.identifier === a.identifier && (s.removeEventListener("message", u), c())
            };
            s.addEventListener("message", u)
          })))
        },
        eQ = (r, e, t, i) => () => {
          let n = tUe();
          return globalThis.postMessage({
            type: e,
            identifier: n,
            name: r
          }), new Promise(s => {
            let o = a => {
              if (!a || !a.data) return;
              let c = {
                type: a.data.type,
                identifier: a.data.identifier
              };
              c && c.type === t && c.identifier === n && (globalThis.removeEventListener("message", o), s(() => {
                globalThis.postMessage({
                  type: i,
                  identifier: n,
                  name: r
                })
              }))
            };
            globalThis.addEventListener("message", o)
          })
        },
        rUe = {
          singleProcess: !1
        };
      HZ.exports = r => {
        if (r = Object.assign({}, rUe, r), !!globalThis.document || r.singleProcess) {
          let t = new eUe;
          return ZZ.addEventListener("message", QZ(t, "requestReadLock", GZ, $Z, WZ)), ZZ.addEventListener("message", QZ(t, "requestWriteLock", YZ, JZ, XZ)), t
        }
        return {
          isWorker: !0,
          readLock: t => eQ(t, GZ, WZ, $Z),
          writeLock: t => eQ(t, YZ, XZ, JZ)
        }
      }
    });
    var rQ = y((a4t, aA) => {
      l();
      "use strict";
      var Iw, o4t = aA.exports.timeout = function (r, e) {
        var t = new Iw,
          i;
        return Promise.race([r, new Promise(function (n, s) {
          i = setTimeout(function () {
            s(t)
          }, e)
        })]).then(function (n) {
          return clearTimeout(i), n
        }, function (n) {
          throw clearTimeout(i), n
        })
      };
      Iw = aA.exports.TimeoutError = function () {
        Error.call(this), this.stack = Error().stack, this.message = "Timeout"
      };
      Iw.prototype = Object.create(Error.prototype);
      Iw.prototype.name = "TimeoutError"
    });
    var fA = y((c4t, cA) => {
      l();
      var iUe = jZ(),
        nUe = tQ(),
        {
          default: iQ
        } = Tl(),
        {
          timeout: sUe
        } = rQ(),
        oUe = oA(),
        Dl = {},
        hf;

      function uA(r, e) {
        let t, i = new Promise(n => {
          t = n
        });
        return r.add(() => sUe((() => new Promise(n => {
          t(() => {
            n()
          })
        }))(), e.timeout)), i
      }
      var aUe = (r, e) => {
        if (hf.isWorker) return {
          readLock: hf.readLock(r, e),
          writeLock: hf.writeLock(r, e)
        };
        let t = new iQ({
          concurrency: 1
        }),
          i = null;
        return {
          readLock: () => {
            if (i) return uA(i, e);
            i = new iQ({
              concurrency: e.concurrency,
              autoStart: !1
            });
            let n = i,
              s = uA(i, e);
            return t.add(() => (n.start(), n.onIdle().then(() => {
              i === n && (i = null)
            }))), s
          },
          writeLock: () => (i = null, uA(t, e))
        }
      },
        cUe = {
          concurrency: Infinity,
          timeout: 846e5,
          global: globalThis,
          singleProcess: !1
        };
      cA.exports = (r, e) => (e || (e = {}), typeof r == "object" && (e = r, r = "lock"), r || (r = "lock"), e = Object.assign({}, cUe, e), hf || (hf = iUe(e) || nUe(e), hf.isWorker || (hf.on("requestReadLock", (t, i) => {
        !Dl[t] || Dl[t].readLock().then(n => i().finally(() => n()))
      }), hf.on("requestWriteLock", async (t, i) => {
        !Dl[t] || Dl[t].writeLock().then(n => i().finally(() => n()))
      }))), Dl[r] || (Dl[r] = aUe(r, e)), Dl[r]);
      cA.exports.Worker = function (r, e) {
        e = e || globalThis.Worker;
        let t;
        try {
          t = new e(r)
        } catch (i) {
          i.message.includes("not a constructor") && (t = e(r))
        }
        if (!t) throw new Error("Could not create Worker from", e);
        return oUe(t), t
      }
    });
    var lA = y((u4t, nQ) => {
      l();
      "use strict";
      var uUe = fA(),
        Tw;
      nQ.exports = (r = !1) => {
        if (Tw) return Tw;
        let e = uUe({
          singleProcess: r
        });
        return Tw = {
          readLock: t => async (...i) => {
            let n = await e.readLock();
            try {
              return await t.apply(null, i)
            } finally {
              n()
            }
          },
          writeLock: t => async (...i) => {
            let n = await e.writeLock();
            try {
              return await t.apply(null, i)
            } finally {
              n()
            }
          }
        }, Tw
      }
    });
    var hA = y((f4t, sQ) => {
      l();
      "use strict";
      var fUe = at(),
        {
          UnixFS: lUe
        } = Ii(),
        {
          DAGNode: hUe
        } = Mr(),
        oQ = Oe()("ipfs:mfs:utils:with-mfs-root"),
        dUe = Jr(),
        pUe = cr().multihash,
        aQ = xe(),
        {
          MFS_ROOT_KEY: cQ
        } = Ji(),
        yUe = async (r, e) => {
          if (e && e.signal && e.signal.aborted) throw aQ(new Error("Request aborted"), "ERR_ABORTED", {
            name: "Aborted"
          });
          await r.repo.datastore.open();
          let t;
          try {
            let i = await r.repo.datastore.get(cQ);
            t = new fUe(i)
          } catch (i) {
            if (i.code !== "ERR_NOT_FOUND") throw i;
            oQ("Creating new MFS root");
            let n = new hUe(new lUe({
              type: "directory"
            }).marshal());
            if (t = await r.ipld.put(n, dUe.DAG_PB, {
              cidVersion: 0,
              hashAlg: pUe.names["sha2-256"]
            }), e && e.signal && e.signal.aborted) throw aQ(new Error("Request aborted"), "ERR_ABORTED", {
              name: "Aborted"
            });
            await r.repo.datastore.put(cQ, t.bytes)
          }
          return oQ(`Loaded MFS root /ipfs/${t}`), t
        };
      sQ.exports = yUe
    });
    var Rw = y((l4t, uQ) => {
      l();
      "use strict";
      var gUe = (r = "") => (r.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
      uQ.exports = gUe
    });
    var tu = y((h4t, fQ) => {
      l();
      "use strict";
      var bUe = hA(),
        mUe = Rw(),
        {
          exporter: vUe
        } = sa(),
        lQ = xe(),
        wUe = at(),
        dA = "ipfs",
        _Ue = async (r, e, t) => {
          let i = await bUe(r, t),
            n = {
              entryType: "file"
            };
          if (wUe.isCID(e) && (e = `/ipfs/${e}`), e = (e || "").trim(), e = e.replace(/(\/\/+)/g, "/"), e.endsWith("/") && e.length > 1 && (e = e.substring(0, e.length - 1)), !e) throw lQ(new Error("paths must not be empty"), "ERR_NO_PATH");
          if (e.substring(0, 1) !== "/") throw lQ(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
          e.substring(e.length - 1) === "/" && (e = e.substring(0, e.length - 1));
          let s = mUe(e);
          if (s[0] === dA) {
            let a;
            s.length === 2 ? a = `/${s.join("/")}` : a = `/${s.slice(0, s.length - 1).join("/")}`, n = {
              type: "ipfs",
              depth: s.length - 2,
              entryType: "file",
              mfsPath: `/${s.join("/")}`,
              mfsDirectory: a,
              parts: s,
              path: `/${s.join("/")}`,
              name: s[s.length - 1]
            }
          } else {
            let a = `/${dA}/${i}${s.length ? "/" + s.join("/") : ""}`,
              c = `/${dA}/${i}/${s.slice(0, s.length - 1).join("/")}`;
            n = {
              type: "mfs",
              depth: s.length,
              entryType: "file",
              mfsDirectory: c,
              mfsPath: a,
              parts: s,
              path: `/${s.join("/")}`,
              name: s[s.length - 1]
            }
          }
          let o = n.type === "mfs" ? n.mfsPath : n.path;
          try {
            let a = await vUe(o, r.ipld);
            n.cid = a.cid, n.mfsPath = `/ipfs/${a.path}`, n.entryType = a.type, n.content = a.content, (n.entryType === "file" || n.entryType === "directory") && (a.type === "file" || a.type === "directory") && (n.unixfs = a.unixfs)
          } catch (a) {
            if (a.code !== "ERR_NOT_FOUND") throw a
          }
          return n.exists = Boolean(n.cid), n
        };
      fQ.exports = _Ue
    });
    var ug = y((d4t, hQ) => {
      l();
      "use strict";
      var EUe = Yr().bind({
        ignoreUndefined: !0
      }),
        SUe = tu(),
        {
          exporter: xUe
        } = sa(),
        AUe = Oe()("ipfs:mfs:stat"),
        IUe = xe(),
        TUe = ze(),
        RUe = {
          withLocal: !1
        };
      hQ.exports = r => {
        async function e(t, i = {}) {
          i = EUe(RUe, i), AUe(`Fetching stats for ${t}`);
          let {
            type: n,
            cid: s,
            mfsPath: o
          } = await SUe(r, t, i), a = n === "ipfs" && s ? s : o, c;
          try {
            c = await xUe(a, r.ipld)
          } catch (u) {
            throw u.code === "ERR_NOT_FOUND" ? IUe(new Error(`${t} does not exist`), "ERR_NOT_FOUND") : u
          }
          if (!dQ[c.type]) throw new Error(`Cannot stat codec ${c.cid.codec}`);
          return dQ[c.type](c)
        }
        return TUe(e)
      };
      var dQ = {
        raw: r => ({
          cid: r.cid,
          size: r.node.length,
          cumulativeSize: r.node.length,
          blocks: 0,
          type: "file",
          local: void 0,
          sizeLocal: void 0,
          withLocality: !1
        }),
        file: r => {
          let e = {
            cid: r.cid,
            type: "file",
            size: r.unixfs.fileSize(),
            cumulativeSize: r.node.size,
            blocks: r.unixfs.blockSizes.length,
            local: void 0,
            sizeLocal: void 0,
            withLocality: !1,
            mode: r.unixfs.mode
          };
          return r.unixfs.mtime && (e.mtime = r.unixfs.mtime), e
        },
        directory: r => {
          let e = {
            cid: r.cid,
            type: "directory",
            size: 0,
            cumulativeSize: r.node.size,
            blocks: r.node.Links.length,
            local: void 0,
            sizeLocal: void 0,
            withLocality: !1,
            mode: r.unixfs.mode
          };
          return r.unixfs.mtime && (e.mtime = r.unixfs.mtime), e
        },
        object: r => ({
          cid: r.cid,
          size: r.node.length,
          cumulativeSize: r.node.length,
          type: "file",
          blocks: 0,
          local: void 0,
          sizeLocal: void 0,
          withLocality: !1
        }),
        identity: r => ({
          cid: r.cid,
          size: r.node.length,
          cumulativeSize: r.node.length,
          blocks: 0,
          type: "file",
          local: void 0,
          sizeLocal: void 0,
          withLocality: !1
        })
      }
    });
    var _0 = y((p4t, pQ) => {
      l();
      "use strict";
      var {
        walkPath: kUe
      } = sa(), PUe = Oe()("ipfs:mfs:utils:to-trail"), CUe = async (r, e) => {
        PUe(`Creating trail for path ${e}`);
        let t = [];
        for await (let i of kUe(e, r.ipld)) {
          let n;
          i.node instanceof Uint8Array ? n = i.node.length : n = i.node.size, t.push({
            name: i.name,
            cid: i.cid,
            size: n,
            type: i.type
          })
        }
        return t
      };
      pQ.exports = CUe
    });
    var yA = y((y4t, yQ) => {
      l();
      "use strict";
      var {
        DAGNode: OUe
      } = Mr(), {
        Bucket: gQ,
        createHAMT: NUe
      } = hw(), qUe = dw(), pA = ow(), kw = Oe()("ipfs:mfs:core:utils:hamt-utils"), {
        UnixFS: bQ
      } = Ii(), MUe = Jr(), BUe = cr().multihash, DUe = Qa(), LUe = async (r, e, t, i) => {
        let n = pA(),
          s = Uint8Array.from(t._children.bitField().reverse()),
          o = bQ.unmarshal(i.parent.Data),
          a = new bQ({
            type: "hamt-sharded-directory",
            data: s,
            fanout: t.tableSize(),
            hashType: n.hamtHashCode,
            mode: o.mode,
            mtime: o.mtime
          }),
          c = BUe.names[i.hashAlg],
          u = new OUe(a.marshal(), e),
          f = await r.ipld.put(u, MUe.DAG_PB, {
            cidVersion: i.cidVersion,
            hashAlg: c,
            onlyHash: !i.flush
          });
        return {
          node: u,
          cid: f,
          size: u.size
        }
      }, mQ = async (r, e, t, i) => {
        let n = new gQ({
          hash: e._options.hash,
          bits: e._options.bits
        }, t, i);
        return t._putObjectAt(i, n), await Pw(r, n, e), n
      }, vQ = async r => {
        let e = pA(),
          t = NUe({
            hashFn: e.hamtHashFn,
            bits: e.hamtBucketBits
          });
        return await Pw(r, t, t), t
      }, Pw = async (r, e, t) => {
        await Promise.all(r.map(i => {
          if (i.Name.length === 2) {
            let n = parseInt(i.Name, 16);
            return e._putObjectAt(n, new gQ({
              hash: t._options.hash,
              bits: t._options.bits
            }, e, n)), Promise.resolve()
          }
          return t.put(i.Name.substring(2), {
            size: i.Tsize,
            cid: i.Hash
          })
        }))
      }, Cw = r => r.toString(16).toUpperCase().padStart(2, "0").substring(0, 2), FUe = async (r, e, t) => {
        let i = await vQ(t.Links),
          n = await i._findNewBucketAndPos(e),
          s = [{
            bucket: n.bucket,
            prefix: Cw(n.pos)
          }],
          o = n.bucket;
        for (; o !== i;) s.push({
          bucket: o,
          prefix: Cw(o._posAtParent)
        }), o = o._parent;
        s.reverse(), s[0].node = t;
        for (let a = 0; a < s.length; a++) {
          let c = s[a];
          if (!c.node) throw new Error("Could not generate HAMT path");
          let u = c.node.Links.filter(d => d.Name.substring(0, 2) === c.prefix).pop();
          if (!u) {
            kw(`Link ${c.prefix}${e} will be added`);
            continue
          }
          if (u.Name === `${c.prefix}${e}`) {
            kw(`Link ${c.prefix}${e} will be replaced`);
            continue
          }
          kw(`Found subshard ${c.prefix}`);
          let f = await r.ipld.get(u.Hash);
          if (!s[a + 1]) {
            kw(`Loaded new subshard ${c.prefix}`), await mQ(f.Links, i, c.bucket, parseInt(c.prefix, 16));
            let d = await i._findNewBucketAndPos(e);
            s.push({
              bucket: d.bucket,
              prefix: Cw(d.pos),
              node: f
            });
            continue
          }
          let h = s[a + 1];
          await Pw(f.Links, h.bucket, i), h.node = f
        }
        return await i.put(e, !0), s.reverse(), {
          rootBucket: i,
          path: s
        }
      }, UUe = async (r, e, t = {}) => {
        let i = pA(),
          n = new qUe({
            root: !0,
            dir: !0,
            parent: null,
            parentKey: null,
            path: "",
            dirty: !0,
            flat: !1,
            mtime: t.mtime,
            mode: t.mode
          }, {
            hamtHashFn: i.hamtHashFn,
            hamtHashCode: i.hamtHashCode,
            hamtBucketBits: i.hamtBucketBits,
            ...t,
            codec: "dag-pb"
          });
        for (let s = 0; s < e.length; s++) await n._bucket.put(e[s].name, {
          size: e[s].size,
          cid: e[s].cid
        });
        return DUe(n.flush(r.block))
      };
      yQ.exports = {
        generatePath: FUe,
        updateHamtDirectory: LUe,
        recreateHamtLevel: mQ,
        recreateInitialHamtLevel: vQ,
        addLinksToHamtBucket: Pw,
        toPrefix: Cw,
        createShard: UUe
      }
    });
    var Ll = y((g4t, wQ) => {
      l();
      "use strict";
      var {
        DAGLink: KUe,
        DAGNode: zUe
      } = Mr(), gA = at(), ac = Oe()("ipfs:mfs:core:utils:add-link"), {
        UnixFS: bA
      } = Ii(), jUe = dw(), VUe = ow(), {
        updateHamtDirectory: HUe,
        recreateHamtLevel: GUe,
        recreateInitialHamtLevel: $Ue,
        createShard: WUe,
        toPrefix: mA,
        addLinksToHamtBucket: YUe
      } = yA(), fg = xe(), JUe = Jr(), XUe = cr().multihash, ZUe = Qa(), rKe = async (r, e) => {
        let t = e.parent;
        if (e.parentCid) {
          if (!gA.isCID(e.parentCid)) throw fg(new Error("Invalid CID passed to addLink"), "EINVALIDPARENTCID");
          ac(`Loading parent node ${e.parentCid}`), t = await r.ipld.get(e.parentCid)
        }
        if (!t) throw fg(new Error("No parent node or CID passed to addLink"), "EINVALIDPARENT");
        if (!e.cid) throw fg(new Error("No child cid passed to addLink"), "EINVALIDCHILDCID");
        if (!e.name) throw fg(new Error("No child name passed to addLink"), "EINVALIDCHILDNAME");
        if (gA.isCID(e.cid) || (e.cid = new gA(e.cid)), !e.size && e.size !== 0) throw fg(new Error("No child size passed to addLink"), "EINVALIDCHILDSIZE");
        let i = bA.unmarshal(t.Data);
        return i.type === "hamt-sharded-directory" ? (ac("Adding link to sharded directory"), tKe(r, {
          ...e,
          parent: t
        })) : t.Links.length >= e.shardSplitThreshold ? (ac("Converting directory to sharded directory"), QUe(r, {
          ...e,
          parent: t,
          mtime: i.mtime,
          mode: i.mode
        })) : (ac(`Adding ${e.name} (${e.cid}) to regular directory`), eKe(r, {
          ...e,
          parent: t
        }))
      }, QUe = async (r, e) => {
        let t = await WUe(r, e.parent.Links.map(i => ({
          name: i.Name,
          size: i.Tsize,
          cid: i.Hash
        })).concat({
          name: e.name,
          size: e.size,
          cid: e.cid
        }), e);
        return ac(`Converted directory to sharded directory ${t.cid}`), t
      }, eKe = async (r, e) => {
        e.parent.rmLink(e.name), e.parent.addLink(new KUe(e.name, e.size, e.cid));
        let t = bA.unmarshal(e.parent.Data);
        if (t.mtime) {
          let s = Date.now(),
            o = Math.floor(s / 1e3);
          t.mtime = {
            secs: o,
            nsecs: (s - o * 1e3) * 1e3
          }, e.parent = new zUe(t.marshal(), e.parent.Links)
        }
        let i = XUe.names[e.hashAlg],
          n = await r.ipld.put(e.parent, JUe.DAG_PB, {
            cidVersion: e.cidVersion,
            hashAlg: i,
            onlyHash: !e.flush
          });
        return {
          node: e.parent,
          cid: n,
          size: e.parent.size
        }
      }, tKe = async (r, e) => {
        let {
          shard: t,
          path: i
        } = await iKe(r, e), n = await ZUe(t.flush(r.block)), s = await r.ipld.get(n.cid), o = e.parent.Links.find(c => c.Name.substring(0, 2) === i[0].prefix), a = s.Links.find(c => c.Name.substring(0, 2) === i[0].prefix);
        if (!a) throw new Error(`No link found with prefix ${i[0].prefix}`);
        return o && e.parent.rmLink(o.Name), e.parent.addLink(a), HUe(r, e.parent.Links, i[0].bucket, e)
      }, iKe = async (r, e) => {
        let t = {
          name: e.name,
          cid: e.cid,
          size: e.size
        },
          i = await $Ue(e.parent.Links),
          n = bA.unmarshal(e.parent.Data),
          s = VUe(),
          o = new jUe({
            root: !0,
            dir: !0,
            parent: null,
            parentKey: null,
            path: "",
            dirty: !0,
            flat: !1,
            mode: n.mode
          }, {
            hamtHashFn: s.hamtHashFn,
            hamtHashCode: s.hamtHashCode,
            hamtBucketBits: s.hamtBucketBits,
            ...e
          });
        o._bucket = i, n.mtime && (o.mtime = new Date);
        let a = await i._findNewBucketAndPos(t.name),
          c = nKe(a);
        c[0].node = e.parent;
        let u = 0;
        for (; u < c.length;) {
          let f = c[u];
          u++;
          let h = f.node;
          if (!h) throw new Error("Segment had no node");
          let d = h.Links.find(m => m.Name.substring(0, 2) === f.prefix);
          if (!d) {
            ac(`Link ${f.prefix}${t.name} will be added`), u = c.length;
            break
          }
          if (d.Name === `${f.prefix}${t.name}`) {
            ac(`Link ${f.prefix}${t.name} will be replaced`), u = c.length;
            break
          }
          if (d.Name.length > 2) {
            ac(`Link ${d.Name} ${d.Hash} will be replaced with a subshard`), u = c.length;
            break
          }
          ac(`Found subshard ${f.prefix}`);
          let p = await r.ipld.get(d.Hash);
          if (!c[u]) {
            ac(`Loaded new subshard ${f.prefix}`), await GUe(p.Links, i, f.bucket, parseInt(f.prefix, 16));
            let m = await i._findNewBucketAndPos(t.name);
            c.push({
              bucket: m.bucket,
              prefix: mA(m.pos),
              node: p
            });
            break
          }
          let g = c[u];
          await YUe(p.Links, g.bucket, i), g.node = p
        }
        return await o._bucket.put(t.name, {
          size: t.size,
          cid: t.cid
        }), {
          shard: o,
          path: c
        }
      }, nKe = r => {
        let e = [{
          bucket: r.bucket,
          prefix: mA(r.pos)
        }],
          t = r.bucket._parent,
          i = r.bucket._posAtParent;
        for (; t;) e.push({
          bucket: t,
          prefix: mA(i)
        }), i = t._posAtParent, t = t._parent;
        return e.reverse(), e
      };
      wQ.exports = rKe
    });
    var Fl = y((b4t, _Q) => {
      l();
      "use strict";
      var EQ = Oe()("ipfs:mfs:utils:update-tree"),
        sKe = Ll(),
        oKe = {
          shardSplitThreshold: 1e3
        },
        aKe = async (r, e, t) => {
          t = Object.assign({}, oKe, t), EQ("Trail", e), e = e.slice().reverse();
          let i = 0,
            n;
          for await (let o of r.ipld.getMany(e.map(a => a.cid))) {
            let a = e[i].cid,
              c = e[i].name;
            if (i++, !n) {
              n = {
                cid: a,
                name: c,
                size: o.size
              };
              continue
            }
            let u = await sKe(r, {
              parent: o,
              name: n.name,
              cid: n.cid,
              size: n.size,
              flush: t.flush,
              shardSplitThreshold: t.shardSplitThreshold,
              hashAlg: t.hashAlg,
              cidVersion: t.cidVersion
            });
            n = {
              cid: u.cid,
              name: c,
              size: u.size
            }
          }
          let {
            cid: s
          } = n;
          return EQ(`Final CID ${s}`), s
        };
      _Q.exports = aKe
    });
    var Ul = y((m4t, SQ) => {
      l();
      "use strict";
      var cKe = Oe()("ipfs:mfs:utils:update-mfs-root"),
        {
          MFS_ROOT_KEY: uKe
        } = Ji(),
        fKe = xe(),
        lKe = async (r, e, t) => {
          if (t && t.signal && t.signal.aborted) throw fKe(new Error("Request aborted"), "ERR_ABORTED", {
            name: "Aborted"
          });
          return cKe(`New MFS root will be ${e}`), await r.repo.datastore.put(uKe, e.bytes), e
        };
      SQ.exports = lKe
    });
    var AQ = y((v4t, xQ) => {
      l();
      "use strict";
      var {
        UnixFS: hKe
      } = Ii(), {
        DAGNode: dKe
      } = Mr(), pKe = Jr(), yKe = cr().multihash, gKe = async (r, e, t) => {
        let i = yKe.names[t.hashAlg],
          n = new hKe({
            type: e,
            mode: t.mode,
            mtime: t.mtime
          }),
          s = new dKe(n.marshal());
        return {
          cid: await r.ipld.put(s, pKe.DAG_PB, {
            cidVersion: t.cidVersion,
            hashAlg: i,
            onlyHash: !t.flush
          }),
          node: s
        }
      };
      xQ.exports = gKe
    });
    var Ow = y((w4t, IQ) => {
      l();
      "use strict";
      var E0 = xe(),
        TQ = Oe()("ipfs:mfs:mkdir"),
        {
          exporter: bKe
        } = sa(),
        mKe = AQ(),
        vKe = Rw(),
        wKe = Ul(),
        _Ke = Fl(),
        EKe = Ll(),
        SKe = hA(),
        xKe = Yr().bind({
          ignoreUndefined: !0
        }),
        AKe = ze(),
        IKe = {
          parents: !1,
          hashAlg: "sha2-256",
          cidVersion: 0,
          shardSplitThreshold: 1e3,
          flush: !0
        };
      IQ.exports = r => {
        async function e(t, i = {}) {
          let n = xKe(IKe, i);
          if (!t) throw new Error("no path given to Mkdir");
          if (t = t.trim(), t === "/") {
            if (n.parents) return;
            throw E0(new Error("cannot create directory '/': Already exists"), "ERR_INVALID_PATH")
          }
          if (t.substring(0, 1) !== "/") throw E0(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
          TQ(`Creating ${t}`);
          let s = vKe(t);
          if (s[0] === "ipfs") throw E0(new Error("path cannot have the prefix 'ipfs'"), "ERR_INVALID_PATH");
          let o = await SKe(r, n),
            a, c = [],
            u = await mKe(r, "directory", n);
          for (let h = 0; h <= s.length; h++) {
            let d = s.slice(0, h),
              p = `/ipfs/${o}/${d.join("/")}`;
            try {
              if (a = await bKe(p, r.ipld), a.type !== "file" && a.type !== "directory") throw E0(new Error(`${t} was not a UnixFS node`), "ERR_NOT_UNIXFS");
              if (h === s.length) {
                if (n.parents) return;
                throw E0(new Error("file already exists"), "ERR_ALREADY_EXISTS")
              }
              c.push({
                name: a.name,
                cid: a.cid
              })
            } catch (g) {
              if (g.code === "ERR_NOT_FOUND") {
                if (h < s.length && !n.parents) throw E0(new Error(`Intermediate directory path ${p} does not exist, use the -p flag to create it`), "ERR_NOT_FOUND");
                await TKe(r, d[d.length - 1], u, c[c.length - 1], c, n)
              } else throw g
            }
          }
          let f = await _Ke(r, c, n);
          await wKe(r, f, n)
        }
        return AKe(e)
      };
      var TKe = async (r, e, t, i, n, s) => {
        TQ(`Adding empty dir called ${e} to ${i.cid}`);
        let o = await EKe(r, {
          parent: i.node,
          parentCid: i.cid,
          size: t.node.size,
          cid: t.cid,
          name: e,
          hashAlg: s.hashAlg,
          cidVersion: s.cidVersion,
          flush: s.flush,
          shardSplitThreshold: s.shardSplitThreshold
        });
        n[n.length - 1].cid = o.cid, n.push({
          name: e,
          cid: t.cid
        })
      }
    });
    var Mw = y((_4t, RQ) => {
      l();
      "use strict";
      var kQ = Ow(),
        RKe = ug(),
        Nw = Oe()("ipfs:mfs:cp"),
        Kl = xe(),
        PQ = Fl(),
        CQ = Ul(),
        kKe = Ll(),
        qw = tu(),
        PKe = Yr().bind({
          ignoreUndefined: !0
        }),
        CKe = _0(),
        OKe = ze(),
        NKe = {
          parents: !1,
          flush: !0,
          hashAlg: "sha2-256",
          cidVersion: 0,
          shardSplitThreshold: 1e3
        };
      RQ.exports = r => {
        async function e(t, i, n = {}) {
          let s = PKe(NKe, n);
          Array.isArray(t) || (t = [t]);
          let o = await Promise.all(t.map(d => qw(r, d, s))),
            a = await qw(r, i, s);
          if (!o.length || !a) throw Kl(new Error("Please supply at least one source"), "ERR_INVALID_PARAMS");
          let c = o.find(d => !d.exists);
          if (c) throw Kl(new Error(`${c.path} does not exist`), "ERR_INVALID_PARAMS");
          let u = OQ(a);
          if (a.exists) {
            if (Nw("Destination exists"), o.length === 1 && !u) throw Kl(new Error("directory already has entry by that name"), "ERR_ALREADY_EXISTS")
          } else if (Nw("Destination does not exist"), o.length > 1) {
            if (!s.parents) throw Kl(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
            await kQ(r)(a.path, s), a = await qw(r, a.path, s)
          } else if (a.parts.length > 1) {
            let d = `/${a.parts.slice(0, -1).join("/")}`;
            try {
              await RKe(r)(d, s)
            } catch (p) {
              if (p.code !== "ERR_NOT_FOUND") throw p;
              if (!s.parents) throw Kl(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
              await kQ(r)(d, s), a = await qw(r, a.path, s)
            }
          }
          let f = OQ(a) ? a.mfsPath : a.mfsDirectory,
            h = await CKe(r, f);
          if (o.length === 1) {
            let d = o.pop();
            if (!d) throw Kl(new Error("could not find source"), "ERR_INVALID_PARAMS");
            let p = u ? d.name : a.name;
            return Nw(`Only one source, copying to destination ${u ? "directory" : "file"} ${p}`), qKe(r, d, p, h, s)
          }
          return Nw("Multiple sources, wrapping in a directory"), MKe(r, o, a, h, s)
        }
        return OKe(e)
      };
      var OQ = r => r.unixfs && r.unixfs.type && r.unixfs.type.includes("directory"),
        qKe = async (r, e, t, i, n) => {
          let s = i.pop();
          if (!s) throw Kl(new Error("destination had no parent"), "ERR_INVALID_PARAMS");
          s = await NQ(r, e, t, s, n), i.push(s);
          let o = await PQ(r, i, n);
          await CQ(r, o, n)
        }, MKe = async (r, e, t, i, n) => {
          for (let o = 0; o < e.length; o++) {
            let a = e[o];
            t = await NQ(r, a, a.name, t, n)
          }
          i[i.length - 1] = t;
          let s = await PQ(r, i, n);
          await CQ(r, s, n)
        }, NQ = async (r, e, t, i, n) => {
          let s = await r.repo.blocks.get(e.cid),
            {
              node: o,
              cid: a
            } = await kKe(r, {
              parentCid: i.cid,
              size: s.data.length,
              cid: e.cid,
              name: t,
              hashAlg: n.hashAlg,
              cidVersion: n.cidVersion,
              flush: n.flush,
              shardSplitThreshold: n.shardSplitThreshold
            });
          return i.node = o, i.cid = a, i.size = o.size, i
        }
    });
    var BQ = y((E4t, qQ) => {
      l();
      "use strict";
      var {
        DAGLink: BKe
      } = Mr(), DKe = at(), df = Oe()("ipfs:mfs:core:utils:remove-link"), {
        UnixFS: LKe
      } = Ii(), {
        generatePath: FKe,
        updateHamtDirectory: vA
      } = yA(), S0 = xe(), UKe = Jr(), KKe = cr().multihash, VKe = async (r, e) => {
        let t = e.parent;
        if (e.parentCid) {
          if (!DKe.isCID(e.parentCid)) throw S0(new Error("Invalid CID passed to removeLink"), "EINVALIDPARENTCID");
          df(`Loading parent node ${e.parentCid}`), t = await r.ipld.get(e.parentCid)
        }
        if (!t) throw S0(new Error("No parent node or CID passed to removeLink"), "EINVALIDPARENT");
        if (!e.name) throw S0(new Error("No child name passed to removeLink"), "EINVALIDCHILDNAME");
        return LKe.unmarshal(t.Data).type === "hamt-sharded-directory" ? (df(`Removing ${e.name} from sharded directory`), jKe(r, {
          ...e,
          parent: t
        })) : (df(`Removing link ${e.name} regular directory`), zKe(r, {
          ...e,
          parent: t
        }))
      }, zKe = async (r, e) => {
        let t = KKe.names[e.hashAlg];
        e.parent.rmLink(e.name);
        let i = await r.ipld.put(e.parent, UKe.DAG_PB, {
          cidVersion: e.cidVersion,
          hashAlg: t
        });
        return df(`Updated regular directory ${i}`), {
          node: e.parent,
          cid: i
        }
      }, jKe = async (r, e) => {
        let {
          rootBucket: t,
          path: i
        } = await FKe(r, e.name, e.parent);
        await t.del(e.name);
        let {
          node: n
        } = await MQ(r, i, e.name, e);
        return vA(r, n.Links, t, e)
      }, MQ = async (r, e, t, i) => {
        let n = e.pop();
        if (!n) throw S0(new Error("Could not find parent"), "EINVALIDPARENT");
        let {
          bucket: s,
          prefix: o,
          node: a
        } = n;
        if (!a) throw S0(new Error("Could not find parent"), "EINVALIDPARENT");
        let c = a.Links.find(p => p.Name.substring(0, 2) === o);
        if (!c) throw S0(new Error(`No link found with prefix ${o} for file ${t}`), "ERR_NOT_FOUND");
        if (c.Name === `${o}${t}`) return df(`Removing existing link ${c.Name}`), a.rmLink(c.Name), await s.del(t), vA(r, a.Links, s, i);
        df(`Descending into sub-shard ${c.Name} for ${o}${t}`);
        let u = await MQ(r, e, t, i),
          f = u.cid,
          h = u.size,
          d = o;
        if (u.node.Links.length === 1) {
          df(`Removing subshard for ${o}`);
          let p = u.node.Links[0];
          d = `${o}${p.Name.substring(2)}`, f = p.Hash, h = p.Tsize
        }
        return df(`Updating shard ${o} with name ${d}`), HKe(r, s, a, o, d, h, f, i)
      }, HKe = (r, e, t, i, n, s, o, a) => (t.rmLink(i), t.addLink(new BKe(n, s, o)), vA(r, t.Links, e, a));
      qQ.exports = VKe
    });
    var Dw = y((S4t, DQ) => {
      l();
      "use strict";
      var Bw = xe(),
        GKe = Fl(),
        $Ke = Ul(),
        WKe = BQ(),
        LQ = tu(),
        YKe = _0(),
        JKe = ze(),
        XKe = Yr().bind({
          ignoreUndefined: !0
        }),
        ZKe = {
          recursive: !1,
          cidVersion: 0,
          hashAlg: "sha2-256",
          flush: !0,
          shardSplitThreshold: 1e3
        };
      DQ.exports = r => {
        async function e(t, i = {}) {
          let n = XKe(ZKe, i);
          Array.isArray(t) || (t = [t]);
          let s = await Promise.all(t.map(o => LQ(r, o, n)));
          if (!s.length) throw Bw(new Error("Please supply at least one path to remove"), "ERR_INVALID_PARAMS");
          s.forEach(o => {
            if (o.path === "/") throw Bw(new Error("Cannot delete root"), "ERR_INVALID_PARAMS")
          });
          for (let o of s) await QKe(r, o.path, n)
        }
        return JKe(e)
      };
      var QKe = async (r, e, t) => {
        let i = await LQ(r, e, t),
          n = await YKe(r, i.mfsPath),
          s = n[n.length - 1];
        n.pop();
        let o = n[n.length - 1];
        if (!o) throw Bw(new Error(`${e} does not exist`), "ERR_NOT_FOUND");
        if (s.type === "directory" && !t.recursive) throw Bw(new Error(`${e} is a directory, use -r to remove directories`), "ERR_WAS_DIR");
        let {
          cid: a
        } = await WKe(r, {
          parentCid: o.cid,
          name: s.name,
          hashAlg: t.hashAlg,
          cidVersion: t.cidVersion,
          flush: t.flush,
          shardSplitThreshold: t.shardSplitThreshold
        });
        o.cid = a;
        let c = await GKe(r, n, t);
        await $Ke(r, c, t)
      }
    });
    var VQ = y((x4t, FQ) => {
      l();
      "use strict";
      var eze = Yr().bind({
        ignoreUndefined: !0
      }),
        tze = tu(),
        rze = Oe()("ipfs:mfs:touch"),
        wA = xe(),
        {
          UnixFS: UQ
        } = Ii(),
        ize = _0(),
        nze = Ll(),
        sze = Fl(),
        oze = Ul(),
        {
          DAGNode: KQ
        } = Mr(),
        aze = Jr(),
        cze = cr().multihash,
        {
          pipe: uze
        } = vi(),
        {
          importer: fze
        } = pw(),
        {
          recursive: lze
        } = sa(),
        hze = Qa(),
        dze = Mw(),
        pze = Dw(),
        yze = Bl(),
        gze = ze(),
        zQ = {
          flush: !0,
          shardSplitThreshold: 1e3,
          hashAlg: "sha2-256",
          cidVersion: 0,
          recursive: !1
        };

      function bze(r, e, t) {
        let i = 0;
        return (r.includes("x") || r.includes("X") && (t || e & 1 || e & 8 || e & 64)) && (i += 1), r.includes("w") && (i += 2), r.includes("r") && (i += 4), i
      }

      function mze(r, e) {
        let t = 0;
        return r.includes("u") && (t += e << 6), r.includes("g") && (t += e << 3), r.includes("o") && (t += e), t
      }

      function vze(r, e, t) {
        return e.includes("t") && (t += parseInt("1000", 8)), e.includes("s") && (r.includes("u") && (t += parseInt("4000", 8)), r.includes("g") && (t += parseInt("2000", 8))), t
      }

      function wze(r, e, t) {
        e || (e = 0);
        let i = r.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);
        if (!i) throw new Error(`Invalid file mode: ${r}`);
        let [, n, s, o] = i;
        (n === "a" || !n) && (n = "ugo");
        let a = bze(o, e, t);
        return a = mze(n, a), a = vze(n, o, a), s === "=" ? (n.includes("u") && (e = e & parseInt("7077", 8), e = e | a), n.includes("g") && (e = e & parseInt("7707", 8), e = e | a), n.includes("o") && (e = e & parseInt("7770", 8), e = e | a), e) : s === "+" ? a | e : s === "-" ? a ^ e : e
      }

      function jQ(r, e) {
        if (r instanceof String || typeof r == "string") {
          let t = `${r}`;
          t.match(/^\d+$/g) ? r = parseInt(t, 8) : r = 0 + t.split(",").reduce((i, n) => wze(n, i, e.isDirectory()), e.mode || 0)
        }
        return r
      }
      FQ.exports = r => {
        async function e(t, i, n = {}) {
          let s = eze(zQ, n);
          rze(`Fetching stats for ${t}`);
          let {
            cid: o,
            mfsDirectory: a,
            name: c
          } = await tze(r, t, s);
          if (o.codec !== "dag-pb") throw wA(new Error(`${t} was not a UnixFS node`), "ERR_NOT_UNIXFS");
          if (s.recursive) {
            let O = await uze(async function* () {
              for await (let q of lze(o, r.ipld)) {
                if (q.type !== "file" && q.type !== "directory") throw wA(new Error(`${t} was not a UnixFS node`), "ERR_NOT_UNIXFS");
                q.unixfs.mode = jQ(i, q.unixfs);
                let J = new KQ(q.unixfs.marshal(), q.node.Links);
                yield {
                  path: q.path,
                  content: J
                }
              }
            }, q => fze(q, r.block, {
              ...s,
              pin: !1,
              dagBuilder: async function* (J, Z, H) {
                for await (let te of J) yield async function () {
                  let ae = te.content,
                    oe = ae.serialize(),
                    U = await yze(oe, Z, H),
                    b = UQ.unmarshal(ae.Data);
                  return {
                    cid: U,
                    size: oe.length,
                    path: te.path,
                    unixfs: b
                  }
                }
              }
            }), q => hze(q));
            if (!O) throw wA(new Error(`Could not chmod ${t}`), "ERR_COULD_NOT_CHMOD");
            await pze(r)(t, s), await dze(r)(`/ipfs/${O.cid}`, t, s);
            return
          }
          let u = await r.ipld.get(o),
            f = UQ.unmarshal(u.Data);
          f.mode = jQ(i, f), u = new KQ(f.marshal(), u.Links);
          let h = s.hashAlg || zQ.hashAlg,
            d = await r.ipld.put(u, aze.DAG_PB, {
              cidVersion: o.version,
              hashAlg: cze.names[h],
              onlyHash: !s.flush
            }),
            p = await ize(r, a),
            g = p[p.length - 1],
            m = await r.ipld.get(g.cid),
            E = await nze(r, {
              parent: m,
              name: c,
              cid: d,
              size: u.serialize().length,
              flush: s.flush,
              hashAlg: h,
              cidVersion: o.version,
              shardSplitThreshold: Infinity
            });
          g.cid = E.cid;
          let w = await sze(r, p, s);
          await oze(r, w, s)
        }
        return gze(e)
      }
    });
    var GQ = y((A4t, HQ) => {
      l();
      "use strict";
      var _ze = ug(),
        Eze = ze(),
        Sze = Yr().bind({
          ignoreUndefined: !0
        }),
        xze = {};
      HQ.exports = r => {
        async function e(t, i = {}) {
          i = Sze(xze, i);
          let {
            cid: n
          } = await _ze(r)(t, i);
          return n
        }
        return Eze(e)
      }
    });
    var WQ = y((I4t, $Q) => {
      l();
      "use strict";
      var Aze = Mw(),
        Ize = Dw(),
        Tze = Yr().bind({
          ignoreUndefined: !0
        }),
        Rze = ze(),
        kze = {
          parents: !1,
          flush: !0,
          cidVersion: 0,
          hashAlg: "sha2-256",
          shardSplitThreshold: 1e3
        };
      $Q.exports = r => {
        async function e(t, i, n = {}) {
          let s = Tze(kze, n);
          await Aze(r)(t, i, s), await Ize(r)(t, {
            ...s,
            recursive: !0
          })
        }
        return Rze(e)
      }
    });
    var eee = y((T4t, YQ) => {
      l();
      "use strict";
      var Pze = Yr().bind({
        ignoreUndefined: !0
      }),
        Cze = tu(),
        Oze = Oe()("ipfs:mfs:touch"),
        Nze = xe(),
        {
          UnixFS: JQ
        } = Ii(),
        qze = _0(),
        Mze = Ll(),
        Bze = Fl(),
        Dze = Ul(),
        {
          DAGNode: XQ
        } = Mr(),
        ZQ = Jr(),
        QQ = cr().multihash,
        Lze = ze(),
        Fze = {
          flush: !0,
          shardSplitThreshold: 1e3,
          cidVersion: 0,
          hashAlg: "sha2-256"
        };
      YQ.exports = r => {
        async function e(t, i = {}) {
          let n = Pze(Fze, i);
          n.mtime = n.mtime || new Date, Oze(`Touching ${t} mtime: ${n.mtime}`);
          let {
            cid: s,
            mfsDirectory: o,
            name: a,
            exists: c
          } = await Cze(r, t, n), u, f, h = n.cidVersion;
          if (c) {
            if (s.codec !== "dag-pb") throw Nze(new Error(`${t} was not a UnixFS node`), "ERR_NOT_UNIXFS");
            h = s.version, u = await r.ipld.get(s);
            let w = JQ.unmarshal(u.Data);
            w.mtime = n.mtime, u = new XQ(w.marshal(), u.Links), f = await r.ipld.put(u, ZQ.DAG_PB, {
              cidVersion: s.version,
              hashAlg: QQ.names["sha2-256"],
              onlyHash: !n.flush
            })
          } else {
            let w = new JQ({
              type: "file",
              mtime: n.mtime
            });
            u = new XQ(w.marshal()), f = await r.ipld.put(u, ZQ.DAG_PB, {
              cidVersion: n.cidVersion,
              hashAlg: QQ.names["sha2-256"],
              onlyHash: !n.flush
            })
          }
          let d = await qze(r, o),
            p = d[d.length - 1],
            g = await r.ipld.get(p.cid),
            m = await Mze(r, {
              parent: g,
              name: a,
              cid: f,
              size: u.serialize().length,
              flush: n.flush,
              shardSplitThreshold: n.shardSplitThreshold,
              hashAlg: "sha2-256",
              cidVersion: h
            });
          p.cid = m.cid;
          let E = await Bze(r, d, n);
          await Dze(r, E, n)
        }
        return Lze(e)
      }
    });
    var nee = y((R4t, tee) => {
      l();
      "use strict";
      var ree = xe(),
        lg = Oe()("ipfs:mfs:utils:to-async-iterator"),
        {
          MFS_MAX_CHUNK_SIZE: iee
        } = Ji(),
        Uze = gt(),
        Kze = r => {
          if (!r) throw ree(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
          if ((typeof r == "string" || r instanceof String) && (lg("Content was a string"), r = Uze(r.toString())), r.length) return lg("Content was array-like"), {
            [Symbol.asyncIterator]: function* () {
              yield r
            }
          };
          if (r[Symbol.asyncIterator]) return lg("Content was an async iterator"), r;
          if (r[Symbol.iterator]) return lg("Content was an iterator"), r;
          if (globalThis.Blob && r instanceof globalThis.Blob) {
            lg("Content was an HTML5 Blob");
            let e = 0,
              t = {
                next: () => e > r.size ? {
                  done: !0
                } : new Promise((i, n) => {
                  let s = r.slice(e, iee);
                  e += iee;
                  let o = new globalThis.FileReader,
                    a = c => {
                      if (o.removeEventListener("loadend", a, !1), c.error) return n(c.error);
                      i({
                        done: !1,
                        value: new Uint8Array(o.result)
                      })
                    };
                  o.addEventListener("loadend", a), o.readAsArrayBuffer(s)
                })
              };
            return {
              [Symbol.asyncIterator]: () => t
            }
          }
          throw ree(new Error(`Don't know how to convert ${r} into an async iterator`), "ERR_INVALID_PARAMS")
        };
      tee.exports = Kze
    });
    var uee = y((k4t, see) => {
      l();
      "use strict";
      var cc = Oe()("ipfs:mfs:write"),
        {
          importer: zze
        } = pw(),
        jze = ug(),
        Vze = Ow(),
        Hze = Ll(),
        Gze = Yr().bind({
          ignoreUndefined: !0
        }),
        oee = lA(),
        $ze = nee(),
        _A = tu(),
        Wze = Rw(),
        Yze = _0(),
        Jze = Fl(),
        Xze = Ul(),
        ru = xe(),
        {
          MFS_MAX_CHUNK_SIZE: Zze
        } = Ji(),
        Qze = Qa(),
        eje = ze(),
        {
          parseMode: tje,
          parseMtime: rje
        } = Ii(),
        ije = {
          offset: 0,
          length: Infinity,
          create: !1,
          truncate: !1,
          rawLeaves: !1,
          reduceSingleLeafToSelf: !1,
          cidVersion: 0,
          hashAlg: "sha2-256",
          parents: !1,
          progress: (r, e) => { },
          strategy: "trickle",
          flush: !0,
          leafType: "raw",
          shardSplitThreshold: 1e3
        };
      see.exports = r => {
        async function e(t, i, n = {}) {
          let s = Gze(ije, n),
            o, a, c;
          if (cc("Reading source, destination and parent"), await oee().readLock(async () => {
            o = await $ze(i), a = await _A(r, t, s), c = await _A(r, a.mfsDirectory, s)
          })(), cc("Read source, destination and parent"), !s.parents && !c.exists) throw ru(new Error("directory does not exist"), "ERR_NO_EXIST");
          if (o == null) throw ru(new Error("could not create source"), "ERR_NO_SOURCE");
          if (a == null) throw ru(new Error("could not create destination"), "ERR_NO_DESTINATION");
          if (!s.create && !a.exists) throw ru(new Error("file does not exist"), "ERR_NO_EXIST");
          if (a.entryType !== "file") throw ru(new Error("not a file"), "ERR_NOT_A_FILE");
          return nje(r, t, o, a, s)
        }
        return eje(e)
      };
      var nje = async (r, e, t, i, n) => {
        let s = await sje(r, t, i, n);
        await oee().writeLock(async () => {
          let o = Wze(e),
            a = o.pop();
          if (a == null) throw ru(new Error("source does not exist"), "ERR_NO_EXIST");
          let c = !1;
          try {
            await jze(r)(`/${o.join("/")}`, n), c = !0
          } catch (m) {
            if (m.code !== "ERR_NOT_FOUND") throw m
          }
          c || await Vze(r)(`/${o.join("/")}`, n);
          let u = await _A(r, e, n),
            f = await Yze(r, u.mfsDirectory),
            h = f[f.length - 1];
          if (!h) throw ru(new Error("directory does not exist"), "ERR_NO_EXIST");
          if (!h.type || !h.type.includes("directory")) throw ru(new Error(`cannot write to ${h.name}: Not a directory`), "ERR_NOT_A_DIRECTORY");
          let d = await r.ipld.get(h.cid),
            p = await Hze(r, {
              parent: d,
              name: a,
              cid: s.cid,
              size: s.size,
              flush: n.flush,
              shardSplitThreshold: n.shardSplitThreshold,
              hashAlg: n.hashAlg,
              cidVersion: n.cidVersion
            });
          h.cid = p.cid;
          let g = await Jze(r, f, n);
          await Xze(r, g, n)
        })()
      }, sje = async (r, e, t, i) => {
        t.exists ? cc(`Overwriting file ${t.cid} offset ${i.offset} length ${i.length}`) : cc(`Writing file offset ${i.offset} length ${i.length}`);
        let n = [];
        if (i.offset > 0)
          if (t.unixfs) {
            if (cc(`Writing first ${i.offset} bytes of original file`), n.push(() => t.content({
              offset: 0,
              length: i.offset
            })), t.unixfs.fileSize() < i.offset) {
              let u = i.offset - t.unixfs.fileSize();
              cc(`Writing zeros for extra ${u} bytes`), n.push(cee(u))
            }
          } else cc(`Writing zeros for first ${i.offset} bytes`), n.push(cee(i.offset));
        n.push(aee(e, i.length));
        let s = aje(oje(n), u => {
          if (t.unixfs && !i.truncate) {
            let f = t.unixfs.fileSize();
            if (f > u) return cc(`Writing last ${f - u} of ${f} bytes from original file starting at offset ${u}`), t.content({
              offset: u
            });
            cc("Not writing last bytes from original file")
          }
          return {
            [Symbol.asyncIterator]: async function* () { }
          }
        }),
          o;
        i.mode !== void 0 && i.mode !== null ? o = tje(i.mode) : t && t.unixfs && (o = t.unixfs.mode);
        let a;
        i.mtime != null ? a = rje(i.mtime) : t && t.unixfs && (a = t.unixfs.mtime);
        let c = await Qze(zze([{
          content: s,
          mode: o,
          mtime: a
        }], r.block, {
          progress: i.progress,
          hashAlg: i.hashAlg,
          cidVersion: i.cidVersion,
          strategy: i.strategy,
          rawLeaves: i.rawLeaves,
          reduceSingleLeafToSelf: i.reduceSingleLeafToSelf,
          leafType: i.leafType,
          pin: !1
        }));
        if (!c) throw ru(new Error(`cannot write to ${parent.name}`), "ERR_COULD_NOT_WRITE");
        return cc(`Wrote ${c.cid}`), {
          cid: c.cid,
          size: c.size
        }
      }, aee = (r, e) => async function* () {
        let i = 0;
        for await (let n of r) {
          if (i += n.length, i > e) {
            yield n.slice(0, e - i);
            return
          }
          yield n
        }
      }, cee = (r, e = Zze) => {
        let t = new Uint8Array(e);
        async function* i() {
          for (; ;) yield t.slice()
        }
        return aee(i(), r)
      }, oje = async function* (r) {
        for (let e = 0; e < r.length; e++) yield* r[e]()
      }, aje = async function* (r, e) {
        let t = 0;
        for await (let i of r) t += i.length, yield i;
        for await (let i of e(t)) t += i.length, yield i
      }
    });
    var hee = y((P4t, fee) => {
      l();
      "use strict";
      var {
        exporter: cje
      } = sa(), uje = Yr().bind({
        ignoreUndefined: !0
      }), fje = tu(), lee = xe(), lje = ze(), hje = {
        offset: 0,
        length: Infinity
      };
      fee.exports = r => {
        function e(t, i = {}) {
          return i = uje(hje, i), {
            [Symbol.asyncIterator]: async function* () {
              let s = await fje(r, t, i),
                o = await cje(s.mfsPath, r.ipld);
              if (o.type !== "file") throw lee(new Error(`${t} was not a file`), "ERR_NOT_FILE");
              if (!o.content) throw lee(new Error(`Could not load content stream from ${t}`), "ERR_NO_CONTENT");
              for await (let a of o.content({
                offset: i.offset,
                length: i.length
              })) yield a
            }
          }
        }
        return lje(e)
      }
    });
    var yee = y((C4t, dee) => {
      l();
      "use strict";
      var {
        exporter: dje
      } = sa(), pje = tu(), yje = ze(), gje = Qc(), pee = r => {
        let e = {
          cid: r.cid,
          name: r.name,
          type: r.type === "directory" ? "directory" : "file",
          size: r.size
        };
        return (r.type === "file" || r.type === "directory") && (e.mode = r.unixfs.mode, e.mtime = r.unixfs.mtime), e
      };
      dee.exports = r => {
        async function* e(t, i = {}) {
          let n = await pje(r, t, i),
            s = await dje(n.mfsPath, r.ipld);
          if (s.type === "directory") {
            yield* gje(s.content(i), pee);
            return
          }
          yield pee(s)
        }
        return yje(e)
      }
    });
    var wee = y((O4t, gee) => {
      l();
      "use strict";
      var bje = lA(),
        bee = Sl(),
        mje = {
          stat: ug()
        },
        vje = {
          chmod: VQ(),
          cp: Mw(),
          flush: GQ(),
          mkdir: Ow(),
          mv: WQ(),
          rm: Dw(),
          touch: eee()
        },
        mee = {
          write: uee(),
          read: hee(),
          ls: yee()
        },
        vee = ({
          options: r,
          mfs: e,
          operations: t,
          lock: i
        }) => {
          Object.keys(t).forEach(n => {
            e[n] = i(t[n](r))
          })
        },
        wje = {
          repoOwner: !0,
          ipld: null,
          repo: null
        };

      function _je(r) {
        let {
          repoOwner: e
        } = Object.assign({}, wje || {}, r);
        r.repo = {
          blocks: r.blocks,
          datastore: r.datastore
        };
        let t = bje(e),
          i = o => t.readLock(o),
          n = o => t.writeLock(o),
          s = {};
        return vee({
          options: r,
          mfs: s,
          operations: mje,
          lock: i
        }), vee({
          options: r,
          mfs: s,
          operations: vje,
          lock: n
        }), Object.keys(mee).forEach(o => {
          s[o] = mee[o](r)
        }), s
      }
      gee.exports = ({
        ipld: r,
        block: e,
        blockService: t,
        repo: i,
        preload: n,
        options: s
      }) => {
        let o = _je({
          ipld: r,
          block: e,
          blocks: t,
          datastore: i.root,
          repoOwner: s.repoOwner
        }),
          a = c => (...f) => {
            let h = f.filter(d => bee.ipfsPath(d) || bee.cid(d));
            if (h.length) {
              let d = f[f.length - 1];
              d && d.preload !== !1 && h.forEach(p => n(p))
            }
            return c(...f)
          };
        return {
          ...o,
          chmod: o.chmod,
          cp: a(o.cp),
          mkdir: o.mkdir,
          stat: a(o.stat),
          rm: o.rm,
          read: a(o.read),
          touch: o.touch,
          write: o.write,
          mv: a(o.mv),
          flush: o.flush,
          ls: a(async function* (...c) {
            for await (let u of o.ls(...c)) yield {
              ...u,
              size: u.size || 0
            }
          })
        }
      }
    });
    var Eee = y((N4t, _ee) => {
      l();
      "use strict";
      var Eje = ze();
      _ee.exports = ({
        keychain: r
      }) => Eje((t, i) => r.exportKey(t, i))
    });
    var Iee = y((q4t, See) => {
      l();
      "use strict";
      var Sje = ze(),
        xee = "rsa",
        Aee = 2048;
      See.exports = ({
        keychain: r
      }) => Sje((t, i = {
        type: xee,
        size: Aee
      }) => r.createKey(t, i.type || xee, i.size || Aee))
    });
    var Ree = y((M4t, Tee) => {
      l();
      "use strict";
      var xje = ze();
      Tee.exports = ({
        keychain: r
      }) => xje((t, i, n) => r.importKey(t, i, n))
    });
    var Pee = y((B4t, kee) => {
      l();
      "use strict";
      var Aje = ze();
      kee.exports = ({
        keychain: r
      }) => Aje(t => r.findKeyByName(t))
    });
    var Oee = y((D4t, Cee) => {
      l();
      "use strict";
      var Ije = ze();
      Cee.exports = ({
        keychain: r
      }) => Ije(() => r.listKeys())
    });
    var qee = y((L4t, Nee) => {
      l();
      "use strict";
      var Tje = ze();
      Nee.exports = ({
        keychain: r
      }) => Tje(async (t, i) => {
        let n = await r.renameKey(t, i);
        return {
          was: t,
          now: n.name,
          id: n.id,
          overwrite: !1
        }
      })
    });
    var Bee = y((F4t, Mee) => {
      l();
      "use strict";
      var Rje = ze();
      Mee.exports = ({
        keychain: r
      }) => Rje(t => r.removeKey(t))
    });
    var Fee = y((U4t, Dee) => {
      l();
      "use strict";
      var kje = Eee(),
        Pje = Iee(),
        Cje = Ree(),
        Oje = Pee(),
        Nje = Oee(),
        qje = qee(),
        Mje = Bee(),
        Lee = class {
          constructor({
            keychain: e
          }) {
            this.gen = Pje({
              keychain: e
            }), this.list = Nje({
              keychain: e
            }), this.rm = Mje({
              keychain: e
            }), this.rename = qje({
              keychain: e
            }), this.export = kje({
              keychain: e
            }), this.import = Cje({
              keychain: e
            }), this.info = Oje({
              keychain: e
            })
          }
        };
      Dee.exports = Lee
    });
    var pf = y((K4t, Uee) => {
      l();
      "use strict";
      var Bje = at(),
        Dje = xe(),
        Lje = ze();
      Uee.exports = ({
        ipld: r,
        preload: e
      }) => {
        async function t(i, n = {}) {
          let s;
          try {
            s = new Bje(i)
          } catch (o) {
            throw Dje(o, "ERR_INVALID_CID")
          }
          return n.preload !== !1 && e(s), r.get(s, {
            signal: n.signal
          })
        }
        return Lje(t)
      }
    });
    var zee = y((z4t, Kee) => {
      l();
      "use strict";
      var Fje = ze();
      Kee.exports = ({
        ipld: r,
        preload: e
      }) => {
        let t = pf()({
          ipld: r,
          preload: e
        });
        async function i(n, s = {}) {
          return (await t(n, s)).Data
        }
        return Fje(i)
      }
    });
    var Hee = y((j4t, jee) => {
      l();
      "use strict";
      var {
        DAGLink: Vee
      } = Mr(), EA = at(), Uje = ze();

      function SA(r, e = []) {
        for (let t in r) {
          let i = r[t];
          if (t === "/" && Object.keys(r).length === 1) try {
            e.push(new Vee("", 0, new EA(i)));
            continue
          } catch (n) { }
          if (EA.isCID(i)) {
            e.push(new Vee("", 0, i));
            continue
          }
          Array.isArray(i) && SA(i, e), i && typeof i == "object" && SA(i, e)
        }
        return e
      }
      jee.exports = ({
        ipld: r
      }) => {
        async function e(t, i = {}) {
          let n = new EA(t),
            s = await r.get(n, i);
          if (n.codec === "raw") return [];
          if (n.codec === "dag-pb") return s.Links;
          if (n.codec === "dag-cbor") return SA(s);
          throw new Error(`Cannot resolve links from codec ${n.codec}`)
        }
        return Uje(e)
      }
    });
    var $ee = y((V4t, Gee) => {
      l();
      "use strict";
      var {
        DAGNode: Kje
      } = Mr(), zje = Jr(), jje = cr().multihash, {
        UnixFS: Vje
      } = Ii(), Hje = ze();
      Gee.exports = ({
        ipld: r,
        preload: e
      }) => {
        async function t(i = {}) {
          let n;
          if (i.template)
            if (i.template === "unixfs-dir") n = new Vje({
              type: "directory"
            }).marshal();
            else throw new Error("unknown template");
          else n = new Uint8Array(0);
          let s = new Kje(n),
            o = await r.put(s, zje.DAG_PB, {
              cidVersion: 0,
              hashAlg: jje.names["sha2-256"],
              signal: i.signal
            });
          return i.preload !== !1 && e(o), o
        }
        return Hje(t)
      }
    });
    var x0 = y((H4t, Wee) => {
      l();
      "use strict";
      var {
        DAGNode: Lw,
        DAGLink: Gje,
        util: $je
      } = Mr(), Yee = cr().multihash, Wje = Jr(), Yje = ze(), Jje = ct(), Xje = gt();

      function eVe(r, e) {
        switch (e) {
          case "json":
            return Zje(r);
          case "protobuf":
            return Qje(r);
          default:
            throw new Error(`unknown encoding: ${e}`)
        }
      }

      function Zje(r) {
        let e, t;
        try {
          let i = JSON.parse(Jje(r));
          t = (i.Links || []).map(n => new Gje(n.Name || n.name, n.Size || n.size, Yee.fromB58String(n.Hash || n.hash || n.multihash))), e = Xje(i.Data)
        } catch (i) {
          throw new Error("failed to parse JSON: " + i)
        }
        return new Lw(e, t)
      }

      function Qje(r) {
        return $je.deserialize(r)
      }
      Wee.exports = ({
        ipld: r,
        gcLock: e,
        preload: t
      }) => {
        async function i(n, s = {}) {
          let o = s.enc,
            a;
          if (n instanceof Uint8Array) o ? a = await eVe(n, o) : a = new Lw(n);
          else if (n instanceof Lw) a = n;
          else if (typeof n == "object") a = new Lw(n.Data, n.Links);
          else throw new Error("obj not recognized");
          let c = await e.readLock();
          try {
            let u = await r.put(a, Wje.DAG_PB, {
              cidVersion: 0,
              hashAlg: Yee.names["sha2-256"]
            });
            return s.preload !== !1 && t(u), u
          } finally {
            c()
          }
        }
        return Yje(i)
      }
    });
    var Zee = y((G4t, Jee) => {
      l();
      "use strict";
      var Xee = Mr(),
        tVe = ze();
      Jee.exports = ({
        ipld: r,
        preload: e
      }) => {
        let t = pf()({
          ipld: r,
          preload: e
        });
        async function i(n, s = {}) {
          let o = await t(n, s),
            a = Xee.util.serialize(o),
            c = await Xee.util.cid(a, {
              cidVersion: 0
            }),
            u = a.length,
            f = o.Links.reduce((h, d) => h + d.Tsize, 0);
          return {
            Hash: c.toBaseEncodedString(),
            NumLinks: o.Links.length,
            BlockSize: u,
            LinksSize: u - o.Data.length,
            DataSize: o.Data.length,
            CumulativeSize: u + f
          }
        }
        return tVe(i)
      }
    });
    var ete = y(($4t, Qee) => {
      l();
      "use strict";
      var rVe = ze();
      Qee.exports = ({
        ipld: r,
        gcLock: e,
        preload: t
      }) => {
        let i = pf()({
          ipld: r,
          preload: t
        }),
          n = x0()({
            ipld: r,
            gcLock: e,
            preload: t
          });
        async function s(o, a, c = {}) {
          let u = await i(o, c);
          return u.addLink(a), n(u, c)
        }
        return rVe(s)
      }
    });
    var rte = y((W4t, tte) => {
      l();
      "use strict";
      var {
        DAGNode: iVe
      } = Mr(), nVe = ze(), sVe = xi();
      tte.exports = ({
        ipld: r,
        gcLock: e,
        preload: t
      }) => {
        let i = pf()({
          ipld: r,
          preload: t
        }),
          n = x0()({
            ipld: r,
            gcLock: e,
            preload: t
          });
        async function s(o, a, c = {}) {
          let u = await i(o, c),
            f = sVe([u.Data, a]);
          return n(new iVe(f, u.Links), c)
        }
        return nVe(s)
      }
    });
    var nte = y((Y4t, ite) => {
      l();
      "use strict";
      var oVe = ze();
      ite.exports = ({
        ipld: r,
        gcLock: e,
        preload: t
      }) => {
        let i = pf()({
          ipld: r,
          preload: t
        }),
          n = x0()({
            ipld: r,
            gcLock: e,
            preload: t
          });
        async function s(o, a, c = {}) {
          let u = await i(o, c);
          return u.rmLink(a.Name || a.name || a), n(u, c)
        }
        return oVe(s)
      }
    });
    var ote = y((J4t, ste) => {
      l();
      "use strict";
      var {
        DAGNode: aVe
      } = Mr(), cVe = ze();
      ste.exports = ({
        ipld: r,
        gcLock: e,
        preload: t
      }) => {
        let i = pf()({
          ipld: r,
          preload: t
        }),
          n = x0()({
            ipld: r,
            gcLock: e,
            preload: t
          });
        async function s(o, a, c = {}) {
          let u = await i(o, c);
          return n(new aVe(a, u.Links), c)
        }
        return cVe(s)
      }
    });
    var ute = y((X4t, ate) => {
      l();
      "use strict";
      var uVe = ete(),
        fVe = rte(),
        lVe = nte(),
        hVe = ote(),
        cte = class {
          constructor({
            ipld: e,
            preload: t,
            gcLock: i
          }) {
            this.addLink = uVe({
              ipld: e,
              preload: t,
              gcLock: i
            }), this.appendData = fVe({
              ipld: e,
              preload: t,
              gcLock: i
            }), this.rmLink = lVe({
              ipld: e,
              preload: t,
              gcLock: i
            }), this.setData = hVe({
              ipld: e,
              preload: t,
              gcLock: i
            })
          }
        };
      ate.exports = cte
    });
    var hte = y((Z4t, fte) => {
      l();
      "use strict";
      var dVe = zee(),
        pVe = pf(),
        yVe = Hee(),
        gVe = $ee(),
        bVe = x0(),
        mVe = Zee(),
        vVe = ute(),
        lte = class {
          constructor({
            ipld: e,
            preload: t,
            gcLock: i
          }) {
            this.data = dVe({
              ipld: e,
              preload: t
            }), this.get = pVe({
              ipld: e,
              preload: t
            }), this.links = yVe({
              ipld: e
            }), this.new = gVe({
              ipld: e,
              preload: t
            }), this.put = bVe({
              ipld: e,
              preload: t,
              gcLock: i
            }), this.stat = mVe({
              ipld: e,
              preload: t
            }), this.patch = new vVe({
              ipld: e,
              preload: t,
              gcLock: i
            })
          }
        };
      fte.exports = lte
    });
    var gte = y((Q4t, dte) => {
      l();
      "use strict";
      var pte = at(),
        hg = Oe()("ipfs:repo:gc"),
        {
          MFS_ROOT_KEY: wVe
        } = Ji(),
        _Ve = ze(),
        {
          Errors: EVe
        } = fr(),
        SVe = EVe.notFoundError().code,
        {
          parallelMerge: xVe,
          transform: AVe,
          map: IVe
        } = Ml(),
        yte = ln(),
        TVe = 256;
      dte.exports = ({
        gcLock: r,
        pin: e,
        refs: t,
        repo: i
      }) => {
        async function* n(s = {}) {
          let o = Date.now();
          hg("Creating set of marked blocks");
          let a = await r.writeLock();
          try {
            let c = await RVe({
              pin: e,
              refs: t,
              repo: i
            }),
              u = i.blocks.queryKeys({});
            yield* kVe({
              repo: i
            }, c, u), hg(`Complete (${Date.now() - o}ms)`)
          } finally {
            a()
          }
        }
        return _Ve(n)
      };
      async function RVe({
        pin: r,
        refs: e,
        repo: t
      }) {
        let i = IVe(({
          cid: o
        }) => o, r.ls()),
          n = async function* () {
            let o;
            try {
              o = await t.root.get(wVe)
            } catch (c) {
              if (c.code === SVe) {
                hg("No blocks in MFS");
                return
              }
              throw c
            }
            let a = new pte(o);
            yield a;
            for await (let {
              ref: c
            } of e(a, {
              recursive: !0
            })) yield new pte(c)
          }(), s = new Set;
        for await (let o of xVe(i, n)) s.add(yte.encode("base32", o.multihash).toString());
        return s
      }
      async function* kVe({
        repo: r
      }, e, t) {
        let i = 0,
          n = 0,
          s = async o => {
            i++;
            try {
              let a = yte.encode("base32", o.multihash).toString();
              if (e.has(a)) return null;
              try {
                await r.blocks.delete(o), n++
              } catch (c) {
                return {
                  err: new Error(`Could not delete block with CID ${o}: ${c.message}`)
                }
              }
              return {
                cid: o
              }
            } catch (a) {
              let c = `Could delete block with CID ${o}`;
              return hg(c, a), {
                err: new Error(c + `: ${a.message}`)
              }
            }
          };
        for await (let o of AVe(TVe, s, t)) o && (yield o);
        hg(`Marked set has ${e.size} unique blocks. Blockstore has ${i} blocks. Deleted ${n} blocks.`)
      }
    });
    var xA = y((eEt, bte) => {
      l();
      "use strict";
      var PVe = ze();
      bte.exports = ({
        repo: r
      }) => {
        async function e(t = {}) {
          let i = await r.stat();
          return {
            numObjects: BigInt(i.numObjects.toString()),
            repoSize: BigInt(i.repoSize.toString()),
            repoPath: i.repoPath,
            version: `${i.version}`,
            storageMax: BigInt(i.storageMax.toString())
          }
        }
        return PVe(e)
      }
    });
    var AA = y((tEt, mte) => {
      l();
      mte.exports = CVe;

      function CVe(r, e, t) {
        if (!r) return t;
        var i, n;
        if (Array.isArray(e) && (i = e.slice(0)), typeof e == "string" && (i = e.split(".")), typeof e == "symbol" && (i = [e]), !Array.isArray(i)) throw new Error("props arg must be an array, a string or a symbol");
        for (; i.length;)
          if (n = i.shift(), !r || (r = r[n], r === void 0)) return t;
        return r
      }
    });
    var yf = y((rEt, vte) => {
      l();
      "use strict";
      var {
        Key: wte,
        Errors: _te
      } = fr(), Ete = Yv(), OVe = Ete.ShardingDatastore, NVe = new wte("/config"), qVe = new wte("/version");

      function MVe(r, e) {
        if (!e || !e.storageBackends) throw new Error("Please pass storage backend definitions");
        if (!e.storageBackends[r]) throw new Error(`Storage backend '${r}' not defined in config`);
        let t = e.storageBackends[r],
          i = {};
        return e.storageBackendOptions !== void 0 && e.storageBackendOptions[r] !== void 0 && (i = e.storageBackendOptions[r]), {
          StorageBackend: t,
          storageOptions: i
        }
      }

      function IA(r) {
        let e = r;
        for (; e.db || e.child;)
          if (e = e.db || e.child, e.type === "level-js" || e.constructor.name === "Level") return e
      }
      async function Ste(r, e, t) {
        let i = await e(r);
        if (i) return i;
        let n = IA(t);
        return n ? new Promise((s, o) => {
          let a = n.store("readonly").get(r.toString());
          a.transaction.onabort = () => {
            o(a.transaction.error)
          }, a.transaction.oncomplete = () => {
            s(Boolean(a.result))
          }
        }) : !1
      }
      async function xte(r, e, t, i) {
        if (await t(r)) return e(r);
        let n = IA(i);
        if (!n) throw _te.notFoundError();
        return new Promise((s, o) => {
          let a = n.store("readonly").get(r.toString());
          a.transaction.onabort = () => {
            o(a.transaction.error)
          }, a.transaction.oncomplete = () => {
            if (a.result) return s(a.result);
            o(_te.notFoundError())
          }
        })
      }

      function BVe(r, e, t) {
        let {
          StorageBackend: i,
          storageOptions: n
        } = MVe(e, t);
        e !== "root" && (r = `${r}/${e}`);
        let s = new i(r, n);
        n.sharding && (s = new OVe(s, new Ete.shard.NextToLast(2)));
        let o = s.get.bind(s),
          a = s.has.bind(s);
        return s.get = c => xte(c, o, a, s), s.has = c => Ste(c, a, s), s
      }
      vte.exports = {
        createStore: BVe,
        hasWithFallback: Ste,
        getWithFallback: xte,
        findLevelJs: IA,
        CONFIG_KEY: NVe,
        VERSION_KEY: qVe
      }
    });
    var TA = y((iEt, Ate) => {
      l();
      "use strict";
      var DVe = async r => {
        let e = 0;
        for await (let t of r) e++;
        return e
      };
      Ate.exports = DVe
    });
    var Cte = y((nEt, Ite) => {
      l();
      "use strict";
      var Tte = at(),
        Rte = fr().Key,
        Fw = ln(),
        LVe = Oe()("ipfs:repo:migrator:migration-8"),
        kte = ct(),
        {
          createStore: FVe
        } = yf(),
        UVe = TA();

      function KVe(r) {
        let e = Fw.decode(`b${r.toString().slice(1)}`),
          t = new Tte(e).multihash;
        t = Fw.encode("base32", t).slice(1);
        let i = kte(t).toUpperCase();
        return new Rte(`/${i}`, !1)
      }

      function zVe(r) {
        let e = Fw.decode(`b${r.toString().slice(1)}`),
          t = Fw.encode("base32", new Tte(1, "raw", e).bytes).slice(1);
        return new Rte(`/${kte(t)}`.toUpperCase(), !1)
      }
      async function Pte(r, e, t, i) {
        let n = FVe(r, "blocks", e);
        await n.open();
        let s;
        s = await UVe(n.queryKeys({
          filters: [o => i(o).toString() !== o.toString()]
        }));
        try {
          let o = 0;
          for await (let a of n.query({})) {
            let c = i(a.key);
            c.toString() !== a.key.toString() && (o += 1, LVe(`Migrating Block from ${a.key} to ${c}`), await n.delete(a.key), await n.put(c, a.value), t(o / s * 100, `Migrated Block from ${a.key} to ${c}`))
          }
        } finally {
          await n.close()
        }
      }
      Ite.exports = {
        version: 8,
        description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",
        migrate: (r, e, t = () => { }) => Pte(r, e, t, KVe),
        revert: (r, e, t = () => { }) => Pte(r, e, t, zVe)
      }
    });
    var qte = y((oEt, Ote) => {
      l();
      "use strict";
      var A0 = bi(),
        Nte = A0.Reader,
        jVe = A0.Writer,
        sEt = A0.util,
        dg = A0.roots.default || (A0.roots.default = {});
      dg.ipfs = function () {
        var r = {};
        return r.pin = function () {
          var e = {};
          return e.Set = function () {
            function t(i) {
              if (i)
                for (var n = Object.keys(i), s = 0; s < n.length; ++s) i[n[s]] != null && (this[n[s]] = i[n[s]])
            }
            return t.prototype.version = 0, t.prototype.fanout = 0, t.prototype.seed = 0, t.encode = function (n, s) {
              return s || (s = jVe.create()), n.version != null && Object.hasOwnProperty.call(n, "version") && s.uint32(8).uint32(n.version), n.fanout != null && Object.hasOwnProperty.call(n, "fanout") && s.uint32(16).uint32(n.fanout), n.seed != null && Object.hasOwnProperty.call(n, "seed") && s.uint32(29).fixed32(n.seed), s
            }, t.decode = function (n, s) {
              n instanceof Nte || (n = Nte.create(n));
              for (var o = s === void 0 ? n.len : n.pos + s, a = new dg.ipfs.pin.Set; n.pos < o;) {
                var c = n.uint32();
                switch (c >>> 3) {
                  case 1:
                    a.version = n.uint32();
                    break;
                  case 2:
                    a.fanout = n.uint32();
                    break;
                  case 3:
                    a.seed = n.fixed32();
                    break;
                  default:
                    n.skipType(c & 7);
                    break
                }
              }
              return a
            }, t.fromObject = function (n) {
              if (n instanceof dg.ipfs.pin.Set) return n;
              var s = new dg.ipfs.pin.Set;
              return n.version != null && (s.version = n.version >>> 0), n.fanout != null && (s.fanout = n.fanout >>> 0), n.seed != null && (s.seed = n.seed >>> 0), s
            }, t.toObject = function (n, s) {
              s || (s = {});
              var o = {};
              return s.defaults && (o.version = 0, o.fanout = 0, o.seed = 0), n.version != null && n.hasOwnProperty("version") && (o.version = n.version), n.fanout != null && n.hasOwnProperty("fanout") && (o.fanout = n.fanout), n.seed != null && n.hasOwnProperty("seed") && (o.seed = n.seed), o
            }, t.prototype.toJSON = function () {
              return this.constructor.toObject(this, A0.util.toJSONOptions)
            }, t
          }(), e
        }(), r
      }();
      Ote.exports = dg
    });
    var Bte = y((aEt, Mte) => {
      l();
      RA.BASE = 2166136261;

      function RA(r) {
        for (var e = RA.BASE, t = 0, i = r.length; t < i; t++) e ^= r.charCodeAt(t), e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24);
        return e >>> 0
      }
      Mte.exports = RA
    });
    var kA = y((cEt, Dte) => {
      l();
      "use strict";
      var VVe = ln(),
        {
          Key: Lte
        } = fr(),
        HVe = cr().multihash,
        GVe = new Lte("/local/pins"),
        $Ve = 256,
        WVe = 8192,
        YVe = HVe.fromB58String("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n"),
        JVe = {
          direct: "direct",
          recursive: "recursive"
        };

      function XVe(r) {
        return new Lte(`/${VVe.encoding("base32upper").encode(r.multihash)}`)
      }
      Dte.exports = {
        PIN_DS_KEY: GVe,
        DEFAULT_FANOUT: $Ve,
        MAX_ITEMS: WVe,
        EMPTY_KEY: YVe,
        PinTypes: JVe,
        cidToKey: XVe
      }
    });
    var Vte = y((uEt, Fte) => {
      l();
      "use strict";
      var ZVe = at(),
        {
          ipfs: {
            pin: {
              Set: PA
            }
          }
        } = qte(),
        QVe = Bte(),
        CA = Yo(),
        pg = Mr(),
        Ute = hv(),
        Uw = rf(),
        Kte = cr().multihash,
        {
          cidToKey: Kw,
          DEFAULT_FANOUT: OA,
          MAX_ITEMS: eHe,
          EMPTY_KEY: zte
        } = kA(),
        NA = xi(),
        tHe = B5(),
        rHe = ct(),
        iHe = gt(),
        nHe = Lr();

      function sHe(r) {
        return new ZVe(r).toBaseEncodedString()
      }

      function oHe(r) {
        let e = r.Data,
          t = CA.decode(e),
          i = CA.decode.bytes;
        if (i <= 0) throw new Error("Invalid Set header length");
        if (i + t > e.length) throw new Error("Impossibly large set header length");
        let n = e.slice(i, t + i),
          s = PA.toObject(PA.decode(n), {
            defaults: !1,
            arrays: !0,
            longs: Number,
            objects: !1
          });
        if (s.version !== 1) throw new Error(`Unsupported Set version: ${s.version}`);
        if (s.fanout > r.Links.length) throw new Error("Impossibly large fanout");
        return {
          header: s,
          data: e.slice(t + i)
        }
      }

      function aHe(r, e) {
        let t = new Uint8Array(4);
        new DataView(t.buffer).setUint32(0, r, !0);
        let n = iHe(sHe(e)),
          s = NA([t, n], t.byteLength + n.byteLength);
        return QVe(rHe(s))
      }
      async function* jte(r, e) {
        let t = oHe(e),
          i = 0;
        for (let n of e.Links) {
          if (i < t.header.fanout) {
            let s = n.Hash;
            if (!nHe(zte, s.bytes)) {
              let o = await r.get(Kw(s)),
                a = pg.util.deserialize(o);
              yield* jte(r, a)
            }
          } else yield n.Hash;
          i++
        }
      }
      async function* cHe(r, e, t) {
        let i = e.Links.find(o => o.Name === t);
        if (!i) throw new Error("No link found with name " + t);
        let n = await r.get(Kw(i.Hash)),
          s = pg.util.deserialize(n);
        yield* jte(r, s)
      }

      function uHe(r, e) {
        return t(e, 0);
        async function t(i, n) {
          let s = PA.encode({
            version: 1,
            fanout: OA,
            seed: n
          }).finish(),
            o = CA.encode(s.length),
            a = NA([o, s]),
            c = [];
          for (let f = 0; f < OA; f++) c.push(new Uw("", 1, zte));
          if (i.length <= eHe) {
            let f = i.map(p => ({
              link: new Uw("", 1, p.key),
              data: p.data || new Uint8Array
            })).sort((p, g) => tHe(p.link.Hash.bytes, g.link.Hash.bytes)),
              h = c.concat(f.map(p => p.link)),
              d = NA([a, ...f.map(p => p.data)]);
            return new Ute(d, h)
          } else {
            let f = i.reduce((d, p) => {
              let g = aHe(n, p.key) % OA;
              return d[g] = g in d ? d[g].concat([p]) : [p], d
            }, []),
              h = 0;
            for (let d of f) {
              let p = await t(d, n + 1);
              await u(p, h), h++
            }
            return new Ute(a, c)
          }
          async function u(f, h) {
            let d = pg.util.serialize(f),
              p = await pg.util.cid(d, {
                cidVersion: 0,
                hashAlg: Kte.names["sha2-256"]
              });
            await r.put(Kw(p), d), c[h] = new Uw("", f.size, p)
          }
        }
      }
      async function fHe(r, e, t) {
        let i = await uHe(r, t.map(o => ({
          key: o
        }))),
          n = i.serialize(),
          s = await pg.util.cid(n, {
            cidVersion: 0,
            hashAlg: Kte.names["sha2-256"]
          });
        return await r.put(Kw(s), n), new Uw(e, i.size, s)
      }
      Fte.exports = {
        loadSet: cHe,
        storeSet: fHe
      }
    });
    var Wte = y((fEt, Hte) => {
      l();
      "use strict";
      var Gte = at(),
        qA = Mr(),
        MA = ($8(), G8),
        BA = Jr(),
        lHe = ln(),
        I0 = Vte(),
        {
          createStore: DA
        } = yf(),
        {
          cidToKey: yg,
          PIN_DS_KEY: zw,
          PinTypes: T0
        } = kA(),
        LA = TA();
      async function hHe(r, e, t, i) {
        if (!await e.has(zw)) return;
        let n = await e.get(zw),
          s = new Gte(n),
          o = await r.get(yg(s)),
          a = qA.util.deserialize(o),
          c = 0,
          u;
        u = await LA(I0.loadSet(r, a, T0.recursive)) + await LA(I0.loadSet(r, a, T0.direct));
        for await (let f of I0.loadSet(r, a, T0.recursive)) {
          c++;
          let h = {
            depth: Infinity
          };
          f.version !== 0 && (h.version = f.version), f.codec !== "dag-pb" && (h.codec = BA.getNumber(f.codec)), await t.put(yg(f), MA.encode(h)), i(c / u * 100, `Migrated recursive pin ${f}`)
        }
        for await (let f of I0.loadSet(r, a, T0.direct)) {
          c++;
          let h = {
            depth: 0
          };
          f.version !== 0 && (h.version = f.version), f.codec !== "dag-pb" && (h.codec = BA.getNumber(f.codec)), await t.put(yg(f), MA.encode(h)), i(c / u * 100, `Migrated direct pin ${f}`)
        }
        await r.delete(yg(s)), await e.delete(zw)
      }
      async function dHe(r, e, t, i) {
        let n = [],
          s = [],
          o = 0,
          a = await LA(t.queryKeys({}));
        for await (let {
          key: h,
          value: d
        } of t.query({})) {
          o++;
          let p = MA.decode(d),
            g = new Gte(p.version || 0, p.codec && BA.getName(p.codec) || "dag-pb", lHe.decode("b" + h.toString().split("/").pop()));
          p.depth === 0 ? (i(o / a * 100, `Reverted direct pin ${g}`), s.push(g)) : (i(o / a * 100, `Reverted recursive pin ${g}`), n.push(g))
        }
        i(100, "Updating pin root");
        let u = new qA.DAGNode(new Uint8Array, [await I0.storeSet(r, T0.recursive, n), await I0.storeSet(r, T0.direct, s)]).serialize(),
          f = await qA.util.cid(u, {
            cidVersion: 0
          });
        await r.put(yg(f), u), await e.put(zw, f.multihash)
      }
      async function $te(r, e, t, i) {
        let n = DA(r, "blocks", e),
          s = DA(r, "datastore", e),
          o = DA(r, "pins", e);
        await n.open(), await s.open(), await o.open();
        try {
          await i(n, s, o, t)
        } finally {
          await o.close(), await s.close(), await n.close()
        }
      }
      Hte.exports = {
        version: 9,
        description: "Migrates pins to datastore",
        migrate: (r, e, t = () => { }) => $te(r, e, t, hHe),
        revert: (r, e, t = () => { }) => $te(r, e, t, dHe)
      }
    });
    var Qte = y((lEt, Yte) => {
      l();
      "use strict";
      var {
        createStore: pHe,
        findLevelJs: Jte
      } = yf(), yHe = gt(), gHe = ct();
      async function bHe(r, e, t = () => { }) {
        let i = Jte(e);
        if (!i) {
          t(`${r} did not need an upgrade`);
          return
        }
        t(`Upgrading ${r}`), await Xte(i, (s, o) => [{
          type: "del",
          key: s
        }, {
          type: "put",
          key: yHe(s),
          value: o
        }])
      }
      async function mHe(r, e, t = () => { }) {
        let i = Jte(e);
        if (!i) {
          t(`${r} did not need a downgrade`);
          return
        }
        t(`Downgrading ${r}`), await Xte(i, (s, o) => [{
          type: "del",
          key: s
        }, {
          type: "put",
          key: gHe(s),
          value: o
        }])
      }
      async function Zte(r, e, t, i) {
        let n = Object.keys(e.storageBackends).filter(o => e.storageBackends[o].name === "LevelDatastore").map(o => ({
          name: o,
          store: pHe(r, o, e)
        }));
        t(0, `Migrating ${n.length} dbs`);
        let s = 0;
        for (let {
          name: o,
          store: a
        } of n) {
          await a.open();
          try {
            await i(o, a, u => {
              t(Math.round(s / n.length * 100), u)
            })
          } finally {
            s++, a.close()
          }
        }
        t(100, `Migrated ${n.length} dbs`)
      }
      Yte.exports = {
        version: 10,
        description: "Migrates datastore-level keys to binary",
        migrate: (r, e, t = () => { }) => Zte(r, e, t, bHe),
        revert: (r, e, t = () => { }) => Zte(r, e, t, mHe)
      };

      function Xte(r, e) {
        function t(i, n) {
          let s = r.store("readwrite"),
            o = s.transaction,
            a = 0,
            c;
          o.onabort = () => n(c || o.error || new Error("aborted by user")), o.oncomplete = () => n();

          function u() {
            var f = i[a++],
              h = f.key;
            try {
              var d = f.type === "del" ? s.delete(h) : s.put(f.value, h)
            } catch (p) {
              c = p, o.abort();
              return
            }
            a < i.length && (d.onsuccess = u)
          }
          u()
        }
        return new Promise((i, n) => {
          let s = r.iterator(),
            o = c => c;
          s._deserializeKey = s._deserializeValue = o, a();

          function a() {
            let c = (u, f, h) => {
              if (u || f === void 0) {
                let d = p => {
                  if (p) {
                    n(p);
                    return
                  }
                  i()
                };
                s.end(d);
                return
              }
              t(e(f, h), a)
            };
            s.next(c)
          }
        })
      }
    });
    var tre = y((hEt, ere) => {
      l();
      "use strict";
      var zl = {
        description: "Empty migration.",
        migrate: () => { },
        revert: () => { },
        empty: !0
      };
      ere.exports = [Object.assign({
        version: 1
      }, zl), Object.assign({
        version: 2
      }, zl), Object.assign({
        version: 3
      }, zl), Object.assign({
        version: 4
      }, zl), Object.assign({
        version: 5
      }, zl), Object.assign({
        version: 6
      }, zl), Object.assign({
        version: 7
      }, zl), Cte(), Wte(), Qte()]
    });
    var jw = y((dEt, rre) => {
      l();
      "use strict";
      var FA = class extends Error {
        constructor(e) {
          super(e);
          this.name = "NonReversibleMigrationError", this.code = "ERR_NON_REVERSIBLE_MIGRATION", this.message = e
        }
      };
      FA.code = "ERR_NON_REVERSIBLE_MIGRATION";
      var UA = class extends Error {
        constructor(e) {
          super(e);
          this.name = "NotInitializedRepoError", this.code = "ERR_NOT_INITIALIZED_REPO", this.message = e
        }
      };
      UA.code = "ERR_NOT_INITIALIZED_REPO";
      var KA = class extends Error {
        constructor(e) {
          super(e);
          this.name = "RequiredParameterError", this.code = "ERR_REQUIRED_PARAMETER", this.message = e
        }
      };
      KA.code = "ERR_REQUIRED_PARAMETER";
      var zA = class extends Error {
        constructor(e) {
          super(e);
          this.name = "InvalidValueError", this.code = "ERR_INVALID_VALUE", this.message = e
        }
      };
      zA.code = "ERR_INVALID_VALUE";
      var jA = class extends Error {
        constructor(e) {
          super(e);
          this.name = "MissingRepoOptionsError", this.code = "ERR_MISSING_REPO_OPTIONS", this.message = e
        }
      };
      jA.code = "ERR_MISSING_REPO_OPTIONS";
      rre.exports = {
        NonReversibleMigrationError: FA,
        NotInitializedRepoError: UA,
        RequiredParameterError: KA,
        InvalidValueError: zA,
        MissingRepoOptionsError: jA
      }
    });
    var nre = y((pEt, ire) => {
      l();
      "use strict";
      var VA = Oe()("ipfs:repo:migrator:repo:init"),
        {
          CONFIG_KEY: vHe,
          VERSION_KEY: wHe,
          createStore: _He
        } = yf(),
        {
          MissingRepoOptionsError: EHe
        } = jw();
      async function SHe(r, e) {
        if (!e) throw new EHe("Please pass repo options when trying to open a repo");
        let t;
        try {
          t = _He(r, "root", e), await t.open();
          let i = await t.has(wHe),
            n = await t.has(vHe);
          return !i || !n ? (VA(`Version entry present: ${i}`), VA(`Config entry present: ${n}`), !1) : !0
        } catch (i) {
          return VA("While checking if repo is initialized error was thrown: " + i.message), !1
        } finally {
          t !== void 0 && await t.close()
        }
      }
      ire.exports = {
        isRepoInitialized: SHe
      }
    });
    var ure = y((yEt, sre) => {
      l();
      "use strict";
      var xHe = nre(),
        {
          MissingRepoOptionsError: ore,
          NotInitializedRepoError: AHe
        } = jw(),
        {
          VERSION_KEY: are,
          createStore: cre
        } = yf(),
        IHe = gt(),
        THe = ct();
      async function RHe(r, e) {
        if (!await xHe.isRepoInitialized(r, e)) throw new AHe(`Repo in path ${r} is not initialized!`);
        if (!e) throw new ore("Please pass repo options when trying to open a repo");
        let t = cre(r, "root", e);
        await t.open();
        try {
          return parseInt(THe(await t.get(are)))
        } finally {
          await t.close()
        }
      }
      async function kHe(r, e, t) {
        if (!t) throw new ore("Please pass repo options when trying to open a repo");
        let i = cre(r, "root", t);
        await i.open(), await i.put(are, IHe(String(e))), await i.close()
      }
      sre.exports = {
        getVersion: RHe,
        setVersion: kHe
      }
    });
    var hre = y(fre => {
      l();
      "use strict";
      var PHe = Oe(),
        lre = PHe("ipfs:repo:migrator:repo_mem_lock"),
        CHe = "repo.lock",
        Vw = {};
      fre.lock = async function (e, t) {
        let i = t + "/" + CHe;
        if (lre("locking %s", i), Vw[i] === !0) throw Error(`There is already present lock for: ${i}`);
        return Vw[i] = !0, {
          close() {
            Vw[i] && (lre("releasing lock %s", i), delete Vw[i])
          }
        }
      }
    });
    var gre = y(R0 => {
      l();
      "use strict";
      var HA = tre(),
        jl = ure(),
        dre = hre(),
        Fs = jw(),
        oa = Oe()("ipfs:repo:migrator");
      R0.getCurrentRepoVersion = jl.getVersion;
      R0.errors = Fs;

      function pre(r) {
        return r = r || HA, !Array.isArray(r) || r.length === 0 ? 0 : r[r.length - 1].version
      }
      R0.getLatestMigrationVersion = pre;
      async function OHe(r, e, t, {
        ignoreLock: i = !1,
        onProgress: n,
        isDryRun: s = !1,
        migrations: o
      }) {
        if (o = o || HA, !r) throw new Fs.RequiredParameterError("Path argument is required!");
        if (!e) throw new Fs.RequiredParameterError("repoOptions argument is required!");
        if (!t) throw new Fs.RequiredParameterError("toVersion argument is required!");
        if (!Number.isInteger(t) || t <= 0) throw new Fs.InvalidValueError("Version has to be positive integer!");
        let a = await jl.getVersion(r, e);
        if (a === t) {
          oa("Nothing to migrate.");
          return
        }
        if (a > t) throw new Fs.InvalidValueError(`Current repo's version (${a}) is higher then toVersion (${t}), you probably wanted to revert it?`);
        yre(o, a, t);
        let c;
        !s && !i && (c = await dre.lock(a, r, e));
        try {
          for (let u of o) {
            if (t !== void 0 && u.version > t) break;
            if (!(u.version <= a)) {
              oa(`Migrating version ${u.version}`);
              try {
                if (!s) {
                  let f = () => { };
                  n && (f = (h, d) => n(u.version, h.toFixed(2), d)), await u.migrate(r, e, f)
                }
              } catch (f) {
                let h = u.version - 1;
                throw oa(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${h}`), await jl.setVersion(r, h, e), new Error(`During migration to version ${u.version} exception was raised: ${f.stack || f.message || f}`)
              }
              oa(`Migrating to version ${u.version} finished`)
            }
          }
          s || await jl.setVersion(r, t || pre(o), e), oa("Repo successfully migrated", t !== void 0 ? `to version ${t}!` : "to latest version!")
        } finally {
          !s && !i && c && await c.close()
        }
      }
      R0.migrate = OHe;
      async function NHe(r, e, t, {
        ignoreLock: i = !1,
        onProgress: n,
        isDryRun: s = !1,
        migrations: o
      }) {
        if (o = o || HA, !r) throw new Fs.RequiredParameterError("Path argument is required!");
        if (!e) throw new Fs.RequiredParameterError("repoOptions argument is required!");
        if (!t) throw new Fs.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
        if (!Number.isInteger(t) || t <= 0) throw new Fs.InvalidValueError("Version has to be positive integer!");
        let a = await jl.getVersion(r, e);
        if (a === t) {
          oa("Nothing to revert.");
          return
        }
        if (a < t) throw new Fs.InvalidValueError(`Current repo's version (${a}) is lower then toVersion (${t}), you probably wanted to migrate it?`);
        yre(o, t, a, !0);
        let c;
        !s && !i && (c = await dre.lock(a, r, e)), oa(`Reverting from version ${a} to ${t}`);
        try {
          let u = o.slice().reverse();
          for (let f of u) {
            if (f.version <= t) break;
            if (!(f.version > a)) {
              oa(`Reverting migration version ${f.version}`);
              try {
                if (!s) {
                  let h = () => { };
                  n && (h = (d, p) => n(f.version, d.toFixed(2), p)), await f.revert(r, e, h)
                }
              } catch (h) {
                let d = f.version;
                throw oa(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${d}`), await jl.setVersion(r, d, e), h.message = `During reversion to version ${f.version} exception was raised: ${h.message}`, h
              }
              oa(`Reverting to version ${f.version} finished`)
            }
          }
          s || await jl.setVersion(r, t, e), oa(`All migrations successfully reverted to version ${t}!`)
        } finally {
          !s && !i && c && await c.close()
        }
      }
      R0.revert = NHe;

      function yre(r, e, t, i = !1) {
        let n = 0;
        for (let s of r) {
          if (s.version > t) break;
          if (s.version > e) {
            if (i && !s.revert) throw new Fs.NonReversibleMigrationError(`It is not possible to revert to version ${e} because migration version ${s.version} is not reversible. Cancelling reversion.`);
            n++
          }
        }
        if (n !== t - e) throw new Fs.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${e} to ${t}`)
      }
    });
    var vre = y((mEt, Hw) => {
      l();
      "use strict";
      Hw.exports = qHe;
      Hw.exports.format = bre;
      Hw.exports.parse = mre;
      var MHe = /\B(?=(\d{3})+(?!\d))/g,
        BHe = /(?:\.0*|(\.[^0]+)0+)$/,
        gf = {
          b: 1,
          kb: 1 << 10,
          mb: 1 << 20,
          gb: 1 << 30,
          tb: Math.pow(1024, 4),
          pb: Math.pow(1024, 5)
        },
        DHe = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;

      function qHe(r, e) {
        return typeof r == "string" ? mre(r) : typeof r == "number" ? bre(r, e) : null
      }

      function bre(r, e) {
        if (!Number.isFinite(r)) return null;
        var t = Math.abs(r),
          i = e && e.thousandsSeparator || "",
          n = e && e.unitSeparator || "",
          s = e && e.decimalPlaces !== void 0 ? e.decimalPlaces : 2,
          o = Boolean(e && e.fixedDecimals),
          a = e && e.unit || "";
        (!a || !gf[a.toLowerCase()]) && (t >= gf.pb ? a = "PB" : t >= gf.tb ? a = "TB" : t >= gf.gb ? a = "GB" : t >= gf.mb ? a = "MB" : t >= gf.kb ? a = "KB" : a = "B");
        var c = r / gf[a.toLowerCase()],
          u = c.toFixed(s);
        return o || (u = u.replace(BHe, "$1")), i && (u = u.replace(MHe, i)), u + n + a
      }

      function mre(r) {
        if (typeof r == "number" && !isNaN(r)) return r;
        if (typeof r != "string") return null;
        var e = DHe.exec(r),
          t, i = "b";
        return e ? (t = parseFloat(e[1]), i = e[4].toLowerCase()) : (t = parseInt(r, 10), i = "b"), Math.floor(gf[i] * t)
      }
    });
    var _re = y((vEt, wre) => {
      l();
      "use strict";

      function LHe(...r) {
        return r.length === 0 ? "." : r.join("/")
      }
      wre.exports = LHe
    });
    var Sre = y((wEt, Ere) => {
      l();
      "use strict";
      Ere.exports = {
        repoVersion: 10
      }
    });
    var Are = y((_Et, xre) => {
      l();
      "use strict";

      function FHe(r, e, t) {
        let i = t.storageBackends[r],
          n = Object.assign({}, t.storageBackendOptions[r] || {});
        return new i(e, n)
      }
      xre.exports = {
        create: FHe
      }
    });
    var Tre = y((EEt, Ire) => {
      l();
      "use strict";
      var UHe = fr().Key,
        KHe = Oe(),
        zHe = KHe("ipfs:repo:version"),
        jHe = ct(),
        VHe = gt(),
        {
          hasWithFallback: HHe,
          getWithFallback: GHe
        } = yf(),
        GA = new UHe("version");
      Ire.exports = r => ({
        async exists() {
          return HHe(GA, r.has.bind(r), r)
        },
        async get() {
          let e = await GHe(GA, r.get.bind(r), r.has.bind(r), r);
          return parseInt(jHe(e), 10)
        },
        set(e) {
          return r.put(GA, VHe(String(e)))
        },
        async check(e) {
          let t = await this.get();
          return zHe("comparing version: %s and %s", t, e), t === e || (t === 6 && e === 7 || e === 6 && t === 7)
        }
      })
    });
    var Gw = y(Vl => {
      l();
      "use strict";
      var gg = class extends Error {
        constructor(e) {
          super(e);
          this.name = "LockExistsError", this.code = gg.code
        }
      };
      gg.code = "ERR_LOCK_EXISTS";
      Vl.LockExistsError = gg;
      var bg = class extends Error {
        constructor(e) {
          super(e);
          this.name = "NotFoundError", this.code = bg.code
        }
      };
      bg.code = "ERR_NOT_FOUND";
      Vl.NotFoundError = bg;
      var mg = class extends Error {
        constructor(e) {
          super(e);
          this.name = "InvalidRepoVersionError", this.code = mg.code
        }
      };
      mg.code = "ERR_INVALID_REPO_VERSION";
      Vl.InvalidRepoVersionError = mg;
      Vl.ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED";
      Vl.ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN";
      Vl.ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED"
    });
    var Pre = y((xEt, Rre) => {
      l();
      "use strict";
      var {
        Key: $He
      } = fr(), {
        default: WHe
      } = Tl(), YHe = AA(), JHe = Qx(), $A = xe(), kre = Gw(), XHe = ct(), ZHe = gt(), {
        hasWithFallback: QHe,
        getWithFallback: eGe
      } = yf(), WA = new $He("config");
      Rre.exports = r => {
        let e = new WHe({
          concurrency: 1
        }),
          t = {
            async getAll(s = {}) {
              let o = await eGe(WA, r.get.bind(r), r.has.bind(r), r, {
                signal: s.signal
              });
              return JSON.parse(XHe(o))
            },
            async get(s, o = {}) {
              if (s == null) throw new kre.NotFoundError(`Key ${s} does not exist in config`);
              let a = await this.getAll(o),
                c = YHe(a, s);
              if (c === void 0) throw new kre.NotFoundError(`Key ${s} does not exist in config`);
              return c
            },
            set(s, o, a = {}) {
              if (typeof s != "string" && !(s instanceof String)) throw $A(new Error("Invalid key type: " + typeof s), "ERR_INVALID_KEY");
              if (o === void 0 || o instanceof Uint8Array) throw $A(new Error("Invalid value type: " + typeof o), "ERR_INVALID_VALUE");
              return e.add(() => i({
                key: s,
                value: o
              }, a.signal))
            },
            replace(s, o = {}) {
              if (!s || s instanceof Uint8Array) throw $A(new Error("Invalid value type: " + typeof s), "ERR_INVALID_VALUE");
              return e.add(() => i({
                key: void 0,
                value: s
              }, o.signal))
            },
            async exists() {
              return QHe(WA, r.has.bind(r), r)
            }
          };
        return t;
        async function i(s, o) {
          if (o && o.aborted) return;
          let a = s.key,
            c = s.value;
          if (a) {
            let u = await t.getAll();
            return typeof u == "object" && u !== null && JHe(u, a, c), n(u)
          }
          return n(c)
        }

        function n(s) {
          let o = ZHe(JSON.stringify(s, null, 2));
          return r.put(WA, o)
        }
      }
    });
    var Ore = y((AEt, Cre) => {
      l();
      "use strict";
      Cre.exports = r => {
        if (Object.prototype.toString.call(r) !== "[object Object]") return !1;
        let e = Object.getPrototypeOf(r);
        return e === null || e === Object.prototype
      }
    });
    var qre = y((IEt, Nre) => {
      l();
      "use strict";
      var YA = Ore();
      Nre.exports = (r, e = {}) => {
        if (!YA(r) && !Array.isArray(r)) throw new TypeError("Expected a plain object or array");
        let {
          deep: t
        } = e, i = [], n = [], s = a => {
          let c = i.indexOf(a);
          if (c !== -1) return n[c];
          let u = [];
          return i.push(a), n.push(u), u.push(...a.map(f => Array.isArray(f) ? s(f) : YA(f) ? o(f) : f)), u
        }, o = a => {
          let c = i.indexOf(a);
          if (c !== -1) return n[c];
          let u = {},
            f = Object.keys(a).sort(e.compare);
          i.push(a), n.push(u);
          for (let h of f) {
            let d = a[h],
              p;
            t && Array.isArray(d) ? p = s(d) : p = t && YA(d) ? o(d) : d, Object.defineProperty(u, h, {
              ...Object.getOwnPropertyDescriptor(a, h),
              value: p
            })
          }
          return u
        };
        return Array.isArray(r) ? t ? s(r) : r.slice() : o(r)
      }
    });
    var Bre = y((TEt, Mre) => {
      l();
      "use strict";
      var tGe = fr().Key,
        rGe = qre(),
        iGe = ct(),
        nGe = gt(),
        JA = new tGe("datastore_spec");
      Mre.exports = r => ({
        exists() {
          return r.has(JA)
        },
        async get() {
          let e = await r.get(JA);
          return JSON.parse(iGe(e))
        },
        async set(e) {
          return r.put(JA, nGe(JSON.stringify(rGe(e, {
            deep: !0
          }))))
        }
      })
    });
    var Lre = y((REt, Dre) => {
      l();
      "use strict";
      var sGe = fr().Key,
        oGe = gt(),
        XA = new sGe("api");
      Dre.exports = r => ({
        async get() {
          let e = await r.get(XA);
          return e && e.toString()
        },
        set(e) {
          return r.put(XA, oGe(e.toString()))
        },
        delete() {
          return r.delete(XA)
        }
      })
    });
    var QA = y(ZA => {
      l();
      "use strict";
      var {
        Key: aGe
      } = fr(), Fre = at(), Ure = ln(), cGe = xe(), uGe = ct();
      ZA.cidToKey = r => {
        if (!Fre.isCID(r)) throw cGe(new Error("Not a valid cid"), "ERR_INVALID_CID");
        return new aGe("/" + uGe(Ure.encode("base32", r.multihash)).slice(1).toUpperCase(), !1)
      };
      ZA.keyToCid = r => new Fre(1, "raw", Ure.decode("b" + r.toString().slice(1).toLowerCase()))
    });
    var jre = y((PEt, Kre) => {
      l();
      "use strict";
      var {
        shard: fGe,
        ShardingDatastore: lGe
      } = Yv(), eI = ql(), {
        cidToKey: k0,
        keyToCid: zre
      } = QA(), hGe = Qc(), dGe = Vd(), pGe = eu();
      Kre.exports = (r, e) => {
        let t = yGe(r, e);
        return gGe(t)
      };

      function yGe(r, e) {
        return e.sharding ? new lGe(r, new fGe.NextToLast(2)) : r
      }

      function gGe(r) {
        return {
          open() {
            return r.open()
          },
          async *query(e, t) {
            for await (let {
              key: i,
              value: n
            } of r.query(e, t)) yield new eI(n, zre(i))
          },
          async *queryKeys(e, t) {
            for await (let i of r.queryKeys(e, t)) yield zre(i)
          },
          async get(e, t) {
            let i = k0(e),
              n = await r.get(i, t);
            return new eI(n, e)
          },
          async *getMany(e, t) {
            for await (let i of e) yield this.get(i, t)
          },
          async put(e, t) {
            if (!eI.isBlock(e)) throw new Error("invalid block");
            let i = k0(e.cid);
            return await r.has(i, t) || await r.put(i, e.data, t), e
          },
          async *putMany(e, t) {
            let i = pGe();
            (process && process.nextTick ? process.nextTick : setImmediate)(async () => {
              try {
                await dGe(r.putMany(async function* () {
                  for await (let s of e) {
                    let o = k0(s.cid);
                    await r.has(o, t) || (yield {
                      key: o,
                      value: s.data
                    }), i.push(s)
                  }
                }())), i.end()
              } catch (s) {
                i.end(s)
              }
            }), yield* i
          },
          has(e, t) {
            return r.has(k0(e), t)
          },
          delete(e, t) {
            return r.delete(k0(e), t)
          },
          deleteMany(e, t) {
            return r.deleteMany(hGe(e, i => k0(i)), t)
          },
          close() {
            return r.close()
          }
        }
      }
    });
    var Hre = y((CEt, Vre) => {
      l();
      "use strict";
      var bGe = ql(),
        mGe = xl(),
        vGe = Do(),
        wGe = eu(),
        _Ge = Vd(),
        EGe = at(),
        SGe = xe();
      Vre.exports = xGe;

      function xGe(r) {
        return {
          open() {
            return r.open()
          },
          query(e, t) {
            return r.query(e, t)
          },
          queryKeys(e, t) {
            return r.queryKeys(e, t)
          },
          async get(e, t) {
            let i = P0(e);
            return i.isIdentity ? Promise.resolve(new bGe(i.digest, e)) : r.get(e, t)
          },
          async *getMany(e, t) {
            for await (let i of e) yield this.get(i, t)
          },
          async put(e, t) {
            let {
              isIdentity: i
            } = P0(e.cid);
            return i ? Promise.resolve(e) : r.put(e, t)
          },
          async *putMany(e, t) {
            let i = wGe();
            (process && process.nextTick ? process.nextTick : setImmediate)(async () => {
              try {
                await _Ge(r.putMany(async function* () {
                  for await (let s of e) P0(s.cid).isIdentity || (yield s), i.push(s)
                }())), i.end()
              } catch (s) {
                i.end(s)
              }
            }), yield* i
          },
          has(e, t) {
            let {
              isIdentity: i
            } = P0(e);
            return i ? Promise.resolve(!0) : r.has(e, t)
          },
          delete(e, t) {
            let {
              isIdentity: i
            } = P0(e);
            return i ? Promise.resolve() : r.delete(e, t)
          },
          deleteMany(e, t) {
            return r.deleteMany(mGe(e, i => !P0(i).isIdentity), t)
          },
          close() {
            return r.close()
          }
        }
      }

      function P0(r) {
        if (!EGe.isCID(r)) throw SGe(new Error("Not a valid cid"), "ERR_INVALID_CID");
        let e = vGe.decode(r.multihash);
        return e.name !== "identity" ? {
          isIdentity: !1
        } : {
          isIdentity: !0,
          digest: e.digest
        }
      }
    });
    var $re = y((OEt, Gre) => {
      l();
      "use strict";
      Gre.exports = function () {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {},
          t = Symbol("test"),
          i = Object(t);
        if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]") return !1;
        var n = 42;
        e[t] = n;
        for (t in e) return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var s = Object.getOwnPropertySymbols(e);
        if (s.length !== 1 || s[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
          var o = Object.getOwnPropertyDescriptor(e, t);
          if (o.value !== n || o.enumerable !== !0) return !1
        }
        return !0
      }
    });
    var $w = y((NEt, Wre) => {
      l();
      "use strict";
      var Yre = typeof Symbol != "undefined" && Symbol,
        AGe = $re();
      Wre.exports = function () {
        return typeof Yre != "function" || typeof Symbol != "function" || typeof Yre("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : AGe()
      }
    });
    var Xre = y((qEt, Jre) => {
      l();
      "use strict";
      var IGe = "Function.prototype.bind called on incompatible ",
        tI = Array.prototype.slice,
        TGe = Object.prototype.toString,
        RGe = "[object Function]";
      Jre.exports = function (e) {
        var t = this;
        if (typeof t != "function" || TGe.call(t) !== RGe) throw new TypeError(IGe + t);
        for (var i = tI.call(arguments, 1), n, s = function () {
          if (this instanceof n) {
            var f = t.apply(this, i.concat(tI.call(arguments)));
            return Object(f) === f ? f : this
          } else return t.apply(e, i.concat(tI.call(arguments)))
        }, o = Math.max(0, t.length - i.length), a = [], c = 0; c < o; c++) a.push("$" + c);
        if (n = Function("binder", "return function (" + a.join(",") + "){ return binder.apply(this,arguments); }")(s), t.prototype) {
          var u = function () { };
          u.prototype = t.prototype, n.prototype = new u, u.prototype = null
        }
        return n
      }
    });
    var Ww = y((MEt, Zre) => {
      l();
      "use strict";
      var kGe = Xre();
      Zre.exports = Function.prototype.bind || kGe
    });
    var eie = y((BEt, Qre) => {
      l();
      "use strict";
      var PGe = Ww();
      Qre.exports = PGe.call(Function.call, Object.prototype.hasOwnProperty)
    });
    var Zw = y((DEt, tie) => {
      l();
      "use strict";
      var Vt, vg = SyntaxError,
        rie = Function,
        C0 = TypeError,
        rI = function (r) {
          try {
            return rie('"use strict"; return (' + r + ").constructor;")()
          } catch (e) { }
        },
        Hl = Object.getOwnPropertyDescriptor;
      if (Hl) try {
        Hl({}, "")
      } catch (r) {
        Hl = null
      }
      var iI = function () {
        throw new C0
      },
        CGe = Hl ? function () {
          try {
            return arguments.callee, iI
          } catch (r) {
            try {
              return Hl(arguments, "callee").get
            } catch (e) {
              return iI
            }
          }
        }() : iI,
        O0 = $w()(),
        bf = Object.getPrototypeOf || function (r) {
          return r.__proto__
        },
        N0 = {},
        OGe = typeof Uint8Array == "undefined" ? Vt : bf(Uint8Array),
        q0 = {
          "%AggregateError%": typeof AggregateError == "undefined" ? Vt : AggregateError,
          "%Array%": Array,
          "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? Vt : ArrayBuffer,
          "%ArrayIteratorPrototype%": O0 ? bf([][Symbol.iterator]()) : Vt,
          "%AsyncFromSyncIteratorPrototype%": Vt,
          "%AsyncFunction%": N0,
          "%AsyncGenerator%": N0,
          "%AsyncGeneratorFunction%": N0,
          "%AsyncIteratorPrototype%": N0,
          "%Atomics%": typeof Atomics == "undefined" ? Vt : Atomics,
          "%BigInt%": typeof BigInt == "undefined" ? Vt : BigInt,
          "%Boolean%": Boolean,
          "%DataView%": typeof DataView == "undefined" ? Vt : DataView,
          "%Date%": Date,
          "%decodeURI%": decodeURI,
          "%decodeURIComponent%": decodeURIComponent,
          "%encodeURI%": encodeURI,
          "%encodeURIComponent%": encodeURIComponent,
          "%Error%": Error,
          "%eval%": eval,
          "%EvalError%": EvalError,
          "%Float32Array%": typeof Float32Array == "undefined" ? Vt : Float32Array,
          "%Float64Array%": typeof Float64Array == "undefined" ? Vt : Float64Array,
          "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? Vt : FinalizationRegistry,
          "%Function%": rie,
          "%GeneratorFunction%": N0,
          "%Int8Array%": typeof Int8Array == "undefined" ? Vt : Int8Array,
          "%Int16Array%": typeof Int16Array == "undefined" ? Vt : Int16Array,
          "%Int32Array%": typeof Int32Array == "undefined" ? Vt : Int32Array,
          "%isFinite%": isFinite,
          "%isNaN%": isNaN,
          "%IteratorPrototype%": O0 ? bf(bf([][Symbol.iterator]())) : Vt,
          "%JSON%": typeof JSON == "object" ? JSON : Vt,
          "%Map%": typeof Map == "undefined" ? Vt : Map,
          "%MapIteratorPrototype%": typeof Map == "undefined" || !O0 ? Vt : bf(new Map()[Symbol.iterator]()),
          "%Math%": Math,
          "%Number%": Number,
          "%Object%": Object,
          "%parseFloat%": parseFloat,
          "%parseInt%": parseInt,
          "%Promise%": typeof Promise == "undefined" ? Vt : Promise,
          "%Proxy%": typeof Proxy == "undefined" ? Vt : Proxy,
          "%RangeError%": RangeError,
          "%ReferenceError%": ReferenceError,
          "%Reflect%": typeof Reflect == "undefined" ? Vt : Reflect,
          "%RegExp%": RegExp,
          "%Set%": typeof Set == "undefined" ? Vt : Set,
          "%SetIteratorPrototype%": typeof Set == "undefined" || !O0 ? Vt : bf(new Set()[Symbol.iterator]()),
          "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? Vt : SharedArrayBuffer,
          "%String%": String,
          "%StringIteratorPrototype%": O0 ? bf(""[Symbol.iterator]()) : Vt,
          "%Symbol%": O0 ? Symbol : Vt,
          "%SyntaxError%": vg,
          "%ThrowTypeError%": CGe,
          "%TypedArray%": OGe,
          "%TypeError%": C0,
          "%Uint8Array%": typeof Uint8Array == "undefined" ? Vt : Uint8Array,
          "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? Vt : Uint8ClampedArray,
          "%Uint16Array%": typeof Uint16Array == "undefined" ? Vt : Uint16Array,
          "%Uint32Array%": typeof Uint32Array == "undefined" ? Vt : Uint32Array,
          "%URIError%": URIError,
          "%WeakMap%": typeof WeakMap == "undefined" ? Vt : WeakMap,
          "%WeakRef%": typeof WeakRef == "undefined" ? Vt : WeakRef,
          "%WeakSet%": typeof WeakSet == "undefined" ? Vt : WeakSet
        },
        NGe = function r(e) {
          var t;
          if (e === "%AsyncFunction%") t = rI("async function () {}");
          else if (e === "%GeneratorFunction%") t = rI("function* () {}");
          else if (e === "%AsyncGeneratorFunction%") t = rI("async function* () {}");
          else if (e === "%AsyncGenerator%") {
            var i = r("%AsyncGeneratorFunction%");
            i && (t = i.prototype)
          } else if (e === "%AsyncIteratorPrototype%") {
            var n = r("%AsyncGenerator%");
            n && (t = bf(n.prototype))
          }
          return q0[e] = t, t
        },
        iie = {
          "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
          "%ArrayPrototype%": ["Array", "prototype"],
          "%ArrayProto_entries%": ["Array", "prototype", "entries"],
          "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
          "%ArrayProto_keys%": ["Array", "prototype", "keys"],
          "%ArrayProto_values%": ["Array", "prototype", "values"],
          "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
          "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
          "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
          "%BooleanPrototype%": ["Boolean", "prototype"],
          "%DataViewPrototype%": ["DataView", "prototype"],
          "%DatePrototype%": ["Date", "prototype"],
          "%ErrorPrototype%": ["Error", "prototype"],
          "%EvalErrorPrototype%": ["EvalError", "prototype"],
          "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
          "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
          "%FunctionPrototype%": ["Function", "prototype"],
          "%Generator%": ["GeneratorFunction", "prototype"],
          "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
          "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
          "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
          "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
          "%JSONParse%": ["JSON", "parse"],
          "%JSONStringify%": ["JSON", "stringify"],
          "%MapPrototype%": ["Map", "prototype"],
          "%NumberPrototype%": ["Number", "prototype"],
          "%ObjectPrototype%": ["Object", "prototype"],
          "%ObjProto_toString%": ["Object", "prototype", "toString"],
          "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
          "%PromisePrototype%": ["Promise", "prototype"],
          "%PromiseProto_then%": ["Promise", "prototype", "then"],
          "%Promise_all%": ["Promise", "all"],
          "%Promise_reject%": ["Promise", "reject"],
          "%Promise_resolve%": ["Promise", "resolve"],
          "%RangeErrorPrototype%": ["RangeError", "prototype"],
          "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
          "%RegExpPrototype%": ["RegExp", "prototype"],
          "%SetPrototype%": ["Set", "prototype"],
          "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
          "%StringPrototype%": ["String", "prototype"],
          "%SymbolPrototype%": ["Symbol", "prototype"],
          "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
          "%TypedArrayPrototype%": ["TypedArray", "prototype"],
          "%TypeErrorPrototype%": ["TypeError", "prototype"],
          "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
          "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
          "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
          "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
          "%URIErrorPrototype%": ["URIError", "prototype"],
          "%WeakMapPrototype%": ["WeakMap", "prototype"],
          "%WeakSetPrototype%": ["WeakSet", "prototype"]
        },
        Yw = Ww(),
        Jw = eie(),
        qGe = Yw.call(Function.call, Array.prototype.concat),
        MGe = Yw.call(Function.apply, Array.prototype.splice),
        nie = Yw.call(Function.call, String.prototype.replace),
        Xw = Yw.call(Function.call, String.prototype.slice),
        BGe = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        DGe = /\\(\\)?/g,
        LGe = function (e) {
          var t = Xw(e, 0, 1),
            i = Xw(e, -1);
          if (t === "%" && i !== "%") throw new vg("invalid intrinsic syntax, expected closing `%`");
          if (i === "%" && t !== "%") throw new vg("invalid intrinsic syntax, expected opening `%`");
          var n = [];
          return nie(e, BGe, function (s, o, a, c) {
            n[n.length] = a ? nie(c, DGe, "$1") : o || s
          }), n
        },
        FGe = function (e, t) {
          var i = e,
            n;
          if (Jw(iie, i) && (n = iie[i], i = "%" + n[0] + "%"), Jw(q0, i)) {
            var s = q0[i];
            if (s === N0 && (s = NGe(i)), typeof s == "undefined" && !t) throw new C0("intrinsic " + e + " exists, but is not available. Please file an issue!");
            return {
              alias: n,
              name: i,
              value: s
            }
          }
          throw new vg("intrinsic " + e + " does not exist!")
        };
      tie.exports = function (e, t) {
        if (typeof e != "string" || e.length === 0) throw new C0("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof t != "boolean") throw new C0('"allowMissing" argument must be a boolean');
        var i = LGe(e),
          n = i.length > 0 ? i[0] : "",
          s = FGe("%" + n + "%", t),
          o = s.name,
          a = s.value,
          c = !1,
          u = s.alias;
        u && (n = u[0], MGe(i, qGe([0, 1], u)));
        for (var f = 1, h = !0; f < i.length; f += 1) {
          var d = i[f],
            p = Xw(d, 0, 1),
            g = Xw(d, -1);
          if ((p === '"' || p === "'" || p === "`" || g === '"' || g === "'" || g === "`") && p !== g) throw new vg("property names with quotes must have matching quotes");
          if ((d === "constructor" || !h) && (c = !0), n += "." + d, o = "%" + n + "%", Jw(q0, o)) a = q0[o];
          else if (a != null) {
            if (!(d in a)) {
              if (!t) throw new C0("base intrinsic for " + e + " exists, but the property is not available.");
              return
            }
            if (Hl && f + 1 >= i.length) {
              var m = Hl(a, d);
              h = !!m, h && "get" in m && !("originalValue" in m.get) ? a = m.get : a = a[d]
            } else h = Jw(a, d), a = a[d];
            h && !c && (q0[o] = a)
          }
        }
        return a
      }
    });
    var e3 = y((LEt, Qw) => {
      l();
      "use strict";
      var nI = Ww(),
        M0 = Zw(),
        sie = M0("%Function.prototype.apply%"),
        oie = M0("%Function.prototype.call%"),
        aie = M0("%Reflect.apply%", !0) || nI.call(oie, sie),
        cie = M0("%Object.getOwnPropertyDescriptor%", !0),
        Gl = M0("%Object.defineProperty%", !0),
        UGe = M0("%Math.max%");
      if (Gl) try {
        Gl({}, "a", {
          value: 1
        })
      } catch (r) {
        Gl = null
      }
      Qw.exports = function (e) {
        var t = aie(nI, oie, arguments);
        if (cie && Gl) {
          var i = cie(t, "length");
          i.configurable && Gl(t, "length", {
            value: 1 + UGe(0, e.length - (arguments.length - 1))
          })
        }
        return t
      };
      var uie = function () {
        return aie(nI, sie, arguments)
      };
      Gl ? Gl(Qw.exports, "apply", {
        value: uie
      }) : Qw.exports.apply = uie
    });
    var t3 = y((FEt, fie) => {
      l();
      "use strict";
      var lie = Zw(),
        hie = e3(),
        KGe = hie(lie("String.prototype.indexOf"));
      fie.exports = function (e, t) {
        var i = lie(e, !!t);
        return typeof i == "function" && KGe(e, ".prototype.") > -1 ? hie(i) : i
      }
    });
    var yie = y((UEt, die) => {
      l();
      "use strict";
      var zGe = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol",
        jGe = t3(),
        sI = jGe("Object.prototype.toString"),
        r3 = function (e) {
          return zGe && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : sI(e) === "[object Arguments]"
        },
        pie = function (e) {
          return r3(e) ? !0 : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && sI(e) !== "[object Array]" && sI(e.callee) === "[object Function]"
        },
        VGe = function () {
          return r3(arguments)
        }();
      r3.isLegacyArguments = pie;
      die.exports = VGe ? r3 : pie
    });
    var mie = y((KEt, gie) => {
      l();
      "use strict";
      var HGe = Object.prototype.toString,
        GGe = Function.prototype.toString,
        $Ge = /^\s*(?:function)?\*/,
        bie = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol",
        oI = Object.getPrototypeOf,
        WGe = function () {
          if (!bie) return !1;
          try {
            return Function("return function*() {}")()
          } catch (r) { }
        },
        aI;
      gie.exports = function (e) {
        if (typeof e != "function") return !1;
        if ($Ge.test(GGe.call(e))) return !0;
        if (!bie) {
          var t = HGe.call(e);
          return t === "[object GeneratorFunction]"
        }
        if (!oI) return !1;
        if (typeof aI == "undefined") {
          var i = WGe();
          aI = i ? oI(i) : !1
        }
        return oI(e) === aI
      }
    });
    var cI = y((zEt, vie) => {
      l();
      var YGe = Object.prototype.hasOwnProperty,
        JGe = Object.prototype.toString;
      vie.exports = function (e, t, i) {
        if (JGe.call(t) !== "[object Function]") throw new TypeError("iterator must be a function");
        var n = e.length;
        if (n === +n)
          for (var s = 0; s < n; s++) t.call(i, e[s], s, e);
        else
          for (var o in e) YGe.call(e, o) && t.call(i, e[o], o, e)
      }
    });
    var fI = y((jEt, wie) => {
      l();
      "use strict";
      var uI = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"];
      wie.exports = function () {
        for (var e = [], t = 0; t < uI.length; t++) typeof globalThis[uI[t]] == "function" && (e[e.length] = uI[t]);
        return e
      }
    });
    var lI = y((VEt, _ie) => {
      l();
      "use strict";
      var XGe = Zw(),
        i3 = XGe("%Object.getOwnPropertyDescriptor%");
      if (i3) try {
        i3([], "length")
      } catch (r) {
        i3 = null
      }
      _ie.exports = i3
    });
    var pI = y((HEt, Eie) => {
      l();
      "use strict";
      var Sie = cI(),
        ZGe = fI(),
        hI = t3(),
        QGe = hI("Object.prototype.toString"),
        e$e = $w()(),
        xie = e$e && typeof Symbol.toStringTag == "symbol",
        Aie = ZGe(),
        t$e = hI("Array.prototype.indexOf", !0) || function (e, t) {
          for (var i = 0; i < e.length; i += 1)
            if (e[i] === t) return i;
          return -1
        },
        r$e = hI("String.prototype.slice"),
        Iie = {},
        n3 = lI(),
        dI = Object.getPrototypeOf;
      xie && n3 && dI && Sie(Aie, function (r) {
        var e = new globalThis[r];
        if (!(Symbol.toStringTag in e)) throw new EvalError("this engine has support for Symbol.toStringTag, but " + r + " does not have the property! Please report this.");
        var t = dI(e),
          i = n3(t, Symbol.toStringTag);
        if (!i) {
          var n = dI(t);
          i = n3(n, Symbol.toStringTag)
        }
        Iie[r] = i.get
      });
      var i$e = function (e) {
        var t = !1;
        return Sie(Iie, function (i, n) {
          if (!t) try {
            t = i.call(e) === n
          } catch (s) { }
        }), t
      };
      Eie.exports = function (e) {
        if (!e || typeof e != "object") return !1;
        if (!xie) {
          var t = r$e(QGe(e), 8, -1);
          return t$e(Aie, t) > -1
        }
        return n3 ? i$e(e) : !1
      }
    });
    var Oie = y((GEt, Tie) => {
      l();
      "use strict";
      var Rie = cI(),
        n$e = fI(),
        kie = t3(),
        s$e = kie("Object.prototype.toString"),
        o$e = $w()(),
        Pie = o$e && typeof Symbol.toStringTag == "symbol",
        a$e = n$e(),
        c$e = kie("String.prototype.slice"),
        Cie = {},
        yI = lI(),
        gI = Object.getPrototypeOf;
      Pie && yI && gI && Rie(a$e, function (r) {
        if (typeof globalThis[r] == "function") {
          var e = new globalThis[r];
          if (!(Symbol.toStringTag in e)) throw new EvalError("this engine has support for Symbol.toStringTag, but " + r + " does not have the property! Please report this.");
          var t = gI(e),
            i = yI(t, Symbol.toStringTag);
          if (!i) {
            var n = gI(t);
            i = yI(n, Symbol.toStringTag)
          }
          Cie[r] = i.get
        }
      });
      var u$e = function (e) {
        var t = !1;
        return Rie(Cie, function (i, n) {
          if (!t) try {
            var s = i.call(e);
            s === n && (t = s)
          } catch (o) { }
        }), t
      },
        f$e = pI();
      Tie.exports = function (e) {
        return f$e(e) ? Pie ? u$e(e) : c$e(s$e(e), 8, -1) : !1
      }
    });
    var Gie = y(Ct => {
      l();
      "use strict";
      var l$e = yie(),
        h$e = mie(),
        aa = Oie(),
        Nie = pI();

      function B0(r) {
        return r.call.bind(r)
      }
      var qie = typeof BigInt != "undefined",
        Mie = typeof Symbol != "undefined",
        bo = B0(Object.prototype.toString),
        d$e = B0(Number.prototype.valueOf),
        p$e = B0(String.prototype.valueOf),
        y$e = B0(Boolean.prototype.valueOf);
      qie && (Bie = B0(BigInt.prototype.valueOf));
      var Bie;
      Mie && (Die = B0(Symbol.prototype.valueOf));
      var Die;

      function wg(r, e) {
        if (typeof r != "object") return !1;
        try {
          return e(r), !0
        } catch (t) {
          return !1
        }
      }
      Ct.isArgumentsObject = l$e;
      Ct.isGeneratorFunction = h$e;
      Ct.isTypedArray = Nie;

      function g$e(r) {
        return typeof Promise != "undefined" && r instanceof Promise || r !== null && typeof r == "object" && typeof r.then == "function" && typeof r.catch == "function"
      }
      Ct.isPromise = g$e;

      function b$e(r) {
        return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(r) : Nie(r) || Lie(r)
      }
      Ct.isArrayBufferView = b$e;

      function m$e(r) {
        return aa(r) === "Uint8Array"
      }
      Ct.isUint8Array = m$e;

      function v$e(r) {
        return aa(r) === "Uint8ClampedArray"
      }
      Ct.isUint8ClampedArray = v$e;

      function w$e(r) {
        return aa(r) === "Uint16Array"
      }
      Ct.isUint16Array = w$e;

      function _$e(r) {
        return aa(r) === "Uint32Array"
      }
      Ct.isUint32Array = _$e;

      function E$e(r) {
        return aa(r) === "Int8Array"
      }
      Ct.isInt8Array = E$e;

      function S$e(r) {
        return aa(r) === "Int16Array"
      }
      Ct.isInt16Array = S$e;

      function x$e(r) {
        return aa(r) === "Int32Array"
      }
      Ct.isInt32Array = x$e;

      function A$e(r) {
        return aa(r) === "Float32Array"
      }
      Ct.isFloat32Array = A$e;

      function I$e(r) {
        return aa(r) === "Float64Array"
      }
      Ct.isFloat64Array = I$e;

      function T$e(r) {
        return aa(r) === "BigInt64Array"
      }
      Ct.isBigInt64Array = T$e;

      function R$e(r) {
        return aa(r) === "BigUint64Array"
      }
      Ct.isBigUint64Array = R$e;

      function s3(r) {
        return bo(r) === "[object Map]"
      }
      s3.working = typeof Map != "undefined" && s3(new Map);

      function k$e(r) {
        return typeof Map == "undefined" ? !1 : s3.working ? s3(r) : r instanceof Map
      }
      Ct.isMap = k$e;

      function o3(r) {
        return bo(r) === "[object Set]"
      }
      o3.working = typeof Set != "undefined" && o3(new Set);

      function P$e(r) {
        return typeof Set == "undefined" ? !1 : o3.working ? o3(r) : r instanceof Set
      }
      Ct.isSet = P$e;

      function a3(r) {
        return bo(r) === "[object WeakMap]"
      }
      a3.working = typeof WeakMap != "undefined" && a3(new WeakMap);

      function C$e(r) {
        return typeof WeakMap == "undefined" ? !1 : a3.working ? a3(r) : r instanceof WeakMap
      }
      Ct.isWeakMap = C$e;

      function bI(r) {
        return bo(r) === "[object WeakSet]"
      }
      bI.working = typeof WeakSet != "undefined" && bI(new WeakSet);

      function O$e(r) {
        return bI(r)
      }
      Ct.isWeakSet = O$e;

      function c3(r) {
        return bo(r) === "[object ArrayBuffer]"
      }
      c3.working = typeof ArrayBuffer != "undefined" && c3(new ArrayBuffer);

      function Fie(r) {
        return typeof ArrayBuffer == "undefined" ? !1 : c3.working ? c3(r) : r instanceof ArrayBuffer
      }
      Ct.isArrayBuffer = Fie;

      function u3(r) {
        return bo(r) === "[object DataView]"
      }
      u3.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && u3(new DataView(new ArrayBuffer(1), 0, 1));

      function Lie(r) {
        return typeof DataView == "undefined" ? !1 : u3.working ? u3(r) : r instanceof DataView
      }
      Ct.isDataView = Lie;
      var mI = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : void 0;

      function _g(r) {
        return bo(r) === "[object SharedArrayBuffer]"
      }

      function Uie(r) {
        return typeof mI == "undefined" ? !1 : (typeof _g.working == "undefined" && (_g.working = _g(new mI)), _g.working ? _g(r) : r instanceof mI)
      }
      Ct.isSharedArrayBuffer = Uie;

      function N$e(r) {
        return bo(r) === "[object AsyncFunction]"
      }
      Ct.isAsyncFunction = N$e;

      function q$e(r) {
        return bo(r) === "[object Map Iterator]"
      }
      Ct.isMapIterator = q$e;

      function M$e(r) {
        return bo(r) === "[object Set Iterator]"
      }
      Ct.isSetIterator = M$e;

      function B$e(r) {
        return bo(r) === "[object Generator]"
      }
      Ct.isGeneratorObject = B$e;

      function D$e(r) {
        return bo(r) === "[object WebAssembly.Module]"
      }
      Ct.isWebAssemblyCompiledModule = D$e;

      function Kie(r) {
        return wg(r, d$e)
      }
      Ct.isNumberObject = Kie;

      function zie(r) {
        return wg(r, p$e)
      }
      Ct.isStringObject = zie;

      function jie(r) {
        return wg(r, y$e)
      }
      Ct.isBooleanObject = jie;

      function Vie(r) {
        return qie && wg(r, Bie)
      }
      Ct.isBigIntObject = Vie;

      function Hie(r) {
        return Mie && wg(r, Die)
      }
      Ct.isSymbolObject = Hie;

      function L$e(r) {
        return Kie(r) || zie(r) || jie(r) || Vie(r) || Hie(r)
      }
      Ct.isBoxedPrimitive = L$e;

      function F$e(r) {
        return typeof Uint8Array != "undefined" && (Fie(r) || Uie(r))
      }
      Ct.isAnyArrayBuffer = F$e;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function (r) {
        Object.defineProperty(Ct, r, {
          enumerable: !1,
          value: function () {
            throw new Error(r + " is not supported in userland")
          }
        })
      })
    });
    var Wie = y((WEt, $ie) => {
      l();
      $ie.exports = function (e) {
        return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function"
      }
    });
    var Yl = y(Ot => {
      l();
      var Yie = Object.getOwnPropertyDescriptors || function (e) {
        for (var t = Object.keys(e), i = {}, n = 0; n < t.length; n++) i[t[n]] = Object.getOwnPropertyDescriptor(e, t[n]);
        return i
      },
        U$e = /%[sdj%]/g;
      Ot.format = function (r) {
        if (!l3(r)) {
          for (var e = [], t = 0; t < arguments.length; t++) e.push(mf(arguments[t]));
          return e.join(" ")
        }
        for (var t = 1, i = arguments, n = i.length, s = String(r).replace(U$e, function (a) {
          if (a === "%%") return "%";
          if (t >= n) return a;
          switch (a) {
            case "%s":
              return String(i[t++]);
            case "%d":
              return Number(i[t++]);
            case "%j":
              try {
                return JSON.stringify(i[t++])
              } catch (c) {
                return "[Circular]"
              }
            default:
              return a
          }
        }), o = i[t]; t < n; o = i[++t]) f3(o) || !D0(o) ? s += " " + o : s += " " + mf(o);
        return s
      };
      Ot.deprecate = function (r, e) {
        if (typeof process != "undefined" && process.noDeprecation === !0) return r;
        if (typeof process == "undefined") return function () {
          return Ot.deprecate(r, e).apply(this, arguments)
        };
        var t = !1;

        function i() {
          if (!t) {
            if (process.throwDeprecation) throw new Error(e);
            process.traceDeprecation ? console.trace(e) : console.error(e), t = !0
          }
          return r.apply(this, arguments)
        }
        return i
      };
      var h3 = {},
        Jie = /^$/;
      process.env.NODE_DEBUG && (d3 = process.env.NODE_DEBUG, d3 = d3.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), Jie = new RegExp("^" + d3 + "$", "i"));
      var d3;
      Ot.debuglog = function (r) {
        if (r = r.toUpperCase(), !h3[r])
          if (Jie.test(r)) {
            var e = process.pid;
            h3[r] = function () {
              var t = Ot.format.apply(Ot, arguments);
              console.error("%s %d: %s", r, e, t)
            }
          } else h3[r] = function () { };
        return h3[r]
      };

      function mf(r, e) {
        var t = {
          seen: [],
          stylize: z$e
        };
        return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), vI(e) ? t.showHidden = e : e && Ot._extend(t, e), $l(t.showHidden) && (t.showHidden = !1), $l(t.depth) && (t.depth = 2), $l(t.colors) && (t.colors = !1), $l(t.customInspect) && (t.customInspect = !0), t.colors && (t.stylize = K$e), p3(t, r, t.depth)
      }
      Ot.inspect = mf;
      mf.colors = {
        bold: [1, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        white: [37, 39],
        grey: [90, 39],
        black: [30, 39],
        blue: [34, 39],
        cyan: [36, 39],
        green: [32, 39],
        magenta: [35, 39],
        red: [31, 39],
        yellow: [33, 39]
      };
      mf.styles = {
        special: "cyan",
        number: "yellow",
        boolean: "yellow",
        undefined: "grey",
        null: "bold",
        string: "green",
        date: "magenta",
        regexp: "red"
      };

      function K$e(r, e) {
        var t = mf.styles[e];
        return t ? "[" + mf.colors[t][0] + "m" + r + "[" + mf.colors[t][1] + "m" : r
      }

      function z$e(r, e) {
        return r
      }

      function j$e(r) {
        var e = {};
        return r.forEach(function (t, i) {
          e[t] = !0
        }), e
      }

      function p3(r, e, t) {
        if (r.customInspect && e && g3(e.inspect) && e.inspect !== Ot.inspect && !(e.constructor && e.constructor.prototype === e)) {
          var i = e.inspect(t, r);
          return l3(i) || (i = p3(r, i, t)), i
        }
        var n = V$e(r, e);
        if (n) return n;
        var s = Object.keys(e),
          o = j$e(s);
        if (r.showHidden && (s = Object.getOwnPropertyNames(e)), Sg(e) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0)) return wI(e);
        if (s.length === 0) {
          if (g3(e)) {
            var a = e.name ? ": " + e.name : "";
            return r.stylize("[Function" + a + "]", "special")
          }
          if (Eg(e)) return r.stylize(RegExp.prototype.toString.call(e), "regexp");
          if (y3(e)) return r.stylize(Date.prototype.toString.call(e), "date");
          if (Sg(e)) return wI(e)
        }
        var c = "",
          u = !1,
          f = ["{", "}"];
        if (Xie(e) && (u = !0, f = ["[", "]"]), g3(e)) {
          var h = e.name ? ": " + e.name : "";
          c = " [Function" + h + "]"
        }
        if (Eg(e) && (c = " " + RegExp.prototype.toString.call(e)), y3(e) && (c = " " + Date.prototype.toUTCString.call(e)), Sg(e) && (c = " " + wI(e)), s.length === 0 && (!u || e.length == 0)) return f[0] + c + f[1];
        if (t < 0) return Eg(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
        r.seen.push(e);
        var d;
        return u ? d = H$e(r, e, t, o, s) : d = s.map(function (p) {
          return _I(r, e, t, o, p, u)
        }), r.seen.pop(), G$e(d, c, f)
      }

      function V$e(r, e) {
        if ($l(e)) return r.stylize("undefined", "undefined");
        if (l3(e)) {
          var t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return r.stylize(t, "string")
        }
        if (Zie(e)) return r.stylize("" + e, "number");
        if (vI(e)) return r.stylize("" + e, "boolean");
        if (f3(e)) return r.stylize("null", "null")
      }

      function wI(r) {
        return "[" + Error.prototype.toString.call(r) + "]"
      }

      function H$e(r, e, t, i, n) {
        for (var s = [], o = 0, a = e.length; o < a; ++o) Qie(e, String(o)) ? s.push(_I(r, e, t, i, String(o), !0)) : s.push("");
        return n.forEach(function (c) {
          c.match(/^\d+$/) || s.push(_I(r, e, t, i, c, !0))
        }), s
      }

      function _I(r, e, t, i, n, s) {
        var o, a, c;
        if (c = Object.getOwnPropertyDescriptor(e, n) || {
          value: e[n]
        }, c.get ? c.set ? a = r.stylize("[Getter/Setter]", "special") : a = r.stylize("[Getter]", "special") : c.set && (a = r.stylize("[Setter]", "special")), Qie(i, n) || (o = "[" + n + "]"), a || (r.seen.indexOf(c.value) < 0 ? (f3(t) ? a = p3(r, c.value, null) : a = p3(r, c.value, t - 1), a.indexOf(`
`) > -1 && (s ? a = a.split(`
`).map(function (u) {
          return "  " + u
        }).join(`
`).substr(2) : a = `
` + a.split(`
`).map(function (u) {
          return "   " + u
        }).join(`
`))) : a = r.stylize("[Circular]", "special")), $l(o)) {
          if (s && n.match(/^\d+$/)) return a;
          o = JSON.stringify("" + n), o.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.substr(1, o.length - 2), o = r.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o = r.stylize(o, "string"))
        }
        return o + ": " + a
      }

      function G$e(r, e, t) {
        var i = 0,
          n = r.reduce(function (s, o) {
            return i++, o.indexOf(`
`) >= 0 && i++, s + o.replace(/\u001b\[\d\d?m/g, "").length + 1
          }, 0);
        return n > 60 ? t[0] + (e === "" ? "" : e + `
`) + " " + r.join(`,
`) + " " + t[1] : t[0] + e + " " + r.join(", ") + " " + t[1]
      }
      Ot.types = Gie();

      function Xie(r) {
        return Array.isArray(r)
      }
      Ot.isArray = Xie;

      function vI(r) {
        return typeof r == "boolean"
      }
      Ot.isBoolean = vI;

      function f3(r) {
        return r === null
      }
      Ot.isNull = f3;

      function $$e(r) {
        return r == null
      }
      Ot.isNullOrUndefined = $$e;

      function Zie(r) {
        return typeof r == "number"
      }
      Ot.isNumber = Zie;

      function l3(r) {
        return typeof r == "string"
      }
      Ot.isString = l3;

      function W$e(r) {
        return typeof r == "symbol"
      }
      Ot.isSymbol = W$e;

      function $l(r) {
        return r === void 0
      }
      Ot.isUndefined = $l;

      function Eg(r) {
        return D0(r) && EI(r) === "[object RegExp]"
      }
      Ot.isRegExp = Eg;
      Ot.types.isRegExp = Eg;

      function D0(r) {
        return typeof r == "object" && r !== null
      }
      Ot.isObject = D0;

      function y3(r) {
        return D0(r) && EI(r) === "[object Date]"
      }
      Ot.isDate = y3;
      Ot.types.isDate = y3;

      function Sg(r) {
        return D0(r) && (EI(r) === "[object Error]" || r instanceof Error)
      }
      Ot.isError = Sg;
      Ot.types.isNativeError = Sg;

      function g3(r) {
        return typeof r == "function"
      }
      Ot.isFunction = g3;

      function Y$e(r) {
        return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || typeof r == "undefined"
      }
      Ot.isPrimitive = Y$e;
      Ot.isBuffer = Wie();

      function EI(r) {
        return Object.prototype.toString.call(r)
      }

      function SI(r) {
        return r < 10 ? "0" + r.toString(10) : r.toString(10)
      }
      var J$e = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

      function X$e() {
        var r = new Date,
          e = [SI(r.getHours()), SI(r.getMinutes()), SI(r.getSeconds())].join(":");
        return [r.getDate(), J$e[r.getMonth()], e].join(" ")
      }
      Ot.log = function () {
        console.log("%s - %s", X$e(), Ot.format.apply(Ot, arguments))
      };
      Ot.inherits = dn();
      Ot._extend = function (r, e) {
        if (!e || !D0(e)) return r;
        for (var t = Object.keys(e), i = t.length; i--;) r[t[i]] = e[t[i]];
        return r
      };

      function Qie(r, e) {
        return Object.prototype.hasOwnProperty.call(r, e)
      }
      var Wl = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : void 0;
      Ot.promisify = function (e) {
        if (typeof e != "function") throw new TypeError('The "original" argument must be of type Function');
        if (Wl && e[Wl]) {
          var t = e[Wl];
          if (typeof t != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(t, Wl, {
            value: t,
            enumerable: !1,
            writable: !1,
            configurable: !0
          }), t
        }

        function t() {
          for (var i, n, s = new Promise(function (c, u) {
            i = c, n = u
          }), o = [], a = 0; a < arguments.length; a++) o.push(arguments[a]);
          o.push(function (c, u) {
            c ? n(c) : i(u)
          });
          try {
            e.apply(this, o)
          } catch (c) {
            n(c)
          }
          return s
        }
        return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Wl && Object.defineProperty(t, Wl, {
          value: t,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), Object.defineProperties(t, Yie(e))
      };
      Ot.promisify.custom = Wl;

      function Z$e(r, e) {
        if (!r) {
          var t = new Error("Promise was rejected with a falsy value");
          t.reason = r, r = t
        }
        return e(r)
      }

      function Q$e(r) {
        if (typeof r != "function") throw new TypeError('The "original" argument must be of type Function');

        function e() {
          for (var t = [], i = 0; i < arguments.length; i++) t.push(arguments[i]);
          var n = t.pop();
          if (typeof n != "function") throw new TypeError("The last argument must be of type Function");
          var s = this,
            o = function () {
              return n.apply(s, arguments)
            };
          r.apply(this, t).then(function (a) {
            process.nextTick(o.bind(null, null, a))
          }, function (a) {
            process.nextTick(Z$e.bind(null, a, o))
          })
        }
        return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), Object.defineProperties(e, Yie(r)), e
      }
      Ot.callbackify = Q$e
    });
    var xI = y((JEt, ene) => {
      l();
      "use strict";
      ene.exports = function (...e) {
        let t = e.reduce((i, n) => Object.assign(i, n), {});
        return Object.assign(t, {
          bufferKeys: t.bufferKeys || !1,
          snapshots: t.snapshots || !1,
          permanence: t.permanence || !1,
          seek: t.seek || !1,
          clear: t.clear || !1,
          status: t.status || !1,
          createIfMissing: t.createIfMissing || !1,
          errorIfExists: t.errorIfExists || !1,
          deferredOpen: t.deferredOpen || !1,
          openCallback: t.openCallback || !1,
          promises: t.promises || !1,
          streams: t.streams || !1,
          encodings: t.encodings || !1,
          additionalMethods: Object.assign({}, t.additionalMethods)
        })
      }
    });
    var rne = y((XEt, tne) => {
      l();
      tne.exports = function (e) {
        return e != null && e.constructor != null && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e)
      }
    });
    var b3 = y((ZEt, ine) => {
      l();
      var nne;
      ine.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window != "undefined" ? window : globalThis) : r => (nne || (nne = Promise.resolve())).then(r).catch(e => setTimeout(() => {
        throw e
      }, 0))
    });
    var m3 = y((QEt, sne) => {
      l();
      "use strict";
      var one = b3();
      sne.exports = function (r, ...e) {
        e.length === 0 ? one(r) : one(() => r(...e))
      }
    });
    var AI = y((eSt, ane) => {
      l();
      "use strict";

      function vf(r) {
        if (typeof r != "object" || r === null) throw new TypeError("First argument must be an abstract-leveldown compliant store");
        this.db = r, this._ended = !1, this._nexting = !1
      }
      vf.prototype.next = function (r) {
        if (typeof r != "function") throw new Error("next() requires a callback argument");
        return this._ended ? (this._nextTick(r, new Error("cannot call next() after end()")), this) : this._nexting ? (this._nextTick(r, new Error("cannot call next() before previous next() has completed")), this) : (this._nexting = !0, this._next((e, ...t) => {
          this._nexting = !1, r(e, ...t)
        }), this)
      };
      vf.prototype._next = function (r) {
        this._nextTick(r)
      };
      vf.prototype.seek = function (r) {
        if (this._ended) throw new Error("cannot call seek() after end()");
        if (this._nexting) throw new Error("cannot call seek() before next() has completed");
        r = this.db._serializeKey(r), this._seek(r)
      };
      vf.prototype._seek = function (r) { };
      vf.prototype.end = function (r) {
        if (typeof r != "function") throw new Error("end() requires a callback argument");
        if (this._ended) return this._nextTick(r, new Error("end() already called on iterator"));
        this._ended = !0, this._end(r)
      };
      vf.prototype._end = function (r) {
        this._nextTick(r)
      };
      vf.prototype._nextTick = m3();
      ane.exports = vf
    });
    var II = y((tSt, cne) => {
      l();
      "use strict";
      var une = Object.freeze({});

      function ca(r) {
        if (typeof r != "object" || r === null) throw new TypeError("First argument must be an abstract-leveldown compliant store");
        this.db = r, this._operations = [], this._written = !1
      }
      ca.prototype._checkWritten = function () {
        if (this._written) throw new Error("write() already called on this batch")
      };
      ca.prototype.put = function (r, e, t) {
        this._checkWritten();
        let i = this.db._checkKey(r) || this.db._checkValue(e);
        if (i) throw i;
        return r = this.db._serializeKey(r), e = this.db._serializeValue(e), this._put(r, e, t ?? une), this
      };
      ca.prototype._put = function (r, e, t) {
        this._operations.push({
          ...t,
          type: "put",
          key: r,
          value: e
        })
      };
      ca.prototype.del = function (r, e) {
        this._checkWritten();
        let t = this.db._checkKey(r);
        if (t) throw t;
        return r = this.db._serializeKey(r), this._del(r, e ?? une), this
      };
      ca.prototype._del = function (r, e) {
        this._operations.push({
          ...e,
          type: "del",
          key: r
        })
      };
      ca.prototype.clear = function () {
        return this._checkWritten(), this._clear(), this
      };
      ca.prototype._clear = function () {
        this._operations = []
      };
      ca.prototype.write = function (r, e) {
        if (this._checkWritten(), typeof r == "function" && (e = r), typeof e != "function") throw new Error("write() requires a callback argument");
        (typeof r != "object" || r === null) && (r = {}), this._written = !0, this._write(r, e)
      };
      ca.prototype._write = function (r, e) {
        this.db._batch(this._operations, r, e)
      };
      ca.prototype._nextTick = m3();
      cne.exports = ca
    });
    var hne = y((rSt, fne) => {
      l();
      "use strict";
      var eWe = xI(),
        tWe = rne(),
        rWe = AI(),
        iWe = II(),
        nWe = Object.prototype.hasOwnProperty,
        sWe = ["lt", "lte", "gt", "gte"];

      function Kr(r) {
        this.status = "new", this.supports = eWe(r, {
          status: !0
        })
      }
      Kr.prototype.open = function (r, e) {
        let t = this.status;
        if (typeof r == "function" && (e = r), typeof e != "function") throw new Error("open() requires a callback argument");
        (typeof r != "object" || r === null) && (r = {}), r.createIfMissing = r.createIfMissing !== !1, r.errorIfExists = !!r.errorIfExists, this.status = "opening", this._open(r, i => {
          if (i) return this.status = t, e(i);
          this.status = "open", e()
        })
      };
      Kr.prototype._open = function (r, e) {
        this._nextTick(e)
      };
      Kr.prototype.close = function (r) {
        let e = this.status;
        if (typeof r != "function") throw new Error("close() requires a callback argument");
        this.status = "closing", this._close(t => {
          if (t) return this.status = e, r(t);
          this.status = "closed", r()
        })
      };
      Kr.prototype._close = function (r) {
        this._nextTick(r)
      };
      Kr.prototype.get = function (r, e, t) {
        if (typeof e == "function" && (t = e), typeof t != "function") throw new Error("get() requires a callback argument");
        let i = this._checkKey(r);
        if (i) return this._nextTick(t, i);
        r = this._serializeKey(r), (typeof e != "object" || e === null) && (e = {}), e.asBuffer = e.asBuffer !== !1, this._get(r, e, t)
      };
      Kr.prototype._get = function (r, e, t) {
        this._nextTick(function () {
          t(new Error("NotFound"))
        })
      };
      Kr.prototype.put = function (r, e, t, i) {
        if (typeof t == "function" && (i = t), typeof i != "function") throw new Error("put() requires a callback argument");
        let n = this._checkKey(r) || this._checkValue(e);
        if (n) return this._nextTick(i, n);
        r = this._serializeKey(r), e = this._serializeValue(e), (typeof t != "object" || t === null) && (t = {}), this._put(r, e, t, i)
      };
      Kr.prototype._put = function (r, e, t, i) {
        this._nextTick(i)
      };
      Kr.prototype.del = function (r, e, t) {
        if (typeof e == "function" && (t = e), typeof t != "function") throw new Error("del() requires a callback argument");
        let i = this._checkKey(r);
        if (i) return this._nextTick(t, i);
        r = this._serializeKey(r), (typeof e != "object" || e === null) && (e = {}), this._del(r, e, t)
      };
      Kr.prototype._del = function (r, e, t) {
        this._nextTick(t)
      };
      Kr.prototype.batch = function (r, e, t) {
        if (!arguments.length) return this._chainedBatch();
        if (typeof e == "function" && (t = e), typeof r == "function" && (t = r), typeof t != "function") throw new Error("batch(array) requires a callback argument");
        if (!Array.isArray(r)) return this._nextTick(t, new Error("batch(array) requires an array argument"));
        if (r.length === 0) return this._nextTick(t);
        (typeof e != "object" || e === null) && (e = {});
        let i = new Array(r.length);
        for (let n = 0; n < r.length; n++) {
          if (typeof r[n] != "object" || r[n] === null) return this._nextTick(t, new Error("batch(array) element must be an object and not `null`"));
          let s = Object.assign({}, r[n]);
          if (s.type !== "put" && s.type !== "del") return this._nextTick(t, new Error("`type` must be 'put' or 'del'"));
          let o = this._checkKey(s.key);
          if (o) return this._nextTick(t, o);
          if (s.key = this._serializeKey(s.key), s.type === "put") {
            let a = this._checkValue(s.value);
            if (a) return this._nextTick(t, a);
            s.value = this._serializeValue(s.value)
          }
          i[n] = s
        }
        this._batch(i, e, t)
      };
      Kr.prototype._batch = function (r, e, t) {
        this._nextTick(t)
      };
      Kr.prototype.clear = function (r, e) {
        if (typeof r == "function") e = r;
        else if (typeof e != "function") throw new Error("clear() requires a callback argument");
        r = lne(this, r), r.reverse = !!r.reverse, r.limit = "limit" in r ? r.limit : -1, this._clear(r, e)
      };
      Kr.prototype._clear = function (r, e) {
        r.keys = !0, r.values = !1, r.keyAsBuffer = !0, r.valueAsBuffer = !0;
        let t = this._iterator(r),
          i = {},
          n = s => {
            if (s) return t.end(function () {
              e(s)
            });
            t.next((o, a) => {
              if (o) return n(o);
              if (a === void 0) return t.end(e);
              this._del(a, i, n)
            })
          };
        n()
      };
      Kr.prototype._setupIteratorOptions = function (r) {
        return r = lne(this, r), r.reverse = !!r.reverse, r.keys = r.keys !== !1, r.values = r.values !== !1, r.limit = "limit" in r ? r.limit : -1, r.keyAsBuffer = r.keyAsBuffer !== !1, r.valueAsBuffer = r.valueAsBuffer !== !1, r
      };

      function lne(r, e) {
        let t = {};
        for (let i in e) {
          if (!nWe.call(e, i)) continue;
          if (i === "start" || i === "end") throw new Error('Legacy range options ("start" and "end") have been removed');
          let n = e[i];
          oWe(i) && (n = r._serializeKey(n)), t[i] = n
        }
        return t
      }

      function oWe(r) {
        return sWe.indexOf(r) !== -1
      }
      Kr.prototype.iterator = function (r) {
        return (typeof r != "object" || r === null) && (r = {}), r = this._setupIteratorOptions(r), this._iterator(r)
      };
      Kr.prototype._iterator = function (r) {
        return new rWe(this)
      };
      Kr.prototype._chainedBatch = function () {
        return new iWe(this)
      };
      Kr.prototype._serializeKey = function (r) {
        return r
      };
      Kr.prototype._serializeValue = function (r) {
        return r
      };
      Kr.prototype._checkKey = function (r) {
        if (r == null) return new Error("key cannot be `null` or `undefined`");
        if (tWe(r) && r.length === 0) return new Error("key cannot be an empty Buffer");
        if (r === "") return new Error("key cannot be an empty String");
        if (Array.isArray(r) && r.length === 0) return new Error("key cannot be an empty Array")
      };
      Kr.prototype._checkValue = function (r) {
        if (r == null) return new Error("value cannot be `null` or `undefined`")
      };
      Kr.prototype._nextTick = m3();
      fne.exports = Kr
    });
    var wf = y(v3 => {
      l();
      "use strict";
      v3.AbstractLevelDOWN = hne();
      v3.AbstractIterator = AI();
      v3.AbstractChainedBatch = II()
    });
    var yne = y((nSt, dne) => {
      l();
      "use strict";
      var pne = wf().AbstractIterator,
        aWe = dn();

      function L0(r, e) {
        pne.call(this, r), this._options = e, this._iterator = null, this._operations = []
      }
      aWe(L0, pne);
      L0.prototype.setDb = function (r) {
        let e = this._iterator = r.iterator(this._options);
        for (let t of this._operations) e[t.method](...t.args)
      };
      L0.prototype._operation = function (r, e) {
        if (this._iterator) return this._iterator[r](...e);
        this._operations.push({
          method: r,
          args: e
        })
      };
      for (let r of ["next", "end"]) L0.prototype["_" + r] = function (...e) {
        this._operation(r, e)
      };
      L0.prototype.seek = function (...r) {
        this._operation("seek", r)
      };
      dne.exports = L0
    });
    var wne = y((sSt, TI) => {
      l();
      "use strict";
      var gne = wf().AbstractLevelDOWN,
        cWe = dn(),
        bne = yne(),
        mne = "put get del batch clear".split(" "),
        uWe = "approximateSize compactRange".split(" ");

      function Jl(r) {
        gne.call(this, r.supports || {});
        for (let e of uWe) typeof r[e] == "function" && !this.supports.additionalMethods[e] && (this.supports.additionalMethods[e] = !0);
        this._db = r, this._operations = [], vne(this)
      }
      cWe(Jl, gne);
      Jl.prototype.type = "deferred-leveldown";
      Jl.prototype._open = function (r, e) {
        this._db.open(r, t => {
          if (t) return e(t);
          for (let i of this._operations) i.iterator ? i.iterator.setDb(this._db) : this._db[i.method](...i.args);
          this._operations = [], fWe(this), e()
        })
      };
      Jl.prototype._close = function (r) {
        this._db.close(e => {
          if (e) return r(e);
          vne(this), r()
        })
      };

      function fWe(r) {
        for (let e of mne.concat("iterator")) r["_" + e] = function (...t) {
          return this._db[e](...t)
        };
        for (let e of Object.keys(r.supports.additionalMethods)) r[e] = function (...t) {
          return this._db[e](...t)
        }
      }

      function vne(r) {
        for (let e of mne) r["_" + e] = function (...t) {
          this._operations.push({
            method: e,
            args: t
          })
        };
        for (let e of Object.keys(r.supports.additionalMethods)) r[e] = function (...t) {
          this._operations.push({
            method: e,
            args: t
          })
        };
        r._iterator = function (e) {
          let t = new bne(r, e);
          return this._operations.push({
            iterator: t
          }), t
        }
      }
      Jl.prototype._serializeKey = function (r) {
        return r
      };
      Jl.prototype._serializeValue = function (r) {
        return r
      };
      TI.exports = Jl;
      TI.exports.DeferredIterator = bne
    });
    var RI = y((oSt, _ne) => {
      l();
      _ne.exports = Br().EventEmitter
    });
    var kI = y(() => {
      l()
    });
    var Ane = y((uSt, Ene) => {
      l();
      "use strict";

      function Sne(r, e) {
        var t = Object.keys(r);
        if (Object.getOwnPropertySymbols) {
          var i = Object.getOwnPropertySymbols(r);
          e && (i = i.filter(function (n) {
            return Object.getOwnPropertyDescriptor(r, n).enumerable
          })), t.push.apply(t, i)
        }
        return t
      }

      function hWe(r) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e] != null ? arguments[e] : {};
          e % 2 ? Sne(Object(t), !0).forEach(function (i) {
            lWe(r, i, t[i])
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : Sne(Object(t)).forEach(function (i) {
            Object.defineProperty(r, i, Object.getOwnPropertyDescriptor(t, i))
          })
        }
        return r
      }

      function lWe(r, e, t) {
        return e in r ? Object.defineProperty(r, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : r[e] = t, r
      }

      function dWe(r, e) {
        if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function")
      }

      function xne(r, e) {
        for (var t = 0; t < e.length; t++) {
          var i = e[t];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, i.key, i)
        }
      }

      function pWe(r, e, t) {
        return e && xne(r.prototype, e), t && xne(r, t), r
      }
      var yWe = Wt(),
        w3 = yWe.Buffer,
        gWe = kI(),
        PI = gWe.inspect,
        bWe = PI && PI.custom || "inspect";

      function mWe(r, e, t) {
        w3.prototype.copy.call(r, e, t)
      }
      Ene.exports = function () {
        function r() {
          dWe(this, r), this.head = null, this.tail = null, this.length = 0
        }
        return pWe(r, [{
          key: "push",
          value: function (t) {
            var i = {
              data: t,
              next: null
            };
            this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length
          }
        }, {
          key: "unshift",
          value: function (t) {
            var i = {
              data: t,
              next: this.head
            };
            this.length === 0 && (this.tail = i), this.head = i, ++this.length
          }
        }, {
          key: "shift",
          value: function () {
            if (this.length !== 0) {
              var t = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t
            }
          }
        }, {
          key: "clear",
          value: function () {
            this.head = this.tail = null, this.length = 0
          }
        }, {
          key: "join",
          value: function (t) {
            if (this.length === 0) return "";
            for (var i = this.head, n = "" + i.data; i = i.next;) n += t + i.data;
            return n
          }
        }, {
          key: "concat",
          value: function (t) {
            if (this.length === 0) return w3.alloc(0);
            for (var i = w3.allocUnsafe(t >>> 0), n = this.head, s = 0; n;) mWe(n.data, i, s), s += n.data.length, n = n.next;
            return i
          }
        }, {
          key: "consume",
          value: function (t, i) {
            var n;
            return t < this.head.data.length ? (n = this.head.data.slice(0, t), this.head.data = this.head.data.slice(t)) : t === this.head.data.length ? n = this.shift() : n = i ? this._getString(t) : this._getBuffer(t), n
          }
        }, {
          key: "first",
          value: function () {
            return this.head.data
          }
        }, {
          key: "_getString",
          value: function (t) {
            var i = this.head,
              n = 1,
              s = i.data;
            for (t -= s.length; i = i.next;) {
              var o = i.data,
                a = t > o.length ? o.length : t;
              if (a === o.length ? s += o : s += o.slice(0, t), t -= a, t === 0) {
                a === o.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = o.slice(a));
                break
              } ++n
            }
            return this.length -= n, s
          }
        }, {
          key: "_getBuffer",
          value: function (t) {
            var i = w3.allocUnsafe(t),
              n = this.head,
              s = 1;
            for (n.data.copy(i), t -= n.data.length; n = n.next;) {
              var o = n.data,
                a = t > o.length ? o.length : t;
              if (o.copy(i, i.length - t, 0, a), t -= a, t === 0) {
                a === o.length ? (++s, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = o.slice(a));
                break
              } ++s
            }
            return this.length -= s, i
          }
        }, {
          key: bWe,
          value: function (t, i) {
            return PI(this, hWe({}, i, {
              depth: 0,
              customInspect: !1
            }))
          }
        }]), r
      }()
    });
    var OI = y((fSt, Ine) => {
      l();
      "use strict";

      function vWe(r, e) {
        var t = this,
          i = this._readableState && this._readableState.destroyed,
          n = this._writableState && this._writableState.destroyed;
        return i || n ? (e ? e(r) : r && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(CI, this, r)) : process.nextTick(CI, this, r)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(r || null, function (s) {
          !e && s ? t._writableState ? t._writableState.errorEmitted ? process.nextTick(_3, t) : (t._writableState.errorEmitted = !0, process.nextTick(Tne, t, s)) : process.nextTick(Tne, t, s) : e ? (process.nextTick(_3, t), e(s)) : process.nextTick(_3, t)
        }), this)
      }

      function Tne(r, e) {
        CI(r, e), _3(r)
      }

      function _3(r) {
        r._writableState && !r._writableState.emitClose || r._readableState && !r._readableState.emitClose || r.emit("close")
      }

      function wWe() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
      }

      function CI(r, e) {
        r.emit("error", e)
      }

      function _We(r, e) {
        var t = r._readableState,
          i = r._writableState;
        t && t.autoDestroy || i && i.autoDestroy ? r.destroy(e) : r.emit("error", e)
      }
      Ine.exports = {
        destroy: vWe,
        undestroy: wWe,
        errorOrDestroy: _We
      }
    });
    var Xl = y((lSt, Rne) => {
      l();
      "use strict";

      function EWe(r, e) {
        r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.__proto__ = e
      }
      var kne = {};

      function mo(r, e, t) {
        t || (t = Error);

        function i(s, o, a) {
          return typeof e == "string" ? e : e(s, o, a)
        }
        var n = function (s) {
          EWe(o, s);

          function o(a, c, u) {
            return s.call(this, i(a, c, u)) || this
          }
          return o
        }(t);
        n.prototype.name = t.name, n.prototype.code = r, kne[r] = n
      }

      function Pne(r, e) {
        if (Array.isArray(r)) {
          var t = r.length;
          return r = r.map(function (i) {
            return String(i)
          }), t > 2 ? "one of ".concat(e, " ").concat(r.slice(0, t - 1).join(", "), ", or ") + r[t - 1] : t === 2 ? "one of ".concat(e, " ").concat(r[0], " or ").concat(r[1]) : "of ".concat(e, " ").concat(r[0])
        } else return "of ".concat(e, " ").concat(String(r))
      }

      function SWe(r, e, t) {
        return r.substr(!t || t < 0 ? 0 : +t, e.length) === e
      }

      function xWe(r, e, t) {
        return (t === void 0 || t > r.length) && (t = r.length), r.substring(t - e.length, t) === e
      }

      function AWe(r, e, t) {
        return typeof t != "number" && (t = 0), t + e.length > r.length ? !1 : r.indexOf(e, t) !== -1
      }
      mo("ERR_INVALID_OPT_VALUE", function (r, e) {
        return 'The value "' + e + '" is invalid for option "' + r + '"'
      }, TypeError);
      mo("ERR_INVALID_ARG_TYPE", function (r, e, t) {
        var i;
        typeof e == "string" && SWe(e, "not ") ? (i = "must not be", e = e.replace(/^not /, "")) : i = "must be";
        var n;
        if (xWe(r, " argument")) n = "The ".concat(r, " ").concat(i, " ").concat(Pne(e, "type"));
        else {
          var s = AWe(r, ".") ? "property" : "argument";
          n = 'The "'.concat(r, '" ').concat(s, " ").concat(i, " ").concat(Pne(e, "type"))
        }
        return n += ". Received type ".concat(typeof t), n
      }, TypeError);
      mo("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      mo("ERR_METHOD_NOT_IMPLEMENTED", function (r) {
        return "The " + r + " method is not implemented"
      });
      mo("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      mo("ERR_STREAM_DESTROYED", function (r) {
        return "Cannot call " + r + " after a stream was destroyed"
      });
      mo("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      mo("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      mo("ERR_STREAM_WRITE_AFTER_END", "write after end");
      mo("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      mo("ERR_UNKNOWN_ENCODING", function (r) {
        return "Unknown encoding: " + r
      }, TypeError);
      mo("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      Rne.exports.codes = kne
    });
    var NI = y((hSt, Cne) => {
      l();
      "use strict";
      var IWe = Xl().codes.ERR_INVALID_OPT_VALUE;

      function TWe(r, e, t) {
        return r.highWaterMark != null ? r.highWaterMark : e ? r[t] : null
      }

      function RWe(r, e, t, i) {
        var n = TWe(e, i, t);
        if (n != null) {
          if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
            var s = i ? t : "highWaterMark";
            throw new IWe(s, n)
          }
          return Math.floor(n)
        }
        return r.objectMode ? 16 : 16 * 1024
      }
      Cne.exports = {
        getHighWaterMark: RWe
      }
    });
    var Nne = y((dSt, One) => {
      l();
      One.exports = kWe;

      function kWe(r, e) {
        if (qI("noDeprecation")) return r;
        var t = !1;

        function i() {
          if (!t) {
            if (qI("throwDeprecation")) throw new Error(e);
            qI("traceDeprecation") ? console.trace(e) : console.warn(e), t = !0
          }
          return r.apply(this, arguments)
        }
        return i
      }

      function qI(r) {
        try {
          if (!globalThis.localStorage) return !1
        } catch (t) {
          return !1
        }
        var e = globalThis.localStorage[r];
        return e == null ? !1 : String(e).toLowerCase() === "true"
      }
    });
    var DI = y((pSt, qne) => {
      l();
      "use strict";
      qne.exports = ti;

      function Mne(r) {
        var e = this;
        this.next = null, this.entry = null, this.finish = function () {
          PWe(e, r)
        }
      }
      var F0;
      ti.WritableState = xg;
      var CWe = {
        deprecate: Nne()
      },
        Bne = RI(),
        E3 = Wt().Buffer,
        OWe = globalThis.Uint8Array || function () { };

      function NWe(r) {
        return E3.from(r)
      }

      function qWe(r) {
        return E3.isBuffer(r) || r instanceof OWe
      }
      var MI = OI(),
        MWe = NI(),
        BWe = MWe.getHighWaterMark,
        _f = Xl().codes,
        DWe = _f.ERR_INVALID_ARG_TYPE,
        LWe = _f.ERR_METHOD_NOT_IMPLEMENTED,
        FWe = _f.ERR_MULTIPLE_CALLBACK,
        UWe = _f.ERR_STREAM_CANNOT_PIPE,
        KWe = _f.ERR_STREAM_DESTROYED,
        zWe = _f.ERR_STREAM_NULL_VALUES,
        jWe = _f.ERR_STREAM_WRITE_AFTER_END,
        VWe = _f.ERR_UNKNOWN_ENCODING,
        U0 = MI.errorOrDestroy;
      dn()(ti, Bne);

      function HWe() { }

      function xg(r, e, t) {
        F0 = F0 || Zl(), r = r || {}, typeof t != "boolean" && (t = e instanceof F0), this.objectMode = !!r.objectMode, t && (this.objectMode = this.objectMode || !!r.writableObjectMode), this.highWaterMark = BWe(this, r, "writableHighWaterMark", t), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var i = r.decodeStrings === !1;
        this.decodeStrings = !i, this.defaultEncoding = r.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (n) {
          GWe(e, n)
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = r.emitClose !== !1, this.autoDestroy = !!r.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Mne(this)
      }
      xg.prototype.getBuffer = function () {
        for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
        return t
      };
      (function () {
        try {
          Object.defineProperty(xg.prototype, "buffer", {
            get: CWe.deprecate(function () {
              return this.getBuffer()
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          })
        } catch (r) { }
      })();
      var S3;
      typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (S3 = Function.prototype[Symbol.hasInstance], Object.defineProperty(ti, Symbol.hasInstance, {
        value: function (e) {
          return S3.call(this, e) ? !0 : this !== ti ? !1 : e && e._writableState instanceof xg
        }
      })) : S3 = function (e) {
        return e instanceof this
      };

      function ti(r) {
        F0 = F0 || Zl();
        var e = this instanceof F0;
        if (!e && !S3.call(ti, this)) return new ti(r);
        this._writableState = new xg(r, this, e), this.writable = !0, r && (typeof r.write == "function" && (this._write = r.write), typeof r.writev == "function" && (this._writev = r.writev), typeof r.destroy == "function" && (this._destroy = r.destroy), typeof r.final == "function" && (this._final = r.final)), Bne.call(this)
      }
      ti.prototype.pipe = function () {
        U0(this, new UWe)
      };

      function $We(r, e) {
        var t = new jWe;
        U0(r, t), process.nextTick(e, t)
      }

      function WWe(r, e, t, i) {
        var n;
        return t === null ? n = new zWe : typeof t != "string" && !e.objectMode && (n = new DWe("chunk", ["string", "Buffer"], t)), n ? (U0(r, n), process.nextTick(i, n), !1) : !0
      }
      ti.prototype.write = function (r, e, t) {
        var i = this._writableState,
          n = !1,
          s = !i.objectMode && qWe(r);
        return s && !E3.isBuffer(r) && (r = NWe(r)), typeof e == "function" && (t = e, e = null), s ? e = "buffer" : e || (e = i.defaultEncoding), typeof t != "function" && (t = HWe), i.ending ? $We(this, t) : (s || WWe(this, i, r, t)) && (i.pendingcb++, n = YWe(this, i, s, r, e, t)), n
      };
      ti.prototype.cork = function () {
        this._writableState.corked++
      };
      ti.prototype.uncork = function () {
        var r = this._writableState;
        r.corked && (r.corked--, !r.writing && !r.corked && !r.bufferProcessing && r.bufferedRequest && Dne(this, r))
      };
      ti.prototype.setDefaultEncoding = function (e) {
        if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new VWe(e);
        return this._writableState.defaultEncoding = e, this
      };
      Object.defineProperty(ti.prototype, "writableBuffer", {
        enumerable: !1,
        get: function () {
          return this._writableState && this._writableState.getBuffer()
        }
      });

      function JWe(r, e, t) {
        return !r.objectMode && r.decodeStrings !== !1 && typeof e == "string" && (e = E3.from(e, t)), e
      }
      Object.defineProperty(ti.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function () {
          return this._writableState.highWaterMark
        }
      });

      function YWe(r, e, t, i, n, s) {
        if (!t) {
          var o = JWe(e, i, n);
          i !== o && (t = !0, n = "buffer", i = o)
        }
        var a = e.objectMode ? 1 : i.length;
        e.length += a;
        var c = e.length < e.highWaterMark;
        if (c || (e.needDrain = !0), e.writing || e.corked) {
          var u = e.lastBufferedRequest;
          e.lastBufferedRequest = {
            chunk: i,
            encoding: n,
            isBuf: t,
            callback: s,
            next: null
          }, u ? u.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1
        } else BI(r, e, !1, a, i, n, s);
        return c
      }

      function BI(r, e, t, i, n, s, o) {
        e.writelen = i, e.writecb = o, e.writing = !0, e.sync = !0, e.destroyed ? e.onwrite(new KWe("write")) : t ? r._writev(n, e.onwrite) : r._write(n, s, e.onwrite), e.sync = !1
      }

      function XWe(r, e, t, i, n) {
        --e.pendingcb, t ? (process.nextTick(n, i), process.nextTick(Ag, r, e), r._writableState.errorEmitted = !0, U0(r, i)) : (n(i), r._writableState.errorEmitted = !0, U0(r, i), Ag(r, e))
      }

      function ZWe(r) {
        r.writing = !1, r.writecb = null, r.length -= r.writelen, r.writelen = 0
      }

      function GWe(r, e) {
        var t = r._writableState,
          i = t.sync,
          n = t.writecb;
        if (typeof n != "function") throw new FWe;
        if (ZWe(t), e) XWe(r, t, i, e, n);
        else {
          var s = Fne(t) || r.destroyed;
          !s && !t.corked && !t.bufferProcessing && t.bufferedRequest && Dne(r, t), i ? process.nextTick(Lne, r, t, s, n) : Lne(r, t, s, n)
        }
      }

      function Lne(r, e, t, i) {
        t || QWe(r, e), e.pendingcb--, i(), Ag(r, e)
      }

      function QWe(r, e) {
        e.length === 0 && e.needDrain && (e.needDrain = !1, r.emit("drain"))
      }

      function Dne(r, e) {
        e.bufferProcessing = !0;
        var t = e.bufferedRequest;
        if (r._writev && t && t.next) {
          var i = e.bufferedRequestCount,
            n = new Array(i),
            s = e.corkedRequestsFree;
          s.entry = t;
          for (var o = 0, a = !0; t;) n[o] = t, t.isBuf || (a = !1), t = t.next, o += 1;
          n.allBuffers = a, BI(r, e, !0, e.length, n, "", s.finish), e.pendingcb++, e.lastBufferedRequest = null, s.next ? (e.corkedRequestsFree = s.next, s.next = null) : e.corkedRequestsFree = new Mne(e), e.bufferedRequestCount = 0
        } else {
          for (; t;) {
            var c = t.chunk,
              u = t.encoding,
              f = t.callback,
              h = e.objectMode ? 1 : c.length;
            if (BI(r, e, !1, h, c, u, f), t = t.next, e.bufferedRequestCount--, e.writing) break
          }
          t === null && (e.lastBufferedRequest = null)
        }
        e.bufferedRequest = t, e.bufferProcessing = !1
      }
      ti.prototype._write = function (r, e, t) {
        t(new LWe("_write()"))
      };
      ti.prototype._writev = null;
      ti.prototype.end = function (r, e, t) {
        var i = this._writableState;
        return typeof r == "function" ? (t = r, r = null, e = null) : typeof e == "function" && (t = e, e = null), r != null && this.write(r, e), i.corked && (i.corked = 1, this.uncork()), i.ending || eYe(this, i, t), this
      };
      Object.defineProperty(ti.prototype, "writableLength", {
        enumerable: !1,
        get: function () {
          return this._writableState.length
        }
      });

      function Fne(r) {
        return r.ending && r.length === 0 && r.bufferedRequest === null && !r.finished && !r.writing
      }

      function tYe(r, e) {
        r._final(function (t) {
          e.pendingcb--, t && U0(r, t), e.prefinished = !0, r.emit("prefinish"), Ag(r, e)
        })
      }

      function rYe(r, e) {
        !e.prefinished && !e.finalCalled && (typeof r._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = !0, process.nextTick(tYe, r, e)) : (e.prefinished = !0, r.emit("prefinish")))
      }

      function Ag(r, e) {
        var t = Fne(e);
        if (t && (rYe(r, e), e.pendingcb === 0 && (e.finished = !0, r.emit("finish"), e.autoDestroy))) {
          var i = r._readableState;
          (!i || i.autoDestroy && i.endEmitted) && r.destroy()
        }
        return t
      }

      function eYe(r, e, t) {
        e.ending = !0, Ag(r, e), t && (e.finished ? process.nextTick(t) : r.once("finish", t)), e.ended = !0, r.writable = !1
      }

      function PWe(r, e, t) {
        var i = r.entry;
        for (r.entry = null; i;) {
          var n = i.callback;
          e.pendingcb--, n(t), i = i.next
        }
        e.corkedRequestsFree.next = r
      }
      Object.defineProperty(ti.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
          return this._writableState === void 0 ? !1 : this._writableState.destroyed
        },
        set: function (e) {
          !this._writableState || (this._writableState.destroyed = e)
        }
      });
      ti.prototype.destroy = MI.destroy;
      ti.prototype._undestroy = MI.undestroy;
      ti.prototype._destroy = function (r, e) {
        e(r)
      }
    });
    var Zl = y((ySt, Une) => {
      l();
      "use strict";
      var iYe = Object.keys || function (r) {
        var e = [];
        for (var t in r) e.push(t);
        return e
      };
      Une.exports = uc;
      var Kne = LI(),
        FI = DI();
      dn()(uc, Kne);
      for (UI = iYe(FI.prototype), x3 = 0; x3 < UI.length; x3++) A3 = UI[x3], uc.prototype[A3] || (uc.prototype[A3] = FI.prototype[A3]);
      var UI, A3, x3;

      function uc(r) {
        if (!(this instanceof uc)) return new uc(r);
        Kne.call(this, r), FI.call(this, r), this.allowHalfOpen = !0, r && (r.readable === !1 && (this.readable = !1), r.writable === !1 && (this.writable = !1), r.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", nYe)))
      }
      Object.defineProperty(uc.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function () {
          return this._writableState.highWaterMark
        }
      });
      Object.defineProperty(uc.prototype, "writableBuffer", {
        enumerable: !1,
        get: function () {
          return this._writableState && this._writableState.getBuffer()
        }
      });
      Object.defineProperty(uc.prototype, "writableLength", {
        enumerable: !1,
        get: function () {
          return this._writableState.length
        }
      });

      function nYe() {
        this._writableState.ended || process.nextTick(sYe, this)
      }

      function sYe(r) {
        r.end()
      }
      Object.defineProperty(uc.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
          return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
        },
        set: function (e) {
          this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed = e)
        }
      })
    });
    var Vne = y((KI, zne) => {
      l();
      var I3 = Wt(),
        iu = I3.Buffer;

      function jne(r, e) {
        for (var t in r) e[t] = r[t]
      }
      iu.from && iu.alloc && iu.allocUnsafe && iu.allocUnsafeSlow ? zne.exports = I3 : (jne(I3, KI), KI.Buffer = K0);

      function K0(r, e, t) {
        return iu(r, e, t)
      }
      jne(iu, K0);
      K0.from = function (r, e, t) {
        if (typeof r == "number") throw new TypeError("Argument must not be a number");
        return iu(r, e, t)
      };
      K0.alloc = function (r, e, t) {
        if (typeof r != "number") throw new TypeError("Argument must be a number");
        var i = iu(r);
        return e !== void 0 ? typeof t == "string" ? i.fill(e, t) : i.fill(e) : i.fill(0), i
      };
      K0.allocUnsafe = function (r) {
        if (typeof r != "number") throw new TypeError("Argument must be a number");
        return iu(r)
      };
      K0.allocUnsafeSlow = function (r) {
        if (typeof r != "number") throw new TypeError("Argument must be a number");
        return I3.SlowBuffer(r)
      }
    });
    var VI = y(Hne => {
      l();
      "use strict";
      var zI = Vne().Buffer,
        Gne = zI.isEncoding || function (r) {
          switch (r = "" + r, r && r.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return !0;
            default:
              return !1
          }
        };

      function oYe(r) {
        if (!r) return "utf8";
        for (var e; ;) switch (r) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return r;
          default:
            if (e) return;
            r = ("" + r).toLowerCase(), e = !0
        }
      }

      function aYe(r) {
        var e = oYe(r);
        if (typeof e != "string" && (zI.isEncoding === Gne || !Gne(r))) throw new Error("Unknown encoding: " + r);
        return e || r
      }
      Hne.StringDecoder = Ig;

      function Ig(r) {
        this.encoding = aYe(r);
        var e;
        switch (this.encoding) {
          case "utf16le":
            this.text = uYe, this.end = fYe, e = 4;
            break;
          case "utf8":
            this.fillLast = cYe, e = 4;
            break;
          case "base64":
            this.text = lYe, this.end = hYe, e = 3;
            break;
          default:
            this.write = dYe, this.end = pYe;
            return
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = zI.allocUnsafe(e)
      }
      Ig.prototype.write = function (r) {
        if (r.length === 0) return "";
        var e, t;
        if (this.lastNeed) {
          if (e = this.fillLast(r), e === void 0) return "";
          t = this.lastNeed, this.lastNeed = 0
        } else t = 0;
        return t < r.length ? e ? e + this.text(r, t) : this.text(r, t) : e || ""
      };
      Ig.prototype.end = yYe;
      Ig.prototype.text = gYe;
      Ig.prototype.fillLast = function (r) {
        if (this.lastNeed <= r.length) return r.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        r.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, r.length), this.lastNeed -= r.length
      };

      function jI(r) {
        return r <= 127 ? 0 : r >> 5 == 6 ? 2 : r >> 4 == 14 ? 3 : r >> 3 == 30 ? 4 : r >> 6 == 2 ? -1 : -2
      }

      function bYe(r, e, t) {
        var i = e.length - 1;
        if (i < t) return 0;
        var n = jI(e[i]);
        return n >= 0 ? (n > 0 && (r.lastNeed = n - 1), n) : --i < t || n === -2 ? 0 : (n = jI(e[i]), n >= 0 ? (n > 0 && (r.lastNeed = n - 2), n) : --i < t || n === -2 ? 0 : (n = jI(e[i]), n >= 0 ? (n > 0 && (n === 2 ? n = 0 : r.lastNeed = n - 3), n) : 0))
      }

      function mYe(r, e, t) {
        if ((e[0] & 192) != 128) return r.lastNeed = 0, "\uFFFD";
        if (r.lastNeed > 1 && e.length > 1) {
          if ((e[1] & 192) != 128) return r.lastNeed = 1, "\uFFFD";
          if (r.lastNeed > 2 && e.length > 2 && (e[2] & 192) != 128) return r.lastNeed = 2, "\uFFFD"
        }
      }

      function cYe(r) {
        var e = this.lastTotal - this.lastNeed,
          t = mYe(this, r, e);
        if (t !== void 0) return t;
        if (this.lastNeed <= r.length) return r.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        r.copy(this.lastChar, e, 0, r.length), this.lastNeed -= r.length
      }

      function gYe(r, e) {
        var t = bYe(this, r, e);
        if (!this.lastNeed) return r.toString("utf8", e);
        this.lastTotal = t;
        var i = r.length - (t - this.lastNeed);
        return r.copy(this.lastChar, 0, i), r.toString("utf8", e, i)
      }

      function yYe(r) {
        var e = r && r.length ? this.write(r) : "";
        return this.lastNeed ? e + "\uFFFD" : e
      }

      function uYe(r, e) {
        if ((r.length - e) % 2 == 0) {
          var t = r.toString("utf16le", e);
          if (t) {
            var i = t.charCodeAt(t.length - 1);
            if (i >= 55296 && i <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = r[r.length - 2], this.lastChar[1] = r[r.length - 1], t.slice(0, -1)
          }
          return t
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = r[r.length - 1], r.toString("utf16le", e, r.length - 1)
      }

      function fYe(r) {
        var e = r && r.length ? this.write(r) : "";
        if (this.lastNeed) {
          var t = this.lastTotal - this.lastNeed;
          return e + this.lastChar.toString("utf16le", 0, t)
        }
        return e
      }

      function lYe(r, e) {
        var t = (r.length - e) % 3;
        return t === 0 ? r.toString("base64", e) : (this.lastNeed = 3 - t, this.lastTotal = 3, t === 1 ? this.lastChar[0] = r[r.length - 1] : (this.lastChar[0] = r[r.length - 2], this.lastChar[1] = r[r.length - 1]), r.toString("base64", e, r.length - t))
      }

      function hYe(r) {
        var e = r && r.length ? this.write(r) : "";
        return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e
      }

      function dYe(r) {
        return r.toString(this.encoding)
      }

      function pYe(r) {
        return r && r.length ? this.write(r) : ""
      }
    });
    var T3 = y((bSt, $ne) => {
      l();
      "use strict";
      var Wne = Xl().codes.ERR_STREAM_PREMATURE_CLOSE;

      function vYe(r) {
        var e = !1;
        return function () {
          if (!e) {
            e = !0;
            for (var t = arguments.length, i = new Array(t), n = 0; n < t; n++) i[n] = arguments[n];
            r.apply(this, i)
          }
        }
      }

      function wYe() { }

      function _Ye(r) {
        return r.setHeader && typeof r.abort == "function"
      }

      function Yne(r, e, t) {
        if (typeof e == "function") return Yne(r, null, e);
        e || (e = {}), t = vYe(t || wYe);
        var i = e.readable || e.readable !== !1 && r.readable,
          n = e.writable || e.writable !== !1 && r.writable,
          s = function () {
            r.writable || a()
          },
          o = r._writableState && r._writableState.finished,
          a = function () {
            n = !1, o = !0, i || t.call(r)
          },
          c = r._readableState && r._readableState.endEmitted,
          u = function () {
            i = !1, c = !0, n || t.call(r)
          },
          f = function (g) {
            t.call(r, g)
          },
          h = function () {
            var g;
            if (i && !c) return (!r._readableState || !r._readableState.ended) && (g = new Wne), t.call(r, g);
            if (n && !o) return (!r._writableState || !r._writableState.ended) && (g = new Wne), t.call(r, g)
          },
          d = function () {
            r.req.on("finish", a)
          };
        return _Ye(r) ? (r.on("complete", a), r.on("abort", h), r.req ? d() : r.on("request", d)) : n && !r._writableState && (r.on("end", s), r.on("close", s)), r.on("end", u), r.on("finish", a), e.error !== !1 && r.on("error", f), r.on("close", h),
          function () {
            r.removeListener("complete", a), r.removeListener("abort", h), r.removeListener("request", d), r.req && r.req.removeListener("finish", a), r.removeListener("end", s), r.removeListener("close", s), r.removeListener("finish", a), r.removeListener("end", u), r.removeListener("error", f), r.removeListener("close", h)
          }
      }
      $ne.exports = Yne
    });
    var Xne = y((mSt, Jne) => {
      l();
      "use strict";
      var R3;

      function Ef(r, e, t) {
        return e in r ? Object.defineProperty(r, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : r[e] = t, r
      }
      var EYe = T3(),
        Sf = Symbol("lastResolve"),
        Ql = Symbol("lastReject"),
        Tg = Symbol("error"),
        k3 = Symbol("ended"),
        eh = Symbol("lastPromise"),
        HI = Symbol("handlePromise"),
        th = Symbol("stream");

      function xf(r, e) {
        return {
          value: r,
          done: e
        }
      }

      function SYe(r) {
        var e = r[Sf];
        if (e !== null) {
          var t = r[th].read();
          t !== null && (r[eh] = null, r[Sf] = null, r[Ql] = null, e(xf(t, !1)))
        }
      }

      function xYe(r) {
        process.nextTick(SYe, r)
      }

      function AYe(r, e) {
        return function (t, i) {
          r.then(function () {
            if (e[k3]) {
              t(xf(void 0, !0));
              return
            }
            e[HI](t, i)
          }, i)
        }
      }
      var IYe = Object.getPrototypeOf(function () { }),
        TYe = Object.setPrototypeOf((R3 = {
          get stream() {
            return this[th]
          },
          next: function () {
            var e = this,
              t = this[Tg];
            if (t !== null) return Promise.reject(t);
            if (this[k3]) return Promise.resolve(xf(void 0, !0));
            if (this[th].destroyed) return new Promise(function (o, a) {
              process.nextTick(function () {
                e[Tg] ? a(e[Tg]) : o(xf(void 0, !0))
              })
            });
            var i = this[eh],
              n;
            if (i) n = new Promise(AYe(i, this));
            else {
              var s = this[th].read();
              if (s !== null) return Promise.resolve(xf(s, !1));
              n = new Promise(this[HI])
            }
            return this[eh] = n, n
          }
        }, Ef(R3, Symbol.asyncIterator, function () {
          return this
        }), Ef(R3, "return", function () {
          var e = this;
          return new Promise(function (t, i) {
            e[th].destroy(null, function (n) {
              if (n) {
                i(n);
                return
              }
              t(xf(void 0, !0))
            })
          })
        }), R3), IYe),
        RYe = function (e) {
          var t, i = Object.create(TYe, (t = {}, Ef(t, th, {
            value: e,
            writable: !0
          }), Ef(t, Sf, {
            value: null,
            writable: !0
          }), Ef(t, Ql, {
            value: null,
            writable: !0
          }), Ef(t, Tg, {
            value: null,
            writable: !0
          }), Ef(t, k3, {
            value: e._readableState.endEmitted,
            writable: !0
          }), Ef(t, HI, {
            value: function (s, o) {
              var a = i[th].read();
              a ? (i[eh] = null, i[Sf] = null, i[Ql] = null, s(xf(a, !1))) : (i[Sf] = s, i[Ql] = o)
            },
            writable: !0
          }), t));
          return i[eh] = null, EYe(e, function (n) {
            if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              var s = i[Ql];
              s !== null && (i[eh] = null, i[Sf] = null, i[Ql] = null, s(n)), i[Tg] = n;
              return
            }
            var o = i[Sf];
            o !== null && (i[eh] = null, i[Sf] = null, i[Ql] = null, o(xf(void 0, !0))), i[k3] = !0
          }), e.on("readable", xYe.bind(null, i)), i
        };
      Jne.exports = RYe
    });
    var Qne = y((vSt, Zne) => {
      l();
      Zne.exports = function () {
        throw new Error("Readable.from is not available in the browser")
      }
    });
    var LI = y((_St, ese) => {
      l();
      "use strict";
      ese.exports = Xt;
      var z0;
      Xt.ReadableState = tse;
      var wSt = Br().EventEmitter,
        rse = function (e, t) {
          return e.listeners(t).length
        },
        Rg = RI(),
        P3 = Wt().Buffer,
        kYe = globalThis.Uint8Array || function () { };

      function PYe(r) {
        return P3.from(r)
      }

      function CYe(r) {
        return P3.isBuffer(r) || r instanceof kYe
      }
      var GI = kI(),
        Rt;
      GI && GI.debuglog ? Rt = GI.debuglog("stream") : Rt = function () { };
      var OYe = Ane(),
        $I = OI(),
        NYe = NI(),
        qYe = NYe.getHighWaterMark,
        C3 = Xl().codes,
        MYe = C3.ERR_INVALID_ARG_TYPE,
        BYe = C3.ERR_STREAM_PUSH_AFTER_EOF,
        DYe = C3.ERR_METHOD_NOT_IMPLEMENTED,
        LYe = C3.ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
        j0, WI, YI;
      dn()(Xt, Rg);
      var kg = $I.errorOrDestroy,
        JI = ["error", "close", "destroy", "pause", "resume"];

      function FYe(r, e, t) {
        if (typeof r.prependListener == "function") return r.prependListener(e, t);
        !r._events || !r._events[e] ? r.on(e, t) : Array.isArray(r._events[e]) ? r._events[e].unshift(t) : r._events[e] = [t, r._events[e]]
      }

      function tse(r, e, t) {
        z0 = z0 || Zl(), r = r || {}, typeof t != "boolean" && (t = e instanceof z0), this.objectMode = !!r.objectMode, t && (this.objectMode = this.objectMode || !!r.readableObjectMode), this.highWaterMark = qYe(this, r, "readableHighWaterMark", t), this.buffer = new OYe, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = r.emitClose !== !1, this.autoDestroy = !!r.autoDestroy, this.destroyed = !1, this.defaultEncoding = r.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, r.encoding && (j0 || (j0 = VI().StringDecoder), this.decoder = new j0(r.encoding), this.encoding = r.encoding)
      }

      function Xt(r) {
        if (z0 = z0 || Zl(), !(this instanceof Xt)) return new Xt(r);
        var e = this instanceof z0;
        this._readableState = new tse(r, this, e), this.readable = !0, r && (typeof r.read == "function" && (this._read = r.read), typeof r.destroy == "function" && (this._destroy = r.destroy)), Rg.call(this)
      }
      Object.defineProperty(Xt.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
          return this._readableState === void 0 ? !1 : this._readableState.destroyed
        },
        set: function (e) {
          !this._readableState || (this._readableState.destroyed = e)
        }
      });
      Xt.prototype.destroy = $I.destroy;
      Xt.prototype._undestroy = $I.undestroy;
      Xt.prototype._destroy = function (r, e) {
        e(r)
      };
      Xt.prototype.push = function (r, e) {
        var t = this._readableState,
          i;
        return t.objectMode ? i = !0 : typeof r == "string" && (e = e || t.defaultEncoding, e !== t.encoding && (r = P3.from(r, e), e = ""), i = !0), ise(this, r, e, !1, i)
      };
      Xt.prototype.unshift = function (r) {
        return ise(this, r, null, !0, !1)
      };

      function ise(r, e, t, i, n) {
        Rt("readableAddChunk", e);
        var s = r._readableState;
        if (e === null) s.reading = !1, KYe(r, s);
        else {
          var o;
          if (n || (o = UYe(s, e)), o) kg(r, o);
          else if (s.objectMode || e && e.length > 0)
            if (typeof e != "string" && !s.objectMode && Object.getPrototypeOf(e) !== P3.prototype && (e = PYe(e)), i) s.endEmitted ? kg(r, new LYe) : XI(r, s, e, !0);
            else if (s.ended) kg(r, new BYe);
            else {
              if (s.destroyed) return !1;
              s.reading = !1, s.decoder && !t ? (e = s.decoder.write(e), s.objectMode || e.length !== 0 ? XI(r, s, e, !1) : ZI(r, s)) : XI(r, s, e, !1)
            } else i || (s.reading = !1, ZI(r, s))
        }
        return !s.ended && (s.length < s.highWaterMark || s.length === 0)
      }

      function XI(r, e, t, i) {
        e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, r.emit("data", t)) : (e.length += e.objectMode ? 1 : t.length, i ? e.buffer.unshift(t) : e.buffer.push(t), e.needReadable && O3(r)), ZI(r, e)
      }

      function UYe(r, e) {
        var t;
        return !CYe(e) && typeof e != "string" && e !== void 0 && !r.objectMode && (t = new MYe("chunk", ["string", "Buffer", "Uint8Array"], e)), t
      }
      Xt.prototype.isPaused = function () {
        return this._readableState.flowing === !1
      };
      Xt.prototype.setEncoding = function (r) {
        j0 || (j0 = VI().StringDecoder);
        var e = new j0(r);
        this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
        for (var t = this._readableState.buffer.head, i = ""; t !== null;) i += e.write(t.data), t = t.next;
        return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this
      };
      var nse = 1073741824;

      function zYe(r) {
        return r >= nse ? r = nse : (r--, r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r++), r
      }

      function sse(r, e) {
        return r <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : r !== r ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (r > e.highWaterMark && (e.highWaterMark = zYe(r)), r <= e.length ? r : e.ended ? e.length : (e.needReadable = !0, 0))
      }
      Xt.prototype.read = function (r) {
        Rt("read", r), r = parseInt(r, 10);
        var e = this._readableState,
          t = r;
        if (r !== 0 && (e.emittedReadable = !1), r === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended)) return Rt("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? QI(this) : O3(this), null;
        if (r = sse(r, e), r === 0 && e.ended) return e.length === 0 && QI(this), null;
        var i = e.needReadable;
        Rt("need readable", i), (e.length === 0 || e.length - r < e.highWaterMark) && (i = !0, Rt("length less than watermark", i)), e.ended || e.reading ? (i = !1, Rt("reading or ended", i)) : i && (Rt("do read"), e.reading = !0, e.sync = !0, e.length === 0 && (e.needReadable = !0), this._read(e.highWaterMark), e.sync = !1, e.reading || (r = sse(t, e)));
        var n;
        return r > 0 ? n = ose(r, e) : n = null, n === null ? (e.needReadable = e.length <= e.highWaterMark, r = 0) : (e.length -= r, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = !0), t !== r && e.ended && QI(this)), n !== null && this.emit("data", n), n
      };

      function KYe(r, e) {
        if (Rt("onEofChunk"), !e.ended) {
          if (e.decoder) {
            var t = e.decoder.end();
            t && t.length && (e.buffer.push(t), e.length += e.objectMode ? 1 : t.length)
          }
          e.ended = !0, e.sync ? O3(r) : (e.needReadable = !1, e.emittedReadable || (e.emittedReadable = !0, ase(r)))
        }
      }

      function O3(r) {
        var e = r._readableState;
        Rt("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = !1, e.emittedReadable || (Rt("emitReadable", e.flowing), e.emittedReadable = !0, process.nextTick(ase, r))
      }

      function ase(r) {
        var e = r._readableState;
        Rt("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (r.emit("readable"), e.emittedReadable = !1), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, eT(r)
      }

      function ZI(r, e) {
        e.readingMore || (e.readingMore = !0, process.nextTick(jYe, r, e))
      }

      function jYe(r, e) {
        for (; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0);) {
          var t = e.length;
          if (Rt("maybeReadMore read 0"), r.read(0), t === e.length) break
        }
        e.readingMore = !1
      }
      Xt.prototype._read = function (r) {
        kg(this, new DYe("_read()"))
      };
      Xt.prototype.pipe = function (r, e) {
        var t = this,
          i = this._readableState;
        switch (i.pipesCount) {
          case 0:
            i.pipes = r;
            break;
          case 1:
            i.pipes = [i.pipes, r];
            break;
          default:
            i.pipes.push(r);
            break
        }
        i.pipesCount += 1, Rt("pipe count=%d opts=%j", i.pipesCount, e);
        var n = (!e || e.end !== !1) && r !== process.stdout && r !== process.stderr,
          s = n ? a : m;
        i.endEmitted ? process.nextTick(s) : t.once("end", s), r.on("unpipe", o);

        function o(E, w) {
          Rt("onunpipe"), E === t && w && w.hasUnpiped === !1 && (w.hasUnpiped = !0, f())
        }

        function a() {
          Rt("onend"), r.end()
        }
        var c = VYe(t);
        r.on("drain", c);
        var u = !1;

        function f() {
          Rt("cleanup"), r.removeListener("close", p), r.removeListener("finish", g), r.removeListener("drain", c), r.removeListener("error", d), r.removeListener("unpipe", o), t.removeListener("end", a), t.removeListener("end", m), t.removeListener("data", h), u = !0, i.awaitDrain && (!r._writableState || r._writableState.needDrain) && c()
        }
        t.on("data", h);

        function h(E) {
          Rt("ondata");
          var w = r.write(E);
          Rt("dest.write", w), w === !1 && ((i.pipesCount === 1 && i.pipes === r || i.pipesCount > 1 && cse(i.pipes, r) !== -1) && !u && (Rt("false write response, pause", i.awaitDrain), i.awaitDrain++), t.pause())
        }

        function d(E) {
          Rt("onerror", E), m(), r.removeListener("error", d), rse(r, "error") === 0 && kg(r, E)
        }
        FYe(r, "error", d);

        function p() {
          r.removeListener("finish", g), m()
        }
        r.once("close", p);

        function g() {
          Rt("onfinish"), r.removeListener("close", p), m()
        }
        r.once("finish", g);

        function m() {
          Rt("unpipe"), t.unpipe(r)
        }
        return r.emit("pipe", t), i.flowing || (Rt("pipe resume"), t.resume()), r
      };

      function VYe(r) {
        return function () {
          var t = r._readableState;
          Rt("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, t.awaitDrain === 0 && rse(r, "data") && (t.flowing = !0, eT(r))
        }
      }
      Xt.prototype.unpipe = function (r) {
        var e = this._readableState,
          t = {
            hasUnpiped: !1
          };
        if (e.pipesCount === 0) return this;
        if (e.pipesCount === 1) return r && r !== e.pipes ? this : (r || (r = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = !1, r && r.emit("unpipe", this, t), this);
        if (!r) {
          var i = e.pipes,
            n = e.pipesCount;
          e.pipes = null, e.pipesCount = 0, e.flowing = !1;
          for (var s = 0; s < n; s++) i[s].emit("unpipe", this, {
            hasUnpiped: !1
          });
          return this
        }
        var o = cse(e.pipes, r);
        return o === -1 ? this : (e.pipes.splice(o, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), r.emit("unpipe", this, t), this)
      };
      Xt.prototype.on = function (r, e) {
        var t = Rg.prototype.on.call(this, r, e),
          i = this._readableState;
        return r === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : r === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, Rt("on readable", i.length, i.reading), i.length ? O3(this) : i.reading || process.nextTick(HYe, this)), t
      };
      Xt.prototype.addListener = Xt.prototype.on;
      Xt.prototype.removeListener = function (r, e) {
        var t = Rg.prototype.removeListener.call(this, r, e);
        return r === "readable" && process.nextTick(use, this), t
      };
      Xt.prototype.removeAllListeners = function (r) {
        var e = Rg.prototype.removeAllListeners.apply(this, arguments);
        return (r === "readable" || r === void 0) && process.nextTick(use, this), e
      };

      function use(r) {
        var e = r._readableState;
        e.readableListening = r.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = !0 : r.listenerCount("data") > 0 && r.resume()
      }

      function HYe(r) {
        Rt("readable nexttick read 0"), r.read(0)
      }
      Xt.prototype.resume = function () {
        var r = this._readableState;
        return r.flowing || (Rt("resume"), r.flowing = !r.readableListening, GYe(this, r)), r.paused = !1, this
      };

      function GYe(r, e) {
        e.resumeScheduled || (e.resumeScheduled = !0, process.nextTick($Ye, r, e))
      }

      function $Ye(r, e) {
        Rt("resume", e.reading), e.reading || r.read(0), e.resumeScheduled = !1, r.emit("resume"), eT(r), e.flowing && !e.reading && r.read(0)
      }
      Xt.prototype.pause = function () {
        return Rt("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Rt("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
      };

      function eT(r) {
        var e = r._readableState;
        for (Rt("flow", e.flowing); e.flowing && r.read() !== null;);
      }
      Xt.prototype.wrap = function (r) {
        var e = this,
          t = this._readableState,
          i = !1;
        r.on("end", function () {
          if (Rt("wrapped end"), t.decoder && !t.ended) {
            var o = t.decoder.end();
            o && o.length && e.push(o)
          }
          e.push(null)
        }), r.on("data", function (o) {
          if (Rt("wrapped data"), t.decoder && (o = t.decoder.write(o)), !(t.objectMode && o == null) && !(!t.objectMode && (!o || !o.length))) {
            var a = e.push(o);
            a || (i = !0, r.pause())
          }
        });
        for (var n in r) this[n] === void 0 && typeof r[n] == "function" && (this[n] = function (a) {
          return function () {
            return r[a].apply(r, arguments)
          }
        }(n));
        for (var s = 0; s < JI.length; s++) r.on(JI[s], this.emit.bind(this, JI[s]));
        return this._read = function (o) {
          Rt("wrapped _read", o), i && (i = !1, r.resume())
        }, this
      };
      typeof Symbol == "function" && (Xt.prototype[Symbol.asyncIterator] = function () {
        return WI === void 0 && (WI = Xne()), WI(this)
      });
      Object.defineProperty(Xt.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function () {
          return this._readableState.highWaterMark
        }
      });
      Object.defineProperty(Xt.prototype, "readableBuffer", {
        enumerable: !1,
        get: function () {
          return this._readableState && this._readableState.buffer
        }
      });
      Object.defineProperty(Xt.prototype, "readableFlowing", {
        enumerable: !1,
        get: function () {
          return this._readableState.flowing
        },
        set: function (e) {
          this._readableState && (this._readableState.flowing = e)
        }
      });
      Xt._fromList = ose;
      Object.defineProperty(Xt.prototype, "readableLength", {
        enumerable: !1,
        get: function () {
          return this._readableState.length
        }
      });

      function ose(r, e) {
        if (e.length === 0) return null;
        var t;
        return e.objectMode ? t = e.buffer.shift() : !r || r >= e.length ? (e.decoder ? t = e.buffer.join("") : e.buffer.length === 1 ? t = e.buffer.first() : t = e.buffer.concat(e.length), e.buffer.clear()) : t = e.buffer.consume(r, e.decoder), t
      }

      function QI(r) {
        var e = r._readableState;
        Rt("endReadable", e.endEmitted), e.endEmitted || (e.ended = !0, process.nextTick(WYe, e, r))
      }

      function WYe(r, e) {
        if (Rt("endReadableNT", r.endEmitted, r.length), !r.endEmitted && r.length === 0 && (r.endEmitted = !0, e.readable = !1, e.emit("end"), r.autoDestroy)) {
          var t = e._writableState;
          (!t || t.autoDestroy && t.finished) && e.destroy()
        }
      }
      typeof Symbol == "function" && (Xt.from = function (r, e) {
        return YI === void 0 && (YI = Qne()), YI(Xt, r, e)
      });

      function cse(r, e) {
        for (var t = 0, i = r.length; t < i; t++)
          if (r[t] === e) return t;
        return -1
      }
    });
    var tT = y((ESt, fse) => {
      l();
      "use strict";
      fse.exports = nu;
      var N3 = Xl().codes,
        YYe = N3.ERR_METHOD_NOT_IMPLEMENTED,
        JYe = N3.ERR_MULTIPLE_CALLBACK,
        XYe = N3.ERR_TRANSFORM_ALREADY_TRANSFORMING,
        ZYe = N3.ERR_TRANSFORM_WITH_LENGTH_0,
        q3 = Zl();
      dn()(nu, q3);

      function QYe(r, e) {
        var t = this._transformState;
        t.transforming = !1;
        var i = t.writecb;
        if (i === null) return this.emit("error", new JYe);
        t.writechunk = null, t.writecb = null, e != null && this.push(e), i(r);
        var n = this._readableState;
        n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark)
      }

      function nu(r) {
        if (!(this instanceof nu)) return new nu(r);
        q3.call(this, r), this._transformState = {
          afterTransform: QYe.bind(this),
          needTransform: !1,
          transforming: !1,
          writecb: null,
          writechunk: null,
          writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, r && (typeof r.transform == "function" && (this._transform = r.transform), typeof r.flush == "function" && (this._flush = r.flush)), this.on("prefinish", eJe)
      }

      function eJe() {
        var r = this;
        typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function (e, t) {
          lse(r, e, t)
        }) : lse(this, null, null)
      }
      nu.prototype.push = function (r, e) {
        return this._transformState.needTransform = !1, q3.prototype.push.call(this, r, e)
      };
      nu.prototype._transform = function (r, e, t) {
        t(new YYe("_transform()"))
      };
      nu.prototype._write = function (r, e, t) {
        var i = this._transformState;
        if (i.writecb = t, i.writechunk = r, i.writeencoding = e, !i.transforming) {
          var n = this._readableState;
          (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark)
        }
      };
      nu.prototype._read = function (r) {
        var e = this._transformState;
        e.writechunk !== null && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0
      };
      nu.prototype._destroy = function (r, e) {
        q3.prototype._destroy.call(this, r, function (t) {
          e(t)
        })
      };

      function lse(r, e, t) {
        if (e) return r.emit("error", e);
        if (t != null && r.push(t), r._writableState.length) throw new ZYe;
        if (r._transformState.transforming) throw new XYe;
        return r.push(null)
      }
    });
    var pse = y((SSt, hse) => {
      l();
      "use strict";
      hse.exports = Pg;
      var dse = tT();
      dn()(Pg, dse);

      function Pg(r) {
        if (!(this instanceof Pg)) return new Pg(r);
        dse.call(this, r)
      }
      Pg.prototype._transform = function (r, e, t) {
        t(null, r)
      }
    });
    var vse = y((xSt, yse) => {
      l();
      "use strict";
      var rT;

      function tJe(r) {
        var e = !1;
        return function () {
          e || (e = !0, r.apply(void 0, arguments))
        }
      }
      var gse = Xl().codes,
        rJe = gse.ERR_MISSING_ARGS,
        iJe = gse.ERR_STREAM_DESTROYED;

      function bse(r) {
        if (r) throw r
      }

      function nJe(r) {
        return r.setHeader && typeof r.abort == "function"
      }

      function sJe(r, e, t, i) {
        i = tJe(i);
        var n = !1;
        r.on("close", function () {
          n = !0
        }), rT === void 0 && (rT = T3()), rT(r, {
          readable: e,
          writable: t
        }, function (o) {
          if (o) return i(o);
          n = !0, i()
        });
        var s = !1;
        return function (o) {
          if (!n && !s) {
            if (s = !0, nJe(r)) return r.abort();
            if (typeof r.destroy == "function") return r.destroy();
            i(o || new iJe("pipe"))
          }
        }
      }

      function mse(r) {
        r()
      }

      function oJe(r, e) {
        return r.pipe(e)
      }

      function aJe(r) {
        return !r.length || typeof r[r.length - 1] != "function" ? bse : r.pop()
      }

      function cJe() {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        var i = aJe(e);
        if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new rJe("streams");
        var n, s = e.map(function (o, a) {
          var c = a < e.length - 1,
            u = a > 0;
          return sJe(o, c, u, function (f) {
            n || (n = f), f && s.forEach(mse), !c && (s.forEach(mse), i(n))
          })
        });
        return e.reduce(oJe)
      }
      yse.exports = cJe
    });
    var iT = y((vo, wse) => {
      l();
      vo = wse.exports = LI();
      vo.Stream = vo;
      vo.Readable = vo;
      vo.Writable = DI();
      vo.Duplex = Zl();
      vo.Transform = tT();
      vo.PassThrough = pse();
      vo.finished = T3();
      vo.pipeline = vse()
    });
    var Sse = y((ASt, _se) => {
      l();
      "use strict";
      var uJe = dn(),
        {
          Readable: Ese
        } = iT();
      _se.exports = V0;
      uJe(V0, Ese);

      function V0(r, e) {
        if (!(this instanceof V0)) return new V0(r, e);
        e = e || {}, Ese.call(this, Object.assign({}, e, {
          objectMode: !0
        })), this._iterator = r, this._options = e, this.on("end", this.destroy.bind(this, null, null))
      }
      V0.prototype._read = function () {
        this.destroyed || this._iterator.next((r, e, t) => {
          if (!this.destroyed) {
            if (r) return this.destroy(r);
            e === void 0 && t === void 0 ? this.push(null) : this._options.keys !== !1 && this._options.values === !1 ? this.push(e) : this._options.keys === !1 && this._options.values !== !1 ? this.push(t) : this.push({
              key: e,
              value: t
            })
          }
        })
      };
      V0.prototype._destroy = function (r, e) {
        this._iterator.end(function (t) {
          e(r || t)
        })
      }
    });
    var Ase = y((xse, M3) => {
      l();
      (function (r, e, t) {
        typeof M3 != "undefined" && M3.exports ? M3.exports = t() : e[r] = t()
      })("prr", xse, function () {
        var r = typeof Object.defineProperty == "function" ? function (i, n, s) {
          return Object.defineProperty(i, n, s), i
        } : function (i, n, s) {
          return i[n] = s.value, i
        },
          e = function (i, n) {
            var s = typeof n == "object",
              o = !s && typeof n == "string",
              a = function (c) {
                return s ? !!n[c] : o ? n.indexOf(c[0]) > -1 : !1
              };
            return {
              enumerable: a("enumerable"),
              configurable: a("configurable"),
              writable: a("writable"),
              value: i
            }
          },
          t = function (i, n, s, o) {
            var a;
            if (o = e(s, o), typeof n == "object") {
              for (a in n) Object.hasOwnProperty.call(n, a) && (o.value = n[a], r(i, a, o));
              return i
            }
            return r(i, n, o)
          };
        return t
      })
    });
    var Rse = y((ISt, Ise) => {
      l();
      var fJe = Ase();

      function Tse(r, e, t) {
        !!e && typeof e != "string" && (e = e.message || e.name), fJe(this, {
          type: r,
          name: r,
          cause: typeof e != "string" ? e : t,
          message: e
        }, "ewr")
      }

      function nT(r, e) {
        Error.call(this), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), Tse.call(this, "CustomError", r, e)
      }
      nT.prototype = new Error;

      function lJe(r, e, t) {
        var i = function (n, s) {
          Tse.call(this, e, n, s), e == "FilesystemError" && (this.code = this.cause.code, this.path = this.cause.path, this.errno = this.cause.errno, this.message = (r.errno[this.cause.errno] ? r.errno[this.cause.errno].description : this.cause.message) + (this.cause.path ? " [" + this.cause.path + "]" : "")), Error.call(this), Error.captureStackTrace && Error.captureStackTrace(this, i)
        };
        return i.prototype = t ? new t : new nT, i
      }
      Ise.exports = function (r) {
        var e = function (t, i) {
          return lJe(r, t, i)
        };
        return {
          CustomError: nT,
          FilesystemError: e("FilesystemError"),
          createError: e
        }
      }
    });
    var kse = y((TSt, fc) => {
      l();
      var hJe = fc.exports.all = [{
        errno: -2,
        code: "ENOENT",
        description: "no such file or directory"
      }, {
        errno: -1,
        code: "UNKNOWN",
        description: "unknown error"
      }, {
        errno: 0,
        code: "OK",
        description: "success"
      }, {
        errno: 1,
        code: "EOF",
        description: "end of file"
      }, {
        errno: 2,
        code: "EADDRINFO",
        description: "getaddrinfo error"
      }, {
        errno: 3,
        code: "EACCES",
        description: "permission denied"
      }, {
        errno: 4,
        code: "EAGAIN",
        description: "resource temporarily unavailable"
      }, {
        errno: 5,
        code: "EADDRINUSE",
        description: "address already in use"
      }, {
        errno: 6,
        code: "EADDRNOTAVAIL",
        description: "address not available"
      }, {
        errno: 7,
        code: "EAFNOSUPPORT",
        description: "address family not supported"
      }, {
        errno: 8,
        code: "EALREADY",
        description: "connection already in progress"
      }, {
        errno: 9,
        code: "EBADF",
        description: "bad file descriptor"
      }, {
        errno: 10,
        code: "EBUSY",
        description: "resource busy or locked"
      }, {
        errno: 11,
        code: "ECONNABORTED",
        description: "software caused connection abort"
      }, {
        errno: 12,
        code: "ECONNREFUSED",
        description: "connection refused"
      }, {
        errno: 13,
        code: "ECONNRESET",
        description: "connection reset by peer"
      }, {
        errno: 14,
        code: "EDESTADDRREQ",
        description: "destination address required"
      }, {
        errno: 15,
        code: "EFAULT",
        description: "bad address in system call argument"
      }, {
        errno: 16,
        code: "EHOSTUNREACH",
        description: "host is unreachable"
      }, {
        errno: 17,
        code: "EINTR",
        description: "interrupted system call"
      }, {
        errno: 18,
        code: "EINVAL",
        description: "invalid argument"
      }, {
        errno: 19,
        code: "EISCONN",
        description: "socket is already connected"
      }, {
        errno: 20,
        code: "EMFILE",
        description: "too many open files"
      }, {
        errno: 21,
        code: "EMSGSIZE",
        description: "message too long"
      }, {
        errno: 22,
        code: "ENETDOWN",
        description: "network is down"
      }, {
        errno: 23,
        code: "ENETUNREACH",
        description: "network is unreachable"
      }, {
        errno: 24,
        code: "ENFILE",
        description: "file table overflow"
      }, {
        errno: 25,
        code: "ENOBUFS",
        description: "no buffer space available"
      }, {
        errno: 26,
        code: "ENOMEM",
        description: "not enough memory"
      }, {
        errno: 27,
        code: "ENOTDIR",
        description: "not a directory"
      }, {
        errno: 28,
        code: "EISDIR",
        description: "illegal operation on a directory"
      }, {
        errno: 29,
        code: "ENONET",
        description: "machine is not on the network"
      }, {
        errno: 31,
        code: "ENOTCONN",
        description: "socket is not connected"
      }, {
        errno: 32,
        code: "ENOTSOCK",
        description: "socket operation on non-socket"
      }, {
        errno: 33,
        code: "ENOTSUP",
        description: "operation not supported on socket"
      }, {
        errno: 34,
        code: "ENOENT",
        description: "no such file or directory"
      }, {
        errno: 35,
        code: "ENOSYS",
        description: "function not implemented"
      }, {
        errno: 36,
        code: "EPIPE",
        description: "broken pipe"
      }, {
        errno: 37,
        code: "EPROTO",
        description: "protocol error"
      }, {
        errno: 38,
        code: "EPROTONOSUPPORT",
        description: "protocol not supported"
      }, {
        errno: 39,
        code: "EPROTOTYPE",
        description: "protocol wrong type for socket"
      }, {
        errno: 40,
        code: "ETIMEDOUT",
        description: "connection timed out"
      }, {
        errno: 41,
        code: "ECHARSET",
        description: "invalid Unicode character"
      }, {
        errno: 42,
        code: "EAIFAMNOSUPPORT",
        description: "address family for hostname not supported"
      }, {
        errno: 44,
        code: "EAISERVICE",
        description: "servname not supported for ai_socktype"
      }, {
        errno: 45,
        code: "EAISOCKTYPE",
        description: "ai_socktype not supported"
      }, {
        errno: 46,
        code: "ESHUTDOWN",
        description: "cannot send after transport endpoint shutdown"
      }, {
        errno: 47,
        code: "EEXIST",
        description: "file already exists"
      }, {
        errno: 48,
        code: "ESRCH",
        description: "no such process"
      }, {
        errno: 49,
        code: "ENAMETOOLONG",
        description: "name too long"
      }, {
        errno: 50,
        code: "EPERM",
        description: "operation not permitted"
      }, {
        errno: 51,
        code: "ELOOP",
        description: "too many symbolic links encountered"
      }, {
        errno: 52,
        code: "EXDEV",
        description: "cross-device link not permitted"
      }, {
        errno: 53,
        code: "ENOTEMPTY",
        description: "directory not empty"
      }, {
        errno: 54,
        code: "ENOSPC",
        description: "no space left on device"
      }, {
        errno: 55,
        code: "EIO",
        description: "i/o error"
      }, {
        errno: 56,
        code: "EROFS",
        description: "read-only file system"
      }, {
        errno: 57,
        code: "ENODEV",
        description: "no such device"
      }, {
        errno: 58,
        code: "ESPIPE",
        description: "invalid seek"
      }, {
        errno: 59,
        code: "ECANCELED",
        description: "operation canceled"
      }];
      fc.exports.errno = {};
      fc.exports.code = {};
      hJe.forEach(function (r) {
        fc.exports.errno[r.errno] = r, fc.exports.code[r.code] = r
      });
      fc.exports.custom = Rse()(fc.exports);
      fc.exports.create = fc.exports.custom.createError
    });
    var B3 = y((RSt, Pse) => {
      l();
      "use strict";
      var rh = kse().create,
        ih = rh("LevelUPError"),
        sT = rh("NotFoundError", ih);
      sT.prototype.notFound = !0;
      sT.prototype.status = 404;
      Pse.exports = {
        LevelUPError: ih,
        InitializationError: rh("InitializationError", ih),
        OpenError: rh("OpenError", ih),
        ReadError: rh("ReadError", ih),
        WriteError: rh("WriteError", ih),
        NotFoundError: sT,
        EncodingError: rh("EncodingError", ih)
      }
    });
    var aT = y(oT => {
      l();
      "use strict";
      oT.fromCallback = function (r) {
        if (r === void 0) {
          var e = new Promise(function (t, i) {
            r = function (n, s) {
              n ? i(n) : t(s)
            }
          });
          r.promise = e
        }
        return r
      };
      oT.fromPromise = function (r, e) {
        if (e === void 0) return r;
        r.then(function (t) {
          process.nextTick(e, null, t)
        }).catch(function (t) {
          process.nextTick(e, t)
        })
      }
    });
    var Cg = y(cT => {
      l();
      "use strict";
      cT.getCallback = function (r, e) {
        return typeof r == "function" ? r : e
      };
      cT.getOptions = function (r) {
        return typeof r == "object" && r !== null ? r : {}
      }
    });
    var Ose = y((CSt, Cse) => {
      l();
      "use strict";
      var Og = B3().WriteError,
        dJe = aT(),
        pJe = Cg().getCallback,
        yJe = Cg().getOptions;

      function Ng(r) {
        this.db = r, this.batch = r.db.batch(), this.ops = [], this.length = 0
      }
      Ng.prototype.put = function (r, e, t) {
        try {
          this.batch.put(r, e, t)
        } catch (i) {
          throw new Og(i)
        }
        return this.ops.push({
          ...t,
          type: "put",
          key: r,
          value: e
        }), this.length++, this
      };
      Ng.prototype.del = function (r, e) {
        try {
          this.batch.del(r, e)
        } catch (t) {
          throw new Og(t)
        }
        return this.ops.push({
          ...e,
          type: "del",
          key: r
        }), this.length++, this
      };
      Ng.prototype.clear = function () {
        try {
          this.batch.clear()
        } catch (r) {
          throw new Og(r)
        }
        return this.ops = [], this.length = 0, this
      };
      Ng.prototype.write = function (r, e) {
        let t = this.db,
          i = this.ops;
        e = pJe(r, e), e = dJe.fromCallback(e), r = yJe(r);
        try {
          this.batch.write(r, function (n) {
            if (n) return e(new Og(n));
            t.emit("batch", i), e()
          })
        } catch (n) {
          throw new Og(n)
        }
        return e.promise
      };
      Cse.exports = Ng
    });
    var hT = y((OSt, Nse) => {
      l();
      "use strict";

      function H0(r) {
        return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? H0 = function (t) {
          return typeof t
        } : H0 = function (t) {
          return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }, H0(r)
      }

      function gJe(r, e) {
        if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function")
      }

      function mJe(r, e) {
        return e && (H0(e) === "object" || typeof e == "function") ? e : bJe(r)
      }

      function bJe(r) {
        if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return r
      }

      function uT(r) {
        return uT = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }, uT(r)
      }

      function vJe(r, e) {
        if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
        r.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: r,
            writable: !0,
            configurable: !0
          }
        }), e && fT(r, e)
      }

      function fT(r, e) {
        return fT = Object.setPrototypeOf || function (i, n) {
          return i.__proto__ = n, i
        }, fT(r, e)
      }
      var qse = {},
        G0, lT;

      function qg(r, e, t) {
        t || (t = Error);

        function i(s, o, a) {
          return typeof e == "string" ? e : e(s, o, a)
        }
        var n = function (s) {
          vJe(o, s);

          function o(a, c, u) {
            var f;
            return gJe(this, o), f = mJe(this, uT(o).call(this, i(a, c, u))), f.code = r, f
          }
          return o
        }(t);
        qse[r] = n
      }

      function Mse(r, e) {
        if (Array.isArray(r)) {
          var t = r.length;
          return r = r.map(function (i) {
            return String(i)
          }), t > 2 ? "one of ".concat(e, " ").concat(r.slice(0, t - 1).join(", "), ", or ") + r[t - 1] : t === 2 ? "one of ".concat(e, " ").concat(r[0], " or ").concat(r[1]) : "of ".concat(e, " ").concat(r[0])
        } else return "of ".concat(e, " ").concat(String(r))
      }

      function wJe(r, e, t) {
        return r.substr(!t || t < 0 ? 0 : +t, e.length) === e
      }

      function _Je(r, e, t) {
        return (t === void 0 || t > r.length) && (t = r.length), r.substring(t - e.length, t) === e
      }

      function EJe(r, e, t) {
        return typeof t != "number" && (t = 0), t + e.length > r.length ? !1 : r.indexOf(e, t) !== -1
      }
      qg("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
      qg("ERR_INVALID_ARG_TYPE", function (r, e, t) {
        G0 === void 0 && (G0 = D3()), G0(typeof r == "string", "'name' must be a string");
        var i;
        typeof e == "string" && wJe(e, "not ") ? (i = "must not be", e = e.replace(/^not /, "")) : i = "must be";
        var n;
        if (_Je(r, " argument")) n = "The ".concat(r, " ").concat(i, " ").concat(Mse(e, "type"));
        else {
          var s = EJe(r, ".") ? "property" : "argument";
          n = 'The "'.concat(r, '" ').concat(s, " ").concat(i, " ").concat(Mse(e, "type"))
        }
        return n += ". Received type ".concat(H0(t)), n
      }, TypeError);
      qg("ERR_INVALID_ARG_VALUE", function (r, e) {
        var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
        lT === void 0 && (lT = Yl());
        var i = lT.inspect(e);
        return i.length > 128 && (i = "".concat(i.slice(0, 128), "...")), "The argument '".concat(r, "' ").concat(t, ". Received ").concat(i)
      }, TypeError, RangeError);
      qg("ERR_INVALID_RETURN_VALUE", function (r, e, t) {
        var i;
        return t && t.constructor && t.constructor.name ? i = "instance of ".concat(t.constructor.name) : i = "type ".concat(H0(t)), "Expected ".concat(r, ' to be returned from the "').concat(e, '"') + " function but got ".concat(i, ".")
      }, TypeError);
      qg("ERR_MISSING_ARGS", function () {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        G0 === void 0 && (G0 = D3()), G0(e.length > 0, "At least one arg needs to be specified");
        var i = "The ",
          n = e.length;
        switch (e = e.map(function (s) {
          return '"'.concat(s, '"')
        }), n) {
          case 1:
            i += "".concat(e[0], " argument");
            break;
          case 2:
            i += "".concat(e[0], " and ").concat(e[1], " arguments");
            break;
          default:
            i += e.slice(0, n - 1).join(", "), i += ", and ".concat(e[n - 1], " arguments");
            break
        }
        return "".concat(i, " must be specified")
      }, TypeError);
      Nse.exports.codes = qse
    });
    var Use = y((NSt, Bse) => {
      l();
      "use strict";

      function xJe(r) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e] != null ? arguments[e] : {},
            i = Object.keys(t);
          typeof Object.getOwnPropertySymbols == "function" && (i = i.concat(Object.getOwnPropertySymbols(t).filter(function (n) {
            return Object.getOwnPropertyDescriptor(t, n).enumerable
          }))), i.forEach(function (n) {
            SJe(r, n, t[n])
          })
        }
        return r
      }

      function SJe(r, e, t) {
        return e in r ? Object.defineProperty(r, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : r[e] = t, r
      }

      function AJe(r, e) {
        if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function")
      }

      function Dse(r, e) {
        for (var t = 0; t < e.length; t++) {
          var i = e[t];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, i.key, i)
        }
      }

      function IJe(r, e, t) {
        return e && Dse(r.prototype, e), t && Dse(r, t), r
      }

      function $0(r, e) {
        return e && (wo(e) === "object" || typeof e == "function") ? e : dT(r)
      }

      function dT(r) {
        if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return r
      }

      function TJe(r, e) {
        if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
        r.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: r,
            writable: !0,
            configurable: !0
          }
        }), e && Mg(r, e)
      }

      function pT(r) {
        var e = typeof Map == "function" ? new Map : void 0;
        return pT = function (i) {
          if (i === null || !RJe(i)) return i;
          if (typeof i != "function") throw new TypeError("Super expression must either be null or a function");
          if (typeof e != "undefined") {
            if (e.has(i)) return e.get(i);
            e.set(i, n)
          }

          function n() {
            return L3(i, arguments, Af(this).constructor)
          }
          return n.prototype = Object.create(i.prototype, {
            constructor: {
              value: n,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          }), Mg(n, i)
        }, pT(r)
      }

      function kJe() {
        if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
          return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0
        } catch (r) {
          return !1
        }
      }

      function L3(r, e, t) {
        return kJe() ? L3 = Reflect.construct : L3 = function (n, s, o) {
          var a = [null];
          a.push.apply(a, s);
          var c = Function.bind.apply(n, a),
            u = new c;
          return o && Mg(u, o.prototype), u
        }, L3.apply(null, arguments)
      }

      function RJe(r) {
        return Function.toString.call(r).indexOf("[native code]") !== -1
      }

      function Mg(r, e) {
        return Mg = Object.setPrototypeOf || function (i, n) {
          return i.__proto__ = n, i
        }, Mg(r, e)
      }

      function Af(r) {
        return Af = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }, Af(r)
      }

      function wo(r) {
        return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? wo = function (t) {
          return typeof t
        } : wo = function (t) {
          return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }, wo(r)
      }
      var PJe = Yl(),
        yT = PJe.inspect,
        CJe = hT(),
        OJe = CJe.codes.ERR_INVALID_ARG_TYPE;

      function Lse(r, e, t) {
        return (t === void 0 || t > r.length) && (t = r.length), r.substring(t - e.length, t) === e
      }

      function NJe(r, e) {
        if (e = Math.floor(e), r.length == 0 || e == 0) return "";
        var t = r.length * e;
        for (e = Math.floor(Math.log(e) / Math.log(2)); e;) r += r, e--;
        return r += r.substring(0, t - r.length), r
      }
      var ua = "",
        Bg = "",
        Dg = "",
        bn = "",
        nh = {
          deepStrictEqual: "Expected values to be strictly deep-equal:",
          strictEqual: "Expected values to be strictly equal:",
          strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
          deepEqual: "Expected values to be loosely deep-equal:",
          equal: "Expected values to be loosely equal:",
          notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
          notStrictEqual: 'Expected "actual" to be strictly unequal to:',
          notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
          notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
          notEqual: 'Expected "actual" to be loosely unequal to:',
          notIdentical: "Values identical but not reference-equal:"
        },
        qJe = 10;

      function Fse(r) {
        var e = Object.keys(r),
          t = Object.create(Object.getPrototypeOf(r));
        return e.forEach(function (i) {
          t[i] = r[i]
        }), Object.defineProperty(t, "message", {
          value: r.message
        }), t
      }

      function Lg(r) {
        return yT(r, {
          compact: !1,
          customInspect: !1,
          depth: 1e3,
          maxArrayLength: Infinity,
          showHidden: !1,
          breakLength: Infinity,
          showProxy: !1,
          sorted: !0,
          getters: !0
        })
      }

      function MJe(r, e, t) {
        var i = "",
          n = "",
          s = 0,
          o = "",
          a = !1,
          c = Lg(r),
          u = c.split(`
`),
          f = Lg(e).split(`
`),
          h = 0,
          d = "";
        if (t === "strictEqual" && wo(r) === "object" && wo(e) === "object" && r !== null && e !== null && (t = "strictEqualObject"), u.length === 1 && f.length === 1 && u[0] !== f[0]) {
          var p = u[0].length + f[0].length;
          if (p <= qJe) {
            if ((wo(r) !== "object" || r === null) && (wo(e) !== "object" || e === null) && (r !== 0 || e !== 0)) return "".concat(nh[t], `

`) + "".concat(u[0], " !== ").concat(f[0], `
`)
          } else if (t !== "strictEqualObject") {
            var g = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
            if (p < g) {
              for (; u[0][h] === f[0][h];) h++;
              h > 2 && (d = `
`.concat(NJe(" ", h), "^"), h = 0)
            }
          }
        }
        for (var m = u[u.length - 1], E = f[f.length - 1]; m === E && (h++ < 2 ? o = `
`.concat(m).concat(o) : i = m, u.pop(), f.pop(), !(u.length === 0 || f.length === 0));) m = u[u.length - 1], E = f[f.length - 1];
        var w = Math.max(u.length, f.length);
        if (w === 0) {
          var O = c.split(`
`);
          if (O.length > 30)
            for (O[26] = "".concat(ua, "...").concat(bn); O.length > 27;) O.pop();
          return "".concat(nh.notIdentical, `

`).concat(O.join(`
`), `
`)
        }
        h > 3 && (o = `
`.concat(ua, "...").concat(bn).concat(o), a = !0), i !== "" && (o = `
`.concat(i).concat(o), i = "");
        var q = 0,
          J = nh[t] + `
`.concat(Bg, "+ actual").concat(bn, " ").concat(Dg, "- expected").concat(bn),
          Z = " ".concat(ua, "...").concat(bn, " Lines skipped");
        for (h = 0; h < w; h++) {
          var H = h - s;
          if (u.length < h + 1) H > 1 && h > 2 && (H > 4 ? (n += `
`.concat(ua, "...").concat(bn), a = !0) : H > 3 && (n += `
`.concat(f[h - 2]), q++), n += `
`.concat(f[h - 1]), q++), s = h, i += `
`.concat(Dg, "-").concat(bn, " ").concat(f[h]), q++;
          else if (f.length < h + 1) H > 1 && h > 2 && (H > 4 ? (n += `
`.concat(ua, "...").concat(bn), a = !0) : H > 3 && (n += `
`.concat(u[h - 2]), q++), n += `
`.concat(u[h - 1]), q++), s = h, n += `
`.concat(Bg, "+").concat(bn, " ").concat(u[h]), q++;
          else {
            var te = f[h],
              ae = u[h],
              oe = ae !== te && (!Lse(ae, ",") || ae.slice(0, -1) !== te);
            oe && Lse(te, ",") && te.slice(0, -1) === ae && (oe = !1, ae += ","), oe ? (H > 1 && h > 2 && (H > 4 ? (n += `
`.concat(ua, "...").concat(bn), a = !0) : H > 3 && (n += `
`.concat(u[h - 2]), q++), n += `
`.concat(u[h - 1]), q++), s = h, n += `
`.concat(Bg, "+").concat(bn, " ").concat(ae), i += `
`.concat(Dg, "-").concat(bn, " ").concat(te), q += 2) : (n += i, i = "", (H === 1 || h === 0) && (n += `
`.concat(ae), q++))
          }
          if (q > 20 && h < w - 2) return "".concat(J).concat(Z, `
`).concat(n, `
`).concat(ua, "...").concat(bn).concat(i, `
`) + "".concat(ua, "...").concat(bn)
        }
        return "".concat(J).concat(a ? Z : "", `
`).concat(n).concat(i).concat(o).concat(d)
      }
      var BJe = function (r) {
        TJe(e, r);

        function e(t) {
          var i;
          if (AJe(this, e), wo(t) !== "object" || t === null) throw new OJe("options", "Object", t);
          var n = t.message,
            s = t.operator,
            o = t.stackStartFn,
            a = t.actual,
            c = t.expected,
            u = Error.stackTraceLimit;
          if (Error.stackTraceLimit = 0, n != null) i = $0(this, Af(e).call(this, String(n)));
          else if (process.stderr && process.stderr.isTTY && (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1 ? (ua = "[34m", Bg = "[32m", bn = "[39m", Dg = "[31m") : (ua = "", Bg = "", bn = "", Dg = "")), wo(a) === "object" && a !== null && wo(c) === "object" && c !== null && "stack" in a && a instanceof Error && "stack" in c && c instanceof Error && (a = Fse(a), c = Fse(c)), s === "deepStrictEqual" || s === "strictEqual") i = $0(this, Af(e).call(this, MJe(a, c, s)));
          else if (s === "notDeepStrictEqual" || s === "notStrictEqual") {
            var f = nh[s],
              h = Lg(a).split(`
`);
            if (s === "notStrictEqual" && wo(a) === "object" && a !== null && (f = nh.notStrictEqualObject), h.length > 30)
              for (h[26] = "".concat(ua, "...").concat(bn); h.length > 27;) h.pop();
            h.length === 1 ? i = $0(this, Af(e).call(this, "".concat(f, " ").concat(h[0]))) : i = $0(this, Af(e).call(this, "".concat(f, `

`).concat(h.join(`
`), `
`)))
          } else {
            var d = Lg(a),
              p = "",
              g = nh[s];
            s === "notDeepEqual" || s === "notEqual" ? (d = "".concat(nh[s], `

`).concat(d), d.length > 1024 && (d = "".concat(d.slice(0, 1021), "..."))) : (p = "".concat(Lg(c)), d.length > 512 && (d = "".concat(d.slice(0, 509), "...")), p.length > 512 && (p = "".concat(p.slice(0, 509), "...")), s === "deepEqual" || s === "equal" ? d = "".concat(g, `

`).concat(d, `

should equal

`) : p = " ".concat(s, " ").concat(p)), i = $0(this, Af(e).call(this, "".concat(d).concat(p)))
          }
          return Error.stackTraceLimit = u, i.generatedMessage = !n, Object.defineProperty(dT(i), "name", {
            value: "AssertionError [ERR_ASSERTION]",
            enumerable: !1,
            writable: !0,
            configurable: !0
          }), i.code = "ERR_ASSERTION", i.actual = a, i.expected = c, i.operator = s, Error.captureStackTrace && Error.captureStackTrace(dT(i), o), i.stack, i.name = "AssertionError", $0(i)
        }
        return IJe(e, [{
          key: "toString",
          value: function () {
            return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message)
          }
        }, {
          key: yT.custom,
          value: function (i, n) {
            return yT(this, xJe({}, n, {
              customInspect: !1,
              depth: 0
            }))
          }
        }]), e
      }(pT(Error));
      Bse.exports = BJe
    });
    var jse = y((qSt, Kse) => {
      l();
      "use strict";

      function zse(r, e) {
        if (r == null) throw new TypeError("Cannot convert first argument to object");
        for (var t = Object(r), i = 1; i < arguments.length; i++) {
          var n = arguments[i];
          if (n != null)
            for (var s = Object.keys(Object(n)), o = 0, a = s.length; o < a; o++) {
              var c = s[o],
                u = Object.getOwnPropertyDescriptor(n, c);
              u !== void 0 && u.enumerable && (t[c] = n[c])
            }
        }
        return t
      }

      function DJe() {
        Object.assign || Object.defineProperty(Object, "assign", {
          enumerable: !1,
          configurable: !0,
          writable: !0,
          value: zse
        })
      }
      Kse.exports = {
        assign: zse,
        polyfill: DJe
      }
    });
    var gT = y((MSt, Vse) => {
      l();
      "use strict";
      var Hse = Object.prototype.toString;
      Vse.exports = function (e) {
        var t = Hse.call(e),
          i = t === "[object Arguments]";
        return i || (i = t !== "[object Array]" && e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && Hse.call(e.callee) === "[object Function]"), i
      }
    });
    var eoe = y((BSt, Gse) => {
      l();
      "use strict";
      var $se;
      Object.keys || (Fg = Object.prototype.hasOwnProperty, bT = Object.prototype.toString, Wse = gT(), mT = Object.prototype.propertyIsEnumerable, Yse = !mT.call({
        toString: null
      }, "toString"), Jse = mT.call(function () { }, "prototype"), Ug = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], F3 = function (r) {
        var e = r.constructor;
        return e && e.prototype === r
      }, Xse = {
        $applicationCache: !0,
        $console: !0,
        $external: !0,
        $frame: !0,
        $frameElement: !0,
        $frames: !0,
        $innerHeight: !0,
        $innerWidth: !0,
        $onmozfullscreenchange: !0,
        $onmozfullscreenerror: !0,
        $outerHeight: !0,
        $outerWidth: !0,
        $pageXOffset: !0,
        $pageYOffset: !0,
        $parent: !0,
        $scrollLeft: !0,
        $scrollTop: !0,
        $scrollX: !0,
        $scrollY: !0,
        $self: !0,
        $webkitIndexedDB: !0,
        $webkitStorageInfo: !0,
        $window: !0
      }, Zse = function () {
        if (typeof window == "undefined") return !1;
        for (var r in window) try {
          if (!Xse["$" + r] && Fg.call(window, r) && window[r] !== null && typeof window[r] == "object") try {
            F3(window[r])
          } catch (e) {
            return !0
          }
        } catch (e) {
          return !0
        }
        return !1
      }(), Qse = function (r) {
        if (typeof window == "undefined" || !Zse) return F3(r);
        try {
          return F3(r)
        } catch (e) {
          return !1
        }
      }, $se = function (e) {
        var t = e !== null && typeof e == "object",
          i = bT.call(e) === "[object Function]",
          n = Wse(e),
          s = t && bT.call(e) === "[object String]",
          o = [];
        if (!t && !i && !n) throw new TypeError("Object.keys called on a non-object");
        var a = Jse && i;
        if (s && e.length > 0 && !Fg.call(e, 0))
          for (var c = 0; c < e.length; ++c) o.push(String(c));
        if (n && e.length > 0)
          for (var u = 0; u < e.length; ++u) o.push(String(u));
        else
          for (var f in e) !(a && f === "prototype") && Fg.call(e, f) && o.push(String(f));
        if (Yse)
          for (var h = Qse(e), d = 0; d < Ug.length; ++d) !(h && Ug[d] === "constructor") && Fg.call(e, Ug[d]) && o.push(Ug[d]);
        return o
      });
      var Fg, bT, Wse, mT, Yse, Jse, Ug, F3, Xse, Zse, Qse;
      Gse.exports = $se
    });
    var noe = y((DSt, toe) => {
      l();
      "use strict";
      var LJe = Array.prototype.slice,
        FJe = gT(),
        roe = Object.keys,
        U3 = roe ? function (e) {
          return roe(e)
        } : eoe(),
        ioe = Object.keys;
      U3.shim = function () {
        if (Object.keys) {
          var e = function () {
            var t = Object.keys(arguments);
            return t && t.length === arguments.length
          }(1, 2);
          e || (Object.keys = function (i) {
            return FJe(i) ? ioe(LJe.call(i)) : ioe(i)
          })
        } else Object.keys = U3;
        return Object.keys || U3
      };
      toe.exports = U3
    });
    var Kg = y((LSt, soe) => {
      l();
      "use strict";
      var UJe = noe(),
        KJe = typeof Symbol == "function" && typeof Symbol("foo") == "symbol",
        zJe = Object.prototype.toString,
        jJe = Array.prototype.concat,
        vT = Object.defineProperty,
        VJe = function (r) {
          return typeof r == "function" && zJe.call(r) === "[object Function]"
        },
        HJe = function () {
          var r = {};
          try {
            vT(r, "x", {
              enumerable: !1,
              value: r
            });
            for (var e in r) return !1;
            return r.x === r
          } catch (t) {
            return !1
          }
        },
        ooe = vT && HJe(),
        GJe = function (r, e, t, i) {
          e in r && (!VJe(i) || !i()) || (ooe ? vT(r, e, {
            configurable: !0,
            enumerable: !1,
            value: t,
            writable: !0
          }) : r[e] = t)
        },
        aoe = function (r, e) {
          var t = arguments.length > 2 ? arguments[2] : {},
            i = UJe(e);
          KJe && (i = jJe.call(i, Object.getOwnPropertySymbols(e)));
          for (var n = 0; n < i.length; n += 1) GJe(r, i[n], e[i[n]], t[i[n]])
        };
      aoe.supportsDescriptors = !!ooe;
      soe.exports = aoe
    });
    var wT = y((FSt, coe) => {
      l();
      "use strict";
      var uoe = function (r) {
        return r !== r
      };
      coe.exports = function (e, t) {
        return e === 0 && t === 0 ? 1 / e == 1 / t : !!(e === t || uoe(e) && uoe(t))
      }
    });
    var _T = y((USt, foe) => {
      l();
      "use strict";
      var $Je = wT();
      foe.exports = function () {
        return typeof Object.is == "function" ? Object.is : $Je
      }
    });
    var hoe = y((KSt, loe) => {
      l();
      "use strict";
      var WJe = _T(),
        YJe = Kg();
      loe.exports = function () {
        var e = WJe();
        return YJe(Object, {
          is: e
        }, {
          is: function () {
            return Object.is !== e
          }
        }), e
      }
    });
    var ET = y((zSt, doe) => {
      l();
      "use strict";
      var JJe = Kg(),
        XJe = e3(),
        ZJe = wT(),
        poe = _T(),
        QJe = hoe(),
        yoe = XJe(poe(), Object);
      JJe(yoe, {
        getPolyfill: poe,
        implementation: ZJe,
        shim: QJe
      });
      doe.exports = yoe
    });
    var ST = y((jSt, goe) => {
      l();
      "use strict";
      goe.exports = function (e) {
        return e !== e
      }
    });
    var xT = y((VSt, boe) => {
      l();
      "use strict";
      var eXe = ST();
      boe.exports = function () {
        return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : eXe
      }
    });
    var voe = y((HSt, moe) => {
      l();
      "use strict";
      var tXe = Kg(),
        rXe = xT();
      moe.exports = function () {
        var e = rXe();
        return tXe(Number, {
          isNaN: e
        }, {
          isNaN: function () {
            return Number.isNaN !== e
          }
        }), e
      }
    });
    var Soe = y((GSt, woe) => {
      l();
      "use strict";
      var iXe = e3(),
        nXe = Kg(),
        sXe = ST(),
        _oe = xT(),
        oXe = voe(),
        Eoe = iXe(_oe(), Number);
      nXe(Eoe, {
        getPolyfill: _oe,
        implementation: sXe,
        shim: oXe
      });
      woe.exports = Eoe
    });
    var zoe = y(($St, xoe) => {
      l();
      "use strict";

      function Aoe(r, e) {
        return uXe(r) || cXe(r, e) || aXe()
      }

      function aXe() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance")
      }

      function cXe(r, e) {
        var t = [],
          i = !0,
          n = !1,
          s = void 0;
        try {
          for (var o = r[Symbol.iterator](), a; !(i = (a = o.next()).done) && (t.push(a.value), !(e && t.length === e)); i = !0);
        } catch (c) {
          n = !0, s = c
        } finally {
          try {
            !i && o.return != null && o.return()
          } finally {
            if (n) throw s
          }
        }
        return t
      }

      function uXe(r) {
        if (Array.isArray(r)) return r
      }

      function Us(r) {
        return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Us = function (t) {
          return typeof t
        } : Us = function (t) {
          return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }, Us(r)
      }
      var fXe = /a/g.flags !== void 0,
        K3 = function (e) {
          var t = [];
          return e.forEach(function (i) {
            return t.push(i)
          }), t
        },
        Ioe = function (e) {
          var t = [];
          return e.forEach(function (i, n) {
            return t.push([n, i])
          }), t
        },
        Toe = Object.is ? Object.is : ET(),
        z3 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
          return []
        },
        AT = Number.isNaN ? Number.isNaN : Soe();

      function IT(r) {
        return r.call.bind(r)
      }
      var zg = IT(Object.prototype.hasOwnProperty),
        j3 = IT(Object.prototype.propertyIsEnumerable),
        Roe = IT(Object.prototype.toString),
        Wn = Yl().types,
        lXe = Wn.isAnyArrayBuffer,
        hXe = Wn.isArrayBufferView,
        koe = Wn.isDate,
        V3 = Wn.isMap,
        Poe = Wn.isRegExp,
        H3 = Wn.isSet,
        dXe = Wn.isNativeError,
        pXe = Wn.isBoxedPrimitive,
        Coe = Wn.isNumberObject,
        Ooe = Wn.isStringObject,
        Noe = Wn.isBooleanObject,
        qoe = Wn.isBigIntObject,
        yXe = Wn.isSymbolObject,
        gXe = Wn.isFloat32Array,
        bXe = Wn.isFloat64Array;

      function mXe(r) {
        if (r.length === 0 || r.length > 10) return !0;
        for (var e = 0; e < r.length; e++) {
          var t = r.charCodeAt(e);
          if (t < 48 || t > 57) return !0
        }
        return r.length === 10 && r >= Math.pow(2, 32)
      }

      function G3(r) {
        return Object.keys(r).filter(mXe).concat(z3(r).filter(Object.prototype.propertyIsEnumerable.bind(r)))
      }

      function Moe(r, e) {
        if (r === e) return 0;
        for (var t = r.length, i = e.length, n = 0, s = Math.min(t, i); n < s; ++n)
          if (r[n] !== e[n]) {
            t = r[n], i = e[n];
            break
          } return t < i ? -1 : i < t ? 1 : 0
      }
      var $3 = void 0,
        vXe = !0,
        wXe = !1,
        TT = 0,
        RT = 1,
        Boe = 2,
        Doe = 3;

      function _Xe(r, e) {
        return fXe ? r.source === e.source && r.flags === e.flags : RegExp.prototype.toString.call(r) === RegExp.prototype.toString.call(e)
      }

      function EXe(r, e) {
        if (r.byteLength !== e.byteLength) return !1;
        for (var t = 0; t < r.byteLength; t++)
          if (r[t] !== e[t]) return !1;
        return !0
      }

      function SXe(r, e) {
        return r.byteLength !== e.byteLength ? !1 : Moe(new Uint8Array(r.buffer, r.byteOffset, r.byteLength), new Uint8Array(e.buffer, e.byteOffset, e.byteLength)) === 0
      }

      function xXe(r, e) {
        return r.byteLength === e.byteLength && Moe(new Uint8Array(r), new Uint8Array(e)) === 0
      }

      function AXe(r, e) {
        return Coe(r) ? Coe(e) && Toe(Number.prototype.valueOf.call(r), Number.prototype.valueOf.call(e)) : Ooe(r) ? Ooe(e) && String.prototype.valueOf.call(r) === String.prototype.valueOf.call(e) : Noe(r) ? Noe(e) && Boolean.prototype.valueOf.call(r) === Boolean.prototype.valueOf.call(e) : qoe(r) ? qoe(e) && BigInt.prototype.valueOf.call(r) === BigInt.prototype.valueOf.call(e) : yXe(e) && Symbol.prototype.valueOf.call(r) === Symbol.prototype.valueOf.call(e)
      }

      function _o(r, e, t, i) {
        if (r === e) return r !== 0 ? !0 : t ? Toe(r, e) : !0;
        if (t) {
          if (Us(r) !== "object") return typeof r == "number" && AT(r) && AT(e);
          if (Us(e) !== "object" || r === null || e === null || Object.getPrototypeOf(r) !== Object.getPrototypeOf(e)) return !1
        } else {
          if (r === null || Us(r) !== "object") return e === null || Us(e) !== "object" ? r == e : !1;
          if (e === null || Us(e) !== "object") return !1
        }
        var n = Roe(r),
          s = Roe(e);
        if (n !== s) return !1;
        if (Array.isArray(r)) {
          if (r.length !== e.length) return !1;
          var o = G3(r, $3),
            a = G3(e, $3);
          return o.length !== a.length ? !1 : jg(r, e, t, i, RT, o)
        }
        if (n === "[object Object]" && (!V3(r) && V3(e) || !H3(r) && H3(e))) return !1;
        if (koe(r)) {
          if (!koe(e) || Date.prototype.getTime.call(r) !== Date.prototype.getTime.call(e)) return !1
        } else if (Poe(r)) {
          if (!Poe(e) || !_Xe(r, e)) return !1
        } else if (dXe(r) || r instanceof Error) {
          if (r.message !== e.message || r.name !== e.name) return !1
        } else if (hXe(r)) {
          if (!t && (gXe(r) || bXe(r))) {
            if (!EXe(r, e)) return !1
          } else if (!SXe(r, e)) return !1;
          var c = G3(r, $3),
            u = G3(e, $3);
          return c.length !== u.length ? !1 : jg(r, e, t, i, TT, c)
        } else {
          if (H3(r)) return !H3(e) || r.size !== e.size ? !1 : jg(r, e, t, i, Boe);
          if (V3(r)) return !V3(e) || r.size !== e.size ? !1 : jg(r, e, t, i, Doe);
          if (lXe(r)) {
            if (!xXe(r, e)) return !1
          } else if (pXe(r) && !AXe(r, e)) return !1
        }
        return jg(r, e, t, i, TT)
      }

      function Loe(r, e) {
        return e.filter(function (t) {
          return j3(r, t)
        })
      }

      function jg(r, e, t, i, n, s) {
        if (arguments.length === 5) {
          s = Object.keys(r);
          var o = Object.keys(e);
          if (s.length !== o.length) return !1
        }
        for (var a = 0; a < s.length; a++)
          if (!zg(e, s[a])) return !1;
        if (t && arguments.length === 5) {
          var c = z3(r);
          if (c.length !== 0) {
            var u = 0;
            for (a = 0; a < c.length; a++) {
              var f = c[a];
              if (j3(r, f)) {
                if (!j3(e, f)) return !1;
                s.push(f), u++
              } else if (j3(e, f)) return !1
            }
            var h = z3(e);
            if (c.length !== h.length && Loe(e, h).length !== u) return !1
          } else {
            var d = z3(e);
            if (d.length !== 0 && Loe(e, d).length !== 0) return !1
          }
        }
        if (s.length === 0 && (n === TT || n === RT && r.length === 0 || r.size === 0)) return !0;
        if (i === void 0) i = {
          val1: new Map,
          val2: new Map,
          position: 0
        };
        else {
          var p = i.val1.get(r);
          if (p !== void 0) {
            var g = i.val2.get(e);
            if (g !== void 0) return p === g
          }
          i.position++
        }
        i.val1.set(r, i.position), i.val2.set(e, i.position);
        var m = IXe(r, e, t, s, i, n);
        return i.val1.delete(r), i.val2.delete(e), m
      }

      function Foe(r, e, t, i) {
        for (var n = K3(r), s = 0; s < n.length; s++) {
          var o = n[s];
          if (_o(e, o, t, i)) return r.delete(o), !0
        }
        return !1
      }

      function Uoe(r) {
        switch (Us(r)) {
          case "undefined":
            return null;
          case "object":
            return;
          case "symbol":
            return !1;
          case "string":
            r = +r;
          case "number":
            if (AT(r)) return !1
        }
        return !0
      }

      function TXe(r, e, t) {
        var i = Uoe(t);
        return i ?? (e.has(i) && !r.has(i))
      }

      function RXe(r, e, t, i, n) {
        var s = Uoe(t);
        if (s != null) return s;
        var o = e.get(s);
        return o === void 0 && !e.has(s) || !_o(i, o, !1, n) ? !1 : !r.has(s) && _o(i, o, !1, n)
      }

      function kXe(r, e, t, i) {
        for (var n = null, s = K3(r), o = 0; o < s.length; o++) {
          var a = s[o];
          if (Us(a) === "object" && a !== null) n === null && (n = new Set), n.add(a);
          else if (!e.has(a)) {
            if (t || !TXe(r, e, a)) return !1;
            n === null && (n = new Set), n.add(a)
          }
        }
        if (n !== null) {
          for (var c = K3(e), u = 0; u < c.length; u++) {
            var f = c[u];
            if (Us(f) === "object" && f !== null) {
              if (!Foe(n, f, t, i)) return !1
            } else if (!t && !r.has(f) && !Foe(n, f, t, i)) return !1
          }
          return n.size === 0
        }
        return !0
      }

      function Koe(r, e, t, i, n, s) {
        for (var o = K3(r), a = 0; a < o.length; a++) {
          var c = o[a];
          if (_o(t, c, n, s) && _o(i, e.get(c), n, s)) return r.delete(c), !0
        }
        return !1
      }

      function PXe(r, e, t, i) {
        for (var n = null, s = Ioe(r), o = 0; o < s.length; o++) {
          var a = Aoe(s[o], 2),
            c = a[0],
            u = a[1];
          if (Us(c) === "object" && c !== null) n === null && (n = new Set), n.add(c);
          else {
            var f = e.get(c);
            if (f === void 0 && !e.has(c) || !_o(u, f, t, i)) {
              if (t || !RXe(r, e, c, u, i)) return !1;
              n === null && (n = new Set), n.add(c)
            }
          }
        }
        if (n !== null) {
          for (var h = Ioe(e), d = 0; d < h.length; d++) {
            var p = Aoe(h[d], 2),
              c = p[0],
              g = p[1];
            if (Us(c) === "object" && c !== null) {
              if (!Koe(n, r, c, g, t, i)) return !1
            } else if (!t && (!r.has(c) || !_o(r.get(c), g, !1, i)) && !Koe(n, r, c, g, !1, i)) return !1
          }
          return n.size === 0
        }
        return !0
      }

      function IXe(r, e, t, i, n, s) {
        var o = 0;
        if (s === Boe) {
          if (!kXe(r, e, t, n)) return !1
        } else if (s === Doe) {
          if (!PXe(r, e, t, n)) return !1
        } else if (s === RT)
          for (; o < r.length; o++)
            if (zg(r, o)) {
              if (!zg(e, o) || !_o(r[o], e[o], t, n)) return !1
            } else {
              if (zg(e, o)) return !1;
              for (var a = Object.keys(r); o < a.length; o++) {
                var c = a[o];
                if (!zg(e, c) || !_o(r[c], e[c], t, n)) return !1
              }
              return a.length === Object.keys(e).length
            } for (o = 0; o < i.length; o++) {
              var u = i[o];
              if (!_o(r[u], e[u], t, n)) return !1
            }
        return !0
      }

      function CXe(r, e) {
        return _o(r, e, wXe)
      }

      function OXe(r, e) {
        return _o(r, e, vXe)
      }
      xoe.exports = {
        isDeepEqual: CXe,
        isDeepStrictEqual: OXe
      }
    });
    var D3 = y((YSt, joe) => {
      l();
      "use strict";

      function If(r) {
        return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? If = function (t) {
          return typeof t
        } : If = function (t) {
          return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }, If(r)
      }

      function NXe(r, e) {
        if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function")
      }
      var qXe = hT(),
        Vg = qXe.codes,
        Voe = Vg.ERR_AMBIGUOUS_ARGUMENT,
        Hg = Vg.ERR_INVALID_ARG_TYPE,
        MXe = Vg.ERR_INVALID_ARG_VALUE,
        BXe = Vg.ERR_INVALID_RETURN_VALUE,
        Tf = Vg.ERR_MISSING_ARGS,
        sh = Use(),
        DXe = Yl(),
        LXe = DXe.inspect,
        Hoe = Yl().types,
        FXe = Hoe.isPromise,
        kT = Hoe.isRegExp,
        UXe = Object.assign ? Object.assign : jse().assign,
        Goe = Object.is ? Object.is : ET(),
        WSt = new Map,
        Rf, W3;

      function Gg() {
        var r = zoe();
        Rf = r.isDeepEqual, W3 = r.isDeepStrictEqual
      }
      var $oe = !1,
        zr = joe.exports = PT,
        Y3 = {};

      function fa(r) {
        throw r.message instanceof Error ? r.message : new sh(r)
      }

      function Woe(r, e, t, i, n) {
        var s = arguments.length,
          o;
        if (s === 0) o = "Failed";
        else if (s === 1) t = r, r = void 0;
        else {
          if ($oe === !1) {
            $oe = !0;
            var a = process.emitWarning ? process.emitWarning : console.warn.bind(console);
            a("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094")
          }
          s === 2 && (i = "!=")
        }
        if (t instanceof Error) throw t;
        var c = {
          actual: r,
          expected: e,
          operator: i === void 0 ? "fail" : i,
          stackStartFn: n || Woe
        };
        t !== void 0 && (c.message = t);
        var u = new sh(c);
        throw o && (u.message = o, u.generatedMessage = !0), u
      }
      zr.fail = Woe;
      zr.AssertionError = sh;

      function Yoe(r, e, t, i) {
        if (!t) {
          var n = !1;
          if (e === 0) n = !0, i = "No value argument passed to `assert.ok()`";
          else if (i instanceof Error) throw i;
          var s = new sh({
            actual: t,
            expected: !0,
            message: i,
            operator: "==",
            stackStartFn: r
          });
          throw s.generatedMessage = n, s
        }
      }

      function PT() {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        Yoe.apply(void 0, [PT, e.length].concat(e))
      }
      zr.ok = PT;
      zr.equal = function r(e, t, i) {
        if (arguments.length < 2) throw new Tf("actual", "expected");
        e != t && fa({
          actual: e,
          expected: t,
          message: i,
          operator: "==",
          stackStartFn: r
        })
      };
      zr.notEqual = function r(e, t, i) {
        if (arguments.length < 2) throw new Tf("actual", "expected");
        e == t && fa({
          actual: e,
          expected: t,
          message: i,
          operator: "!=",
          stackStartFn: r
        })
      };
      zr.deepEqual = function r(e, t, i) {
        if (arguments.length < 2) throw new Tf("actual", "expected");
        Rf === void 0 && Gg(), Rf(e, t) || fa({
          actual: e,
          expected: t,
          message: i,
          operator: "deepEqual",
          stackStartFn: r
        })
      };
      zr.notDeepEqual = function r(e, t, i) {
        if (arguments.length < 2) throw new Tf("actual", "expected");
        Rf === void 0 && Gg(), Rf(e, t) && fa({
          actual: e,
          expected: t,
          message: i,
          operator: "notDeepEqual",
          stackStartFn: r
        })
      };
      zr.deepStrictEqual = function r(e, t, i) {
        if (arguments.length < 2) throw new Tf("actual", "expected");
        Rf === void 0 && Gg(), W3(e, t) || fa({
          actual: e,
          expected: t,
          message: i,
          operator: "deepStrictEqual",
          stackStartFn: r
        })
      };
      zr.notDeepStrictEqual = Joe;

      function Joe(r, e, t) {
        if (arguments.length < 2) throw new Tf("actual", "expected");
        Rf === void 0 && Gg(), W3(r, e) && fa({
          actual: r,
          expected: e,
          message: t,
          operator: "notDeepStrictEqual",
          stackStartFn: Joe
        })
      }
      zr.strictEqual = function r(e, t, i) {
        if (arguments.length < 2) throw new Tf("actual", "expected");
        Goe(e, t) || fa({
          actual: e,
          expected: t,
          message: i,
          operator: "strictEqual",
          stackStartFn: r
        })
      };
      zr.notStrictEqual = function r(e, t, i) {
        if (arguments.length < 2) throw new Tf("actual", "expected");
        Goe(e, t) && fa({
          actual: e,
          expected: t,
          message: i,
          operator: "notStrictEqual",
          stackStartFn: r
        })
      };
      var Xoe = function r(e, t, i) {
        var n = this;
        NXe(this, r), t.forEach(function (s) {
          s in e && (i !== void 0 && typeof i[s] == "string" && kT(e[s]) && e[s].test(i[s]) ? n[s] = i[s] : n[s] = e[s])
        })
      };

      function KXe(r, e, t, i, n, s) {
        if (!(t in r) || !W3(r[t], e[t])) {
          if (!i) {
            var o = new Xoe(r, n),
              a = new Xoe(e, n, r),
              c = new sh({
                actual: o,
                expected: a,
                operator: "deepStrictEqual",
                stackStartFn: s
              });
            throw c.actual = r, c.expected = e, c.operator = s.name, c
          }
          fa({
            actual: r,
            expected: e,
            message: i,
            operator: s.name,
            stackStartFn: s
          })
        }
      }

      function Zoe(r, e, t, i) {
        if (typeof e != "function") {
          if (kT(e)) return e.test(r);
          if (arguments.length === 2) throw new Hg("expected", ["Function", "RegExp"], e);
          if (If(r) !== "object" || r === null) {
            var n = new sh({
              actual: r,
              expected: e,
              message: t,
              operator: "deepStrictEqual",
              stackStartFn: i
            });
            throw n.operator = i.name, n
          }
          var s = Object.keys(e);
          if (e instanceof Error) s.push("name", "message");
          else if (s.length === 0) throw new MXe("error", e, "may not be an empty object");
          return Rf === void 0 && Gg(), s.forEach(function (o) {
            typeof r[o] == "string" && kT(e[o]) && e[o].test(r[o]) || KXe(r, e, o, t, s, i)
          }), !0
        }
        return e.prototype !== void 0 && r instanceof e ? !0 : Error.isPrototypeOf(e) ? !1 : e.call({}, r) === !0
      }

      function Qoe(r) {
        if (typeof r != "function") throw new Hg("fn", "Function", r);
        try {
          r()
        } catch (e) {
          return e
        }
        return Y3
      }

      function eae(r) {
        return FXe(r) || r !== null && If(r) === "object" && typeof r.then == "function" && typeof r.catch == "function"
      }

      function tae(r) {
        return Promise.resolve().then(function () {
          var e;
          if (typeof r == "function") {
            if (e = r(), !eae(e)) throw new BXe("instance of Promise", "promiseFn", e)
          } else if (eae(r)) e = r;
          else throw new Hg("promiseFn", ["Function", "Promise"], r);
          return Promise.resolve().then(function () {
            return e
          }).then(function () {
            return Y3
          }).catch(function (t) {
            return t
          })
        })
      }

      function rae(r, e, t, i) {
        if (typeof t == "string") {
          if (arguments.length === 4) throw new Hg("error", ["Object", "Error", "Function", "RegExp"], t);
          if (If(e) === "object" && e !== null) {
            if (e.message === t) throw new Voe("error/message", 'The error message "'.concat(e.message, '" is identical to the message.'))
          } else if (e === t) throw new Voe("error/message", 'The error "'.concat(e, '" is identical to the message.'));
          i = t, t = void 0
        } else if (t != null && If(t) !== "object" && typeof t != "function") throw new Hg("error", ["Object", "Error", "Function", "RegExp"], t);
        if (e === Y3) {
          var n = "";
          t && t.name && (n += " (".concat(t.name, ")")), n += i ? ": ".concat(i) : ".";
          var s = r.name === "rejects" ? "rejection" : "exception";
          fa({
            actual: void 0,
            expected: t,
            operator: r.name,
            message: "Missing expected ".concat(s).concat(n),
            stackStartFn: r
          })
        }
        if (t && !Zoe(e, t, i, r)) throw e
      }

      function iae(r, e, t, i) {
        if (e !== Y3) {
          if (typeof t == "string" && (i = t, t = void 0), !t || Zoe(e, t)) {
            var n = i ? ": ".concat(i) : ".",
              s = r.name === "doesNotReject" ? "rejection" : "exception";
            fa({
              actual: e,
              expected: t,
              operator: r.name,
              message: "Got unwanted ".concat(s).concat(n, `
`) + 'Actual message: "'.concat(e && e.message, '"'),
              stackStartFn: r
            })
          }
          throw e
        }
      }
      zr.throws = function r(e) {
        for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];
        rae.apply(void 0, [r, Qoe(e)].concat(i))
      };
      zr.rejects = function r(e) {
        for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];
        return tae(e).then(function (s) {
          return rae.apply(void 0, [r, s].concat(i))
        })
      };
      zr.doesNotThrow = function r(e) {
        for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];
        iae.apply(void 0, [r, Qoe(e)].concat(i))
      };
      zr.doesNotReject = function r(e) {
        for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];
        return tae(e).then(function (s) {
          return iae.apply(void 0, [r, s].concat(i))
        })
      };
      zr.ifError = function r(e) {
        if (e != null) {
          var t = "ifError got unwanted exception: ";
          If(e) === "object" && typeof e.message == "string" ? e.message.length === 0 && e.constructor ? t += e.constructor.name : t += e.message : t += LXe(e);
          var i = new sh({
            actual: e,
            expected: null,
            operator: "ifError",
            message: t,
            stackStartFn: r
          }),
            n = e.stack;
          if (typeof n == "string") {
            var s = n.split(`
`);
            s.shift();
            for (var o = i.stack.split(`
`), a = 0; a < s.length; a++) {
              var c = o.indexOf(s[a]);
              if (c !== -1) {
                o = o.slice(0, c);
                break
              }
            }
            i.stack = "".concat(o.join(`
`), `
`).concat(s.join(`
`))
          }
          throw i
        }
      };

      function nae() {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        Yoe.apply(void 0, [nae, e.length].concat(e))
      }
      zr.strict = UXe(nae, zr, {
        equal: zr.strictEqual,
        deepEqual: zr.deepStrictEqual,
        notEqual: zr.notStrictEqual,
        notDeepEqual: zr.notDeepStrictEqual
      });
      zr.strict.strict = zr.strict
    });
    var aae = y((JSt, sae) => {
      l();
      "use strict";
      var oae = b3();
      sae.exports = function (r, ...e) {
        e.length === 0 ? oae(r) : oae(() => r(...e))
      }
    });
    var lae = y((XSt, cae) => {
      l();
      "use strict";
      var J3 = Br().EventEmitter,
        zXe = Yl().inherits,
        uae = wne(),
        jXe = Sse(),
        VXe = Ose(),
        W0 = B3(),
        HXe = xI(),
        GXe = D3(),
        oh = aT(),
        $g = Cg().getCallback,
        Y0 = Cg().getOptions,
        X3 = aae(),
        Z3 = W0.WriteError,
        fae = W0.ReadError,
        $Xe = W0.NotFoundError,
        WXe = W0.OpenError,
        YXe = W0.InitializationError;

      function Pr(r, e, t) {
        if (!(this instanceof Pr)) return new Pr(r, e, t);
        let i;
        if (J3.call(this), this.setMaxListeners(Infinity), typeof e == "function" && (t = e, e = {}), e = e || {}, !r || typeof r != "object") {
          if (i = new YXe("First argument must be an abstract-leveldown compliant store"), typeof t == "function") return X3(t, i);
          throw i
        }
        GXe.strictEqual(typeof r.status, "string", ".status required, old abstract-leveldown"), this.options = Y0(e), this._db = r, this.db = new uae(r), this.open(t || (n => {
          n && this.emit("error", n)
        })), this.supports = HXe(this.db.supports, {
          status: !1,
          deferredOpen: !0,
          openCallback: !0,
          promises: !0,
          streams: !0
        });
        for (let n of Object.keys(this.supports.additionalMethods)) this[n] == null && (this[n] = function (...s) {
          return this.db[n](...s)
        })
      }
      Pr.prototype.emit = J3.prototype.emit;
      Pr.prototype.once = J3.prototype.once;
      zXe(Pr, J3);
      Pr.prototype.open = function (r, e) {
        return typeof r == "function" && (e = r, r = null), e = oh.fromCallback(e), r || (r = this.options), this.isOpen() ? (X3(e, null, this), e.promise) : this._isOpening() ? (this.once("open", () => {
          e(null, this)
        }), e.promise) : (this.emit("opening"), this.db.open(r, t => {
          if (t) return e(new WXe(t));
          this.db = this._db, e(null, this), this.emit("open"), this.emit("ready")
        }), e.promise)
      };
      Pr.prototype.close = function (r) {
        return r = oh.fromCallback(r), this.isOpen() ? (this.db.close((e, ...t) => {
          this.emit("closed"), r(e, ...t)
        }), this.emit("closing"), this.db = new uae(this._db)) : this.isClosed() ? X3(r) : this.db.status === "closing" ? this.once("closed", r) : this._isOpening() && this.once("open", () => {
          this.close(r)
        }), r.promise
      };
      Pr.prototype.isOpen = function () {
        return this.db.status === "open"
      };
      Pr.prototype._isOpening = function () {
        return this.db.status === "opening"
      };
      Pr.prototype.isClosed = function () {
        return /^clos|new/.test(this.db.status)
      };
      Pr.prototype.get = function (r, e, t) {
        return t = $g(e, t), t = oh.fromCallback(t), Wg(this, t) || (e = Y0(e), this.db.get(r, e, function (i, n) {
          if (i) return /notfound/i.test(i) || i.notFound ? i = new $Xe("Key not found in database [" + r + "]", i) : i = new fae(i), t(i);
          t(null, n)
        })), t.promise
      };
      Pr.prototype.put = function (r, e, t, i) {
        return i = $g(t, i), i = oh.fromCallback(i), Wg(this, i) || (t = Y0(t), this.db.put(r, e, t, n => {
          if (n) return i(new Z3(n));
          this.emit("put", r, e), i()
        })), i.promise
      };
      Pr.prototype.del = function (r, e, t) {
        return t = $g(e, t), t = oh.fromCallback(t), Wg(this, t) || (e = Y0(e), this.db.del(r, e, i => {
          if (i) return t(new Z3(i));
          this.emit("del", r), t()
        })), t.promise
      };
      Pr.prototype.batch = function (r, e, t) {
        return arguments.length ? (typeof r == "function" ? t = r : t = $g(e, t), t = oh.fromCallback(t), Wg(this, t) || (e = Y0(e), this.db.batch(r, e, i => {
          if (i) return t(new Z3(i));
          this.emit("batch", r), t()
        })), t.promise) : new VXe(this)
      };
      Pr.prototype.iterator = function (r) {
        return this.db.iterator(r)
      };
      Pr.prototype.clear = function (r, e) {
        return e = $g(r, e), r = Y0(r), e = oh.fromCallback(e), Wg(this, e) || this.db.clear(r, t => {
          if (t) return e(new Z3(t));
          this.emit("clear", r), e()
        }), e.promise
      };
      Pr.prototype.readStream = Pr.prototype.createReadStream = function (r) {
        return r = Object.assign({
          keys: !0,
          values: !0
        }, r), typeof r.limit != "number" && (r.limit = -1), new jXe(this.db.iterator(r), r)
      };
      Pr.prototype.keyStream = Pr.prototype.createKeyStream = function (r) {
        return this.createReadStream(Object.assign({}, r, {
          keys: !0,
          values: !1
        }))
      };
      Pr.prototype.valueStream = Pr.prototype.createValueStream = function (r) {
        return this.createReadStream(Object.assign({}, r, {
          keys: !1,
          values: !0
        }))
      };
      Pr.prototype.toString = function () {
        return "LevelUP"
      };
      Pr.prototype.type = "levelup";

      function Wg(r, e) {
        if (!r._isOpening() && !r.isOpen()) return X3(e, new fae("Database is not open")), !0
      }
      Pr.errors = W0;
      cae.exports = Pr
    });
    var hae = y(su => {
      l();
      "use strict";
      var {
        Buffer: CT
      } = Wt();
      su.utf8 = su["utf-8"] = {
        encode: function (r) {
          return OT(r) ? r : String(r)
        },
        decode: Q3,
        buffer: !1,
        type: "utf8"
      };
      su.json = {
        encode: JSON.stringify,
        decode: JSON.parse,
        buffer: !1,
        type: "json"
      };
      su.binary = {
        encode: function (r) {
          return OT(r) ? r : CT.from(r)
        },
        decode: Q3,
        buffer: !0,
        type: "binary"
      };
      su.none = {
        encode: Q3,
        decode: Q3,
        buffer: !1,
        type: "id"
      };
      su.id = su.none;
      var JXe = ["hex", "ascii", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le"];
      for (let r of JXe) su[r] = {
        encode: function (e) {
          return OT(e) ? e : CT.from(e, r)
        },
        decode: function (e) {
          return e.toString(r)
        },
        buffer: !0,
        type: r
      };

      function Q3(r) {
        return r
      }

      function OT(r) {
        return r == null || CT.isBuffer(r)
      }
    });
    var pae = y((QSt, dae) => {
      l();
      "use strict";
      var NT = hae(),
        XXe = new Set(["lt", "gt", "lte", "gte"]);
      dae.exports = Yn;

      function Yn(r) {
        if (!(this instanceof Yn)) return new Yn(r);
        this.opts = r || {}, this.encodings = NT
      }
      Yn.prototype._encoding = function (r) {
        return typeof r == "string" && (r = NT[r]), r || (r = NT.id), r
      };
      Yn.prototype._keyEncoding = function (r, e) {
        return this._encoding(e && e.keyEncoding || r && r.keyEncoding || this.opts.keyEncoding)
      };
      Yn.prototype._valueEncoding = function (r, e) {
        return this._encoding(e && (e.valueEncoding || e.encoding) || r && (r.valueEncoding || r.encoding) || this.opts.valueEncoding || this.opts.encoding)
      };
      Yn.prototype.encodeKey = function (r, e, t) {
        return this._keyEncoding(e, t).encode(r)
      };
      Yn.prototype.encodeValue = function (r, e, t) {
        return this._valueEncoding(e, t).encode(r)
      };
      Yn.prototype.decodeKey = function (r, e) {
        return this._keyEncoding(e).decode(r)
      };
      Yn.prototype.decodeValue = function (r, e) {
        return this._valueEncoding(e).decode(r)
      };
      Yn.prototype.encodeBatch = function (r, e) {
        return r.map(t => {
          let i = {
            type: t.type,
            key: this.encodeKey(t.key, e, t)
          };
          return this.keyAsBuffer(e, t) && (i.keyEncoding = "binary"), t.prefix && (i.prefix = t.prefix), "value" in t && (i.value = this.encodeValue(t.value, e, t), this.valueAsBuffer(e, t) && (i.valueEncoding = "binary")), i
        })
      };
      Yn.prototype.encodeLtgt = function (r) {
        let e = {};
        for (let t of Object.keys(r)) {
          if (t === "start" || t === "end") throw new Error('Legacy range options ("start" and "end") have been removed');
          e[t] = XXe.has(t) ? this.encodeKey(r[t], r) : r[t]
        }
        return e
      };
      Yn.prototype.createStreamDecoder = function (r) {
        return r.keys && r.values ? (e, t) => ({
          key: this.decodeKey(e, r),
          value: this.decodeValue(t, r)
        }) : r.keys ? e => this.decodeKey(e, r) : r.values ? (e, t) => this.decodeValue(t, r) : function () { }
      };
      Yn.prototype.keyAsBuffer = function (r) {
        return this._keyEncoding(r).buffer
      };
      Yn.prototype.valueAsBuffer = function (r) {
        return this._valueEncoding(r).buffer
      }
    });
    var wae = y((e5t, yae) => {
      l();
      "use strict";
      var gae = wf().AbstractLevelDOWN,
        bae = wf().AbstractChainedBatch,
        mae = wf().AbstractIterator,
        qT = dn(),
        ZXe = pae(),
        vae = B3().EncodingError,
        QXe = ["approximateSize", "compactRange"];
      yae.exports = Pn;

      function Pn(r, e) {
        if (!(this instanceof Pn)) return new Pn(r, e);
        let t = r.supports || {},
          i = t.additionalMethods || {};
        gae.call(this, t), this.supports.encodings = !0, this.supports.additionalMethods = {}, QXe.forEach(function (n) {
          let s = typeof r[n] == "function";
          (i[n] || s) && (this.supports.additionalMethods[n] = !0, this[n] = function (o, a, c, u) {
            return o = this.codec.encodeKey(o, c), a = this.codec.encodeKey(a, c), this.db[n](o, a, c, u)
          })
        }, this), e = e || {}, typeof e.keyEncoding == "undefined" && (e.keyEncoding = "utf8"), typeof e.valueEncoding == "undefined" && (e.valueEncoding = "utf8"), this.db = r, this.codec = new ZXe(e)
      }
      qT(Pn, gae);
      Pn.prototype.type = "encoding-down";
      Pn.prototype._serializeKey = Pn.prototype._serializeValue = function (r) {
        return r
      };
      Pn.prototype._open = function (r, e) {
        this.db.open(r, e)
      };
      Pn.prototype._close = function (r) {
        this.db.close(r)
      };
      Pn.prototype._put = function (r, e, t, i) {
        r = this.codec.encodeKey(r, t), e = this.codec.encodeValue(e, t), this.db.put(r, e, t, i)
      };
      Pn.prototype._get = function (r, e, t) {
        r = this.codec.encodeKey(r, e), e.asBuffer = this.codec.valueAsBuffer(e), this.db.get(r, e, (i, n) => {
          if (i) return t(i);
          try {
            n = this.codec.decodeValue(n, e)
          } catch (s) {
            return t(new vae(s))
          }
          t(null, n)
        })
      };
      Pn.prototype._del = function (r, e, t) {
        r = this.codec.encodeKey(r, e), this.db.del(r, e, t)
      };
      Pn.prototype._chainedBatch = function () {
        return new J0(this)
      };
      Pn.prototype._batch = function (r, e, t) {
        r = this.codec.encodeBatch(r, e), this.db.batch(r, e, t)
      };
      Pn.prototype._iterator = function (r) {
        return r.keyAsBuffer = this.codec.keyAsBuffer(r), r.valueAsBuffer = this.codec.valueAsBuffer(r), new Yg(this, r)
      };
      Pn.prototype._clear = function (r, e) {
        r = this.codec.encodeLtgt(r), this.db.clear(r, e)
      };

      function Yg(r, e) {
        mae.call(this, r), this.codec = r.codec, this.keys = e.keys, this.values = e.values, this.opts = this.codec.encodeLtgt(e), this.it = r.db.iterator(this.opts)
      }
      qT(Yg, mae);
      Yg.prototype._next = function (r) {
        this.it.next((e, t, i) => {
          if (e) return r(e);
          try {
            this.keys && typeof t != "undefined" ? t = this.codec.decodeKey(t, this.opts) : t = void 0, this.values && typeof i != "undefined" ? i = this.codec.decodeValue(i, this.opts) : i = void 0
          } catch (n) {
            return r(new vae(n))
          }
          r(null, t, i)
        })
      };
      Yg.prototype._seek = function (r) {
        r = this.codec.encodeKey(r, this.opts), this.it.seek(r)
      };
      Yg.prototype._end = function (r) {
        this.it.end(r)
      };

      function J0(r, e) {
        bae.call(this, r), this.codec = r.codec, this.batch = r.db.batch()
      }
      qT(J0, bae);
      J0.prototype._put = function (r, e, t) {
        r = this.codec.encodeKey(r, t), e = this.codec.encodeValue(e, t), this.batch.put(r, e)
      };
      J0.prototype._del = function (r, e) {
        r = this.codec.encodeKey(r, e), this.batch.del(r)
      };
      J0.prototype._clear = function () {
        this.batch.clear()
      };
      J0.prototype._write = function (r, e) {
        this.batch.write(r, e)
      }
    });
    var Sae = y((t5t, _ae) => {
      l();
      "use strict";
      var Eae = lae(),
        eZe = wae();

      function tZe(r) {
        function e(i, n, s) {
          return typeof i == "function" ? s = i : typeof n == "function" && (s = n), t(n) || (n = t(i) ? i : {}), Eae(eZe(r(i, n), n), n, s)
        }

        function t(i) {
          return typeof i == "object" && i !== null
        }
        for (let i of ["destroy", "repair"]) typeof r[i] == "function" && (e[i] = function (...n) {
          r[i](...n)
        });
        return e.errors = Eae.errors, e
      }
      _ae.exports = tZe
    });
    var Aae = y(li => {
      l();
      li.compare = function (r, e) {
        if (Buffer.isBuffer(r)) {
          for (var t = Math.min(r.length, e.length), i = 0; i < t; i++) {
            var n = r[i] - e[i];
            if (n) return n
          }
          return r.length - e.length
        }
        return r < e ? -1 : r > e ? 1 : 0
      };

      function xae(r) {
        return r !== void 0 && r !== ""
      }

      function X0(r, e) {
        return Object.hasOwnProperty.call(r, e)
      }

      function lc(r, e) {
        return Object.hasOwnProperty.call(r, e) && e
      }
      var rZe = li.lowerBoundKey = function (r) {
        return lc(r, "gt") || lc(r, "gte") || lc(r, "min") || (r.reverse ? lc(r, "end") : lc(r, "start")) || void 0
      },
        MT = li.lowerBound = function (r, e) {
          var t = rZe(r);
          return t ? r[t] : e
        },
        BT = li.lowerBoundInclusive = function (r) {
          return !X0(r, "gt")
        },
        DT = li.upperBoundInclusive = function (r) {
          return !X0(r, "lt")
        },
        iZe = li.lowerBoundExclusive = function (r) {
          return !BT(r)
        },
        nZe = li.upperBoundExclusive = function (r) {
          return !DT(r)
        },
        sZe = li.upperBoundKey = function (r) {
          return lc(r, "lt") || lc(r, "lte") || lc(r, "max") || (r.reverse ? lc(r, "start") : lc(r, "end")) || void 0
        },
        LT = li.upperBound = function (r, e) {
          var t = sZe(r);
          return t ? r[t] : e
        };
      li.start = function (r, e) {
        return r.reverse ? LT(r, e) : MT(r, e)
      };
      li.end = function (r, e) {
        return r.reverse ? MT(r, e) : LT(r, e)
      };
      li.startInclusive = function (r) {
        return r.reverse ? DT(r) : BT(r)
      };
      li.endInclusive = function (r) {
        return r.reverse ? BT(r) : DT(r)
      };

      function oZe(r) {
        return r
      }
      li.toLtgt = function (r, e, t, i, n) {
        e = e || {}, t = t || oZe;
        var s = arguments.length > 3,
          o = li.lowerBoundKey(r),
          a = li.upperBoundKey(r);
        return o ? o === "gt" ? e.gt = t(r.gt, !1) : e.gte = t(r[o], !1) : s && (e.gte = t(i, !1)), a ? a === "lt" ? e.lt = t(r.lt, !0) : e.lte = t(r[a], !0) : s && (e.lte = t(n, !0)), r.reverse != null && (e.reverse = !!r.reverse), X0(e, "max") && delete e.max, X0(e, "min") && delete e.min, X0(e, "start") && delete e.start, X0(e, "end") && delete e.end, e
      };
      li.contains = function (r, e, t) {
        t = t || li.compare;
        var i = MT(r);
        if (xae(i)) {
          var n = t(e, i);
          if (n < 0 || n === 0 && iZe(r)) return !1
        }
        var s = LT(r);
        if (xae(s)) {
          var n = t(e, s);
          if (n > 0 || n === 0 && nZe(r)) return !1
        }
        return !0
      };
      li.filter = function (r, e) {
        return function (t) {
          return li.contains(r, t, e)
        }
      }
    });
    var FT = y((i5t, Iae) => {
      l();
      "use strict";
      var e_ = Aae(),
        kf = Symbol("none");
      Iae.exports = function (e) {
        let t = e_.lowerBound(e, kf),
          i = e_.upperBound(e, kf),
          n = e_.lowerBoundExclusive(e, kf),
          s = e_.upperBoundExclusive(e, kf);
        return t !== kf && i !== kf ? IDBKeyRange.bound(t, i, n, s) : t !== kf ? IDBKeyRange.lowerBound(t, n) : i !== kf ? IDBKeyRange.upperBound(i, s) : null
      }
    });
    var UT = y((n5t, Tae) => {
      l();
      "use strict";
      var t_ = Wt().Buffer,
        aZe = function () {
          if (globalThis.TextDecoder) {
            let r = new TextDecoder("utf-8");
            return r.decode.bind(r)
          } else return function (e) {
            return Rae(e).toString()
          }
        }(),
        cZe = function () {
          if (globalThis.TextDecoder) {
            let r = new TextDecoder("utf-8");
            return r.decode.bind(r)
          } else return function (e) {
            return t_.from(e).toString()
          }
        }();

      function Rae(r) {
        let e = t_.from(r.buffer);
        return r.byteLength === r.buffer.byteLength ? e : e.slice(r.byteOffset, r.byteOffset + r.byteLength)
      }
      Tae.exports = function (r, e) {
        return r instanceof Uint8Array ? e ? Rae(r) : aZe(r) : r instanceof ArrayBuffer ? e ? t_.from(r) : cZe(r) : e ? t_.from(String(r)) : String(r)
      }
    });
    var Oae = y((s5t, kae) => {
      l();
      "use strict";
      var uZe = dn(),
        Pae = wf().AbstractIterator,
        fZe = FT(),
        Cae = UT(),
        lZe = function () { };
      kae.exports = la;

      function la(r, e, t) {
        if (Pae.call(this, r), this._limit = t.limit, this._count = 0, this._callback = null, this._cache = [], this._completed = !1, this._aborted = !1, this._error = null, this._transaction = null, this._keys = t.keys, this._values = t.values, this._keyAsBuffer = t.keyAsBuffer, this._valueAsBuffer = t.valueAsBuffer, this._limit === 0) {
          this._completed = !0;
          return
        }
        let i;
        try {
          i = fZe(t)
        } catch (n) {
          this._completed = !0;
          return
        }
        this.createIterator(e, i, t.reverse)
      }
      uZe(la, Pae);
      la.prototype.createIterator = function (r, e, t) {
        let i = this.db.db.transaction([r], "readonly"),
          s = i.objectStore(r).openCursor(e, t ? "prev" : "next");
        s.onsuccess = o => {
          let a = o.target.result;
          a && this.onItem(a)
        }, this._transaction = i, i.onabort = () => {
          this.onAbort(this._transaction.error || new Error("aborted by user"))
        }, i.oncomplete = () => {
          this.onComplete()
        }
      };
      la.prototype.onItem = function (r) {
        this._cache.push(r.key, r.value), (this._limit <= 0 || ++this._count < this._limit) && r.continue(), this.maybeNext()
      };
      la.prototype.onAbort = function (r) {
        this._aborted = !0, this._error = r, this.maybeNext()
      };
      la.prototype.onComplete = function () {
        this._completed = !0, this.maybeNext()
      };
      la.prototype.maybeNext = function () {
        this._callback && (this._next(this._callback), this._callback = null)
      };
      la.prototype._next = function (r) {
        if (this._aborted) {
          let e = this._error;
          this._error = null, this._nextTick(r, e)
        } else if (this._cache.length > 0) {
          let e = this._cache.shift(),
            t = this._cache.shift();
          this._keys && e !== void 0 ? e = this._deserializeKey(e, this._keyAsBuffer) : e = void 0, this._values && t !== void 0 ? t = this._deserializeValue(t, this._valueAsBuffer) : t = void 0, this._nextTick(r, null, e, t)
        } else this._completed ? this._nextTick(r) : this._callback = r
      };
      la.prototype._deserializeKey = Cae;
      la.prototype._deserializeValue = Cae;
      la.prototype._end = function (r) {
        if (this._aborted || this._completed) return this._nextTick(r, this._error);
        this.onItem = lZe, this.onAbort = r, this.onComplete = r
      }
    });
    var Mae = y((o5t, Nae) => {
      l();
      "use strict";
      var qae = Wt().Buffer,
        hZe = function () {
          if (globalThis.TextEncoder) {
            let r = new TextEncoder("utf-8");
            return r.encode.bind(r)
          } else return qae.from
        }();
      Nae.exports = function (r, e) {
        return e ? qae.isBuffer(r) ? r : hZe(String(r)) : String(r)
      }
    });
    var Bae = y(r_ => {
      l();
      "use strict";
      var dZe = Wt().Buffer;
      r_.test = function (r) {
        return function (t) {
          try {
            return t.cmp(r, 0), !0
          } catch (i) {
            return !1
          }
        }
      };
      r_.bufferKeys = r_.test(dZe.alloc(0))
    });
    var Lae = y((c5t, Dae) => {
      l();
      "use strict";
      Dae.exports = function (e, t, i, n, s) {
        if (n.limit === 0) return e._nextTick(s);
        let o = e.db.transaction([t], "readwrite"),
          a = o.objectStore(t),
          c = 0;
        o.oncomplete = function () {
          s()
        }, o.onabort = function () {
          s(o.error || new Error("aborted by user"))
        };
        let u = a.openKeyCursor ? "openKeyCursor" : "openCursor",
          f = n.reverse ? "prev" : "next";
        a[u](i, f).onsuccess = function (h) {
          let d = h.target.result;
          d && (a.delete(d.key).onsuccess = function () {
            (n.limit <= 0 || ++c < n.limit) && d.continue()
          })
        }
      }
    });
    var jae = y((u5t, Fae) => {
      l();
      "use strict";
      Fae.exports = Pi;
      var Uae = wf().AbstractLevelDOWN,
        pZe = dn(),
        yZe = Oae(),
        Kae = Mae(),
        KT = UT(),
        gZe = Bae(),
        bZe = Lae(),
        mZe = FT(),
        zae = "level-js-";

      function Pi(r, e) {
        if (!(this instanceof Pi)) return new Pi(r, e);
        if (Uae.call(this, {
          bufferKeys: gZe.bufferKeys(indexedDB),
          snapshots: !0,
          permanence: !0,
          clear: !0
        }), e = e || {}, typeof r != "string") throw new Error("constructor requires a location string argument");
        this.location = r, this.prefix = e.prefix == null ? zae : e.prefix, this.version = parseInt(e.version || 1, 10)
      }
      pZe(Pi, Uae);
      Pi.prototype.type = "level-js";
      Pi.prototype._open = function (r, e) {
        let t = indexedDB.open(this.prefix + this.location, this.version);
        t.onerror = function () {
          e(t.error || new Error("unknown error"))
        }, t.onsuccess = () => {
          this.db = t.result, e()
        }, t.onupgradeneeded = i => {
          let n = i.target.result;
          n.objectStoreNames.contains(this.location) || n.createObjectStore(this.location)
        }
      };
      Pi.prototype.store = function (r) {
        return this.db.transaction([this.location], r).objectStore(this.location)
      };
      Pi.prototype.await = function (r, e) {
        let t = r.transaction;
        t.onabort = function () {
          e(t.error || new Error("aborted by user"))
        }, t.oncomplete = function () {
          e(null, r.result)
        }
      };
      Pi.prototype._get = function (r, e, t) {
        let i = this.store("readonly"),
          n;
        try {
          n = i.get(r)
        } catch (s) {
          return this._nextTick(t, s)
        }
        this.await(n, function (s, o) {
          if (s) return t(s);
          if (o === void 0) return t(new Error("NotFound"));
          t(null, KT(o, e.asBuffer))
        })
      };
      Pi.prototype._del = function (r, e, t) {
        let i = this.store("readwrite"),
          n;
        try {
          n = i.delete(r)
        } catch (s) {
          return this._nextTick(t, s)
        }
        this.await(n, t)
      };
      Pi.prototype._put = function (r, e, t, i) {
        let n = this.store("readwrite"),
          s;
        try {
          s = n.put(e, r)
        } catch (o) {
          return this._nextTick(i, o)
        }
        this.await(s, i)
      };
      Pi.prototype._serializeKey = function (r) {
        return Kae(r, this.supports.bufferKeys)
      };
      Pi.prototype._serializeValue = function (r) {
        return Kae(r, !0)
      };
      Pi.prototype._iterator = function (r) {
        return new yZe(this, this.location, r)
      };
      Pi.prototype._batch = function (r, e, t) {
        if (r.length === 0) return this._nextTick(t);
        let i = this.store("readwrite"),
          n = i.transaction,
          s = 0,
          o;
        n.onabort = function () {
          t(o || n.error || new Error("aborted by user"))
        }, n.oncomplete = function () {
          t()
        };

        function a() {
          let c = r[s++],
            u = c.key,
            f;
          try {
            f = c.type === "del" ? i.delete(u) : i.put(c.value, u)
          } catch (h) {
            o = h, n.abort();
            return
          }
          s < r.length && (f.onsuccess = a)
        }
        a()
      };
      Pi.prototype._clear = function (r, e) {
        let t, i;
        try {
          t = mZe(r)
        } catch (n) {
          return this._nextTick(e)
        }
        if (r.limit >= 0) return bZe(this, this.location, t, r, e);
        try {
          let n = this.store("readwrite");
          i = t ? n.delete(t) : n.clear()
        } catch (n) {
          return this._nextTick(e, n)
        }
        this.await(i, e)
      };
      Pi.prototype._close = function (r) {
        this.db.close(), this._nextTick(r)
      };
      Pi.prototype.upgrade = function (r) {
        if (this.status !== "open") return this._nextTick(r, new Error("cannot upgrade() before open()"));
        let e = this.iterator(),
          t = {},
          i = this;
        e._deserializeKey = e._deserializeValue = a, n();

        function n(c) {
          if (c) return o(c);
          e.next(s)
        }

        function s(c, u, f) {
          if (c || u === void 0) return o(c);
          let h = i._serializeKey(KT(u, !0)),
            d = i._serializeValue(KT(f, !0));
          i._batch([{
            type: "del",
            key: u
          }, {
            type: "put",
            key: h,
            value: d
          }], t, n)
        }

        function o(c) {
          e.end(function (u) {
            r(c || u)
          })
        }

        function a(c) {
          return c
        }
      };
      Pi.destroy = function (r, e, t) {
        typeof e == "function" && (t = e, e = zae);
        let i = indexedDB.deleteDatabase(e + r);
        i.onsuccess = function () {
          t()
        }, i.onerror = function (n) {
          t(n)
        }
      }
    });
    var Hae = y((f5t, Vae) => {
      l();
      Vae.exports = Sae()(jae())
    });
    var Z0 = y((l5t, Gae) => {
      l();
      "use strict";
      var {
        Key: vZe,
        Errors: Jg,
        Adapter: wZe,
        utils: {
          sortAll: $ae
        }
      } = fr(), i_ = xl(), _Ze = Qc(), Wae = ov(), Yae = class extends wZe {
        constructor(e, t) {
          super();
          this.path = e, this.opts = t, t && t.db ? (this.database = t.db, delete t.db) : this.database = Hae()
        }
        _initDb() {
          return new Promise((e, t) => {
            this.db = this.database(this.path, {
              ...this.opts,
              valueEncoding: "binary",
              compression: !1
            }, i => {
              if (i) return t(i);
              e(this.db)
            })
          })
        }
        async open() {
          try {
            this.db ? await this.db.open() : this.db = await this._initDb()
          } catch (e) {
            throw Jg.dbOpenFailedError(e)
          }
        }
        async put(e, t) {
          try {
            await this.db.put(e.toString(), t)
          } catch (i) {
            throw Jg.dbWriteFailedError(i)
          }
        }
        async get(e) {
          let t;
          try {
            t = await this.db.get(e.toString())
          } catch (i) {
            throw i.notFound ? Jg.notFoundError(i) : Jg.dbWriteFailedError(i)
          }
          return t
        }
        async has(e) {
          try {
            await this.db.get(e.toString())
          } catch (t) {
            if (t.notFound) return !1;
            throw t
          }
          return !0
        }
        async delete(e) {
          try {
            await this.db.del(e.toString())
          } catch (t) {
            throw Jg.dbDeleteFailedError(t)
          }
        }
        close() {
          return this.db && this.db.close()
        }
        batch() {
          let e = [];
          return {
            put: (t, i) => {
              e.push({
                type: "put",
                key: t.toString(),
                value: i
              })
            },
            delete: t => {
              e.push({
                type: "del",
                key: t.toString()
              })
            },
            commit: () => this.db.batch(e)
          }
        }
        query(e) {
          let t = this._query({
            values: !0,
            prefix: e.prefix
          });
          Array.isArray(e.filters) && (t = e.filters.reduce((s, o) => i_(s, o), t)), Array.isArray(e.orders) && (t = e.orders.reduce((s, o) => $ae(s, o), t));
          let {
            offset: i,
            limit: n
          } = e;
          if (i) {
            let s = 0;
            t = i_(t, () => s++ >= i)
          }
          return n && (t = Wae(t, n)), t
        }
        queryKeys(e) {
          let t = _Ze(this._query({
            values: !1,
            prefix: e.prefix
          }), ({
            key: s
          }) => s);
          Array.isArray(e.filters) && (t = e.filters.reduce((s, o) => i_(s, o), t)), Array.isArray(e.orders) && (t = e.orders.reduce((s, o) => $ae(s, o), t));
          let {
            offset: i,
            limit: n
          } = e;
          if (i) {
            let s = 0;
            t = i_(t, () => s++ >= i)
          }
          return n && (t = Wae(t, n)), t
        }
        _query(e) {
          let t = {
            keys: !0,
            keyAsBuffer: !0,
            values: e.values
          };
          if (e.prefix != null) {
            let i = e.prefix.toString();
            t.gte = i, t.lt = i + "\xFF"
          }
          return EZe(this.db.iterator(t))
        }
      };

      function EZe(r) {
        return {
          [Symbol.asyncIterator]() {
            return {
              next: () => new Promise((e, t) => {
                r.next((i, n, s) => {
                  if (i) return t(i);
                  if (n == null) return r.end(o => {
                    if (o) return t(o);
                    e({
                      done: !0,
                      value: void 0
                    })
                  });
                  e({
                    done: !1,
                    value: {
                      key: new vZe(n, !1),
                      value: s
                    }
                  })
                })
              }),
              return: () => new Promise((e, t) => {
                r.end(i => {
                  if (i) return t(i);
                  e({
                    done: !0,
                    value: void 0
                  })
                })
              })
            }
          }
        }
      }
      Gae.exports = Yae
    });
    var Xae = y((h5t, Jae) => {
      l();
      "use strict";
      Jae.exports = {
        autoMigrate: !0,
        onMigrationProgress: () => { },
        lock: "memory",
        storageBackends: {
          root: Z0(),
          blocks: Z0(),
          keys: Z0(),
          datastore: Z0(),
          pins: Z0()
        },
        storageBackendOptions: {
          root: {
            extension: "",
            prefix: "",
            version: 2
          },
          blocks: {
            sharding: !1,
            prefix: "",
            version: 2
          },
          keys: {
            sharding: !1,
            prefix: "",
            version: 2
          },
          datastore: {
            sharding: !1,
            prefix: "",
            version: 2
          },
          pins: {
            sharding: !1,
            prefix: "",
            version: 2
          }
        }
      }
    });
    var Qae = y((d5t, Zae) => {
      l();
      "use strict";
      Zae.exports = {
        Spec: {
          type: "mount",
          mounts: [{
            mountpoint: "/blocks",
            type: "measure",
            prefix: "flatfs.datastore",
            child: {
              type: "flatfs",
              path: "blocks",
              sync: !0,
              shardFunc: "/repo/flatfs/shard/v1/next-to-last/2"
            }
          }, {
            mountpoint: "/",
            type: "measure",
            prefix: "leveldb.datastore",
            child: {
              type: "levelds",
              path: "datastore",
              compression: "none"
            }
          }]
        }
      }
    });
    var jT = y(zT => {
      l();
      "use strict";
      var SZe = Gw(),
        xZe = Oe(),
        ece = xZe("ipfs:repo:lock"),
        tce = "repo.lock",
        Xg = {};
      zT.lock = async r => {
        let e = r + "/" + tce;
        if (ece("locking %s", e), Xg[e] === !0) throw new SZe.LockExistsError(`Lock already being held for file: ${e}`);
        return Xg[e] = !0, {
          async close() {
            Xg[e] && delete Xg[e]
          }
        }
      };
      zT.locked = async r => {
        let e = r + "/" + tce;
        return ece(`checking lock: ${e}`), Boolean(Xg[e])
      }
    });
    var o_ = y((y5t, Zg) => {
      l();
      "use strict";
      var rce = AA(),
        AZe = Oe(),
        Q0 = xe(),
        ice = gre(),
        IZe = vre(),
        n_ = _re(),
        TZe = Yr(),
        s_ = Sre(),
        Qg = Are(),
        RZe = Tre(),
        kZe = Pre(),
        PZe = Bre(),
        CZe = Lre(),
        OZe = jre(),
        NZe = Hre(),
        qZe = Xae(),
        nce = Qae(),
        ou = Gw(),
        vs = AZe("ipfs:repo"),
        MZe = Number.MAX_SAFE_INTEGER,
        BZe = "repoAutoMigrate",
        sce = {
          memory: jT(),
          fs: jT()
        },
        oce = class {
          constructor(e, t = {}) {
            if (typeof e != "string") throw new Error("missing repoPath");
            this.options = TZe(qZe, t), this.closed = !0, this.path = e, this._locker = this._getLocker(), this.root = Qg.create("root", this.path, this.options), this.datastore = Qg.create("datastore", n_(this.path, "datastore"), this.options), this.keys = Qg.create("keys", n_(this.path, "keys"), this.options), this.pins = Qg.create("pins", n_(this.path, "pins"), this.options);
            let i = Qg.create("blocks", n_(this.path, "blocks"), this.options),
              n = OZe(i, this.options.storageBackendOptions.blocks);
            this.blocks = NZe(n), this.version = RZe(this.root), this.config = kZe(this.root), this.spec = PZe(this.root), this.apiAddr = CZe(this.root)
          }
          async init(e) {
            vs("initializing at: %s", this.path), await this._openRoot(), await this.config.replace(DZe(e)), await this.spec.set(LZe(e)), await this.version.set(s_.repoVersion)
          }
          async isInitialized() {
            if (!this.closed) return !0;
            try {
              return await this._openRoot(), await this._checkInitialized(), await this.root.close(), !0
            } catch (e) {
              return !1
            }
          }
          async open() {
            if (!this.closed) throw Q0(new Error("repo is already open"), ou.ERR_REPO_ALREADY_OPEN);
            vs("opening at: %s", this.path);
            try {
              if (await this._openRoot(), await this._checkInitialized(), this.lockfile = await this._openLock(this.path), vs("acquired repo.lock"), !await this.version.check(s_.repoVersion))
                if (await this._isAutoMigrationEnabled()) await this._migrate(s_.repoVersion);
                else throw new ou.InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
              vs("creating datastore"), await this.datastore.open(), vs("creating blocks"), this.blocks.open(), vs("creating keystore"), await this.keys.open(), vs("creating pins"), await this.pins.open(), this.closed = !1, vs("all opened")
            } catch (e) {
              if (this.lockfile) try {
                await this._closeLock(), this.lockfile = null
              } catch (t) {
                vs("error removing lock", t)
              }
              throw e
            }
          }
          _getLocker() {
            if (typeof this.options.lock == "string") {
              if (!sce[this.options.lock]) throw new Error("Unknown lock type: " + this.options.lock);
              return sce[this.options.lock]
            }
            if (!this.options.lock) throw new Error("No lock provided");
            return this.options.lock
          }
          async _openRoot() {
            try {
              await this.root.open()
            } catch (e) {
              if (e.message !== "Already open") throw e
            }
          }
          async _openLock(e) {
            let t = await this._locker.lock(e);
            if (typeof t.close != "function") throw Q0(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
            return t
          }
          _closeLock() {
            return this.lockfile && this.lockfile.close()
          }
          async _checkInitialized() {
            vs("init check");
            let e;
            try {
              [e] = await Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()])
            } catch (t) {
              throw t.code === "ERR_NOT_FOUND" ? Q0(new Error("repo is not initialized yet"), ou.ERR_REPO_NOT_INITIALIZED, {
                path: this.path
              }) : t
            }
            if (!e) throw Q0(new Error("repo is not initialized yet"), ou.ERR_REPO_NOT_INITIALIZED, {
              path: this.path
            })
          }
          async close() {
            if (this.closed) throw Q0(new Error("repo is already closed"), ou.ERR_REPO_ALREADY_CLOSED);
            vs("closing at: %s", this.path);
            try {
              await this.apiAddr.delete()
            } catch (e) {
              if (e.code !== ou.ERR_REPO_NOT_INITIALIZED && !e.message.startsWith("ENOENT")) throw e
            }
            await Promise.all([this.root, this.blocks, this.keys, this.datastore, this.pins].map(e => e && e.close())), vs("unlocking"), this.closed = !0, await this._closeLock()
          }
          exists() {
            return this.version.exists()
          }
          async stat() {
            if (this.datastore && this.keys) {
              let [e, t, i, n, s] = await Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), ace(this.datastore), ace(this.keys)]), o = t.size + n + s;
              return {
                repoPath: this.path,
                storageMax: e,
                version: i,
                numObjects: t.count,
                repoSize: o
              }
            }
            throw Q0(new Error("repo is not initialized yet"), ou.ERR_REPO_NOT_INITIALIZED, {
              path: this.path
            })
          }
          async _isAutoMigrationEnabled() {
            if (this.options.autoMigrate !== void 0) return this.options.autoMigrate;
            let e;
            try {
              e = await this.config.get(BZe)
            } catch (t) {
              if (t.code === ou.NotFoundError.code) e = !0;
              else throw t
            }
            return e
          }
          async _migrate(e) {
            return await this.version.get() > e ? (vs(`reverting to version ${e}`), ice.revert(this.path, this.options, e, {
              ignoreLock: !0,
              onProgress: this.options.onMigrationProgress
            })) : (vs(`migrating to version ${e}`), ice.migrate(this.path, this.options, e, {
              ignoreLock: !0,
              onProgress: this.options.onMigrationProgress
            }))
          }
          async _storageMaxStat() {
            try {
              let e = await this.config.get("Datastore.StorageMax");
              return BigInt(IZe(e))
            } catch (e) {
              return BigInt(MZe)
            }
          }
          async _blockStat() {
            let e = BigInt(0),
              t = BigInt(0);
            if (this.blocks)
              for await (let i of this.blocks.query({})) {
                let n = i;
                e += BigInt(1), t += BigInt(n.data.byteLength), t += BigInt(n.cid.bytes.byteLength)
              }
            return {
              count: e,
              size: t
            }
          }
        };
      async function ace(r) {
        let e = BigInt(0);
        for await (let t of r.query({})) e += BigInt(t.value.byteLength), e += BigInt(t.key.uint8Array().byteLength);
        return e
      }
      Zg.exports = oce;
      Zg.exports.utils = {
        blockstore: QA()
      };
      Zg.exports.repoVersion = s_.repoVersion;
      Zg.exports.errors = ou;

      function DZe(r) {
        return r.Datastore = Object.assign({}, nce, rce(r, "datastore")), r
      }

      function LZe(r) {
        let e = {
          ...nce.Spec,
          ...rce(r, "Datastore.Spec")
        };
        return {
          type: e.type,
          mounts: e.mounts.map(t => ({
            mountpoint: t.mountpoint,
            type: t.child.type,
            path: t.child.path,
            shardFunc: t.child.shardFunc
          }))
        }
      }
    });
    var uce = y((g5t, cce) => {
      l();
      "use strict";
      var {
        repoVersion: FZe
      } = o_(), UZe = ze();
      cce.exports = ({
        repo: r
      }) => {
        async function e(t = {}) {
          try {
            await r._checkInitialized(t)
          } catch (i) {
            if ([/Key not found in database \[\/version\]/, /ENOENT/, /repo is not initialized yet/].some(s => s.test(i.message))) return FZe;
            throw i
          }
          return r.version.get()
        }
        return UZe(e)
      }
    });
    var hce = y((b5t, fce) => {
      l();
      "use strict";
      var KZe = gte(),
        zZe = xA(),
        jZe = uce(),
        lce = class {
          constructor({
            gcLock: e,
            pin: t,
            repo: i,
            refs: n
          }) {
            this.gc = KZe({
              gcLock: e,
              pin: t,
              refs: n,
              repo: i
            }), this.stat = zZe({
              repo: i
            }), this.version = jZe({
              repo: i
            })
          }
        };
      fce.exports = lce
    });
    var yce = y((m5t, dce) => {
      l();
      "use strict";
      var {
        default: VZe
      } = av(), HZe = xe(), GZe = ze();

      function pce(r, e) {
        let t;
        if (r.metrics ? e.peer ? t = r.metrics.forPeer(e.peer) : e.proto ? t = r.metrics.forProtocol(e.proto) : t = r.metrics.global : t = void 0, !t) return {
          totalIn: BigInt(0),
          totalOut: BigInt(0),
          rateIn: BigInt(0),
          rateOut: BigInt(0)
        };
        let {
          movingAverages: i,
          snapshot: n
        } = t;
        return {
          totalIn: BigInt(n.dataReceived.toString()),
          totalOut: BigInt(n.dataSent.toString()),
          rateIn: BigInt(i.dataReceived[6e4].movingAverage() / 60),
          rateOut: BigInt(i.dataSent[6e4].movingAverage() / 60)
        }
      }
      dce.exports = ({
        network: r
      }) => GZe(async function* (t = {}) {
        let {
          libp2p: i
        } = await r.use(t);
        if (!t.poll) {
          yield pce(i, t);
          return
        }
        let n = t.interval || 1e3,
          s = -1;
        try {
          if (s = typeof n == "string" ? VZe(n) || -1 : n, !s || s < 0) throw new Error("invalid duration")
        } catch (a) {
          throw HZe(a, "ERR_INVALID_POLL_INTERVAL")
        }
        let o;
        try {
          for (; ;) yield pce(i, t), await new Promise(a => {
            o = setTimeout(a, s)
          })
        } finally {
          clearTimeout(o)
        }
      })
    });
    var mce = y((v5t, gce) => {
      l();
      "use strict";
      var $Ze = yce(),
        WZe = xA(),
        YZe = Tx(),
        bce = class {
          constructor({
            repo: e,
            network: t
          }) {
            this.repo = WZe({
              repo: e
            }), this.bw = $Ze({
              network: t
            }), this.bitswap = YZe({
              network: t
            })
          }
        };
      gce.exports = bce
    });
    var Ece = y((w5t, vce) => {
      l();
      "use strict";
      var JZe = Qc(),
        wce = xe(),
        _ce = class {
          constructor(e) {
            this._repo = e, this._bitswap = null
          }
          setExchange(e) {
            this._bitswap = e
          }
          unsetExchange() {
            this._bitswap = null
          }
          hasExchange() {
            return this._bitswap != null
          }
          put(e, t) {
            return this.hasExchange() ? this._bitswap.put(e, t) : this._repo.blocks.put(e, t)
          }
          putMany(e, t) {
            return this.hasExchange() ? this._bitswap.putMany(e, t) : this._repo.blocks.putMany(e, t)
          }
          get(e, t) {
            return this.hasExchange() ? this._bitswap.get(e, t) : this._repo.blocks.get(e, t)
          }
          getMany(e, t) {
            if (!Array.isArray(e)) throw new Error("first arg must be an array of cids");
            return this.hasExchange() ? this._bitswap.getMany(e, t) : JZe(e, i => this._repo.blocks.get(i, t))
          }
          async delete(e, t) {
            if (!await this._repo.blocks.has(e)) throw wce(new Error("blockstore: block not found"), "ERR_BLOCK_NOT_FOUND");
            return this._repo.blocks.delete(e, t)
          }
          deleteMany(e, t) {
            let i = this._repo;
            return this._repo.blocks.deleteMany(async function* () {
              for await (let n of e) {
                if (!await i.blocks.has(n)) throw wce(new Error("blockstore: block not found"), "ERR_BLOCK_NOT_FOUND");
                yield n
              }
            }(), t)
          }
        };
      vce.exports = _ce
    });
    var xce = y((_5t, Sce) => {
      l();
      Sce.exports = function (e, t, i) {
        var n = new e.Uint8Array(i),
          s = t.pushInt,
          o = t.pushInt32,
          a = t.pushInt32Neg,
          c = t.pushInt64,
          u = t.pushInt64Neg,
          f = t.pushFloat,
          h = t.pushFloatSingle,
          d = t.pushFloatDouble,
          p = t.pushTrue,
          g = t.pushFalse,
          m = t.pushUndefined,
          E = t.pushNull,
          w = t.pushInfinity,
          O = t.pushInfinityNeg,
          q = t.pushNaN,
          J = t.pushNaNNeg,
          Z = t.pushArrayStart,
          H = t.pushArrayStartFixed,
          te = t.pushArrayStartFixed32,
          ae = t.pushArrayStartFixed64,
          oe = t.pushObjectStart,
          U = t.pushObjectStartFixed,
          b = t.pushObjectStartFixed32,
          _ = t.pushObjectStartFixed64,
          R = t.pushByteString,
          D = t.pushByteStringStart,
          K = t.pushUtf8String,
          ee = t.pushUtf8StringStart,
          re = t.pushSimpleUnassigned,
          V = t.pushTagStart,
          v = t.pushTagStart4,
          Y = t.pushTagStart8,
          Se = t.pushTagUnassigned,
          Q = t.pushBreak,
          ve = e.Math.pow,
          x = 0,
          I = 0,
          le = 0;

        function he(P) {
          for (P = P | 0, x = 0, I = P;
            (x | 0) < (I | 0) && (le = kc[n[x] & 255](n[x] | 0) | 0, !((le | 0) > 0)););
          return le | 0
        }

        function S(P) {
          return P = P | 0, ((x | 0) + (P | 0) | 0) < (I | 0) ? 0 : 1
        }

        function T(P) {
          return P = P | 0, n[P | 0] << 8 | n[P + 1 | 0] | 0
        }

        function j(P) {
          return P = P | 0, n[P | 0] << 24 | n[P + 1 | 0] << 16 | n[P + 2 | 0] << 8 | n[P + 3 | 0] | 0
        }

        function G(P) {
          return P = P | 0, s(P | 0), x = x + 1 | 0, 0
        }

        function k(P) {
          return P = P | 0, S(1) | 0 ? 1 : (s(n[x + 1 | 0] | 0), x = x + 2 | 0, 0)
        }

        function F(P) {
          return P = P | 0, S(2) | 0 ? 1 : (s(T(x + 1 | 0) | 0), x = x + 3 | 0, 0)
        }

        function B(P) {
          return P = P | 0, S(4) | 0 ? 1 : (o(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0), x = x + 5 | 0, 0)
        }

        function L(P) {
          return P = P | 0, S(8) | 0 ? 1 : (c(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0, T(x + 5 | 0) | 0, T(x + 7 | 0) | 0), x = x + 9 | 0, 0)
        }

        function $(P) {
          return P = P | 0, s(-1 - (P - 32 | 0) | 0), x = x + 1 | 0, 0
        }

        function ie(P) {
          return P = P | 0, S(1) | 0 ? 1 : (s(-1 - (n[x + 1 | 0] | 0) | 0), x = x + 2 | 0, 0)
        }

        function ne(P) {
          P = P | 0;
          var Ve = 0;
          return S(2) | 0 ? 1 : (Ve = T(x + 1 | 0) | 0, s(-1 - (Ve | 0) | 0), x = x + 3 | 0, 0)
        }

        function pe(P) {
          return P = P | 0, S(4) | 0 ? 1 : (a(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0), x = x + 5 | 0, 0)
        }

        function be(P) {
          return P = P | 0, S(8) | 0 ? 1 : (u(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0, T(x + 5 | 0) | 0, T(x + 7 | 0) | 0), x = x + 9 | 0, 0)
        }

        function de(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return Fe = P - 64 | 0, S(Fe | 0) | 0 ? 1 : (Ve = x + 1 | 0, We = (x + 1 | 0) + (Fe | 0) | 0, R(Ve | 0, We | 0), x = We | 0, 0)
        }

        function Ne(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(1) | 0 || (Fe = n[x + 1 | 0] | 0, Ve = x + 2 | 0, We = (x + 2 | 0) + (Fe | 0) | 0, S(Fe + 1 | 0) | 0) ? 1 : (R(Ve | 0, We | 0), x = We | 0, 0)
        }

        function Re(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(2) | 0 || (Fe = T(x + 1 | 0) | 0, Ve = x + 3 | 0, We = (x + 3 | 0) + (Fe | 0) | 0, S(Fe + 2 | 0) | 0) ? 1 : (R(Ve | 0, We | 0), x = We | 0, 0)
        }

        function $e(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(4) | 0 || (Fe = j(x + 1 | 0) | 0, Ve = x + 5 | 0, We = (x + 5 | 0) + (Fe | 0) | 0, S(Fe + 4 | 0) | 0) ? 1 : (R(Ve | 0, We | 0), x = We | 0, 0)
        }

        function Ke(P) {
          return P = P | 0, 1
        }

        function Me(P) {
          return P = P | 0, D(), x = x + 1 | 0, 0
        }

        function Ie(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return Fe = P - 96 | 0, S(Fe | 0) | 0 ? 1 : (Ve = x + 1 | 0, We = (x + 1 | 0) + (Fe | 0) | 0, K(Ve | 0, We | 0), x = We | 0, 0)
        }

        function tt(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(1) | 0 || (Fe = n[x + 1 | 0] | 0, Ve = x + 2 | 0, We = (x + 2 | 0) + (Fe | 0) | 0, S(Fe + 1 | 0) | 0) ? 1 : (K(Ve | 0, We | 0), x = We | 0, 0)
        }

        function nt(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(2) | 0 || (Fe = T(x + 1 | 0) | 0, Ve = x + 3 | 0, We = (x + 3 | 0) + (Fe | 0) | 0, S(Fe + 2 | 0) | 0) ? 1 : (K(Ve | 0, We | 0), x = We | 0, 0)
        }

        function Ge(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 0;
          return S(4) | 0 || (Fe = j(x + 1 | 0) | 0, Ve = x + 5 | 0, We = (x + 5 | 0) + (Fe | 0) | 0, S(Fe + 4 | 0) | 0) ? 1 : (K(Ve | 0, We | 0), x = We | 0, 0)
        }

        function se(P) {
          return P = P | 0, 1
        }

        function A(P) {
          return P = P | 0, ee(), x = x + 1 | 0, 0
        }

        function X(P) {
          return P = P | 0, H(P - 128 | 0), x = x + 1 | 0, 0
        }

        function Kt(P) {
          return P = P | 0, S(1) | 0 ? 1 : (H(n[x + 1 | 0] | 0), x = x + 2 | 0, 0)
        }

        function st(P) {
          return P = P | 0, S(2) | 0 ? 1 : (H(T(x + 1 | 0) | 0), x = x + 3 | 0, 0)
        }

        function Nt(P) {
          return P = P | 0, S(4) | 0 ? 1 : (te(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0), x = x + 5 | 0, 0)
        }

        function on(P) {
          return P = P | 0, S(8) | 0 ? 1 : (ae(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0, T(x + 5 | 0) | 0, T(x + 7 | 0) | 0), x = x + 9 | 0, 0)
        }

        function qt(P) {
          return P = P | 0, Z(), x = x + 1 | 0, 0
        }

        function De(P) {
          P = P | 0;
          var Ve = 0;
          return Ve = P - 160 | 0, S(Ve | 0) | 0 ? 1 : (U(Ve | 0), x = x + 1 | 0, 0)
        }

        function an(P) {
          return P = P | 0, S(1) | 0 ? 1 : (U(n[x + 1 | 0] | 0), x = x + 2 | 0, 0)
        }

        function Mt(P) {
          return P = P | 0, S(2) | 0 ? 1 : (U(T(x + 1 | 0) | 0), x = x + 3 | 0, 0)
        }

        function Bt(P) {
          return P = P | 0, S(4) | 0 ? 1 : (b(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0), x = x + 5 | 0, 0)
        }

        function cn(P) {
          return P = P | 0, S(8) | 0 ? 1 : (_(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0, T(x + 5 | 0) | 0, T(x + 7 | 0) | 0), x = x + 9 | 0, 0)
        }

        function Dt(P) {
          return P = P | 0, oe(), x = x + 1 | 0, 0
        }

        function yt(P) {
          return P = P | 0, V(P - 192 | 0 | 0), x = x + 1 | 0, 0
        }

        function Bn(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function Ht(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function Gt(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function Dn(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function et(P) {
          return P = P | 0, V(P - 192 | 0 | 0), x = x + 1 | 0, 0
        }

        function $t(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function Ln(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function dr(P) {
          return P = P | 0, V(P | 0), x = x + 1 | 0, 0
        }

        function nr(P) {
          return P = P | 0, S(1) | 0 ? 1 : (V(n[x + 1 | 0] | 0), x = x + 2 | 0, 0)
        }

        function Ss(P) {
          return P = P | 0, S(2) | 0 ? 1 : (V(T(x + 1 | 0) | 0), x = x + 3 | 0, 0)
        }

        function sr(P) {
          return P = P | 0, S(4) | 0 ? 1 : (v(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0), x = x + 5 | 0, 0)
        }

        function or(P) {
          return P = P | 0, S(8) | 0 ? 1 : (Y(T(x + 1 | 0) | 0, T(x + 3 | 0) | 0, T(x + 5 | 0) | 0, T(x + 7 | 0) | 0), x = x + 9 | 0, 0)
        }

        function ut(P) {
          return P = P | 0, re((P | 0) - 224 | 0), x = x + 1 | 0, 0
        }

        function ar(P) {
          return P = P | 0, g(), x = x + 1 | 0, 0
        }

        function Lt(P) {
          return P = P | 0, p(), x = x + 1 | 0, 0
        }

        function Fn(P) {
          return P = P | 0, E(), x = x + 1 | 0, 0
        }

        function ns(P) {
          return P = P | 0, m(), x = x + 1 | 0, 0
        }

        function ss(P) {
          return P = P | 0, S(1) | 0 ? 1 : (re(n[x + 1 | 0] | 0), x = x + 2 | 0, 0)
        }

        function os(P) {
          P = P | 0;
          var Ve = 0,
            We = 0,
            Fe = 1,
            Un = 0,
            un = 0,
            Yf = 0;
          return S(2) | 0 ? 1 : (Ve = n[x + 1 | 0] | 0, We = n[x + 2 | 0] | 0, (Ve | 0) & 128 && (Fe = -1), Un = +(((Ve | 0) & 124) >> 2), un = +(((Ve | 0) & 3) << 8 | We), +Un == 0 ? f(+(+Fe * 5960464477539063e-23 * +un)) : +Un == 31 ? +Fe == 1 ? +un > 0 ? q() : w() : +un > 0 ? J() : O() : f(+(+Fe * ve(2, +(+Un - 25)) * +(1024 + un))), x = x + 3 | 0, 0)
        }

        function as(P) {
          return P = P | 0, S(4) | 0 ? 1 : (h(n[x + 1 | 0] | 0, n[x + 2 | 0] | 0, n[x + 3 | 0] | 0, n[x + 4 | 0] | 0), x = x + 5 | 0, 0)
        }

        function cs(P) {
          return P = P | 0, S(8) | 0 ? 1 : (d(n[x + 1 | 0] | 0, n[x + 2 | 0] | 0, n[x + 3 | 0] | 0, n[x + 4 | 0] | 0, n[x + 5 | 0] | 0, n[x + 6 | 0] | 0, n[x + 7 | 0] | 0, n[x + 8 | 0] | 0), x = x + 9 | 0, 0)
        }

        function Ze(P) {
          return P = P | 0, 1
        }

        function us(P) {
          return P = P | 0, Q(), x = x + 1 | 0, 0
        }
        var kc = [G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, k, F, B, L, Ze, Ze, Ze, Ze, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, $, ie, ne, pe, be, Ze, Ze, Ze, Ze, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, de, Ne, Re, $e, Ke, Ze, Ze, Ze, Me, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, Ie, tt, nt, Ge, se, Ze, Ze, Ze, A, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, Kt, st, Nt, on, Ze, Ze, Ze, qt, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, De, an, Mt, Bt, cn, Ze, Ze, Ze, Dt, yt, yt, yt, yt, yt, yt, et, et, et, et, et, et, et, et, et, et, et, et, et, et, et, et, et, et, nr, Ss, sr, or, Ze, Ze, Ze, Ze, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ar, Lt, Fn, ns, ss, os, as, cs, Ze, Ze, Ze, us];
        return {
          parse: he
        }
      }
    });
    var eb = y(Ks => {
      l();
      "use strict";
      var VT = tc().BigNumber;
      Ks.MT = {
        POS_INT: 0,
        NEG_INT: 1,
        BYTE_STRING: 2,
        UTF8_STRING: 3,
        ARRAY: 4,
        MAP: 5,
        TAG: 6,
        SIMPLE_FLOAT: 7
      };
      Ks.TAG = {
        DATE_STRING: 0,
        DATE_EPOCH: 1,
        POS_BIGINT: 2,
        NEG_BIGINT: 3,
        DECIMAL_FRAC: 4,
        BIGFLOAT: 5,
        BASE64URL_EXPECTED: 21,
        BASE64_EXPECTED: 22,
        BASE16_EXPECTED: 23,
        CBOR: 24,
        URI: 32,
        BASE64URL: 33,
        BASE64: 34,
        REGEXP: 35,
        MIME: 36
      };
      Ks.NUMBYTES = {
        ZERO: 0,
        ONE: 24,
        TWO: 25,
        FOUR: 26,
        EIGHT: 27,
        INDEFINITE: 31
      };
      Ks.SIMPLE = {
        FALSE: 20,
        TRUE: 21,
        NULL: 22,
        UNDEFINED: 23
      };
      Ks.SYMS = {
        NULL: Symbol("null"),
        UNDEFINED: Symbol("undef"),
        PARENT: Symbol("parent"),
        BREAK: Symbol("break"),
        STREAM: Symbol("stream")
      };
      Ks.SHIFT32 = Math.pow(2, 32);
      Ks.SHIFT16 = Math.pow(2, 16);
      Ks.MAX_SAFE_HIGH = 2097151;
      Ks.NEG_ONE = new VT(-1);
      Ks.TEN = new VT(10);
      Ks.TWO = new VT(2);
      Ks.PARENT = {
        ARRAY: 0,
        OBJECT: 1,
        MAP: 2,
        TAG: 3,
        BYTE_STRING: 4,
        UTF8_STRING: 5
      }
    });
    var a_ = y(Eo => {
      l();
      "use strict";
      var {
        Buffer: XZe
      } = Wt(), Ace = tc().BigNumber, Ice = eb(), Tce = Ice.SHIFT32, ZZe = Ice.SHIFT16, QZe = 2097151;
      Eo.parseHalf = function (e) {
        let t = e[0] & 128 ? -1 : 1,
          i = (e[0] & 124) >> 2,
          n = (e[0] & 3) << 8 | e[1];
        return i ? i === 31 ? t * (n ? 0 / 0 : Infinity) : t * Math.pow(2, i - 25) * (1024 + n) : t * 5960464477539063e-23 * n
      };

      function eQe(r) {
        return r < 16 ? "0" + r.toString(16) : r.toString(16)
      }
      Eo.arrayBufferToBignumber = function (r) {
        let e = r.byteLength,
          t = "";
        for (let i = 0; i < e; i++) t += eQe(r[i]);
        return new Ace(t, 16)
      };
      Eo.buildMap = r => {
        let e = new Map,
          t = Object.keys(r),
          i = t.length;
        for (let n = 0; n < i; n++) e.set(t[n], r[t[n]]);
        return e
      };
      Eo.buildInt32 = (r, e) => r * ZZe + e;
      Eo.buildInt64 = (r, e, t, i) => {
        let n = Eo.buildInt32(r, e),
          s = Eo.buildInt32(t, i);
        return n > QZe ? new Ace(n).times(Tce).plus(s) : n * Tce + s
      };
      Eo.writeHalf = function (e, t) {
        let i = XZe.allocUnsafe(4);
        i.writeFloatBE(t, 0);
        let n = i.readUInt32BE(0);
        if ((n & 8191) != 0) return !1;
        let s = n >> 16 & 32768,
          o = n >> 23 & 255,
          a = n & 8388607;
        if (o >= 113 && o <= 142) s += (o - 112 << 10) + (a >> 13);
        else if (o >= 103 && o < 113) {
          if (a & (1 << 126 - o) - 1) return !1;
          s += a + 8388608 >> 126 - o
        } else return !1;
        return e.writeUInt16BE(s, 0), !0
      };
      Eo.keySorter = function (r, e) {
        let t = r[0].byteLength,
          i = e[0].byteLength;
        return t > i ? 1 : i > t ? -1 : r[0].compare(e[0])
      };
      Eo.isNegativeZero = r => r === 0 && 1 / r < 0;
      Eo.nextPowerOf2 = r => {
        let e = 0;
        if (r && !(r & r - 1)) return r;
        for (; r !== 0;) r >>= 1, e += 1;
        return 1 << e
      }
    });
    var $T = y((x5t, Rce) => {
      l();
      "use strict";
      var HT = eb(),
        tQe = HT.MT,
        c_ = HT.SIMPLE,
        GT = HT.SYMS,
        tb = class {
          constructor(e) {
            if (typeof e != "number") throw new Error("Invalid Simple type: " + typeof e);
            if (e < 0 || e > 255 || (e | 0) !== e) throw new Error("value must be a small positive integer: " + e);
            this.value = e
          }
          toString() {
            return "simple(" + this.value + ")"
          }
          inspect() {
            return "simple(" + this.value + ")"
          }
          encodeCBOR(e) {
            return e._pushInt(this.value, tQe.SIMPLE_FLOAT)
          }
          static isSimple(e) {
            return e instanceof tb
          }
          static decode(e, t) {
            switch (t == null && (t = !0), e) {
              case c_.FALSE:
                return !1;
              case c_.TRUE:
                return !0;
              case c_.NULL:
                return t ? null : GT.NULL;
              case c_.UNDEFINED:
                return t ? void 0 : GT.UNDEFINED;
              case -1:
                if (!t) throw new Error("Invalid BREAK");
                return GT.BREAK;
              default:
                return new tb(e)
            }
          }
        };
      Rce.exports = tb
    });
    var WT = y((A5t, kce) => {
      l();
      "use strict";
      var rb = class {
        constructor(e, t, i) {
          if (this.tag = e, this.value = t, this.err = i, typeof this.tag != "number") throw new Error("Invalid tag type (" + typeof this.tag + ")");
          if (this.tag < 0 || (this.tag | 0) !== this.tag) throw new Error("Tag must be a positive integer: " + this.tag)
        }
        toString() {
          return `${this.tag}(${JSON.stringify(this.value)})`
        }
        encodeCBOR(e) {
          return e._pushTag(this.tag), e.pushAny(this.value)
        }
        convert(e) {
          let t, i;
          if (i = e != null ? e[this.tag] : void 0, typeof i != "function" && (i = rb["_tag" + this.tag], typeof i != "function")) return this;
          try {
            return i.call(rb, this.value)
          } catch (n) {
            return t = n, this.err = t, this
          }
        }
      };
      kce.exports = rb
    });
    var YT = y((I5t, Pce) => {
      l();
      "use strict";
      var {
        Buffer: ep
      } = Wt(), Cce = x1(), rQe = tc().BigNumber, iQe = xce(), Jn = a_(), mr = eb(), nQe = $T(), sQe = WT(), {
        URL: oQe
      } = Qh(), ah = class {
        constructor(e) {
          e = e || {}, !e.size || e.size < 65536 ? e.size = 65536 : e.size = Jn.nextPowerOf2(e.size), this._heap = new ArrayBuffer(e.size), this._heap8 = new Uint8Array(this._heap), this._buffer = ep.from(this._heap), this._reset(), this._knownTags = Object.assign({
            0: t => new Date(t),
            1: t => new Date(t * 1e3),
            2: t => Jn.arrayBufferToBignumber(t),
            3: t => mr.NEG_ONE.minus(Jn.arrayBufferToBignumber(t)),
            4: t => mr.TEN.pow(t[0]).times(t[1]),
            5: t => mr.TWO.pow(t[0]).times(t[1]),
            32: t => new oQe(t),
            35: t => new RegExp(t)
          }, e.tags), this.parser = iQe(globalThis, {
            log: console.log.bind(console),
            pushInt: this.pushInt.bind(this),
            pushInt32: this.pushInt32.bind(this),
            pushInt32Neg: this.pushInt32Neg.bind(this),
            pushInt64: this.pushInt64.bind(this),
            pushInt64Neg: this.pushInt64Neg.bind(this),
            pushFloat: this.pushFloat.bind(this),
            pushFloatSingle: this.pushFloatSingle.bind(this),
            pushFloatDouble: this.pushFloatDouble.bind(this),
            pushTrue: this.pushTrue.bind(this),
            pushFalse: this.pushFalse.bind(this),
            pushUndefined: this.pushUndefined.bind(this),
            pushNull: this.pushNull.bind(this),
            pushInfinity: this.pushInfinity.bind(this),
            pushInfinityNeg: this.pushInfinityNeg.bind(this),
            pushNaN: this.pushNaN.bind(this),
            pushNaNNeg: this.pushNaNNeg.bind(this),
            pushArrayStart: this.pushArrayStart.bind(this),
            pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
            pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
            pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
            pushObjectStart: this.pushObjectStart.bind(this),
            pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
            pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
            pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
            pushByteString: this.pushByteString.bind(this),
            pushByteStringStart: this.pushByteStringStart.bind(this),
            pushUtf8String: this.pushUtf8String.bind(this),
            pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
            pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
            pushTagUnassigned: this.pushTagUnassigned.bind(this),
            pushTagStart: this.pushTagStart.bind(this),
            pushTagStart4: this.pushTagStart4.bind(this),
            pushTagStart8: this.pushTagStart8.bind(this),
            pushBreak: this.pushBreak.bind(this)
          }, this._heap)
        }
        get _depth() {
          return this._parents.length
        }
        get _currentParent() {
          return this._parents[this._depth - 1]
        }
        get _ref() {
          return this._currentParent.ref
        }
        _closeParent() {
          let e = this._parents.pop();
          if (e.length > 0) throw new Error(`Missing ${e.length} elements`);
          switch (e.type) {
            case mr.PARENT.TAG:
              this._push(this.createTag(e.ref[0], e.ref[1]));
              break;
            case mr.PARENT.BYTE_STRING:
              this._push(this.createByteString(e.ref, e.length));
              break;
            case mr.PARENT.UTF8_STRING:
              this._push(this.createUtf8String(e.ref, e.length));
              break;
            case mr.PARENT.MAP:
              if (e.values % 2 > 0) throw new Error("Odd number of elements in the map");
              this._push(this.createMap(e.ref, e.length));
              break;
            case mr.PARENT.OBJECT:
              if (e.values % 2 > 0) throw new Error("Odd number of elements in the map");
              this._push(this.createObject(e.ref, e.length));
              break;
            case mr.PARENT.ARRAY:
              this._push(this.createArray(e.ref, e.length));
              break;
            default:
              break
          }
          this._currentParent && this._currentParent.type === mr.PARENT.TAG && this._dec()
        }
        _dec() {
          let e = this._currentParent;
          e.length < 0 || (e.length--, e.length === 0 && this._closeParent())
        }
        _push(e, t) {
          let i = this._currentParent;
          switch (i.values++, i.type) {
            case mr.PARENT.ARRAY:
            case mr.PARENT.BYTE_STRING:
            case mr.PARENT.UTF8_STRING:
              i.length > -1 ? this._ref[this._ref.length - i.length] = e : this._ref.push(e), this._dec();
              break;
            case mr.PARENT.OBJECT:
              i.tmpKey != null ? (this._ref[i.tmpKey] = e, i.tmpKey = null, this._dec()) : (i.tmpKey = e, typeof i.tmpKey != "string" && (i.type = mr.PARENT.MAP, i.ref = Jn.buildMap(i.ref)));
              break;
            case mr.PARENT.MAP:
              i.tmpKey != null ? (this._ref.set(i.tmpKey, e), i.tmpKey = null, this._dec()) : i.tmpKey = e;
              break;
            case mr.PARENT.TAG:
              this._ref.push(e), t || this._dec();
              break;
            default:
              throw new Error("Unknown parent type")
          }
        }
        _createParent(e, t, i) {
          this._parents[this._depth] = {
            type: t,
            length: i,
            ref: e,
            values: 0,
            tmpKey: null
          }
        }
        _reset() {
          this._res = [], this._parents = [{
            type: mr.PARENT.ARRAY,
            length: -1,
            ref: this._res,
            values: 0,
            tmpKey: null
          }]
        }
        createTag(e, t) {
          let i = this._knownTags[e];
          return i ? i(t) : new sQe(e, t)
        }
        createMap(e, t) {
          return e
        }
        createObject(e, t) {
          return e
        }
        createArray(e, t) {
          return e
        }
        createByteString(e, t) {
          return ep.concat(e)
        }
        createByteStringFromHeap(e, t) {
          return e === t ? ep.alloc(0) : ep.from(this._heap.slice(e, t))
        }
        createInt(e) {
          return e
        }
        createInt32(e, t) {
          return Jn.buildInt32(e, t)
        }
        createInt64(e, t, i, n) {
          return Jn.buildInt64(e, t, i, n)
        }
        createFloat(e) {
          return e
        }
        createFloatSingle(e, t, i, n) {
          return Cce.read([e, t, i, n], 0, !1, 23, 4)
        }
        createFloatDouble(e, t, i, n, s, o, a, c) {
          return Cce.read([e, t, i, n, s, o, a, c], 0, !1, 52, 8)
        }
        createInt32Neg(e, t) {
          return -1 - Jn.buildInt32(e, t)
        }
        createInt64Neg(e, t, i, n) {
          let s = Jn.buildInt32(e, t),
            o = Jn.buildInt32(i, n);
          return s > mr.MAX_SAFE_HIGH ? mr.NEG_ONE.minus(new rQe(s).times(mr.SHIFT32).plus(o)) : -1 - (s * mr.SHIFT32 + o)
        }
        createTrue() {
          return !0
        }
        createFalse() {
          return !1
        }
        createNull() {
          return null
        }
        createUndefined() { }
        createInfinity() {
          return Infinity
        }
        createInfinityNeg() {
          return -Infinity
        }
        createNaN() {
          return NaN
        }
        createNaNNeg() {
          return NaN
        }
        createUtf8String(e, t) {
          return e.join("")
        }
        createUtf8StringFromHeap(e, t) {
          return e === t ? "" : this._buffer.toString("utf8", e, t)
        }
        createSimpleUnassigned(e) {
          return new nQe(e)
        }
        pushInt(e) {
          this._push(this.createInt(e))
        }
        pushInt32(e, t) {
          this._push(this.createInt32(e, t))
        }
        pushInt64(e, t, i, n) {
          this._push(this.createInt64(e, t, i, n))
        }
        pushFloat(e) {
          this._push(this.createFloat(e))
        }
        pushFloatSingle(e, t, i, n) {
          this._push(this.createFloatSingle(e, t, i, n))
        }
        pushFloatDouble(e, t, i, n, s, o, a, c) {
          this._push(this.createFloatDouble(e, t, i, n, s, o, a, c))
        }
        pushInt32Neg(e, t) {
          this._push(this.createInt32Neg(e, t))
        }
        pushInt64Neg(e, t, i, n) {
          this._push(this.createInt64Neg(e, t, i, n))
        }
        pushTrue() {
          this._push(this.createTrue())
        }
        pushFalse() {
          this._push(this.createFalse())
        }
        pushNull() {
          this._push(this.createNull())
        }
        pushUndefined() {
          this._push(this.createUndefined())
        }
        pushInfinity() {
          this._push(this.createInfinity())
        }
        pushInfinityNeg() {
          this._push(this.createInfinityNeg())
        }
        pushNaN() {
          this._push(this.createNaN())
        }
        pushNaNNeg() {
          this._push(this.createNaNNeg())
        }
        pushArrayStart() {
          this._createParent([], mr.PARENT.ARRAY, -1)
        }
        pushArrayStartFixed(e) {
          this._createArrayStartFixed(e)
        }
        pushArrayStartFixed32(e, t) {
          let i = Jn.buildInt32(e, t);
          this._createArrayStartFixed(i)
        }
        pushArrayStartFixed64(e, t, i, n) {
          let s = Jn.buildInt64(e, t, i, n);
          this._createArrayStartFixed(s)
        }
        pushObjectStart() {
          this._createObjectStartFixed(-1)
        }
        pushObjectStartFixed(e) {
          this._createObjectStartFixed(e)
        }
        pushObjectStartFixed32(e, t) {
          let i = Jn.buildInt32(e, t);
          this._createObjectStartFixed(i)
        }
        pushObjectStartFixed64(e, t, i, n) {
          let s = Jn.buildInt64(e, t, i, n);
          this._createObjectStartFixed(s)
        }
        pushByteStringStart() {
          this._parents[this._depth] = {
            type: mr.PARENT.BYTE_STRING,
            length: -1,
            ref: [],
            values: 0,
            tmpKey: null
          }
        }
        pushByteString(e, t) {
          this._push(this.createByteStringFromHeap(e, t))
        }
        pushUtf8StringStart() {
          this._parents[this._depth] = {
            type: mr.PARENT.UTF8_STRING,
            length: -1,
            ref: [],
            values: 0,
            tmpKey: null
          }
        }
        pushUtf8String(e, t) {
          this._push(this.createUtf8StringFromHeap(e, t))
        }
        pushSimpleUnassigned(e) {
          this._push(this.createSimpleUnassigned(e))
        }
        pushTagStart(e) {
          this._parents[this._depth] = {
            type: mr.PARENT.TAG,
            length: 1,
            ref: [e]
          }
        }
        pushTagStart4(e, t) {
          this.pushTagStart(Jn.buildInt32(e, t))
        }
        pushTagStart8(e, t, i, n) {
          this.pushTagStart(Jn.buildInt64(e, t, i, n))
        }
        pushTagUnassigned(e) {
          this._push(this.createTag(e))
        }
        pushBreak() {
          if (this._currentParent.length > -1) throw new Error("Unexpected break");
          this._closeParent()
        }
        _createObjectStartFixed(e) {
          if (e === 0) {
            this._push(this.createObject({}));
            return
          }
          this._createParent({}, mr.PARENT.OBJECT, e)
        }
        _createArrayStartFixed(e) {
          if (e === 0) {
            this._push(this.createArray([]));
            return
          }
          this._createParent(new Array(e), mr.PARENT.ARRAY, e)
        }
        _decode(e) {
          if (e.byteLength === 0) throw new Error("Input too short");
          this._reset(), this._heap8.set(e);
          let t = this.parser.parse(e.byteLength);
          if (this._depth > 1) {
            for (; this._currentParent.length === 0;) this._closeParent();
            if (this._depth > 1) throw new Error("Undeterminated nesting")
          }
          if (t > 0) throw new Error("Failed to parse");
          if (this._res.length === 0) throw new Error("No valid result")
        }
        decodeFirst(e) {
          return this._decode(e), this._res[0]
        }
        decodeAll(e) {
          return this._decode(e), this._res
        }
        static decode(e, t) {
          return typeof e == "string" && (e = ep.from(e, t || "hex")), new ah({
            size: e.length
          }).decodeFirst(e)
        }
        static decodeAll(e, t) {
          return typeof e == "string" && (e = ep.from(e, t || "hex")), new ah({
            size: e.length
          }).decodeAll(e)
        }
      };
      ah.decodeFirst = ah.decode;
      Pce.exports = ah
    });
    var qce = y((T5t, Oce) => {
      l();
      "use strict";
      var {
        Buffer: JT
      } = Wt(), aQe = YT(), cQe = a_(), u_ = class extends aQe {
        createTag(e, t) {
          return `${e}(${t})`
        }
        createInt(e) {
          return super.createInt(e).toString()
        }
        createInt32(e, t) {
          return super.createInt32(e, t).toString()
        }
        createInt64(e, t, i, n) {
          return super.createInt64(e, t, i, n).toString()
        }
        createInt32Neg(e, t) {
          return super.createInt32Neg(e, t).toString()
        }
        createInt64Neg(e, t, i, n) {
          return super.createInt64Neg(e, t, i, n).toString()
        }
        createTrue() {
          return "true"
        }
        createFalse() {
          return "false"
        }
        createFloat(e) {
          let t = super.createFloat(e);
          return cQe.isNegativeZero(e) ? "-0_1" : `${t}_1`
        }
        createFloatSingle(e, t, i, n) {
          return `${super.createFloatSingle(e, t, i, n)}_2`
        }
        createFloatDouble(e, t, i, n, s, o, a, c) {
          return `${super.createFloatDouble(e, t, i, n, s, o, a, c)}_3`
        }
        createByteString(e, t) {
          let i = e.join(", ");
          return t === -1 ? `(_ ${i})` : `h'${i}`
        }
        createByteStringFromHeap(e, t) {
          return `h'${JT.from(super.createByteStringFromHeap(e, t)).toString("hex")}'`
        }
        createInfinity() {
          return "Infinity_1"
        }
        createInfinityNeg() {
          return "-Infinity_1"
        }
        createNaN() {
          return "NaN_1"
        }
        createNaNNeg() {
          return "-NaN_1"
        }
        createNull() {
          return "null"
        }
        createUndefined() {
          return "undefined"
        }
        createSimpleUnassigned(e) {
          return `simple(${e})`
        }
        createArray(e, t) {
          let i = super.createArray(e, t);
          return t === -1 ? `[_ ${i.join(", ")}]` : `[${i.join(", ")}]`
        }
        createMap(e, t) {
          let i = super.createMap(e),
            n = Array.from(i.keys()).reduce(Nce(i), "");
          return t === -1 ? `{_ ${n}}` : `{${n}}`
        }
        createObject(e, t) {
          let i = super.createObject(e),
            n = Object.keys(i).reduce(Nce(i), "");
          return t === -1 ? `{_ ${n}}` : `{${n}}`
        }
        createUtf8String(e, t) {
          let i = e.join(", ");
          return t === -1 ? `(_ ${i})` : `"${i}"`
        }
        createUtf8StringFromHeap(e, t) {
          return `"${JT.from(super.createUtf8StringFromHeap(e, t)).toString("utf8")}"`
        }
        static diagnose(e, t) {
          return typeof e == "string" && (e = JT.from(e, t || "hex")), new u_().decodeFirst(e)
        }
      };
      Oce.exports = u_;

      function Nce(r) {
        return (e, t) => e ? `${e}, ${t}: ${r[t]}` : `${t}: ${r[t]}`
      }
    });
    var Fce = y((R5t, Mce) => {
      l();
      "use strict";
      var {
        Buffer: hc
      } = Wt(), {
        URL: uQe
      } = Qh(), XT = tc().BigNumber, ZT = a_(), Ci = eb(), ha = Ci.MT, f_ = Ci.NUMBYTES, Bce = Ci.SHIFT32, Dce = Ci.SYMS, tp = Ci.TAG, fQe = Ci.MT.SIMPLE_FLOAT << 5 | Ci.NUMBYTES.TWO, lQe = Ci.MT.SIMPLE_FLOAT << 5 | Ci.NUMBYTES.FOUR, hQe = Ci.MT.SIMPLE_FLOAT << 5 | Ci.NUMBYTES.EIGHT, dQe = Ci.MT.SIMPLE_FLOAT << 5 | Ci.SIMPLE.TRUE, pQe = Ci.MT.SIMPLE_FLOAT << 5 | Ci.SIMPLE.FALSE, yQe = Ci.MT.SIMPLE_FLOAT << 5 | Ci.SIMPLE.UNDEFINED, Lce = Ci.MT.SIMPLE_FLOAT << 5 | Ci.SIMPLE.NULL, gQe = new XT("0x20000000000000"), bQe = hc.from("f97e00", "hex"), mQe = hc.from("f9fc00", "hex"), vQe = hc.from("f97c00", "hex");

      function wQe(r) {
        return {}.toString.call(r).slice(8, -1)
      }
      var ib = class {
        constructor(e) {
          e = e || {}, this.streaming = typeof e.stream == "function", this.onData = e.stream, this.semanticTypes = [
            [uQe, this._pushUrl],
            [XT, this._pushBigNumber]
          ];
          let t = e.genTypes || [],
            i = t.length;
          for (let n = 0; n < i; n++) this.addSemanticType(t[n][0], t[n][1]);
          this._reset()
        }
        addSemanticType(e, t) {
          let i = this.semanticTypes.length;
          for (let n = 0; n < i; n++)
            if (this.semanticTypes[n][0] === e) {
              let o = this.semanticTypes[n][1];
              return this.semanticTypes[n][1] = t, o
            } return this.semanticTypes.push([e, t]), null
        }
        push(e) {
          return e && (this.result[this.offset] = e, this.resultMethod[this.offset] = 0, this.resultLength[this.offset] = e.length, this.offset++, this.streaming && this.onData(this.finalize())), !0
        }
        pushWrite(e, t, i) {
          return this.result[this.offset] = e, this.resultMethod[this.offset] = t, this.resultLength[this.offset] = i, this.offset++, this.streaming && this.onData(this.finalize()), !0
        }
        _pushUInt8(e) {
          return this.pushWrite(e, 1, 1)
        }
        _pushUInt16BE(e) {
          return this.pushWrite(e, 2, 2)
        }
        _pushUInt32BE(e) {
          return this.pushWrite(e, 3, 4)
        }
        _pushDoubleBE(e) {
          return this.pushWrite(e, 4, 8)
        }
        _pushNaN() {
          return this.push(bQe)
        }
        _pushInfinity(e) {
          let t = e < 0 ? mQe : vQe;
          return this.push(t)
        }
        _pushFloat(e) {
          let t = hc.allocUnsafe(2);
          if (ZT.writeHalf(t, e) && ZT.parseHalf(t) === e) return this._pushUInt8(fQe) && this.push(t);
          let i = hc.allocUnsafe(4);
          return i.writeFloatBE(e, 0), i.readFloatBE(0) === e ? this._pushUInt8(lQe) && this.push(i) : this._pushUInt8(hQe) && this._pushDoubleBE(e)
        }
        _pushInt(e, t, i) {
          let n = t << 5;
          return e < 24 ? this._pushUInt8(n | e) : e <= 255 ? this._pushUInt8(n | f_.ONE) && this._pushUInt8(e) : e <= 65535 ? this._pushUInt8(n | f_.TWO) && this._pushUInt16BE(e) : e <= 4294967295 ? this._pushUInt8(n | f_.FOUR) && this._pushUInt32BE(e) : e <= Number.MAX_SAFE_INTEGER ? this._pushUInt8(n | f_.EIGHT) && this._pushUInt32BE(Math.floor(e / Bce)) && this._pushUInt32BE(e % Bce) : t === ha.NEG_INT ? this._pushFloat(i) : this._pushFloat(e)
        }
        _pushIntNum(e) {
          return e < 0 ? this._pushInt(-e - 1, ha.NEG_INT, e) : this._pushInt(e, ha.POS_INT)
        }
        _pushNumber(e) {
          switch (!1) {
            case e === e:
              return this._pushNaN(e);
            case isFinite(e):
              return this._pushInfinity(e);
            case e % 1 != 0:
              return this._pushIntNum(e);
            default:
              return this._pushFloat(e)
          }
        }
        _pushString(e) {
          let t = hc.byteLength(e, "utf8");
          return this._pushInt(t, ha.UTF8_STRING) && this.pushWrite(e, 5, t)
        }
        _pushBoolean(e) {
          return this._pushUInt8(e ? dQe : pQe)
        }
        _pushUndefined(e) {
          return this._pushUInt8(yQe)
        }
        _pushArray(e, t) {
          let i = t.length;
          if (!e._pushInt(i, ha.ARRAY)) return !1;
          for (let n = 0; n < i; n++)
            if (!e.pushAny(t[n])) return !1;
          return !0
        }
        _pushTag(e) {
          return this._pushInt(e, ha.TAG)
        }
        _pushDate(e, t) {
          return e._pushTag(tp.DATE_EPOCH) && e.pushAny(Math.round(t / 1e3))
        }
        _pushBuffer(e, t) {
          return e._pushInt(t.length, ha.BYTE_STRING) && e.push(t)
        }
        _pushNoFilter(e, t) {
          return e._pushBuffer(e, t.slice())
        }
        _pushRegexp(e, t) {
          return e._pushTag(tp.REGEXP) && e.pushAny(t.source)
        }
        _pushSet(e, t) {
          if (!e._pushInt(t.size, ha.ARRAY)) return !1;
          for (let i of t)
            if (!e.pushAny(i)) return !1;
          return !0
        }
        _pushUrl(e, t) {
          return e._pushTag(tp.URI) && e.pushAny(t.format())
        }
        _pushBigint(e) {
          let t = tp.POS_BIGINT;
          e.isNegative() && (e = e.negated().minus(1), t = tp.NEG_BIGINT);
          let i = e.toString(16);
          i.length % 2 && (i = "0" + i);
          let n = hc.from(i, "hex");
          return this._pushTag(t) && this._pushBuffer(this, n)
        }
        _pushBigNumber(e, t) {
          if (t.isNaN()) return e._pushNaN();
          if (!t.isFinite()) return e._pushInfinity(t.isNegative() ? -Infinity : Infinity);
          if (t.isInteger()) return e._pushBigint(t);
          if (!(e._pushTag(tp.DECIMAL_FRAC) && e._pushInt(2, ha.ARRAY))) return !1;
          let i = t.decimalPlaces(),
            n = t.multipliedBy(new XT(10).pow(i));
          return e._pushIntNum(-i) ? n.abs().isLessThan(gQe) ? e._pushIntNum(n.toNumber()) : e._pushBigint(n) : !1
        }
        _pushMap(e, t) {
          return e._pushInt(t.size, ha.MAP) ? this._pushRawMap(t.size, Array.from(t)) : !1
        }
        _pushObject(e) {
          if (!e) return this._pushUInt8(Lce);
          let t = this.semanticTypes.length;
          for (let o = 0; o < t; o++)
            if (e instanceof this.semanticTypes[o][0]) return this.semanticTypes[o][1].call(e, this, e);
          let i = e.encodeCBOR;
          if (typeof i == "function") return i.call(e, this);
          let n = Object.keys(e),
            s = n.length;
          return this._pushInt(s, ha.MAP) ? this._pushRawMap(s, n.map(o => [o, e[o]])) : !1
        }
        _pushRawMap(e, t) {
          t = t.map(function (i) {
            return i[0] = ib.encode(i[0]), i
          }).sort(ZT.keySorter);
          for (let i = 0; i < e; i++)
            if (!this.push(t[i][0]) || !this.pushAny(t[i][1])) return !1;
          return !0
        }
        write(e) {
          return this.pushAny(e)
        }
        pushAny(e) {
          switch (wQe(e)) {
            case "Number":
              return this._pushNumber(e);
            case "String":
              return this._pushString(e);
            case "Boolean":
              return this._pushBoolean(e);
            case "Object":
              return this._pushObject(e);
            case "Array":
              return this._pushArray(this, e);
            case "Uint8Array":
              return this._pushBuffer(this, hc.isBuffer(e) ? e : hc.from(e));
            case "Null":
              return this._pushUInt8(Lce);
            case "Undefined":
              return this._pushUndefined(e);
            case "Map":
              return this._pushMap(this, e);
            case "Set":
              return this._pushSet(this, e);
            case "URL":
              return this._pushUrl(this, e);
            case "BigNumber":
              return this._pushBigNumber(this, e);
            case "Date":
              return this._pushDate(this, e);
            case "RegExp":
              return this._pushRegexp(this, e);
            case "Symbol":
              switch (e) {
                case Dce.NULL:
                  return this._pushObject(null);
                case Dce.UNDEFINED:
                  return this._pushUndefined(void 0);
                default:
                  throw new Error("Unknown symbol: " + e.toString())
              }
            default:
              throw new Error("Unknown type: " + typeof e + ", " + (e ? e.toString() : ""))
          }
        }
        finalize() {
          if (this.offset === 0) return null;
          let e = this.result,
            t = this.resultLength,
            i = this.resultMethod,
            n = this.offset,
            s = 0,
            o = 0;
          for (; o < n; o++) s += t[o];
          let a = hc.allocUnsafe(s),
            c = 0,
            u = 0;
          for (o = 0; o < n; o++) {
            switch (u = t[o], i[o]) {
              case 0:
                e[o].copy(a, c);
                break;
              case 1:
                a.writeUInt8(e[o], c, !0);
                break;
              case 2:
                a.writeUInt16BE(e[o], c, !0);
                break;
              case 3:
                a.writeUInt32BE(e[o], c, !0);
                break;
              case 4:
                a.writeDoubleBE(e[o], c, !0);
                break;
              case 5:
                a.write(e[o], c, u, "utf8");
                break;
              default:
                throw new Error("unkown method")
            }
            c += u
          }
          let f = a;
          return this._reset(), f
        }
        _reset() {
          this.result = [], this.resultMethod = [], this.resultLength = [], this.offset = 0
        }
        static encode(e) {
          let t = new ib;
          if (!t.pushAny(e)) throw new Error("Failed to encode input");
          return t.finalize()
        }
      };
      Mce.exports = ib
    });
    var Uce = y(Oi => {
      l();
      "use strict";
      Oi.Diagnose = qce();
      Oi.Decoder = YT();
      Oi.Encoder = Fce();
      Oi.Simple = $T();
      Oi.Tagged = WT();
      Oi.decodeAll = Oi.Decoder.decodeAll;
      Oi.decodeFirst = Oi.Decoder.decodeFirst;
      Oi.diagnose = Oi.Diagnose.diagnose;
      Oi.encode = Oi.Encoder.encode;
      Oi.decode = Oi.Decoder.decode;
      Oi.leveldb = {
        decode: Oi.Decoder.decodeAll,
        encode: Oi.Encoder.encode,
        buffer: !0,
        name: "cbor"
      }
    });
    var r7 = y((P5t, l_) => {
      l();
      "use strict";
      var QT = Uce(),
        Kce = Jr(),
        zce = cr(),
        {
          multihash: jce
        } = zce,
        nb = at(),
        _Qe = E8(),
        EQe = xi(),
        SQe = gt(),
        Vce = 42;

      function xQe(r) {
        let e;
        if (typeof r == "string") e = new nb(r).bytes;
        else if (nb.isCID(r)) e = r.bytes;
        else throw new Error("Could not tag CID - was not string or CID");
        return new QT.Tagged(Vce, EQe([SQe("00", "base16"), e], 1 + e.length))
      }

      function AQe(r) {
        let e;
        try {
          e = _Qe(r)
        } catch (i) {
          e = !1
        }
        if (e) throw new Error("The object passed has circular references");

        function t(i) {
          if (!i || i instanceof Uint8Array || typeof i == "string") return i;
          if (Array.isArray(i)) return i.map(t);
          if (nb.isCID(i)) return xQe(i);
          let n = Object.keys(i);
          if (n.length > 0) {
            let s = {};
            return n.forEach(o => {
              typeof i[o] == "object" ? s[o] = t(i[o]) : s[o] = i[o]
            }), s
          } else return i
        }
        return t(r)
      }
      var IQe = Kce.DAG_CBOR,
        TQe = jce.names["sha2-256"],
        Hce = {
          [Vce]: r => (r = r.slice(1), new nb(r))
        },
        Gce = 64 * 1024,
        rp = Gce,
        $ce = 64 * 1024 * 1024,
        e7 = $ce,
        Wce;

      function t7(r) {
        let e = Hce;
        r ? (typeof r.size == "number" && (rp = r.size), typeof r.maxSize == "number" && (e7 = r.maxSize), r.tags && (e = Object.assign({}, Hce, r && r.tags))) : (rp = Gce, e7 = $ce);
        let t = {
          tags: e,
          size: rp
        };
        Wce = new QT.Decoder(t), rp = t.size
      }
      t7();

      function RQe(r) {
        let e = AQe(r);
        return QT.encode(e)
      }

      function kQe(r) {
        if (r.length > rp && r.length <= e7 && t7({
          size: r.length
        }), r.length > rp) throw new Error("Data is too large to deserialize with current decoder");
        let e = Wce.decodeAll(r);
        if (e.length !== 1) throw new Error("Extraneous CBOR data found beyond initial top-level object");
        return e[0]
      }
      async function PQe(r, e = {}) {
        let t = {
          cidVersion: e.cidVersion == null ? 1 : e.cidVersion,
          hashAlg: e.hashAlg == null ? l_.exports.defaultHashAlg : e.hashAlg
        },
          i = jce.codes[t.hashAlg],
          n = await zce(r, i),
          s = Kce.getNameFromCode(l_.exports.codec);
        return new nb(t.cidVersion, s, n)
      }
      l_.exports = {
        codec: IQe,
        defaultHashAlg: TQe,
        configureDecoder: t7,
        serialize: RQe,
        deserialize: kQe,
        cid: PQe
      }
    });
    var Zce = y(i7 => {
      l();
      "use strict";
      var Yce = at(),
        Jce = r7();
      i7.resolve = (r, e = "") => {
        let t = Jce.deserialize(r),
          i = e.split("/").filter(Boolean);
        for (; i.length;) {
          let n = i.shift();
          if (!n || !(n in t)) throw new Error(`Object has no property '${n}'`);
          if (t = t[n], Yce.isCID(t)) return {
            value: t,
            remainderPath: i.join("/")
          }
        }
        return {
          value: t,
          remainderPath: ""
        }
      };
      var Xce = function* (r, e) {
        if (!(r instanceof Uint8Array || Yce.isCID(r) || typeof r == "string" || r === null))
          for (let t of Object.keys(r)) {
            let i = e === void 0 ? t : e + "/" + t;
            yield i, yield* Xce(r[t], i)
          }
      };
      i7.tree = function* (r) {
        let e = Jce.deserialize(r);
        yield* Xce(e)
      }
    });
    var s7 = y((O5t, Qce) => {
      l();
      "use strict";
      var n7 = r7(),
        CQe = Zce();
      Qce.exports = {
        util: n7,
        resolver: CQe,
        codec: n7.codec,
        defaultHashAlg: n7.defaultHashAlg
      }
    });
    var o7 = y((N5t, h_) => {
      l();
      "use strict";
      var OQe = at(),
        eue = cr(),
        {
          multihash: tue
        } = eue,
        rue = Jr();
      h_.exports = {
        codec: rue.RAW,
        defaultHashAlg: tue.names["sha2-256"],
        resolver: {
          resolve: (r, e) => {
            if (e !== "/") throw new Error("Only the root path / may be resolved");
            return {
              value: r,
              remainderPath: ""
            }
          },
          async *tree(r) { }
        },
        util: {
          deserialize: r => r,
          serialize: r => r,
          cid: async (r, e = {}) => {
            let t = {
              cidVersion: e.cidVersion == null ? 1 : e.cidVersion,
              hashAlg: e.hashAlg == null ? h_.exports.defaultHashAlg : e.hashAlg
            },
              i = tue.codes[t.hashAlg],
              n = await eue(r, i),
              s = rue.getNameFromCode(h_.exports.codec);
            return new OQe(t.cidVersion, s, n)
          }
        }
      }
    });
    var sue = y((q5t, iue) => {
      l();
      "use strict";
      var NQe = Yr(),
        d_ = Jr(),
        nue = {
          get [d_.DAG_PB]() {
            return Mr()
          },
          get [d_.DAG_CBOR]() {
            return s7()
          },
          get [d_.RAW]() {
            return o7()
          }
        };
      iue.exports = (r, e) => NQe.call({
        concatArrays: !0
      }, {
        blockService: r,
        formats: [],
        loadFormat: t => {
          if (nue[t]) return Promise.resolve(nue[t]);
          throw new Error(`Missing IPLD format "${d_.getName(t)}"`)
        }
      }, e)
    });
    var aue = y((p_, oue) => {
      l();
      (function (r, e) {
        typeof p_ == "object" && typeof oue != "undefined" ? e(p_) : typeof define == "function" && define.amd ? define(["exports"], e) : (r = r || self, e(r.typical = {}))
      })(p_, function (r) {
        "use strict";

        function e(E) {
          return !isNaN(parseFloat(E)) && isFinite(E)
        }

        function t(E) {
          return E !== null && typeof E == "object" && E.constructor === Object
        }

        function i(E) {
          return n(E) && typeof E.length == "number"
        }

        function n(E) {
          return typeof E == "object" && E !== null
        }

        function s(E) {
          return typeof E != "undefined"
        }

        function o(E) {
          return !s(E)
        }

        function a(E) {
          return E === null
        }

        function c(E) {
          return s(E) && !a(E) && !Number.isNaN(E)
        }

        function u(E) {
          return typeof E == "function" ? /^class /.test(Function.prototype.toString.call(E)) : !1
        }

        function f(E) {
          if (E === null) return !0;
          switch (typeof E) {
            case "string":
            case "number":
            case "symbol":
            case "undefined":
            case "boolean":
              return !0;
            default:
              return !1
          }
        }

        function h(E) {
          if (E) {
            let w = s(Promise) && E instanceof Promise,
              O = E.then && typeof E.then == "function";
            return !!(w || O)
          } else return !1
        }

        function d(E) {
          return E === null || !s(E) ? !1 : typeof E[Symbol.iterator] == "function" || typeof E[Symbol.asyncIterator] == "function"
        }

        function p(E) {
          return typeof E == "string"
        }

        function g(E) {
          return typeof E == "function"
        }
        var m = {
          isNumber: e,
          isPlainObject: t,
          isArrayLike: i,
          isObject: n,
          isDefined: s,
          isUndefined: o,
          isNull: a,
          isDefinedValue: c,
          isClass: u,
          isPrimitive: f,
          isPromise: h,
          isIterable: d,
          isString: p,
          isFunction: g
        };
        r.default = m, r.isArrayLike = i, r.isClass = u, r.isDefined = s, r.isDefinedValue = c, r.isFunction = g, r.isIterable = d, r.isNull = a, r.isNumber = e, r.isObject = n, r.isPlainObject = t, r.isPrimitive = f, r.isPromise = h, r.isString = p, r.isUndefined = o, Object.defineProperty(r, "__esModule", {
          value: !0
        })
      })
    });
    var cue = y(Pf => {
      l();
      "use strict";
      Pf.first = async r => {
        for await (let e of r) return e
      };
      Pf.last = async r => {
        let e;
        for await (e of r);
        return e
      };
      Pf.all = async r => {
        let e = [];
        for await (let t of r) e.push(t);
        return e
      };
      Pf.extendIterator = r => (r.first = () => Pf.first(r), r.last = () => Pf.last(r), r.all = () => Pf.all(r), r)
    });
    var fue = y((B5t, uue) => {
      l();
      "use strict";
      var qQe = ql(),
        y_ = at(),
        g_ = Yr(),
        MQe = s7(),
        BQe = Mr(),
        DQe = o7(),
        ip = Jr(),
        a7 = aue(),
        {
          extendIterator: sb
        } = cue(),
        ob = class {
          constructor(e) {
            let t = g_(ob.defaultOptions, e);
            if (!t.blockService) throw new Error("Missing blockservice");
            this.bs = t.blockService, this.resolvers = {}, typeof t.loadFormat != "function" ? this.loadFormat = i => {
              let n = ip.getNameFromCode(i);
              throw new Error(`No resolver found for codec "${n}"`)
            } : this.loadFormat = t.loadFormat;
            for (let i of t.formats) this.addFormat(i)
          }
          addFormat(e) {
            let t = e.codec;
            if (this.resolvers[e.codec]) {
              let i = ip.getNameFromCode(t);
              throw new Error(`Resolver already exists for codec "${i}"`)
            }
            return this.resolvers[t] = e, this
          }
          removeFormat(e) {
            return this.resolvers[e] && delete this.resolvers[e], this
          }
          resolve(e, t, i) {
            if (!y_.isCID(e)) throw new Error("`cid` argument must be a CID");
            if (typeof t != "string") throw new Error("`path` argument must be a string");
            let n = this;
            return sb(async function* () {
              for (; ;) {
                let o = await n.getFormat(ip.getCodeFromName(e.codec)),
                  a = await n.bs.get(e, i),
                  c = o.resolver.resolve(a.data, t);
                t = c.remainderPath;
                let u = c.value;
                if (Object.keys(u).length === 1 && "/" in u) try {
                  u = new y_(u["/"])
                } catch (f) {
                  u = null
                }
                if (yield {
                  remainderPath: t,
                  value: u
                }, y_.isCID(u)) e = u;
                else return
              }
            }())
          }
          async get(e, t) {
            let i = await this.bs.get(e, t);
            return (await this.getFormat(i.cid.codec)).util.deserialize(i.data)
          }
          getMany(e, t) {
            if (!a7.isIterable(e) || typeof e == "string" || e instanceof Uint8Array) throw new Error("`cids` must be an iterable of CIDs");
            let i = this;
            return sb(async function* () {
              for await (let s of e) yield i.get(s, t)
            }())
          }
          async put(e, t, i) {
            if (t === void 0) throw new Error("`put` requires a format");
            if (typeof t != "number") throw new Error("`format` parameter must be number (multicodec)");
            let n = await this.getFormat(t),
              s = {
                hashAlg: n.defaultHashAlg,
                cidVersion: 1,
                onlyHash: !1
              },
              o = g_(s, i),
              a = {
                cidVersion: o.cidVersion,
                hashAlg: o.hashAlg,
                onlyHash: o.onlyHash
              },
              c = n.util.serialize(e),
              u = await n.util.cid(c, a);
            if (!o.onlyHash) {
              let f = new qQe(c, u);
              await this.bs.put(f, o)
            }
            return u
          }
          putMany(e, t, i) {
            if (!a7.isIterable(e) || typeof e == "string" || e instanceof Uint8Array) throw new Error("`nodes` must be an iterable");
            if (t === void 0) throw new Error("`put` requires a format");
            if (typeof t != "number") throw new Error("`format` parameter must be number (multicodec)");
            let n, s, o = this;
            return sb(async function* () {
              for await (let c of e) {
                if (n === void 0) {
                  s = await o.getFormat(t);
                  let u = {
                    hashAlg: s.defaultHashAlg,
                    cidVersion: 1,
                    onlyHash: !1
                  };
                  n = g_(u, i)
                }
                yield o.put(c, t, n)
              }
            }())
          }
          async remove(e, t) {
            return this.bs.delete(e, t)
          }
          removeMany(e, t) {
            if (!a7.isIterable(e) || typeof e == "string" || e instanceof Uint8Array) throw new Error("`cids` must be an iterable of CIDs");
            let i = this;
            return sb(async function* () {
              for await (let s of e) yield i.remove(s, t)
            }())
          }
          tree(e, t, i) {
            typeof t == "object" && (i = t, t = void 0), t = t || "";
            let s = g_({
              recursive: !1
            }, i),
              o = async (u, f) => {
                let d = (await this.getFormat(ip.getCodeFromName(u.cid.codec))).resolver.resolve(u.data, f);
                if (y_.isCID(d.value)) return d.value
              }, a = this;
            return sb(async function* () {
              let u = [],
                f, h = [{
                  cid: e,
                  basePath: ""
                }],
                d;
              for (; u.length > 0 || h.length > 0;) {
                if (u.length === 0 && h.length > 0) {
                  let m = h.shift();
                  if (m) {
                    ({
                      cid: e,
                      basePath: d
                    } = m);
                    let E = await a.getFormat(ip.getCodeFromName(e.codec));
                    f = await a.bs.get(e, s);
                    let w = E.resolver.tree(f.data);
                    u.push(...w)
                  }
                }
                let p = u.shift() || "",
                  g = d + p;
                if (s.recursive) {
                  let m = await o(f, p);
                  m != null && h.push({
                    cid: m,
                    basePath: g + "/"
                  })
                }
                t !== void 0 && g.startsWith(t) && g.length > t.length && (t.length > 0 && (g = g.slice(t.length + 1)), yield g)
              }
            }())
          }
          async getFormat(e) {
            if (typeof e == "string" && (e = ip.getCodeFromName(e)), this.resolvers[e]) return this.resolvers[e];
            let t = await this.loadFormat(e);
            return this.addFormat(t), t
          }
        };
      ob.defaultOptions = {
        formats: [MQe, BQe, DQe]
      };
      uue.exports = ob
    });
    var hue = y((D5t, lue) => {
      l();
      "use strict";
      var LQe = sue(),
        FQe = fue(),
        UQe = ({
          blockService: r,
          options: e
        }) => new FQe(LQe(r, e));
      lue.exports = UQe
    });
    var pue = y((L5t, due) => {
      l();
      "use strict";
      var KQe = o_();
      due.exports = (r, e) => {
        let t = e.path || "ipfs";
        return new KQe(t, {
          autoMigrate: e.autoMigrate
        })
      }
    });
    var c7 = y((F5t, yue) => {
      l();
      "use strict";
      var gue = () => { },
        bue = Symbol.for("@libp2p/js-interfaces/topology"),
        mue = class {
          constructor({
            min: e = 0,
            max: t = Infinity,
            handlers: i = {}
          }) {
            this.min = e, this.max = t, this._onConnect = i.onConnect || gue, this._onDisconnect = i.onDisconnect || gue, this.peers = new Set
          }
          get [Symbol.toStringTag]() {
            return "Topology"
          }
          get [bue]() {
            return !0
          }
          static isTopology(e) {
            return Boolean(e && e[bue])
          }
          set registrar(e) {
            this._registrar = e
          }
          disconnect(e) {
            this._onDisconnect(e)
          }
        };
      yue.exports = mue
    });
    var b_ = y((U5t, vue) => {
      l();
      "use strict";
      var zQe = c7(),
        wue = Symbol.for("@libp2p/js-interfaces/topology/multicodec-topology"),
        _ue = class extends zQe {
          constructor({
            min: e,
            max: t,
            multicodecs: i,
            handlers: n
          }) {
            super({
              min: e,
              max: t,
              handlers: n
            });
            if (!i) throw new Error("one or more multicodec should be provided");
            if (!n) throw new Error("the handlers should be provided");
            if (typeof n.onConnect != "function") throw new Error("the 'onConnect' handler must be provided");
            if (typeof n.onDisconnect != "function") throw new Error("the 'onDisconnect' handler must be provided");
            this.multicodecs = Array.isArray(i) ? i : [i], this._registrar = void 0, this._onProtocolChange = this._onProtocolChange.bind(this), this._onPeerConnect = this._onPeerConnect.bind(this)
          }
          get [Symbol.toStringTag]() {
            return "Topology"
          }
          get [wue]() {
            return !0
          }
          static isMulticodecTopology(e) {
            return Boolean(e && e[wue])
          }
          set registrar(e) {
            this._registrar = e, this._registrar.peerStore.on("change:protocols", this._onProtocolChange), this._registrar.connectionManager.on("peer:connect", this._onPeerConnect), this._updatePeers(this._registrar.peerStore.peers.values())
          }
          _updatePeers(e) {
            for (let {
              id: t,
              protocols: i
            } of e)
              if (this.multicodecs.filter(n => i.includes(n)).length) {
                this.peers.add(t.toB58String());
                let n = this._registrar.getConnection(t);
                n && this._onConnect(t, n)
              } else this.peers.delete(t.toB58String())
          }
          _onProtocolChange({
            peerId: e,
            protocols: t
          }) {
            let i = this.peers.has(e.toB58String()),
              n = t.filter(s => this.multicodecs.includes(s));
            i && n.length === 0 && this._onDisconnect(e);
            for (let s of t)
              if (this.multicodecs.includes(s)) {
                let o = this._registrar.peerStore.get(e);
                this._updatePeers([o]);
                return
              }
          }
          _onPeerConnect(e) {
            let t = e.remotePeer,
              i = this._registrar.peerStore.protoBook.get(t);
            !i || this.multicodecs.find(n => i.includes(n)) && (this.peers.add(t.toB58String()), this._onConnect(t, e))
          }
        };
      vue.exports = _ue
    });
    var m_ = y(Eue => {
      l();
      "use strict";
      Eue.codes = {
        ERR_INVALID_SIGNATURE_POLICY: "ERR_INVALID_SIGNATURE_POLICY",
        ERR_UNHANDLED_SIGNATURE_POLICY: "ERR_UNHANDLED_SIGNATURE_POLICY",
        ERR_MISSING_SIGNATURE: "ERR_MISSING_SIGNATURE",
        ERR_MISSING_SEQNO: "ERR_MISSING_SEQNO",
        ERR_INVALID_SIGNATURE: "ERR_INVALID_SIGNATURE",
        ERR_UNEXPECTED_FROM: "ERR_UNEXPECTED_FROM",
        ERR_UNEXPECTED_SIGNATURE: "ERR_UNEXPECTED_SIGNATURE",
        ERR_UNEXPECTED_KEY: "ERR_UNEXPECTED_KEY",
        ERR_UNEXPECTED_SEQNO: "ERR_UNEXPECTED_SEQNO"
      }
    });
    var f7 = y((z5t, Sue) => {
      l();
      "use strict";
      var Cf = bi(),
        np = Cf.Reader,
        u7 = Cf.Writer,
        Zt = Cf.util,
        Ni = Cf.roots["libp2p-pubsub-rpc"] || (Cf.roots["libp2p-pubsub-rpc"] = {});
      Ni.RPC = function () {
        function r(e) {
          if (this.subscriptions = [], this.msgs = [], e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.subscriptions = Zt.emptyArray, r.prototype.msgs = Zt.emptyArray, r.encode = function (t, i) {
          if (i || (i = u7.create()), t.subscriptions != null && t.subscriptions.length)
            for (var n = 0; n < t.subscriptions.length; ++n) Ni.RPC.SubOpts.encode(t.subscriptions[n], i.uint32(10).fork()).ldelim();
          if (t.msgs != null && t.msgs.length)
            for (var n = 0; n < t.msgs.length; ++n) Ni.RPC.Message.encode(t.msgs[n], i.uint32(18).fork()).ldelim();
          return i
        }, r.decode = function (t, i) {
          t instanceof np || (t = np.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Ni.RPC; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.subscriptions && s.subscriptions.length || (s.subscriptions = []), s.subscriptions.push(Ni.RPC.SubOpts.decode(t, t.uint32()));
                break;
              case 2:
                s.msgs && s.msgs.length || (s.msgs = []), s.msgs.push(Ni.RPC.Message.decode(t, t.uint32()));
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Ni.RPC) return t;
          var i = new Ni.RPC;
          if (t.subscriptions) {
            if (!Array.isArray(t.subscriptions)) throw TypeError(".RPC.subscriptions: array expected");
            i.subscriptions = [];
            for (var n = 0; n < t.subscriptions.length; ++n) {
              if (typeof t.subscriptions[n] != "object") throw TypeError(".RPC.subscriptions: object expected");
              i.subscriptions[n] = Ni.RPC.SubOpts.fromObject(t.subscriptions[n])
            }
          }
          if (t.msgs) {
            if (!Array.isArray(t.msgs)) throw TypeError(".RPC.msgs: array expected");
            i.msgs = [];
            for (var n = 0; n < t.msgs.length; ++n) {
              if (typeof t.msgs[n] != "object") throw TypeError(".RPC.msgs: object expected");
              i.msgs[n] = Ni.RPC.Message.fromObject(t.msgs[n])
            }
          }
          return i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if ((i.arrays || i.defaults) && (n.subscriptions = [], n.msgs = []), t.subscriptions && t.subscriptions.length) {
            n.subscriptions = [];
            for (var s = 0; s < t.subscriptions.length; ++s) n.subscriptions[s] = Ni.RPC.SubOpts.toObject(t.subscriptions[s], i)
          }
          if (t.msgs && t.msgs.length) {
            n.msgs = [];
            for (var s = 0; s < t.msgs.length; ++s) n.msgs[s] = Ni.RPC.Message.toObject(t.msgs[s], i)
          }
          return n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, Cf.util.toJSONOptions)
        }, r.SubOpts = function () {
          function e(t) {
            if (t)
              for (var i = Object.keys(t), n = 0; n < i.length; ++n) t[i[n]] != null && (this[i[n]] = t[i[n]])
          }
          return e.prototype.subscribe = !1, e.prototype.topicID = "", e.encode = function (i, n) {
            return n || (n = u7.create()), i.subscribe != null && Object.hasOwnProperty.call(i, "subscribe") && n.uint32(8).bool(i.subscribe), i.topicID != null && Object.hasOwnProperty.call(i, "topicID") && n.uint32(18).string(i.topicID), n
          }, e.decode = function (i, n) {
            i instanceof np || (i = np.create(i));
            for (var s = n === void 0 ? i.len : i.pos + n, o = new Ni.RPC.SubOpts; i.pos < s;) {
              var a = i.uint32();
              switch (a >>> 3) {
                case 1:
                  o.subscribe = i.bool();
                  break;
                case 2:
                  o.topicID = i.string();
                  break;
                default:
                  i.skipType(a & 7);
                  break
              }
            }
            return o
          }, e.fromObject = function (i) {
            if (i instanceof Ni.RPC.SubOpts) return i;
            var n = new Ni.RPC.SubOpts;
            return i.subscribe != null && (n.subscribe = Boolean(i.subscribe)), i.topicID != null && (n.topicID = String(i.topicID)), n
          }, e.toObject = function (i, n) {
            n || (n = {});
            var s = {};
            return n.defaults && (s.subscribe = !1, s.topicID = ""), i.subscribe != null && i.hasOwnProperty("subscribe") && (s.subscribe = i.subscribe), i.topicID != null && i.hasOwnProperty("topicID") && (s.topicID = i.topicID), s
          }, e.prototype.toJSON = function () {
            return this.constructor.toObject(this, Cf.util.toJSONOptions)
          }, e
        }(), r.Message = function () {
          function e(t) {
            if (this.topicIDs = [], t)
              for (var i = Object.keys(t), n = 0; n < i.length; ++n) t[i[n]] != null && (this[i[n]] = t[i[n]])
          }
          return e.prototype.from = Zt.newBuffer([]), e.prototype.data = Zt.newBuffer([]), e.prototype.seqno = Zt.newBuffer([]), e.prototype.topicIDs = Zt.emptyArray, e.prototype.signature = Zt.newBuffer([]), e.prototype.key = Zt.newBuffer([]), e.encode = function (i, n) {
            if (n || (n = u7.create()), i.from != null && Object.hasOwnProperty.call(i, "from") && n.uint32(10).bytes(i.from), i.data != null && Object.hasOwnProperty.call(i, "data") && n.uint32(18).bytes(i.data), i.seqno != null && Object.hasOwnProperty.call(i, "seqno") && n.uint32(26).bytes(i.seqno), i.topicIDs != null && i.topicIDs.length)
              for (var s = 0; s < i.topicIDs.length; ++s) n.uint32(34).string(i.topicIDs[s]);
            return i.signature != null && Object.hasOwnProperty.call(i, "signature") && n.uint32(42).bytes(i.signature), i.key != null && Object.hasOwnProperty.call(i, "key") && n.uint32(50).bytes(i.key), n
          }, e.decode = function (i, n) {
            i instanceof np || (i = np.create(i));
            for (var s = n === void 0 ? i.len : i.pos + n, o = new Ni.RPC.Message; i.pos < s;) {
              var a = i.uint32();
              switch (a >>> 3) {
                case 1:
                  o.from = i.bytes();
                  break;
                case 2:
                  o.data = i.bytes();
                  break;
                case 3:
                  o.seqno = i.bytes();
                  break;
                case 4:
                  o.topicIDs && o.topicIDs.length || (o.topicIDs = []), o.topicIDs.push(i.string());
                  break;
                case 5:
                  o.signature = i.bytes();
                  break;
                case 6:
                  o.key = i.bytes();
                  break;
                default:
                  i.skipType(a & 7);
                  break
              }
            }
            return o
          }, e.fromObject = function (i) {
            if (i instanceof Ni.RPC.Message) return i;
            var n = new Ni.RPC.Message;
            if (i.from != null && (typeof i.from == "string" ? Zt.base64.decode(i.from, n.from = Zt.newBuffer(Zt.base64.length(i.from)), 0) : i.from.length && (n.from = i.from)), i.data != null && (typeof i.data == "string" ? Zt.base64.decode(i.data, n.data = Zt.newBuffer(Zt.base64.length(i.data)), 0) : i.data.length && (n.data = i.data)), i.seqno != null && (typeof i.seqno == "string" ? Zt.base64.decode(i.seqno, n.seqno = Zt.newBuffer(Zt.base64.length(i.seqno)), 0) : i.seqno.length && (n.seqno = i.seqno)), i.topicIDs) {
              if (!Array.isArray(i.topicIDs)) throw TypeError(".RPC.Message.topicIDs: array expected");
              n.topicIDs = [];
              for (var s = 0; s < i.topicIDs.length; ++s) n.topicIDs[s] = String(i.topicIDs[s])
            }
            return i.signature != null && (typeof i.signature == "string" ? Zt.base64.decode(i.signature, n.signature = Zt.newBuffer(Zt.base64.length(i.signature)), 0) : i.signature.length && (n.signature = i.signature)), i.key != null && (typeof i.key == "string" ? Zt.base64.decode(i.key, n.key = Zt.newBuffer(Zt.base64.length(i.key)), 0) : i.key.length && (n.key = i.key)), n
          }, e.toObject = function (i, n) {
            n || (n = {});
            var s = {};
            if ((n.arrays || n.defaults) && (s.topicIDs = []), n.defaults && (n.bytes === String ? s.from = "" : (s.from = [], n.bytes !== Array && (s.from = Zt.newBuffer(s.from))), n.bytes === String ? s.data = "" : (s.data = [], n.bytes !== Array && (s.data = Zt.newBuffer(s.data))), n.bytes === String ? s.seqno = "" : (s.seqno = [], n.bytes !== Array && (s.seqno = Zt.newBuffer(s.seqno))), n.bytes === String ? s.signature = "" : (s.signature = [], n.bytes !== Array && (s.signature = Zt.newBuffer(s.signature))), n.bytes === String ? s.key = "" : (s.key = [], n.bytes !== Array && (s.key = Zt.newBuffer(s.key)))), i.from != null && i.hasOwnProperty("from") && (s.from = n.bytes === String ? Zt.base64.encode(i.from, 0, i.from.length) : n.bytes === Array ? Array.prototype.slice.call(i.from) : i.from), i.data != null && i.hasOwnProperty("data") && (s.data = n.bytes === String ? Zt.base64.encode(i.data, 0, i.data.length) : n.bytes === Array ? Array.prototype.slice.call(i.data) : i.data), i.seqno != null && i.hasOwnProperty("seqno") && (s.seqno = n.bytes === String ? Zt.base64.encode(i.seqno, 0, i.seqno.length) : n.bytes === Array ? Array.prototype.slice.call(i.seqno) : i.seqno), i.topicIDs && i.topicIDs.length) {
              s.topicIDs = [];
              for (var o = 0; o < i.topicIDs.length; ++o) s.topicIDs[o] = i.topicIDs[o]
            }
            return i.signature != null && i.hasOwnProperty("signature") && (s.signature = n.bytes === String ? Zt.base64.encode(i.signature, 0, i.signature.length) : n.bytes === Array ? Array.prototype.slice.call(i.signature) : i.signature), i.key != null && i.hasOwnProperty("key") && (s.key = n.bytes === String ? Zt.base64.encode(i.key, 0, i.key.length) : n.bytes === Array ? Array.prototype.slice.call(i.key) : i.key), s
          }, e.prototype.toJSON = function () {
            return this.constructor.toObject(this, Cf.util.toJSONOptions)
          }, e
        }(), r
      }();
      Sue.exports = Ni
    });
    var l7 = y((j5t, xue) => {
      l();
      "use strict";
      var Aue = Yo(),
        {
          Buffer: jQe
        } = Wt(),
        Iue = (r, e, t) => {
          let i = Aue.encode(r, e, t);
          return Iue.bytes = Aue.encode.bytes, e || jQe.from(i)
        };
      xue.exports = Iue
    });
    var Oue = y((V5t, v_) => {
      l();
      "use strict";
      var {
        Buffer: Tue
      } = Wt(), Rue = go(), kue = l7(), h7 = 8, Pue = 10 * 1024;

      function Cue(r) {
        r = r || {};
        let e = Math.max(r.poolSize || Pue, r.minPoolSize || h7),
          t = r.lengthEncoder || kue;
        return async function* (n) {
          let s = Tue.alloc(e),
            o = 0;
          for await (let a of n) {
            t(a.length, s, o);
            let c = s.slice(o, o + t.bytes);
            o += t.bytes, s.length - o < h7 && (s = Tue.alloc(e), o = 0), yield new Rue().append(c).append(a)
          }
        }
      }
      Cue.single = (r, e) => {
        e = e || {};
        let t = e.lengthEncoder || kue;
        return new Rue([t(r.length), r.slice()])
      };
      v_.exports = Cue;
      v_.exports.MIN_POOL_SIZE = h7;
      v_.exports.DEFAULT_POOL_SIZE = Pue
    });
    var d7 = y((H5t, Nue) => {
      l();
      "use strict";
      var que = Yo(),
        {
          Buffer: VQe
        } = Wt(),
        HQe = r => new Proxy({}, {
          get: (e, t) => t[0] === "l" ? r[t] : r.get(parseInt(t))
        }),
        Mue = r => {
          let e = que.decode(VQe.isBuffer(r) ? r : HQe(r));
          return Mue.bytes = que.decode.bytes, e
        };
      Nue.exports = Mue
    });
    var Fue = y((G5t, w_) => {
      l();
      "use strict";
      var {
        Buffer: GQe
      } = Wt(), p7 = go(), $Qe = d7(), Bue = 8, Due = 1024 * 1024 * 4, Lue = GQe.alloc(0), Of = {
        LENGTH: "readLength",
        DATA: "readData"
      }, WQe = {
        [Of.LENGTH]: (r, e, t, i) => {
          e = e.append(r);
          let n;
          try {
            n = i.lengthDecoder(e)
          } catch (s) {
            if (e.length > i.maxLengthLength) throw Object.assign(s, {
              message: "message length too long",
              code: "ERR_MSG_LENGTH_TOO_LONG"
            });
            if (s instanceof RangeError) return {
              mode: Of.LENGTH,
              buffer: e,
              chunk: void 0,
              state: void 0,
              data: void 0
            };
            throw s
          }
          if (n > i.maxDataLength) throw Object.assign(new Error("message data too long"), {
            code: "ERR_MSG_DATA_TOO_LONG"
          });
          return r = e.shallowSlice(i.lengthDecoder.bytes), e = new p7, i.onLength && i.onLength(n), n <= 0 ? (i.onData && i.onData(Lue), {
            mode: Of.LENGTH,
            chunk: r,
            buffer: e,
            data: Lue
          }) : {
            mode: Of.DATA,
            chunk: r,
            buffer: e,
            state: {
              dataLength: n
            },
            data: void 0
          }
        },
        [Of.DATA]: (r, e, t, i) => {
          if (e = e.append(r), !t) throw new Error("state is required");
          if (e.length < t.dataLength) return {
            mode: Of.DATA,
            buffer: e,
            state: t,
            chunk: void 0,
            data: void 0
          };
          let {
            dataLength: n
          } = t, s = e.shallowSlice(0, n), o = e.length > n ? e.shallowSlice(n) : void 0;
          return e = new p7, i.onData && i.onData(s), {
            mode: Of.LENGTH,
            chunk: o,
            buffer: e,
            state: void 0,
            data: s
          }
        }
      };

      function y7(r) {
        r = r || {};
        let e = {
          lengthDecoder: r.lengthDecoder || $Qe,
          maxLengthLength: r.maxLengthLength || Bue,
          maxDataLength: r.maxDataLength || Due,
          onLength: r.onLength,
          onData: r.onData
        };
        return async function* (i) {
          let n = new p7,
            s = Of.LENGTH,
            o;
          for await (let a of i) {
            let c = a;
            for (; c;) {
              let u = WQe[s](c, n, o, e);
              s = u.mode, c = u.chunk, n = u.buffer, o = u.state, u.data && (yield u.data)
            }
          }
          if (n.length) throw Object.assign(new Error("unexpected end of input"), {
            code: "ERR_UNEXPECTED_EOF"
          })
        }
      }
      y7.fromReader = (r, e) => {
        let t = 1,
          i = {
            [Symbol.asyncIterator]() {
              return this
            },
            next: async () => {
              try {
                return await r.next(t)
              } catch (s) {
                if (s.code === "ERR_UNDER_READ") return {
                  done: !0,
                  value: null
                };
                throw s
              } finally {
                t = 1
              }
            }
          };
        return y7({
          ...e || {},
          onLength: s => {
            t = s
          }
        })(i)
      };
      w_.exports = y7;
      w_.exports.MAX_LENGTH_LENGTH = Bue;
      w_.exports.MAX_DATA_LENGTH = Due
    });
    var zue = y(($5t, Uue) => {
      l();
      "use strict";
      var {
        Buffer: YQe
      } = Wt(), Kue = (r, e, t) => (e = e || YQe.allocUnsafe(4), e.writeInt32BE(r, t), e);
      Kue.bytes = 4;
      Uue.exports = Kue
    });
    var Hue = y((W5t, jue) => {
      l();
      "use strict";
      var Vue = r => {
        if (r.length < 4) throw RangeError("Could not decode int32BE");
        return r.readInt32BE(0)
      };
      Vue.bytes = 4;
      jue.exports = Vue
    });
    var da = y(ch => {
      l();
      "use strict";
      ch.encode = Oue();
      ch.decode = Fue();
      ch.varintEncode = l7();
      ch.varintDecode = d7();
      ch.int32BEEncode = zue();
      ch.int32BEDecode = Hue()
    });
    var __ = y((J5t, Gue) => {
      l();
      Gue.exports = function (e) {
        if (e) {
          if (typeof e[Symbol.iterator] == "function") return e[Symbol.iterator]();
          if (typeof e[Symbol.asyncIterator] == "function") return e[Symbol.asyncIterator]();
          if (typeof e.next == "function") return e
        }
        throw new Error("argument is not an iterator or iterable")
      }
    });
    var Wue = y((Z5t, $ue) => {
      l();
      $ue.exports = class extends Error {
        constructor(e, t) {
          super(e || "The operation was aborted");
          this.type = "aborted", this.code = t || "ABORT_ERR"
        }
      }
    });
    var au = y((Q5t, uh) => {
      l();
      var JQe = __(),
        g7 = Wue(),
        Yue = (r, e, t) => b7(r, Array.isArray(e) ? e : [{
          signal: e,
          options: t
        }]),
        b7 = (r, e) => {
          r = JQe(r), e = e.map(({
            signal: i,
            options: n
          }) => ({
            signal: i,
            options: n || {}
          }));
          async function* t() {
            let i, n = () => {
              i && i()
            };
            for (let {
              signal: s
            } of e) s.addEventListener("abort", n);
            for (; ;) {
              let s;
              try {
                for (let {
                  signal: a,
                  options: c
                } of e)
                  if (a.aborted) {
                    let {
                      abortMessage: u,
                      abortCode: f
                    } = c;
                    throw new g7(u, f)
                  } let o = new Promise((a, c) => {
                    i = () => {
                      let {
                        options: u
                      } = e.find(({
                        signal: d
                      }) => d.aborted), {
                        abortMessage: f,
                        abortCode: h
                      } = u;
                      c(new g7(f, h))
                    }
                  });
                s = await Promise.race([o, r.next()]), i = null
              } catch (o) {
                for (let {
                  signal: u
                } of e) u.removeEventListener("abort", n);
                let a = e.find(({
                  signal: u
                }) => u.aborted),
                  c = o.type === "aborted" && a;
                if (c && a.options.onAbort && await a.options.onAbort(r), typeof r.return == "function" && await r.return(), c && a.options.returnOnAbort) return;
                throw o
              }
              if (s.done) break;
              yield s.value
            }
            for (let {
              signal: s
            } of e) s.removeEventListener("abort", n)
          }
          return t()
        },
        Xue = (r, e, t) => Jue(r, Array.isArray(e) ? e : [{
          signal: e,
          options: t
        }]),
        Jue = (r, e) => t => r(b7(t, e)),
        ZQe = (r, e, t) => XQe(r, Array.isArray(e) ? e : [{
          signal: e,
          options: t
        }]),
        XQe = (r, e) => ({
          sink: Jue(r.sink, e),
          source: b7(r.source, e)
        });
      uh.exports = Yue;
      uh.exports.AbortError = g7;
      uh.exports.source = Yue;
      uh.exports.sink = Xue;
      uh.exports.transform = Xue;
      uh.exports.duplex = ZQe
    });
    var ife = y((e8t, Zue) => {
      l();
      "use strict";
      var Que = Oe(),
        QQe = Object.assign(Que("libp2p-pubsub:peer-streams"), {
          error: Que("libp2p-pubsub:peer-streams:err")
        }),
        {
          EventEmitter: eet
        } = Br(),
        efe = da(),
        tet = eu(),
        {
          pipe: tfe
        } = vi(),
        {
          source: ret
        } = au(),
        iet = Zf().default,
        rfe = class extends eet {
          constructor({
            id: e,
            protocol: t
          }) {
            super();
            this.id = e, this.protocol = t, this._rawOutboundStream = null, this._rawInboundStream = null, this._inboundAbortController = new iet, this.outboundStream = null, this.inboundStream = null
          }
          get isReadable() {
            return Boolean(this.inboundStream)
          }
          get isWritable() {
            return Boolean(this.outboundStream)
          }
          write(e) {
            if (!this.outboundStream) {
              let t = this.id.toB58String();
              throw new Error("No writable connection to " + t)
            }
            this.outboundStream.push(e)
          }
          attachInboundStream(e) {
            return this._rawInboundStream = e, this.inboundStream = ret(tfe(this._rawInboundStream, efe.decode()), this._inboundAbortController.signal, {
              returnOnAbort: !0
            }), this.emit("stream:inbound"), this.inboundStream
          }
          async attachOutboundStream(e) {
            let t = this.outboundStream;
            this.outboundStream && await this.outboundStream.end(), this._rawOutboundStream = e, this.outboundStream = tet({
              onEnd: i => {
                this._rawOutboundStream && this._rawOutboundStream.reset && this._rawOutboundStream.reset(), this._rawOutboundStream = null, this.outboundStream = null, i && this.emit("close")
              }
            }), tfe(this.outboundStream, efe.encode(), this._rawOutboundStream).catch(i => {
              QQe.error(i)
            }), t || this.emit("stream:outbound")
          }
          close() {
            this.outboundStream && this.outboundStream.end(), this.inboundStream && this._inboundAbortController.abort(), this._rawOutboundStream = null, this.outboundStream = null, this._rawInboundStream = null, this.inboundStream = null, this.emit("close")
          }
        };
      Zue.exports = rfe
    });
    var sfe = y(nfe => {
      l();
      "use strict";
      var net = {
        StrictSign: "StrictSign",
        StrictNoSign: "StrictNoSign"
      };
      nfe.SignaturePolicy = net
    });
    var cfe = y((r8t, ofe) => {
      l();
      "use strict";
      var set = H1(),
        oet = ct(),
        afe = gt(),
        aet = Et(),
        cet = Do(),
        uet = () => set(8),
        fet = (r, e) => {
          let t = aet.createFromB58String(r).id,
            i = new Uint8Array(t.length + e.length);
          return i.set(t, 0), i.set(e, t.length), i
        },
        het = r => cet.encode(r, "sha2-256"),
        det = (r, e) => {
          let t;
          Array.isArray(e) ? t = i => e.indexOf(i) > -1 : t = i => e.has(i);
          for (let i of r)
            if (t(i)) return !0;
          return !1
        },
        pet = r => Array.isArray(r) ? r : [r],
        yet = (r, e) => {
          let t = Object.assign({}, r);
          return r.from instanceof Uint8Array && (t.from = oet(r.from, "base58btc")), e && (t.receivedFrom = e), t
        },
        get = r => {
          let e = Object.assign({}, r);
          return typeof r.from == "string" && (e.from = afe(r.from, "base58btc")), typeof r.data == "string" && (e.data = afe(r.data)), e
        };
      ofe.exports = {
        randomSeqno: uet,
        msgId: fet,
        noSignMsgId: het,
        anyMatch: det,
        ensureArray: pet,
        normalizeInRpcMessage: yet,
        normalizeOutRpcMessage: get
      }
    });
    var dfe = y((i8t, ufe) => {
      l();
      "use strict";
      var m7 = Et(),
        {
          RPC: ffe
        } = f7(),
        lfe = xi(),
        bet = gt(),
        v7 = bet("libp2p-pubsub:");
      async function met(r, e) {
        let t = lfe([v7, ffe.Message.encode(e).finish()]),
          i = await r.privKey.sign(t);
        return {
          ...e,
          signature: i,
          key: r.pubKey.bytes
        }
      }
      async function vet(r) {
        if (!r.signature) throw new Error("Message must contain a signature to be verified");
        let e = lfe([v7, ffe.Message.encode({
          ...r,
          from: m7.createFromCID(r.from).toBytes(),
          signature: void 0,
          key: void 0
        }).finish()]);
        return (await hfe(r)).verify(e, r.signature)
      }
      async function hfe(r) {
        if (!r.from) throw new Error("Could not get the public key from the originator id");
        let e = m7.createFromCID(r.from);
        if (r.key) {
          let t = await m7.createFromPubKey(r.key);
          if (t.equals(e)) return t.pubKey;
          throw new Error("Public Key does not match the originator")
        } else {
          if (e.pubKey) return e.pubKey;
          throw new Error("Could not get the public key from the originator id")
        }
      }
      ufe.exports = {
        messagePublicKey: hfe,
        signMessage: met,
        SignPrefix: v7,
        verifySignature: vet
      }
    });
    var bfe = y((n8t, pfe) => {
      l();
      "use strict";
      var yfe = Oe(),
        {
          EventEmitter: wet
        } = Br(),
        ws = xe(),
        {
          pipe: _et
        } = vi(),
        Eet = b_(),
        {
          codes: pa
        } = m_(),
        {
          RPC: gfe
        } = f7(),
        xet = ife(),
        {
          SignaturePolicy: cu
        } = sfe(),
        uu = cfe(),
        {
          signMessage: Aet,
          verifySignature: Iet
        } = dfe(),
        E_ = class extends wet {
          constructor({
            debugName: e,
            multicodecs: t,
            libp2p: i,
            globalSignaturePolicy: n = cu.StrictSign,
            canRelayMessage: s = !1,
            emitSelf: o = !1
          }) {
            if (typeof e != "string") throw new Error("a debugname `string` is required");
            if (!t) throw new Error("multicodecs are required");
            if (!i) throw new Error("libp2p is required");
            super();
            if (this.log = Object.assign(yfe(e), {
              err: yfe(`${e}:error`)
            }), this.multicodecs = uu.ensureArray(t), this._libp2p = i, this.registrar = i.registrar, this.peerId = i.peerId, this.started = !1, this.topics = new Map, this.subscriptions = new Set, this.peers = new Map, !cu[n]) throw ws(new Error("Invalid global signature policy"), pa.ERR_INVALID_SIGNATURE_POLICY);
            this.globalSignaturePolicy = n, this.canRelayMessage = s, this.emitSelf = o, this.topicValidators = new Map, this._registrarId = void 0, this._onIncomingStream = this._onIncomingStream.bind(this), this._onPeerConnected = this._onPeerConnected.bind(this), this._onPeerDisconnected = this._onPeerDisconnected.bind(this)
          }
          start() {
            if (this.started) return;
            this.log("starting"), this.registrar.handle(this.multicodecs, this._onIncomingStream);
            let e = new Eet({
              multicodecs: this.multicodecs,
              handlers: {
                onConnect: this._onPeerConnected,
                onDisconnect: this._onPeerDisconnected
              }
            });
            this._registrarId = this.registrar.register(e), this.log("started"), this.started = !0
          }
          stop() {
            !this.started || (this.registrar.unregister(this._registrarId), this.log("stopping"), this.peers.forEach(e => e.close()), this.peers = new Map, this.subscriptions = new Set, this.started = !1, this.log("stopped"))
          }
          _onIncomingStream({
            protocol: e,
            stream: t,
            connection: i
          }) {
            let n = i.remotePeer,
              s = n.toB58String(),
              o = this._addPeer(n, e),
              a = o.attachInboundStream(t);
            this._processMessages(s, a, o)
          }
          async _onPeerConnected(e, t) {
            let i = e.toB58String();
            this.log("connected", i);
            try {
              let {
                stream: n,
                protocol: s
              } = await t.newStream(this.multicodecs);
              await this._addPeer(e, s).attachOutboundStream(n)
            } catch (n) {
              this.log.err(n)
            }
            this._sendSubscriptions(i, Array.from(this.subscriptions), !0)
          }
          _onPeerDisconnected(e, t) {
            let i = e.toB58String();
            this.log("connection ended", i, t ? t.message : ""), this._removePeer(e)
          }
          _addPeer(e, t) {
            let i = e.toB58String(),
              n = this.peers.get(i);
            if (n) return n;
            this.log("new peer", i);
            let s = new xet({
              id: e,
              protocol: t
            });
            return this.peers.set(i, s), s.once("close", () => this._removePeer(e)), s
          }
          _removePeer(e) {
            if (!e) return;
            let t = e.toB58String(),
              i = this.peers.get(t);
            if (!!i) {
              i.removeAllListeners(), i.close(), this.log("delete peer", t), this.peers.delete(t);
              for (let n of this.topics.values()) n.delete(t);
              return i
            }
          }
          async _processMessages(e, t, i) {
            try {
              await _et(t, async n => {
                for await (let s of n) {
                  let o = s instanceof Uint8Array ? s : s.slice(),
                    a = this._decodeRpc(o);
                  this._processRpc(e, i, a)
                }
              })
            } catch (n) {
              this._onPeerDisconnected(i.id, n)
            }
          }
          _processRpc(e, t, i) {
            this.log("rpc from", e);
            let n = i.subscriptions,
              s = i.msgs;
            return n.length && (n.forEach(o => {
              this._processRpcSubOpt(e, o)
            }), this.emit("pubsub:subscription-change", t.id, n)), this._acceptFrom(e) ? (s.length && s.forEach(o => {
              if (!(this.canRelayMessage || o.topicIDs && o.topicIDs.some(c => this.subscriptions.has(c)))) {
                this.log("received message we didn't subscribe to. Dropping.");
                return
              }
              let a = uu.normalizeInRpcMessage(o, e);
              this._processRpcMessage(a)
            }), !0) : (this.log("received message from unacceptable peer %s", e), !1)
          }
          _processRpcSubOpt(e, t) {
            let i = t.topicID;
            if (!i) return;
            let n = this.topics.get(i);
            n || (n = new Set, this.topics.set(i, n)), t.subscribe ? n.add(e) : n.delete(e)
          }
          async _processRpcMessage(e) {
            if (!(this.peerId.toB58String() === e.from && !this.emitSelf)) {
              try {
                await this.validate(e)
              } catch (t) {
                this.log("Message is invalid, dropping it. %O", t);
                return
              }
              this._emitMessage(e), this._publish(uu.normalizeOutRpcMessage(e))
            }
          }
          _emitMessage(e) {
            e.topicIDs.forEach(t => {
              this.subscriptions.has(t) && this.emit(t, e)
            })
          }
          getMsgId(e) {
            let t = this.globalSignaturePolicy;
            switch (t) {
              case cu.StrictSign:
                return uu.msgId(e.from, e.seqno);
              case cu.StrictNoSign:
                return uu.noSignMsgId(e.data);
              default:
                throw ws(new Error("Cannot get message id: unhandled signature policy: " + t), pa.ERR_UNHANDLED_SIGNATURE_POLICY)
            }
          }
          _acceptFrom(e) {
            return !0
          }
          _decodeRpc(e) {
            return gfe.decode(e)
          }
          _encodeRpc(e) {
            return gfe.encode(e).finish()
          }
          _sendRpc(e, t) {
            let i = this.peers.get(e);
            if (!i || !i.isWritable) {
              let n = `Cannot send RPC to ${e} as there is no open stream to it available`;
              this.log.err(n);
              return
            }
            i.write(this._encodeRpc(t))
          }
          _sendSubscriptions(e, t, i) {
            return this._sendRpc(e, {
              subscriptions: t.map(n => ({
                topicID: n,
                subscribe: i
              }))
            })
          }
          async validate(e) {
            let t = this.globalSignaturePolicy;
            switch (t) {
              case cu.StrictNoSign:
                if (e.from) throw ws(new Error("StrictNoSigning: from should not be present"), pa.ERR_UNEXPECTED_FROM);
                if (e.signature) throw ws(new Error("StrictNoSigning: signature should not be present"), pa.ERR_UNEXPECTED_SIGNATURE);
                if (e.key) throw ws(new Error("StrictNoSigning: key should not be present"), pa.ERR_UNEXPECTED_KEY);
                if (e.seqno) throw ws(new Error("StrictNoSigning: seqno should not be present"), pa.ERR_UNEXPECTED_SEQNO);
                break;
              case cu.StrictSign:
                if (!e.signature) throw ws(new Error("StrictSigning: Signing required and no signature was present"), pa.ERR_MISSING_SIGNATURE);
                if (!e.seqno) throw ws(new Error("StrictSigning: Signing required and no seqno was present"), pa.ERR_MISSING_SEQNO);
                if (!await Iet(e)) throw ws(new Error("StrictSigning: Invalid message signature"), pa.ERR_INVALID_SIGNATURE);
                break;
              default:
                throw ws(new Error("Cannot validate message: unhandled signature policy: " + t), pa.ERR_UNHANDLED_SIGNATURE_POLICY)
            }
            for (let i of e.topicIDs) {
              let n = this.topicValidators.get(i);
              n && await n(i, e)
            }
          }
          _buildMessage(e) {
            let t = this.globalSignaturePolicy;
            switch (t) {
              case cu.StrictSign:
                return e.from = this.peerId.toB58String(), e.seqno = uu.randomSeqno(), Aet(this.peerId, uu.normalizeOutRpcMessage(e));
              case cu.StrictNoSign:
                return Promise.resolve(e);
              default:
                throw ws(new Error("Cannot build message: unhandled signature policy: " + t), pa.ERR_UNHANDLED_SIGNATURE_POLICY)
            }
          }
          getSubscribers(e) {
            if (!this.started) throw ws(new Error("not started yet"), "ERR_NOT_STARTED_YET");
            if (!e || typeof e != "string") throw ws(new Error("a string topic must be provided"), "ERR_NOT_VALID_TOPIC");
            let t = this.topics.get(e);
            return t ? Array.from(t) : []
          }
          async publish(e, t) {
            if (!this.started) throw new Error("Pubsub has not started");
            this.log("publish", e, t);
            let n = {
              receivedFrom: this.peerId.toB58String(),
              data: t,
              topicIDs: [e]
            },
              s = await this._buildMessage(n),
              o = uu.normalizeInRpcMessage(s);
            this.emitSelf && this._emitMessage(o), await this._publish(o)
          }
          _publish(e) {
            throw ws(new Error("publish must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED")
          }
          subscribe(e) {
            if (!this.started) throw new Error("Pubsub has not started");
            this.subscriptions.has(e) || (this.subscriptions.add(e), this.peers.forEach((t, i) => this._sendSubscriptions(i, [e], !0)))
          }
          unsubscribe(e) {
            if (!this.started) throw new Error("Pubsub is not started");
            this.subscriptions.has(e) && this.listenerCount(e) === 0 && (this.subscriptions.delete(e), this.peers.forEach((t, i) => this._sendSubscriptions(i, [e], !1)))
          }
          getTopics() {
            if (!this.started) throw new Error("Pubsub is not started");
            return Array.from(this.subscriptions)
          }
        };
      E_.utils = uu;
      E_.SignaturePolicy = cu;
      pfe.exports = E_
    });
    var mfe = y(S_ => {
      l();
      "use strict";
      Object.defineProperty(S_, "__esModule", {
        value: !0
      });
      S_.createGossipRpc = void 0;

      function Tet(r = [], e = {}) {
        return {
          subscriptions: [],
          msgs: r,
          control: Object.assign({
            ihave: [],
            iwant: [],
            graft: [],
            prune: []
          }, e)
        }
      }
      S_.createGossipRpc = Tet
    });
    var vfe = y(x_ => {
      l();
      "use strict";
      Object.defineProperty(x_, "__esModule", {
        value: !0
      });
      x_.shuffle = void 0;

      function Ret(r) {
        if (r.length <= 1) return r;
        let e = () => Math.floor(Math.random() * Math.floor(r.length));
        for (let t = 0; t < r.length; t++) {
          let i = e(),
            n = r[t];
          r[t] = r[i], r[i] = n
        }
        return r
      }
      x_.shuffle = Ret
    });
    var fh = y(Le => {
      l();
      "use strict";
      Object.defineProperty(Le, "__esModule", {
        value: !0
      });
      Le.ERR_TOPIC_VALIDATOR_IGNORE = Le.ERR_TOPIC_VALIDATOR_REJECT = Le.TimeCacheDuration = Le.GossipsubIWantFollowupTime = Le.GossipsubMaxIHaveMessages = Le.GossipsubMaxIHaveLength = Le.GossipsubGraftFloodThreshold = Le.GossipsubOpportunisticGraftPeers = Le.GossipsubOpportunisticGraftTicks = Le.GossipsubDirectConnectInitialDelay = Le.GossipsubDirectConnectTicks = Le.GossipsubConnectionTimeout = Le.GossipsubMaxPendingConnections = Le.GossipsubConnectors = Le.GossipsubPruneBackoffTicks = Le.GossipsubPruneBackoff = Le.GossipsubPrunePeers = Le.GossipsubFanoutTTL = Le.GossipsubHeartbeatInterval = Le.GossipsubHeartbeatInitialDelay = Le.GossipsubGossipRetransmission = Le.GossipsubGossipFactor = Le.GossipsubDlazy = Le.GossipsubHistoryGossip = Le.GossipsubHistoryLength = Le.GossipsubDout = Le.GossipsubDscore = Le.GossipsubDhi = Le.GossipsubDlo = Le.GossipsubD = Le.GossipsubIDv11 = Le.GossipsubIDv10 = Le.FloodsubID = Le.minute = Le.second = void 0;
      Le.second = 1e3;
      Le.minute = 60 * Le.second;
      Le.FloodsubID = "/floodsub/1.0.0";
      Le.GossipsubIDv10 = "/meshsub/1.0.0";
      Le.GossipsubIDv11 = "/meshsub/1.1.0";
      Le.GossipsubD = 6;
      Le.GossipsubDlo = 4;
      Le.GossipsubDhi = 12;
      Le.GossipsubDscore = 4;
      Le.GossipsubDout = 2;
      Le.GossipsubHistoryLength = 5;
      Le.GossipsubHistoryGossip = 3;
      Le.GossipsubDlazy = 6;
      Le.GossipsubGossipFactor = .25;
      Le.GossipsubGossipRetransmission = 3;
      Le.GossipsubHeartbeatInitialDelay = 100;
      Le.GossipsubHeartbeatInterval = Le.second;
      Le.GossipsubFanoutTTL = Le.minute;
      Le.GossipsubPrunePeers = 16;
      Le.GossipsubPruneBackoff = Le.minute;
      Le.GossipsubPruneBackoffTicks = 15;
      Le.GossipsubConnectors = 8;
      Le.GossipsubMaxPendingConnections = 128;
      Le.GossipsubConnectionTimeout = 30 * Le.second;
      Le.GossipsubDirectConnectTicks = 300;
      Le.GossipsubDirectConnectInitialDelay = Le.second;
      Le.GossipsubOpportunisticGraftTicks = 60;
      Le.GossipsubOpportunisticGraftPeers = 2;
      Le.GossipsubGraftFloodThreshold = 10 * Le.second;
      Le.GossipsubMaxIHaveLength = 5e3;
      Le.GossipsubMaxIHaveMessages = 10;
      Le.GossipsubIWantFollowupTime = 3 * Le.second;
      Le.TimeCacheDuration = 120 * 1e3;
      Le.ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
      Le.ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE"
    });
    var _fe = y(A_ => {
      l();
      "use strict";
      Object.defineProperty(A_, "__esModule", {
        value: !0
      });
      A_.hasGossipProtocol = void 0;
      var wfe = fh();

      function ket(r) {
        return r === wfe.GossipsubIDv10 || r === wfe.GossipsubIDv11
      }
      A_.hasGossipProtocol = ket
    });
    var Efe = y(I_ => {
      l();
      "use strict";
      Object.defineProperty(I_, "__esModule", {
        value: !0
      });
      I_.messageIdToString = void 0;
      var Pet = ct();

      function Cet(r) {
        return Pet(r, "base64")
      }
      I_.messageIdToString = Cet
    });
    var lh = y(dc => {
      l();
      "use strict";
      var Oet = dc && dc.__createBinding || (Object.create ? function (r, e, t, i) {
        i === void 0 && (i = t), Object.defineProperty(r, i, {
          enumerable: !0,
          get: function () {
            return e[t]
          }
        })
      } : function (r, e, t, i) {
        i === void 0 && (i = t), r[i] = e[t]
      }),
        T_ = dc && dc.__exportStar || function (r, e) {
          for (var t in r) t !== "default" && !Object.prototype.hasOwnProperty.call(e, t) && Oet(e, r, t)
        };
      Object.defineProperty(dc, "__esModule", {
        value: !0
      });
      T_(mfe(), dc);
      T_(vfe(), dc);
      T_(_fe(), dc);
      T_(Efe(), dc)
    });
    var xfe = y(R_ => {
      l();
      "use strict";
      Object.defineProperty(R_, "__esModule", {
        value: !0
      });
      R_.MessageCache = void 0;
      var k_ = lh(),
        Sfe = class {
          constructor(e, t, i) {
            this.msgs = new Map, this.peertx = new Map, this.history = [];
            for (let n = 0; n < t; n++) this.history[n] = [];
            this.gossip = e, this.msgIdFn = i
          }
          put(e) {
            let t = this.getMsgId(e),
              i = k_.messageIdToString(t);
            this.msgs.set(i, e), this.history[0].push({
              msgID: t,
              topics: e.topicIDs
            })
          }
          getMsgId(e) {
            return this.msgIdFn(e)
          }
          get(e) {
            return this.msgs.get(k_.messageIdToString(e))
          }
          getForPeer(e, t) {
            let i = k_.messageIdToString(e),
              n = this.msgs.get(i);
            if (!n) return [void 0, 0];
            let s = this.peertx.get(i);
            s || (s = new Map, this.peertx.set(i, s));
            let o = (s.get(t) || 0) + 1;
            return s.set(t, o), [n, o]
          }
          getGossipIDs(e) {
            let t = [];
            for (let i = 0; i < this.gossip; i++) this.history[i].forEach(n => {
              for (let s of n.topics)
                if (s === e) {
                  t.push(n.msgID);
                  break
                }
            });
            return t
          }
          shift() {
            this.history[this.history.length - 1].forEach(t => {
              let i = k_.messageIdToString(t.msgID);
              this.msgs.delete(i), this.peertx.delete(i)
            }), this.history.pop(), this.history.unshift([])
          }
        };
      R_.MessageCache = Sfe
    });
    var Ife = y((Afe, ab) => {
      l();
      (function (r, e) {
        typeof define == "function" && define.amd ? define(["protobufjs/minimal"], e) : typeof ab == "object" && ab && ab.exports && (ab.exports = e(bi()))
      })(Afe, function (r) {
        "use strict";
        var e = r.Reader,
          t = r.Writer,
          i = r.util,
          n = r.roots.default || (r.roots.default = {});
        return n.RPC = function () {
          function s(a) {
            if (this.subscriptions = [], this.msgs = [], a)
              for (var c = Object.keys(a), u = 0; u < c.length; ++u) a[c[u]] != null && (this[c[u]] = a[c[u]])
          }
          s.prototype.subscriptions = i.emptyArray, s.prototype.msgs = i.emptyArray, s.prototype.control = null;
          var o;
          return Object.defineProperty(s.prototype, "_control", {
            get: i.oneOfGetter(o = ["control"]),
            set: i.oneOfSetter(o)
          }), s.encode = function (c, u) {
            if (u || (u = t.create()), c.subscriptions != null && c.subscriptions.length)
              for (var f = 0; f < c.subscriptions.length; ++f) n.RPC.SubOpts.encode(c.subscriptions[f], u.uint32(10).fork()).ldelim();
            if (c.msgs != null && c.msgs.length)
              for (var f = 0; f < c.msgs.length; ++f) n.RPC.Message.encode(c.msgs[f], u.uint32(18).fork()).ldelim();
            return c.control != null && Object.hasOwnProperty.call(c, "control") && n.RPC.ControlMessage.encode(c.control, u.uint32(26).fork()).ldelim(), u
          }, s.decode = function (c, u) {
            c instanceof e || (c = e.create(c));
            for (var f = u === void 0 ? c.len : c.pos + u, h = new n.RPC; c.pos < f;) {
              var d = c.uint32();
              switch (d >>> 3) {
                case 1:
                  h.subscriptions && h.subscriptions.length || (h.subscriptions = []), h.subscriptions.push(n.RPC.SubOpts.decode(c, c.uint32()));
                  break;
                case 2:
                  h.msgs && h.msgs.length || (h.msgs = []), h.msgs.push(n.RPC.Message.decode(c, c.uint32()));
                  break;
                case 3:
                  h.control = n.RPC.ControlMessage.decode(c, c.uint32());
                  break;
                default:
                  c.skipType(d & 7);
                  break
              }
            }
            return h
          }, s.fromObject = function (c) {
            if (c instanceof n.RPC) return c;
            var u = new n.RPC;
            if (c.subscriptions) {
              if (!Array.isArray(c.subscriptions)) throw TypeError(".RPC.subscriptions: array expected");
              u.subscriptions = [];
              for (var f = 0; f < c.subscriptions.length; ++f) {
                if (typeof c.subscriptions[f] != "object") throw TypeError(".RPC.subscriptions: object expected");
                u.subscriptions[f] = n.RPC.SubOpts.fromObject(c.subscriptions[f])
              }
            }
            if (c.msgs) {
              if (!Array.isArray(c.msgs)) throw TypeError(".RPC.msgs: array expected");
              u.msgs = [];
              for (var f = 0; f < c.msgs.length; ++f) {
                if (typeof c.msgs[f] != "object") throw TypeError(".RPC.msgs: object expected");
                u.msgs[f] = n.RPC.Message.fromObject(c.msgs[f])
              }
            }
            if (c.control != null) {
              if (typeof c.control != "object") throw TypeError(".RPC.control: object expected");
              u.control = n.RPC.ControlMessage.fromObject(c.control)
            }
            return u
          }, s.toObject = function (c, u) {
            u || (u = {});
            var f = {};
            if ((u.arrays || u.defaults) && (f.subscriptions = [], f.msgs = []), c.subscriptions && c.subscriptions.length) {
              f.subscriptions = [];
              for (var h = 0; h < c.subscriptions.length; ++h) f.subscriptions[h] = n.RPC.SubOpts.toObject(c.subscriptions[h], u)
            }
            if (c.msgs && c.msgs.length) {
              f.msgs = [];
              for (var h = 0; h < c.msgs.length; ++h) f.msgs[h] = n.RPC.Message.toObject(c.msgs[h], u)
            }
            return c.control != null && c.hasOwnProperty("control") && (f.control = n.RPC.ControlMessage.toObject(c.control, u), u.oneofs && (f._control = "control")), f
          }, s.prototype.toJSON = function () {
            return this.constructor.toObject(this, r.util.toJSONOptions)
          }, s.SubOpts = function () {
            function a(u) {
              if (u)
                for (var f = Object.keys(u), h = 0; h < f.length; ++h) u[f[h]] != null && (this[f[h]] = u[f[h]])
            }
            a.prototype.subscribe = null, a.prototype.topicID = null;
            var c;
            return Object.defineProperty(a.prototype, "_subscribe", {
              get: i.oneOfGetter(c = ["subscribe"]),
              set: i.oneOfSetter(c)
            }), Object.defineProperty(a.prototype, "_topicID", {
              get: i.oneOfGetter(c = ["topicID"]),
              set: i.oneOfSetter(c)
            }), a.encode = function (f, h) {
              return h || (h = t.create()), f.subscribe != null && Object.hasOwnProperty.call(f, "subscribe") && h.uint32(8).bool(f.subscribe), f.topicID != null && Object.hasOwnProperty.call(f, "topicID") && h.uint32(18).string(f.topicID), h
            }, a.decode = function (f, h) {
              f instanceof e || (f = e.create(f));
              for (var d = h === void 0 ? f.len : f.pos + h, p = new n.RPC.SubOpts; f.pos < d;) {
                var g = f.uint32();
                switch (g >>> 3) {
                  case 1:
                    p.subscribe = f.bool();
                    break;
                  case 2:
                    p.topicID = f.string();
                    break;
                  default:
                    f.skipType(g & 7);
                    break
                }
              }
              return p
            }, a.fromObject = function (f) {
              if (f instanceof n.RPC.SubOpts) return f;
              var h = new n.RPC.SubOpts;
              return f.subscribe != null && (h.subscribe = Boolean(f.subscribe)), f.topicID != null && (h.topicID = String(f.topicID)), h
            }, a.toObject = function (f, h) {
              h || (h = {});
              var d = {};
              return f.subscribe != null && f.hasOwnProperty("subscribe") && (d.subscribe = f.subscribe, h.oneofs && (d._subscribe = "subscribe")), f.topicID != null && f.hasOwnProperty("topicID") && (d.topicID = f.topicID, h.oneofs && (d._topicID = "topicID")), d
            }, a.prototype.toJSON = function () {
              return this.constructor.toObject(this, r.util.toJSONOptions)
            }, a
          }(), s.Message = function () {
            function a(u) {
              if (this.topicIDs = [], u)
                for (var f = Object.keys(u), h = 0; h < f.length; ++h) u[f[h]] != null && (this[f[h]] = u[f[h]])
            }
            a.prototype.from = null, a.prototype.data = null, a.prototype.seqno = null, a.prototype.topicIDs = i.emptyArray, a.prototype.signature = null, a.prototype.key = null;
            var c;
            return Object.defineProperty(a.prototype, "_from", {
              get: i.oneOfGetter(c = ["from"]),
              set: i.oneOfSetter(c)
            }), Object.defineProperty(a.prototype, "_data", {
              get: i.oneOfGetter(c = ["data"]),
              set: i.oneOfSetter(c)
            }), Object.defineProperty(a.prototype, "_seqno", {
              get: i.oneOfGetter(c = ["seqno"]),
              set: i.oneOfSetter(c)
            }), Object.defineProperty(a.prototype, "_signature", {
              get: i.oneOfGetter(c = ["signature"]),
              set: i.oneOfSetter(c)
            }), Object.defineProperty(a.prototype, "_key", {
              get: i.oneOfGetter(c = ["key"]),
              set: i.oneOfSetter(c)
            }), a.encode = function (f, h) {
              if (h || (h = t.create()), f.from != null && Object.hasOwnProperty.call(f, "from") && h.uint32(10).bytes(f.from), f.data != null && Object.hasOwnProperty.call(f, "data") && h.uint32(18).bytes(f.data), f.seqno != null && Object.hasOwnProperty.call(f, "seqno") && h.uint32(26).bytes(f.seqno), f.topicIDs != null && f.topicIDs.length)
                for (var d = 0; d < f.topicIDs.length; ++d) h.uint32(34).string(f.topicIDs[d]);
              return f.signature != null && Object.hasOwnProperty.call(f, "signature") && h.uint32(42).bytes(f.signature), f.key != null && Object.hasOwnProperty.call(f, "key") && h.uint32(50).bytes(f.key), h
            }, a.decode = function (f, h) {
              f instanceof e || (f = e.create(f));
              for (var d = h === void 0 ? f.len : f.pos + h, p = new n.RPC.Message; f.pos < d;) {
                var g = f.uint32();
                switch (g >>> 3) {
                  case 1:
                    p.from = f.bytes();
                    break;
                  case 2:
                    p.data = f.bytes();
                    break;
                  case 3:
                    p.seqno = f.bytes();
                    break;
                  case 4:
                    p.topicIDs && p.topicIDs.length || (p.topicIDs = []), p.topicIDs.push(f.string());
                    break;
                  case 5:
                    p.signature = f.bytes();
                    break;
                  case 6:
                    p.key = f.bytes();
                    break;
                  default:
                    f.skipType(g & 7);
                    break
                }
              }
              return p
            }, a.fromObject = function (f) {
              if (f instanceof n.RPC.Message) return f;
              var h = new n.RPC.Message;
              if (f.from != null && (typeof f.from == "string" ? i.base64.decode(f.from, h.from = i.newBuffer(i.base64.length(f.from)), 0) : f.from.length && (h.from = f.from)), f.data != null && (typeof f.data == "string" ? i.base64.decode(f.data, h.data = i.newBuffer(i.base64.length(f.data)), 0) : f.data.length && (h.data = f.data)), f.seqno != null && (typeof f.seqno == "string" ? i.base64.decode(f.seqno, h.seqno = i.newBuffer(i.base64.length(f.seqno)), 0) : f.seqno.length && (h.seqno = f.seqno)), f.topicIDs) {
                if (!Array.isArray(f.topicIDs)) throw TypeError(".RPC.Message.topicIDs: array expected");
                h.topicIDs = [];
                for (var d = 0; d < f.topicIDs.length; ++d) h.topicIDs[d] = String(f.topicIDs[d])
              }
              return f.signature != null && (typeof f.signature == "string" ? i.base64.decode(f.signature, h.signature = i.newBuffer(i.base64.length(f.signature)), 0) : f.signature.length && (h.signature = f.signature)), f.key != null && (typeof f.key == "string" ? i.base64.decode(f.key, h.key = i.newBuffer(i.base64.length(f.key)), 0) : f.key.length && (h.key = f.key)), h
            }, a.toObject = function (f, h) {
              h || (h = {});
              var d = {};
              if ((h.arrays || h.defaults) && (d.topicIDs = []), f.from != null && f.hasOwnProperty("from") && (d.from = h.bytes === String ? i.base64.encode(f.from, 0, f.from.length) : h.bytes === Array ? Array.prototype.slice.call(f.from) : f.from, h.oneofs && (d._from = "from")), f.data != null && f.hasOwnProperty("data") && (d.data = h.bytes === String ? i.base64.encode(f.data, 0, f.data.length) : h.bytes === Array ? Array.prototype.slice.call(f.data) : f.data, h.oneofs && (d._data = "data")), f.seqno != null && f.hasOwnProperty("seqno") && (d.seqno = h.bytes === String ? i.base64.encode(f.seqno, 0, f.seqno.length) : h.bytes === Array ? Array.prototype.slice.call(f.seqno) : f.seqno, h.oneofs && (d._seqno = "seqno")), f.topicIDs && f.topicIDs.length) {
                d.topicIDs = [];
                for (var p = 0; p < f.topicIDs.length; ++p) d.topicIDs[p] = f.topicIDs[p]
              }
              return f.signature != null && f.hasOwnProperty("signature") && (d.signature = h.bytes === String ? i.base64.encode(f.signature, 0, f.signature.length) : h.bytes === Array ? Array.prototype.slice.call(f.signature) : f.signature, h.oneofs && (d._signature = "signature")), f.key != null && f.hasOwnProperty("key") && (d.key = h.bytes === String ? i.base64.encode(f.key, 0, f.key.length) : h.bytes === Array ? Array.prototype.slice.call(f.key) : f.key, h.oneofs && (d._key = "key")), d
            }, a.prototype.toJSON = function () {
              return this.constructor.toObject(this, r.util.toJSONOptions)
            }, a
          }(), s.ControlMessage = function () {
            function a(c) {
              if (this.ihave = [], this.iwant = [], this.graft = [], this.prune = [], c)
                for (var u = Object.keys(c), f = 0; f < u.length; ++f) c[u[f]] != null && (this[u[f]] = c[u[f]])
            }
            return a.prototype.ihave = i.emptyArray, a.prototype.iwant = i.emptyArray, a.prototype.graft = i.emptyArray, a.prototype.prune = i.emptyArray, a.encode = function (u, f) {
              if (f || (f = t.create()), u.ihave != null && u.ihave.length)
                for (var h = 0; h < u.ihave.length; ++h) n.RPC.ControlIHave.encode(u.ihave[h], f.uint32(10).fork()).ldelim();
              if (u.iwant != null && u.iwant.length)
                for (var h = 0; h < u.iwant.length; ++h) n.RPC.ControlIWant.encode(u.iwant[h], f.uint32(18).fork()).ldelim();
              if (u.graft != null && u.graft.length)
                for (var h = 0; h < u.graft.length; ++h) n.RPC.ControlGraft.encode(u.graft[h], f.uint32(26).fork()).ldelim();
              if (u.prune != null && u.prune.length)
                for (var h = 0; h < u.prune.length; ++h) n.RPC.ControlPrune.encode(u.prune[h], f.uint32(34).fork()).ldelim();
              return f
            }, a.decode = function (u, f) {
              u instanceof e || (u = e.create(u));
              for (var h = f === void 0 ? u.len : u.pos + f, d = new n.RPC.ControlMessage; u.pos < h;) {
                var p = u.uint32();
                switch (p >>> 3) {
                  case 1:
                    d.ihave && d.ihave.length || (d.ihave = []), d.ihave.push(n.RPC.ControlIHave.decode(u, u.uint32()));
                    break;
                  case 2:
                    d.iwant && d.iwant.length || (d.iwant = []), d.iwant.push(n.RPC.ControlIWant.decode(u, u.uint32()));
                    break;
                  case 3:
                    d.graft && d.graft.length || (d.graft = []), d.graft.push(n.RPC.ControlGraft.decode(u, u.uint32()));
                    break;
                  case 4:
                    d.prune && d.prune.length || (d.prune = []), d.prune.push(n.RPC.ControlPrune.decode(u, u.uint32()));
                    break;
                  default:
                    u.skipType(p & 7);
                    break
                }
              }
              return d
            }, a.fromObject = function (u) {
              if (u instanceof n.RPC.ControlMessage) return u;
              var f = new n.RPC.ControlMessage;
              if (u.ihave) {
                if (!Array.isArray(u.ihave)) throw TypeError(".RPC.ControlMessage.ihave: array expected");
                f.ihave = [];
                for (var h = 0; h < u.ihave.length; ++h) {
                  if (typeof u.ihave[h] != "object") throw TypeError(".RPC.ControlMessage.ihave: object expected");
                  f.ihave[h] = n.RPC.ControlIHave.fromObject(u.ihave[h])
                }
              }
              if (u.iwant) {
                if (!Array.isArray(u.iwant)) throw TypeError(".RPC.ControlMessage.iwant: array expected");
                f.iwant = [];
                for (var h = 0; h < u.iwant.length; ++h) {
                  if (typeof u.iwant[h] != "object") throw TypeError(".RPC.ControlMessage.iwant: object expected");
                  f.iwant[h] = n.RPC.ControlIWant.fromObject(u.iwant[h])
                }
              }
              if (u.graft) {
                if (!Array.isArray(u.graft)) throw TypeError(".RPC.ControlMessage.graft: array expected");
                f.graft = [];
                for (var h = 0; h < u.graft.length; ++h) {
                  if (typeof u.graft[h] != "object") throw TypeError(".RPC.ControlMessage.graft: object expected");
                  f.graft[h] = n.RPC.ControlGraft.fromObject(u.graft[h])
                }
              }
              if (u.prune) {
                if (!Array.isArray(u.prune)) throw TypeError(".RPC.ControlMessage.prune: array expected");
                f.prune = [];
                for (var h = 0; h < u.prune.length; ++h) {
                  if (typeof u.prune[h] != "object") throw TypeError(".RPC.ControlMessage.prune: object expected");
                  f.prune[h] = n.RPC.ControlPrune.fromObject(u.prune[h])
                }
              }
              return f
            }, a.toObject = function (u, f) {
              f || (f = {});
              var h = {};
              if ((f.arrays || f.defaults) && (h.ihave = [], h.iwant = [], h.graft = [], h.prune = []), u.ihave && u.ihave.length) {
                h.ihave = [];
                for (var d = 0; d < u.ihave.length; ++d) h.ihave[d] = n.RPC.ControlIHave.toObject(u.ihave[d], f)
              }
              if (u.iwant && u.iwant.length) {
                h.iwant = [];
                for (var d = 0; d < u.iwant.length; ++d) h.iwant[d] = n.RPC.ControlIWant.toObject(u.iwant[d], f)
              }
              if (u.graft && u.graft.length) {
                h.graft = [];
                for (var d = 0; d < u.graft.length; ++d) h.graft[d] = n.RPC.ControlGraft.toObject(u.graft[d], f)
              }
              if (u.prune && u.prune.length) {
                h.prune = [];
                for (var d = 0; d < u.prune.length; ++d) h.prune[d] = n.RPC.ControlPrune.toObject(u.prune[d], f)
              }
              return h
            }, a.prototype.toJSON = function () {
              return this.constructor.toObject(this, r.util.toJSONOptions)
            }, a
          }(), s.ControlIHave = function () {
            function a(u) {
              if (this.messageIDs = [], u)
                for (var f = Object.keys(u), h = 0; h < f.length; ++h) u[f[h]] != null && (this[f[h]] = u[f[h]])
            }
            a.prototype.topicID = null, a.prototype.messageIDs = i.emptyArray;
            var c;
            return Object.defineProperty(a.prototype, "_topicID", {
              get: i.oneOfGetter(c = ["topicID"]),
              set: i.oneOfSetter(c)
            }), a.encode = function (f, h) {
              if (h || (h = t.create()), f.topicID != null && Object.hasOwnProperty.call(f, "topicID") && h.uint32(10).string(f.topicID), f.messageIDs != null && f.messageIDs.length)
                for (var d = 0; d < f.messageIDs.length; ++d) h.uint32(18).bytes(f.messageIDs[d]);
              return h
            }, a.decode = function (f, h) {
              f instanceof e || (f = e.create(f));
              for (var d = h === void 0 ? f.len : f.pos + h, p = new n.RPC.ControlIHave; f.pos < d;) {
                var g = f.uint32();
                switch (g >>> 3) {
                  case 1:
                    p.topicID = f.string();
                    break;
                  case 2:
                    p.messageIDs && p.messageIDs.length || (p.messageIDs = []), p.messageIDs.push(f.bytes());
                    break;
                  default:
                    f.skipType(g & 7);
                    break
                }
              }
              return p
            }, a.fromObject = function (f) {
              if (f instanceof n.RPC.ControlIHave) return f;
              var h = new n.RPC.ControlIHave;
              if (f.topicID != null && (h.topicID = String(f.topicID)), f.messageIDs) {
                if (!Array.isArray(f.messageIDs)) throw TypeError(".RPC.ControlIHave.messageIDs: array expected");
                h.messageIDs = [];
                for (var d = 0; d < f.messageIDs.length; ++d) typeof f.messageIDs[d] == "string" ? i.base64.decode(f.messageIDs[d], h.messageIDs[d] = i.newBuffer(i.base64.length(f.messageIDs[d])), 0) : f.messageIDs[d].length && (h.messageIDs[d] = f.messageIDs[d])
              }
              return h
            }, a.toObject = function (f, h) {
              h || (h = {});
              var d = {};
              if ((h.arrays || h.defaults) && (d.messageIDs = []), f.topicID != null && f.hasOwnProperty("topicID") && (d.topicID = f.topicID, h.oneofs && (d._topicID = "topicID")), f.messageIDs && f.messageIDs.length) {
                d.messageIDs = [];
                for (var p = 0; p < f.messageIDs.length; ++p) d.messageIDs[p] = h.bytes === String ? i.base64.encode(f.messageIDs[p], 0, f.messageIDs[p].length) : h.bytes === Array ? Array.prototype.slice.call(f.messageIDs[p]) : f.messageIDs[p]
              }
              return d
            }, a.prototype.toJSON = function () {
              return this.constructor.toObject(this, r.util.toJSONOptions)
            }, a
          }(), s.ControlIWant = function () {
            function a(c) {
              if (this.messageIDs = [], c)
                for (var u = Object.keys(c), f = 0; f < u.length; ++f) c[u[f]] != null && (this[u[f]] = c[u[f]])
            }
            return a.prototype.messageIDs = i.emptyArray, a.encode = function (u, f) {
              if (f || (f = t.create()), u.messageIDs != null && u.messageIDs.length)
                for (var h = 0; h < u.messageIDs.length; ++h) f.uint32(10).bytes(u.messageIDs[h]);
              return f
            }, a.decode = function (u, f) {
              u instanceof e || (u = e.create(u));
              for (var h = f === void 0 ? u.len : u.pos + f, d = new n.RPC.ControlIWant; u.pos < h;) {
                var p = u.uint32();
                switch (p >>> 3) {
                  case 1:
                    d.messageIDs && d.messageIDs.length || (d.messageIDs = []), d.messageIDs.push(u.bytes());
                    break;
                  default:
                    u.skipType(p & 7);
                    break
                }
              }
              return d
            }, a.fromObject = function (u) {
              if (u instanceof n.RPC.ControlIWant) return u;
              var f = new n.RPC.ControlIWant;
              if (u.messageIDs) {
                if (!Array.isArray(u.messageIDs)) throw TypeError(".RPC.ControlIWant.messageIDs: array expected");
                f.messageIDs = [];
                for (var h = 0; h < u.messageIDs.length; ++h) typeof u.messageIDs[h] == "string" ? i.base64.decode(u.messageIDs[h], f.messageIDs[h] = i.newBuffer(i.base64.length(u.messageIDs[h])), 0) : u.messageIDs[h].length && (f.messageIDs[h] = u.messageIDs[h])
              }
              return f
            }, a.toObject = function (u, f) {
              f || (f = {});
              var h = {};
              if ((f.arrays || f.defaults) && (h.messageIDs = []), u.messageIDs && u.messageIDs.length) {
                h.messageIDs = [];
                for (var d = 0; d < u.messageIDs.length; ++d) h.messageIDs[d] = f.bytes === String ? i.base64.encode(u.messageIDs[d], 0, u.messageIDs[d].length) : f.bytes === Array ? Array.prototype.slice.call(u.messageIDs[d]) : u.messageIDs[d]
              }
              return h
            }, a.prototype.toJSON = function () {
              return this.constructor.toObject(this, r.util.toJSONOptions)
            }, a
          }(), s.ControlGraft = function () {
            function a(u) {
              if (u)
                for (var f = Object.keys(u), h = 0; h < f.length; ++h) u[f[h]] != null && (this[f[h]] = u[f[h]])
            }
            a.prototype.topicID = null;
            var c;
            return Object.defineProperty(a.prototype, "_topicID", {
              get: i.oneOfGetter(c = ["topicID"]),
              set: i.oneOfSetter(c)
            }), a.encode = function (f, h) {
              return h || (h = t.create()), f.topicID != null && Object.hasOwnProperty.call(f, "topicID") && h.uint32(10).string(f.topicID), h
            }, a.decode = function (f, h) {
              f instanceof e || (f = e.create(f));
              for (var d = h === void 0 ? f.len : f.pos + h, p = new n.RPC.ControlGraft; f.pos < d;) {
                var g = f.uint32();
                switch (g >>> 3) {
                  case 1:
                    p.topicID = f.string();
                    break;
                  default:
                    f.skipType(g & 7);
                    break
                }
              }
              return p
            }, a.fromObject = function (f) {
              if (f instanceof n.RPC.ControlGraft) return f;
              var h = new n.RPC.ControlGraft;
              return f.topicID != null && (h.topicID = String(f.topicID)), h
            }, a.toObject = function (f, h) {
              h || (h = {});
              var d = {};
              return f.topicID != null && f.hasOwnProperty("topicID") && (d.topicID = f.topicID, h.oneofs && (d._topicID = "topicID")), d
            }, a.prototype.toJSON = function () {
              return this.constructor.toObject(this, r.util.toJSONOptions)
            }, a
          }(), s.ControlPrune = function () {
            function a(u) {
              if (this.peers = [], u)
                for (var f = Object.keys(u), h = 0; h < f.length; ++h) u[f[h]] != null && (this[f[h]] = u[f[h]])
            }
            a.prototype.topicID = null, a.prototype.peers = i.emptyArray, a.prototype.backoff = null;
            var c;
            return Object.defineProperty(a.prototype, "_topicID", {
              get: i.oneOfGetter(c = ["topicID"]),
              set: i.oneOfSetter(c)
            }), Object.defineProperty(a.prototype, "_backoff", {
              get: i.oneOfGetter(c = ["backoff"]),
              set: i.oneOfSetter(c)
            }), a.encode = function (f, h) {
              if (h || (h = t.create()), f.topicID != null && Object.hasOwnProperty.call(f, "topicID") && h.uint32(10).string(f.topicID), f.peers != null && f.peers.length)
                for (var d = 0; d < f.peers.length; ++d) n.RPC.PeerInfo.encode(f.peers[d], h.uint32(18).fork()).ldelim();
              return f.backoff != null && Object.hasOwnProperty.call(f, "backoff") && h.uint32(24).uint64(f.backoff), h
            }, a.decode = function (f, h) {
              f instanceof e || (f = e.create(f));
              for (var d = h === void 0 ? f.len : f.pos + h, p = new n.RPC.ControlPrune; f.pos < d;) {
                var g = f.uint32();
                switch (g >>> 3) {
                  case 1:
                    p.topicID = f.string();
                    break;
                  case 2:
                    p.peers && p.peers.length || (p.peers = []), p.peers.push(n.RPC.PeerInfo.decode(f, f.uint32()));
                    break;
                  case 3:
                    p.backoff = f.uint64();
                    break;
                  default:
                    f.skipType(g & 7);
                    break
                }
              }
              return p
            }, a.fromObject = function (f) {
              if (f instanceof n.RPC.ControlPrune) return f;
              var h = new n.RPC.ControlPrune;
              if (f.topicID != null && (h.topicID = String(f.topicID)), f.peers) {
                if (!Array.isArray(f.peers)) throw TypeError(".RPC.ControlPrune.peers: array expected");
                h.peers = [];
                for (var d = 0; d < f.peers.length; ++d) {
                  if (typeof f.peers[d] != "object") throw TypeError(".RPC.ControlPrune.peers: object expected");
                  h.peers[d] = n.RPC.PeerInfo.fromObject(f.peers[d])
                }
              }
              return f.backoff != null && (i.Long ? (h.backoff = i.Long.fromValue(f.backoff)).unsigned = !0 : typeof f.backoff == "string" ? h.backoff = parseInt(f.backoff, 10) : typeof f.backoff == "number" ? h.backoff = f.backoff : typeof f.backoff == "object" && (h.backoff = new i.LongBits(f.backoff.low >>> 0, f.backoff.high >>> 0).toNumber(!0))), h
            }, a.toObject = function (f, h) {
              h || (h = {});
              var d = {};
              if ((h.arrays || h.defaults) && (d.peers = []), f.topicID != null && f.hasOwnProperty("topicID") && (d.topicID = f.topicID, h.oneofs && (d._topicID = "topicID")), f.peers && f.peers.length) {
                d.peers = [];
                for (var p = 0; p < f.peers.length; ++p) d.peers[p] = n.RPC.PeerInfo.toObject(f.peers[p], h)
              }
              return f.backoff != null && f.hasOwnProperty("backoff") && (typeof f.backoff == "number" ? d.backoff = h.longs === String ? String(f.backoff) : f.backoff : d.backoff = h.longs === String ? i.Long.prototype.toString.call(f.backoff) : h.longs === Number ? new i.LongBits(f.backoff.low >>> 0, f.backoff.high >>> 0).toNumber(!0) : f.backoff, h.oneofs && (d._backoff = "backoff")), d
            }, a.prototype.toJSON = function () {
              return this.constructor.toObject(this, r.util.toJSONOptions)
            }, a
          }(), s.PeerInfo = function () {
            function a(u) {
              if (u)
                for (var f = Object.keys(u), h = 0; h < f.length; ++h) u[f[h]] != null && (this[f[h]] = u[f[h]])
            }
            a.prototype.peerID = null, a.prototype.signedPeerRecord = null;
            var c;
            return Object.defineProperty(a.prototype, "_peerID", {
              get: i.oneOfGetter(c = ["peerID"]),
              set: i.oneOfSetter(c)
            }), Object.defineProperty(a.prototype, "_signedPeerRecord", {
              get: i.oneOfGetter(c = ["signedPeerRecord"]),
              set: i.oneOfSetter(c)
            }), a.encode = function (f, h) {
              return h || (h = t.create()), f.peerID != null && Object.hasOwnProperty.call(f, "peerID") && h.uint32(10).bytes(f.peerID), f.signedPeerRecord != null && Object.hasOwnProperty.call(f, "signedPeerRecord") && h.uint32(18).bytes(f.signedPeerRecord), h
            }, a.decode = function (f, h) {
              f instanceof e || (f = e.create(f));
              for (var d = h === void 0 ? f.len : f.pos + h, p = new n.RPC.PeerInfo; f.pos < d;) {
                var g = f.uint32();
                switch (g >>> 3) {
                  case 1:
                    p.peerID = f.bytes();
                    break;
                  case 2:
                    p.signedPeerRecord = f.bytes();
                    break;
                  default:
                    f.skipType(g & 7);
                    break
                }
              }
              return p
            }, a.fromObject = function (f) {
              if (f instanceof n.RPC.PeerInfo) return f;
              var h = new n.RPC.PeerInfo;
              return f.peerID != null && (typeof f.peerID == "string" ? i.base64.decode(f.peerID, h.peerID = i.newBuffer(i.base64.length(f.peerID)), 0) : f.peerID.length && (h.peerID = f.peerID)), f.signedPeerRecord != null && (typeof f.signedPeerRecord == "string" ? i.base64.decode(f.signedPeerRecord, h.signedPeerRecord = i.newBuffer(i.base64.length(f.signedPeerRecord)), 0) : f.signedPeerRecord.length && (h.signedPeerRecord = f.signedPeerRecord)), h
            }, a.toObject = function (f, h) {
              h || (h = {});
              var d = {};
              return f.peerID != null && f.hasOwnProperty("peerID") && (d.peerID = h.bytes === String ? i.base64.encode(f.peerID, 0, f.peerID.length) : h.bytes === Array ? Array.prototype.slice.call(f.peerID) : f.peerID, h.oneofs && (d._peerID = "peerID")), f.signedPeerRecord != null && f.hasOwnProperty("signedPeerRecord") && (d.signedPeerRecord = h.bytes === String ? i.base64.encode(f.signedPeerRecord, 0, f.signedPeerRecord.length) : h.bytes === Array ? Array.prototype.slice.call(f.signedPeerRecord) : f.signedPeerRecord, h.oneofs && (d._signedPeerRecord = "signedPeerRecord")), d
            }, a.prototype.toJSON = function () {
              return this.constructor.toObject(this, r.util.toJSONOptions)
            }, a
          }(), s
        }(), n
      })
    });
    var w7 = y(P_ => {
      l();
      "use strict";
      Object.defineProperty(P_, "__esModule", {
        value: !0
      });
      P_.getGossipPeers = void 0;
      var Tfe = lh();

      function Net(r, e, t, i = () => !0) {
        let n = r.topics.get(e);
        if (!n) return new Set;
        let s = [];
        return n.forEach(o => {
          let a = r.peers.get(o);
          !a || Tfe.hasGossipProtocol(a.protocol) && i(o) && s.push(o)
        }), s = Tfe.shuffle(s), t > 0 && s.length > t && (s = s.slice(0, t)), new Set(s)
      }
      P_.getGossipPeers = Net
    });
    var kfe = y(pc => {
      l();
      "use strict";
      var qet = pc && pc.__createBinding || (Object.create ? function (r, e, t, i) {
        i === void 0 && (i = t), Object.defineProperty(r, i, {
          enumerable: !0,
          get: function () {
            return e[t]
          }
        })
      } : function (r, e, t, i) {
        i === void 0 && (i = t), r[i] = e[t]
      }),
        Met = pc && pc.__setModuleDefault || (Object.create ? function (r, e) {
          Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
          })
        } : function (r, e) {
          r.default = e
        }),
        Bet = pc && pc.__importStar || function (r) {
          if (r && r.__esModule) return r;
          var e = {};
          if (r != null)
            for (var t in r) t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && qet(e, r, t);
          return Met(e, r), e
        };
      Object.defineProperty(pc, "__esModule", {
        value: !0
      });
      pc.Heartbeat = void 0;
      var cb = Bet(fh()),
        C_ = w7(),
        Det = lh(),
        Rfe = class {
          constructor(e) {
            this.gossipsub = e
          }
          start() {
            if (this._heartbeatTimer) return;
            let e = this._heartbeat.bind(this),
              t = setTimeout(() => {
                e(), this._heartbeatTimer.runPeriodically(e, cb.GossipsubHeartbeatInterval)
              }, cb.GossipsubHeartbeatInitialDelay);
            this._heartbeatTimer = {
              _intervalId: void 0,
              runPeriodically: (i, n) => {
                this._heartbeatTimer._intervalId = setInterval(i, n)
              },
              cancel: () => {
                clearTimeout(t), clearInterval(this._heartbeatTimer._intervalId)
              }
            }
          }
          stop() {
            !this._heartbeatTimer || (this._heartbeatTimer.cancel(), this._heartbeatTimer = null)
          }
          _heartbeat() {
            let {
              D: e,
              Dlo: t,
              Dhi: i,
              Dscore: n,
              Dout: s
            } = this.gossipsub._options;
            this.gossipsub.heartbeatTicks++;
            let o = new Map,
              a = d => {
                let p = o.get(d);
                return p === void 0 && (p = this.gossipsub.score.score(d), o.set(d, p)), p
              },
              c = new Map,
              u = new Map,
              f = new Map;
            this.gossipsub._clearBackoff(), this.gossipsub.peerhave.clear(), this.gossipsub.iasked.clear(), this.gossipsub._applyIwantPenalties(), this.gossipsub._directConnect(), this.gossipsub.mesh.forEach((d, p) => {
              let g = E => {
                this.gossipsub.log("HEARTBEAT: Remove mesh link to %s in %s", E, p), this.gossipsub.score.prune(E, p), this.gossipsub._addBackoff(E, p), d.delete(E);
                let w = u.get(E);
                w ? w.push(p) : u.set(E, [p])
              },
                m = E => {
                  this.gossipsub.log("HEARTBEAT: Add mesh link to %s in %s", E, p), this.gossipsub.score.graft(E, p), d.add(E);
                  let w = c.get(E);
                  w ? w.push(p) : c.set(E, [p])
                };
              if (d.forEach(E => {
                let w = a(E);
                w < 0 && (this.gossipsub.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", E, w, p), g(E), f.set(E, !0))
              }), d.size < t) {
                let E = this.gossipsub.backoff.get(p),
                  w = e - d.size;
                C_.getGossipPeers(this.gossipsub, p, w, q => !d.has(q) && !this.gossipsub.direct.has(q) && (!E || !E.has(q)) && a(q) >= 0).forEach(m)
              }
              if (d.size > i) {
                let E = Array.from(d);
                E.sort((O, q) => a(q) - a(O)), E = E.slice(0, n).concat(Det.shuffle(E.slice(n)));
                let w = 0;
                if (E.slice(0, e).forEach(O => {
                  this.gossipsub.outbound.get(O) && w++
                }), w < s) {
                  let O = J => {
                    let Z = E[J];
                    for (let H = J; H > 0; H--) E[H] = E[H - 1];
                    E[0] = Z
                  };
                  if (w > 0) {
                    let J = w;
                    for (let Z = 1; Z < e && J > 0; Z++) this.gossipsub.outbound.get(E[Z]) && (O(Z), J--)
                  }
                  let q = e - w;
                  for (let J = e; J < E.length && q > 0; J++) this.gossipsub.outbound.get(E[J]) && (O(J), q--)
                }
                E.slice(e).forEach(g)
              }
              if (d.size >= t) {
                let E = 0;
                if (d.forEach(w => {
                  this.gossipsub.outbound.get(w) && E++
                }), E < s) {
                  let w = s - E,
                    O = this.gossipsub.backoff.get(p);
                  C_.getGossipPeers(this.gossipsub, p, w, q => !d.has(q) && !this.gossipsub.direct.has(q) && (!O || !O.has(q)) && a(q) >= 0).forEach(m)
                }
              }
              if (this.gossipsub.heartbeatTicks % cb.GossipsubOpportunisticGraftTicks == 0 && d.size > 1) {
                let E = Array.from(d).sort((q, J) => a(q) - a(J)),
                  w = d.size / 2,
                  O = a(E[w]);
                if (O < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {
                  let q = this.gossipsub.backoff.get(p);
                  C_.getGossipPeers(this.gossipsub, p, cb.GossipsubOpportunisticGraftPeers, Z => d.has(Z) && !this.gossipsub.direct.has(Z) && (!q || !q.has(Z)) && a(Z) > O).forEach(Z => {
                    this.gossipsub.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", Z, p), m(Z)
                  })
                }
              }
              this.gossipsub._emitGossip(p, d)
            });
            let h = this.gossipsub._now();
            this.gossipsub.lastpub.forEach((d, p) => {
              d + cb.GossipsubFanoutTTL < h && (this.gossipsub.fanout.delete(p), this.gossipsub.lastpub.delete(p))
            }), this.gossipsub.fanout.forEach((d, p) => {
              let g = this.gossipsub.topics.get(p);
              if (d.forEach(m => {
                (!g.has(m) || a(m) < this.gossipsub._options.scoreThresholds.publishThreshold) && d.delete(m)
              }), d.size < e) {
                let m = e - d.size;
                C_.getGossipPeers(this.gossipsub, p, m, w => !d.has(w) && !this.gossipsub.direct.has(w) && a(w) >= this.gossipsub._options.scoreThresholds.publishThreshold).forEach(w => {
                  d.add(w)
                })
              }
              this.gossipsub._emitGossip(p, d)
            }), this.gossipsub._sendGraftPrune(c, u, f), this.gossipsub._flush(), this.gossipsub.messageCache.shift(), this.gossipsub.emit("gossipsub:heartbeat")
          }
        };
      pc.Heartbeat = Rfe
    });
    var _7 = y(sp => {
      l();
      "use strict";
      Object.defineProperty(sp, "__esModule", {
        value: !0
      });
      sp.ERR_INVALID_PEER_SCORE_THRESHOLDS = sp.ERR_INVALID_PEER_SCORE_PARAMS = void 0;
      sp.ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";
      sp.ERR_INVALID_PEER_SCORE_THRESHOLDS = "ERR_INVALID_PEER_SCORE_THRESHOLDS"
    });
    var E7 = y((y8t, Pfe) => {
      l();
      "use strict";

      function Cfe(r, e) {
        for (let t in e) Object.defineProperty(r, t, {
          value: e[t],
          enumerable: !0,
          configurable: !0
        });
        return r
      }

      function Let(r, e, t) {
        if (!r || typeof r == "string") throw new TypeError("Please pass an Error to err-code");
        t || (t = {}), typeof e == "object" && (t = e, e = void 0), e != null && (t.code = e);
        try {
          return Cfe(r, t)
        } catch (i) {
          t.message = r.message, t.stack = r.stack;
          let n = function () { };
          return n.prototype = Object.create(Object.getPrototypeOf(r)), Cfe(new n, t)
        }
      }
      Pfe.exports = Let
    });
    var S7 = y(Cn => {
      l();
      "use strict";
      Object.defineProperty(Cn, "__esModule", {
        value: !0
      });
      Cn.validateTopicScoreParams = Cn.validatePeerScoreParams = Cn.createTopicScoreParams = Cn.createPeerScoreParams = Cn.defaultTopicScoreParams = Cn.defaultPeerScoreParams = void 0;
      var xr = _7(),
        Ar = E7();
      Cn.defaultPeerScoreParams = {
        topics: {},
        topicScoreCap: 10,
        appSpecificScore: () => 0,
        appSpecificWeight: 10,
        IPColocationFactorWeight: -5,
        IPColocationFactorThreshold: 10,
        IPColocationFactorWhitelist: new Set,
        behaviourPenaltyWeight: -10,
        behaviourPenaltyDecay: .2,
        decayInterval: 1e3,
        decayToZero: .1,
        retainScore: 3600 * 1e3
      };
      Cn.defaultTopicScoreParams = {
        topicWeight: .5,
        timeInMeshWeight: 1,
        timeInMeshQuantum: 1,
        timeInMeshCap: 3600,
        firstMessageDeliveriesWeight: 1,
        firstMessageDeliveriesDecay: .5,
        firstMessageDeliveriesCap: 2e3,
        meshMessageDeliveriesWeight: -1,
        meshMessageDeliveriesDecay: .5,
        meshMessageDeliveriesCap: 100,
        meshMessageDeliveriesThreshold: 20,
        meshMessageDeliveriesWindow: 10,
        meshMessageDeliveriesActivation: 5e3,
        meshFailurePenaltyWeight: -1,
        meshFailurePenaltyDecay: .5,
        invalidMessageDeliveriesWeight: -1,
        invalidMessageDeliveriesDecay: .3
      };

      function Fet(r = {}) {
        return Object.assign(Object.assign(Object.assign({}, Cn.defaultPeerScoreParams), r), {
          topics: r.topics ? Object.entries(r.topics).reduce((e, [t, i]) => (e[t] = Ofe(i), e), {}) : {}
        })
      }
      Cn.createPeerScoreParams = Fet;

      function Ofe(r = {}) {
        return Object.assign(Object.assign({}, Cn.defaultTopicScoreParams), r)
      }
      Cn.createTopicScoreParams = Ofe;

      function Uet(r) {
        for (let [e, t] of Object.entries(r.topics)) try {
          Nfe(t)
        } catch (i) {
          throw Ar(new Error(`invalid score parameters for topic ${e}: ${i.message}`), xr.ERR_INVALID_PEER_SCORE_PARAMS)
        }
        if (r.topicScoreCap < 0) throw Ar(new Error("invalid topic score cap; must be positive (or 0 for no cap)"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.appSpecificScore === null || r.appSpecificScore === void 0) throw Ar(new Error("missing application specific score function"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.IPColocationFactorWeight > 0) throw Ar(new Error("invalid IPColocationFactorWeight; must be negative (or 0 to disable)"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.IPColocationFactorWeight !== 0 && r.IPColocationFactorThreshold < 1) throw Ar(new Error("invalid IPColocationFactorThreshold; must be at least 1"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.behaviourPenaltyWeight > 0) throw Ar(new Error("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.behaviourPenaltyWeight !== 0 && (r.behaviourPenaltyDecay <= 0 || r.behaviourPenaltyDecay >= 1)) throw Ar(new Error("invalid BehaviourPenaltyDecay; must be between 0 and 1"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.decayInterval < 1e3) throw Ar(new Error("invalid DecayInterval; must be at least 1s"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.decayToZero <= 0 || r.decayToZero >= 1) throw Ar(new Error("invalid DecayToZero; must be between 0 and 1"), xr.ERR_INVALID_PEER_SCORE_PARAMS)
      }
      Cn.validatePeerScoreParams = Uet;

      function Nfe(r) {
        if (r.topicWeight < 0) throw Ar(new Error("invalid topic weight; must be >= 0"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.timeInMeshQuantum === 0) throw Ar(new Error("invalid TimeInMeshQuantum; must be non zero"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.timeInMeshWeight < 0) throw Ar(new Error("invalid TimeInMeshWeight; must be positive (or 0 to disable)"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.timeInMeshWeight !== 0 && r.timeInMeshQuantum <= 0) throw Ar(new Error("invalid TimeInMeshQuantum; must be positive"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.timeInMeshWeight !== 0 && r.timeInMeshCap <= 0) throw Ar(new Error("invalid TimeInMeshCap; must be positive"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.firstMessageDeliveriesWeight < 0) throw Ar(new Error("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.firstMessageDeliveriesWeight !== 0 && (r.firstMessageDeliveriesDecay <= 0 || r.firstMessageDeliveriesDecay >= 1)) throw Ar(new Error("invalid FirstMessageDeliveriesDecay; must be between 0 and 1"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.firstMessageDeliveriesWeight !== 0 && r.firstMessageDeliveriesCap <= 0) throw Ar(new Error("invalid FirstMessageDeliveriesCap; must be positive"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.meshMessageDeliveriesWeight > 0) throw Ar(new Error("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.meshMessageDeliveriesWeight !== 0 && (r.meshMessageDeliveriesDecay <= 0 || r.meshMessageDeliveriesDecay >= 1)) throw Ar(new Error("invalid MeshMessageDeliveriesDecay; must be between 0 and 1"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.meshMessageDeliveriesWeight !== 0 && r.meshMessageDeliveriesCap <= 0) throw Ar(new Error("invalid MeshMessageDeliveriesCap; must be positive"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.meshMessageDeliveriesWeight !== 0 && r.meshMessageDeliveriesThreshold <= 0) throw Ar(new Error("invalid MeshMessageDeliveriesThreshold; must be positive"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.meshMessageDeliveriesWindow < 0) throw Ar(new Error("invalid MeshMessageDeliveriesWindow; must be non-negative"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.meshMessageDeliveriesWeight !== 0 && r.meshMessageDeliveriesActivation < 1e3) throw Ar(new Error("invalid MeshMessageDeliveriesActivation; must be at least 1s"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.meshFailurePenaltyWeight > 0) throw Ar(new Error("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.meshFailurePenaltyWeight !== 0 && (r.meshFailurePenaltyDecay <= 0 || r.meshFailurePenaltyDecay >= 1)) throw Ar(new Error("invalid MeshFailurePenaltyDecay; must be between 0 and 1"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.invalidMessageDeliveriesWeight > 0) throw Ar(new Error("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)"), xr.ERR_INVALID_PEER_SCORE_PARAMS);
        if (r.invalidMessageDeliveriesDecay <= 0 || r.invalidMessageDeliveriesDecay >= 1) throw Ar(new Error("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1"), xr.ERR_INVALID_PEER_SCORE_PARAMS)
      }
      Cn.validateTopicScoreParams = Nfe
    });
    var qfe = y(fu => {
      l();
      "use strict";
      Object.defineProperty(fu, "__esModule", {
        value: !0
      });
      fu.validatePeerScoreThresholds = fu.createPeerScoreThresholds = fu.defaultPeerScoreThresholds = void 0;
      var ub = _7(),
        fb = E7();
      fu.defaultPeerScoreThresholds = {
        gossipThreshold: -10,
        publishThreshold: -50,
        graylistThreshold: -80,
        acceptPXThreshold: 10,
        opportunisticGraftThreshold: 20
      };

      function Ket(r = {}) {
        return Object.assign(Object.assign({}, fu.defaultPeerScoreThresholds), r)
      }
      fu.createPeerScoreThresholds = Ket;

      function zet(r) {
        if (r.gossipThreshold > 0) throw fb(new Error("invalid gossip threshold; it must be <= 0"), ub.ERR_INVALID_PEER_SCORE_THRESHOLDS);
        if (r.publishThreshold > 0 || r.publishThreshold > r.gossipThreshold) throw fb(new Error("invalid publish threshold; it must be <= 0 and <= gossip threshold"), ub.ERR_INVALID_PEER_SCORE_THRESHOLDS);
        if (r.graylistThreshold > 0 || r.graylistThreshold > r.publishThreshold) throw fb(new Error("invalid graylist threshold; it must be <= 0 and <= publish threshold"), ub.ERR_INVALID_PEER_SCORE_THRESHOLDS);
        if (r.acceptPXThreshold < 0) throw fb(new Error("invalid accept PX threshold; it must be >= 0"), ub.ERR_INVALID_PEER_SCORE_THRESHOLDS);
        if (r.opportunisticGraftThreshold < 0) throw fb(new Error("invalid opportunistic grafting threshold; it must be >= 0"), ub.ERR_INVALID_PEER_SCORE_THRESHOLDS)
      }
      fu.validatePeerScoreThresholds = zet
    });
    var Mfe = y(Nf => {
      l();
      "use strict";
      Object.defineProperty(Nf, "__esModule", {
        value: !0
      });
      Nf.ensureTopicStats = Nf.createTopicStats = Nf.createPeerStats = void 0;

      function jet(r = {}) {
        return Object.assign(Object.assign({
          connected: !1,
          expire: 0,
          ips: [],
          behaviourPenalty: 0
        }, r), {
          topics: r.topics ? Object.entries(r.topics).reduce((e, [t, i]) => (e[t] = x7(i), e), {}) : {}
        })
      }
      Nf.createPeerStats = jet;

      function x7(r = {}) {
        return Object.assign({
          inMesh: !1,
          graftTime: 0,
          meshTime: 0,
          firstMessageDeliveries: 0,
          meshMessageDeliveries: 0,
          meshMessageDeliveriesActive: !1,
          meshFailurePenalty: 0,
          invalidMessageDeliveries: 0
        }, r)
      }
      Nf.createTopicStats = x7;

      function Vet(r, e, t) {
        let i = e.topics[r];
        if (i) return i;
        if (!!t.topics[r]) return e.topics[r] = i = x7(), i
      }
      Nf.ensureTopicStats = Vet
    });
    var Bfe = y(O_ => {
      l();
      "use strict";
      Object.defineProperty(O_, "__esModule", {
        value: !0
      });
      O_.computeScore = void 0;

      function Het(r, e, t, i) {
        let n = 0;
        return Object.entries(e.topics).forEach(([a, c]) => {
          let u = t.topics[a];
          if (!u) return;
          let f = 0;
          if (c.inMesh) {
            let g = c.meshTime / u.timeInMeshQuantum;
            g > u.timeInMeshCap && (g = u.timeInMeshCap), f += g * u.timeInMeshWeight
          }
          if (f += c.firstMessageDeliveries * u.firstMessageDeliveriesWeight, c.meshMessageDeliveriesActive && c.meshMessageDeliveries < u.meshMessageDeliveriesThreshold) {
            let g = u.meshMessageDeliveriesThreshold - c.meshMessageDeliveries;
            f += g * g * u.meshMessageDeliveriesWeight
          }
          f += c.meshFailurePenalty * u.meshFailurePenaltyWeight, f += c.invalidMessageDeliveries * c.invalidMessageDeliveries * u.invalidMessageDeliveriesWeight, n += f * u.topicWeight
        }), t.topicScoreCap > 0 && n > t.topicScoreCap && (n = t.topicScoreCap), n += t.appSpecificScore(r) * t.appSpecificWeight, e.ips.forEach(a => {
          if (t.IPColocationFactorWhitelist.has(a)) return;
          let c = i.get(a),
            u = c ? c.size : 0;
          if (u > t.IPColocationFactorThreshold) {
            let f = u - t.IPColocationFactorThreshold;
            n += f * f * t.IPColocationFactorWeight
          }
        }), n += e.behaviourPenalty * e.behaviourPenalty * t.behaviourPenaltyWeight, n
      }
      O_.computeScore = Het
    });
    var Lfe = y((w8t, Dfe) => {
      l();
      "use strict";

      function ri(r, e) {
        var e = e || {};
        this._head = 0, this._tail = 0, this._capacity = e.capacity, this._capacityMask = 3, this._list = new Array(4), Array.isArray(r) && this._fromArray(r)
      }
      ri.prototype.peekAt = function (e) {
        var t = e;
        if (t === (t | 0)) {
          var i = this.size();
          if (!(t >= i || t < -i)) return t < 0 && (t += i), t = this._head + t & this._capacityMask, this._list[t]
        }
      };
      ri.prototype.get = function (e) {
        return this.peekAt(e)
      };
      ri.prototype.peek = function () {
        if (this._head !== this._tail) return this._list[this._head]
      };
      ri.prototype.peekFront = function () {
        return this.peek()
      };
      ri.prototype.peekBack = function () {
        return this.peekAt(-1)
      };
      Object.defineProperty(ri.prototype, "length", {
        get: function () {
          return this.size()
        }
      });
      ri.prototype.size = function () {
        return this._head === this._tail ? 0 : this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail)
      };
      ri.prototype.unshift = function (e) {
        if (e === void 0) return this.size();
        var t = this._list.length;
        return this._head = this._head - 1 + t & this._capacityMask, this._list[this._head] = e, this._tail === this._head && this._growArray(), this._capacity && this.size() > this._capacity && this.pop(), this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail)
      };
      ri.prototype.shift = function () {
        var e = this._head;
        if (e !== this._tail) {
          var t = this._list[e];
          return this._list[e] = void 0, this._head = e + 1 & this._capacityMask, e < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2 && this._shrinkArray(), t
        }
      };
      ri.prototype.push = function (e) {
        if (e === void 0) return this.size();
        var t = this._tail;
        return this._list[t] = e, this._tail = t + 1 & this._capacityMask, this._tail === this._head && this._growArray(), this._capacity && this.size() > this._capacity && this.shift(), this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail)
      };
      ri.prototype.pop = function () {
        var e = this._tail;
        if (e !== this._head) {
          var t = this._list.length;
          this._tail = e - 1 + t & this._capacityMask;
          var i = this._list[this._tail];
          return this._list[this._tail] = void 0, this._head < 2 && e > 1e4 && e <= t >>> 2 && this._shrinkArray(), i
        }
      };
      ri.prototype.removeOne = function (e) {
        var t = e;
        if (t === (t | 0) && this._head !== this._tail) {
          var i = this.size(),
            n = this._list.length;
          if (!(t >= i || t < -i)) {
            t < 0 && (t += i), t = this._head + t & this._capacityMask;
            var s = this._list[t],
              o;
            if (e < i / 2) {
              for (o = e; o > 0; o--) this._list[t] = this._list[t = t - 1 + n & this._capacityMask];
              this._list[t] = void 0, this._head = this._head + 1 + n & this._capacityMask
            } else {
              for (o = i - 1 - e; o > 0; o--) this._list[t] = this._list[t = t + 1 + n & this._capacityMask];
              this._list[t] = void 0, this._tail = this._tail - 1 + n & this._capacityMask
            }
            return s
          }
        }
      };
      ri.prototype.remove = function (e, t) {
        var i = e,
          n, s = t;
        if (i === (i | 0) && this._head !== this._tail) {
          var o = this.size(),
            a = this._list.length;
          if (!(i >= o || i < -o || t < 1)) {
            if (i < 0 && (i += o), t === 1 || !t) return n = new Array(1), n[0] = this.removeOne(i), n;
            if (i === 0 && i + t >= o) return n = this.toArray(), this.clear(), n;
            i + t > o && (t = o - i);
            var c;
            for (n = new Array(t), c = 0; c < t; c++) n[c] = this._list[this._head + i + c & this._capacityMask];
            if (i = this._head + i & this._capacityMask, e + t === o) {
              for (this._tail = this._tail - t + a & this._capacityMask, c = t; c > 0; c--) this._list[i = i + 1 + a & this._capacityMask] = void 0;
              return n
            }
            if (e === 0) {
              for (this._head = this._head + t + a & this._capacityMask, c = t - 1; c > 0; c--) this._list[i = i + 1 + a & this._capacityMask] = void 0;
              return n
            }
            if (i < o / 2) {
              for (this._head = this._head + e + t + a & this._capacityMask, c = e; c > 0; c--) this.unshift(this._list[i = i - 1 + a & this._capacityMask]);
              for (i = this._head - 1 + a & this._capacityMask; s > 0;) this._list[i = i - 1 + a & this._capacityMask] = void 0, s--;
              e < 0 && (this._tail = i)
            } else {
              for (this._tail = i, i = i + t + a & this._capacityMask, c = o - (t + e); c > 0; c--) this.push(this._list[i++]);
              for (i = this._tail; s > 0;) this._list[i = i + 1 + a & this._capacityMask] = void 0, s--
            }
            return this._head < 2 && this._tail > 1e4 && this._tail <= a >>> 2 && this._shrinkArray(), n
          }
        }
      };
      ri.prototype.splice = function (e, t) {
        var i = e;
        if (i === (i | 0)) {
          var n = this.size();
          if (i < 0 && (i += n), !(i > n))
            if (arguments.length > 2) {
              var s, o, a, c = arguments.length,
                u = this._list.length,
                f = 2;
              if (!n || i < n / 2) {
                for (o = new Array(i), s = 0; s < i; s++) o[s] = this._list[this._head + s & this._capacityMask];
                for (t === 0 ? (a = [], i > 0 && (this._head = this._head + i + u & this._capacityMask)) : (a = this.remove(i, t), this._head = this._head + i + u & this._capacityMask); c > f;) this.unshift(arguments[--c]);
                for (s = i; s > 0; s--) this.unshift(o[s - 1])
              } else {
                o = new Array(n - (i + t));
                var h = o.length;
                for (s = 0; s < h; s++) o[s] = this._list[this._head + i + t + s & this._capacityMask];
                for (t === 0 ? (a = [], i != n && (this._tail = this._head + i + u & this._capacityMask)) : (a = this.remove(i, t), this._tail = this._tail - h + u & this._capacityMask); f < c;) this.push(arguments[f++]);
                for (s = 0; s < h; s++) this.push(o[s])
              }
              return a
            } else return this.remove(i, t)
        }
      };
      ri.prototype.clear = function () {
        this._head = 0, this._tail = 0
      };
      ri.prototype.isEmpty = function () {
        return this._head === this._tail
      };
      ri.prototype.toArray = function () {
        return this._copyArray(!1)
      };
      ri.prototype._fromArray = function (e) {
        for (var t = 0; t < e.length; t++) this.push(e[t])
      };
      ri.prototype._copyArray = function (e) {
        var t = [],
          i = this._list,
          n = i.length,
          s;
        if (e || this._head > this._tail) {
          for (s = this._head; s < n; s++) t.push(i[s]);
          for (s = 0; s < this._tail; s++) t.push(i[s])
        } else
          for (s = this._head; s < this._tail; s++) t.push(i[s]);
        return t
      };
      ri.prototype._growArray = function () {
        this._head && (this._list = this._copyArray(!0), this._head = 0), this._tail = this._list.length, this._list.length *= 2, this._capacityMask = this._capacityMask << 1 | 1
      };
      ri.prototype._shrinkArray = function () {
        this._list.length >>>= 1, this._capacityMask >>>= 1
      };
      Dfe.exports = ri
    });
    var Kfe = y(lu => {
      l();
      "use strict";
      var Get = lu && lu.__importDefault || function (r) {
        return r && r.__esModule ? r : {
          default: r
        }
      };
      Object.defineProperty(lu, "__esModule", {
        value: !0
      });
      lu.MessageDeliveries = lu.DeliveryRecordStatus = void 0;
      var $et = fh(),
        Wet = Get(Lfe()),
        Yet = lh(),
        Ffe;
      (function (r) {
        r[r.unknown = 0] = "unknown", r[r.valid = 1] = "valid", r[r.invalid = 2] = "invalid", r[r.ignored = 3] = "ignored"
      })(Ffe = lu.DeliveryRecordStatus || (lu.DeliveryRecordStatus = {}));
      var Ufe = class {
        constructor() {
          this.records = new Map, this.queue = new Wet.default
        }
        ensureRecord(e) {
          let t = Yet.messageIdToString(e),
            i = this.records.get(t);
          if (i) return i;
          i = {
            status: Ffe.unknown,
            firstSeen: Date.now(),
            validated: 0,
            peers: new Set
          }, this.records.set(t, i);
          let n = {
            msgId: t,
            expire: Date.now() + $et.TimeCacheDuration
          };
          return this.queue.push(n), i
        }
        gc() {
          let e = Date.now(),
            t = this.queue.peekFront();
          for (; t && t.expire < e;) this.records.delete(t.msgId), this.queue.shift(), t = this.queue.peekFront()
        }
        clear() {
          this.records.clear(), this.queue.clear()
        }
      };
      lu.MessageDeliveries = Ufe
    });
    var jfe = y(op => {
      l();
      "use strict";
      var Jet = op && op.__importDefault || function (r) {
        return r && r.__esModule ? r : {
          default: r
        }
      };
      Object.defineProperty(op, "__esModule", {
        value: !0
      });
      op.PeerScore = void 0;
      var Xet = S7(),
        ap = Mfe(),
        Zet = Bfe(),
        ya = Kfe(),
        Qet = fh(),
        ett = Jet(Et()),
        ttt = Oe(),
        rtt = m_(),
        {
          ERR_INVALID_SIGNATURE: itt,
          ERR_MISSING_SIGNATURE: ntt
        } = rtt.codes,
        cp = ttt("libp2p:gossipsub:score"),
        zfe = class {
          constructor(e, t, i) {
            Xet.validatePeerScoreParams(e), this.params = e, this._connectionManager = t, this.peerStats = new Map, this.peerIPs = new Map, this.deliveryRecords = new ya.MessageDeliveries, this.msgId = i
          }
          start() {
            if (this._backgroundInterval) {
              cp("Peer score already running");
              return
            }
            this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval), cp("started")
          }
          stop() {
            if (!this._backgroundInterval) {
              cp("Peer score already stopped");
              return
            }
            clearInterval(this._backgroundInterval), delete this._backgroundInterval, this.peerIPs.clear(), this.peerStats.clear(), this.deliveryRecords.clear(), cp("stopped")
          }
          background() {
            this._refreshScores(), this._updateIPs(), this.deliveryRecords.gc()
          }
          _refreshScores() {
            let e = Date.now(),
              t = this.params.decayToZero;
            this.peerStats.forEach((i, n) => {
              if (!i.connected) {
                e > i.expire && (this._removeIPs(n, i.ips), this.peerStats.delete(n));
                return
              }
              Object.entries(i.topics).forEach(([s, o]) => {
                let a = this.params.topics[s];
                !a || (o.firstMessageDeliveries *= a.firstMessageDeliveriesDecay, o.firstMessageDeliveries < t && (o.firstMessageDeliveries = 0), o.meshMessageDeliveries *= a.meshMessageDeliveriesDecay, o.meshMessageDeliveries < t && (o.meshMessageDeliveries = 0), o.meshFailurePenalty *= a.meshFailurePenaltyDecay, o.meshFailurePenalty < t && (o.meshFailurePenalty = 0), o.invalidMessageDeliveries *= a.invalidMessageDeliveriesDecay, o.invalidMessageDeliveries < t && (o.invalidMessageDeliveries = 0), o.inMesh && (o.meshTime = e - o.graftTime, o.meshTime > a.meshMessageDeliveriesActivation && (o.meshMessageDeliveriesActive = !0)))
              }), i.behaviourPenalty *= this.params.behaviourPenaltyDecay, i.behaviourPenalty < t && (i.behaviourPenalty = 0)
            })
          }
          score(e) {
            let t = this.peerStats.get(e);
            return t ? Zet.computeScore(e, t, this.params, this.peerIPs) : 0
          }
          addPenalty(e, t) {
            let i = this.peerStats.get(e);
            !i || (i.behaviourPenalty += t)
          }
          addPeer(e) {
            let t = ap.createPeerStats({
              connected: !0
            });
            this.peerStats.set(e, t);
            let i = this._getIPs(e);
            this._setIPs(e, i, t.ips), t.ips = i
          }
          removePeer(e) {
            let t = this.peerStats.get(e);
            if (!!t) {
              if (this.score(e) > 0) {
                this._removeIPs(e, t.ips), this.peerStats.delete(e);
                return
              }
              Object.entries(t.topics).forEach(([i, n]) => {
                n.firstMessageDeliveries = 0;
                let s = this.params.topics[i].meshMessageDeliveriesThreshold;
                if (n.inMesh && n.meshMessageDeliveriesActive && n.meshMessageDeliveries < s) {
                  let o = s - n.meshMessageDeliveries;
                  n.meshFailurePenalty += o * o
                }
                n.inMesh = !1
              }), t.connected = !1, t.expire = Date.now() + this.params.retainScore
            }
          }
          graft(e, t) {
            let i = this.peerStats.get(e);
            if (!i) return;
            let n = ap.ensureTopicStats(t, i, this.params);
            !n || (n.inMesh = !0, n.graftTime = Date.now(), n.meshTime = 0, n.meshMessageDeliveriesActive = !1)
          }
          prune(e, t) {
            let i = this.peerStats.get(e);
            if (!i) return;
            let n = ap.ensureTopicStats(t, i, this.params);
            if (!n) return;
            let s = this.params.topics[t].meshMessageDeliveriesThreshold;
            if (n.meshMessageDeliveriesActive && n.meshMessageDeliveries < s) {
              let o = s - n.meshMessageDeliveries;
              n.meshFailurePenalty += o * o
            }
            n.inMesh = !1
          }
          validateMessage(e) {
            this.deliveryRecords.ensureRecord(this.msgId(e))
          }
          deliverMessage(e) {
            let t = e.receivedFrom;
            this._markFirstMessageDelivery(t, e);
            let i = this.deliveryRecords.ensureRecord(this.msgId(e)),
              n = Date.now();
            if (i.status !== ya.DeliveryRecordStatus.unknown) {
              cp("unexpected delivery: message from %s was first seen %s ago and has delivery status %d", t, n - i.firstSeen, ya.DeliveryRecordStatus[i.status]);
              return
            }
            i.status = ya.DeliveryRecordStatus.valid, i.validated = n, i.peers.forEach(s => {
              s !== t && this._markDuplicateMessageDelivery(s, e)
            })
          }
          rejectMessage(e, t) {
            let i = e.receivedFrom;
            switch (t) {
              case ntt:
              case itt:
                this._markInvalidMessageDelivery(i, e);
                return
            }
            let n = this.deliveryRecords.ensureRecord(this.msgId(e));
            if (n.status !== ya.DeliveryRecordStatus.unknown) {
              cp("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", i, Date.now() - n.firstSeen, ya.DeliveryRecordStatus[n.status]);
              return
            }
            switch (t) {
              case Qet.ERR_TOPIC_VALIDATOR_IGNORE:
                n.status = ya.DeliveryRecordStatus.ignored;
                return
            }
            n.status = ya.DeliveryRecordStatus.invalid, this._markInvalidMessageDelivery(i, e), n.peers.forEach(s => {
              this._markInvalidMessageDelivery(s, e)
            })
          }
          duplicateMessage(e) {
            let t = e.receivedFrom,
              i = this.deliveryRecords.ensureRecord(this.msgId(e));
            if (!i.peers.has(t)) switch (i.status) {
              case ya.DeliveryRecordStatus.unknown:
                i.peers.add(t);
                break;
              case ya.DeliveryRecordStatus.valid:
                i.peers.add(t), this._markDuplicateMessageDelivery(t, e, i.validated);
                break;
              case ya.DeliveryRecordStatus.invalid:
                this._markInvalidMessageDelivery(t, e);
                break
            }
          }
          _markInvalidMessageDelivery(e, t) {
            let i = this.peerStats.get(e);
            !i || t.topicIDs.forEach(n => {
              let s = ap.ensureTopicStats(n, i, this.params);
              !s || (s.invalidMessageDeliveries += 1)
            })
          }
          _markFirstMessageDelivery(e, t) {
            let i = this.peerStats.get(e);
            !i || t.topicIDs.forEach(n => {
              let s = ap.ensureTopicStats(n, i, this.params);
              if (!s) return;
              let o = this.params.topics[n].firstMessageDeliveriesCap;
              s.firstMessageDeliveries += 1, s.firstMessageDeliveries > o && (s.firstMessageDeliveries = o), !!s.inMesh && (o = this.params.topics[n].meshMessageDeliveriesCap, s.meshMessageDeliveries += 1, s.meshMessageDeliveries > o && (s.meshMessageDeliveries = o))
            })
          }
          _markDuplicateMessageDelivery(e, t, i = 0) {
            let n = this.peerStats.get(e);
            if (!n) return;
            let s = i ? Date.now() : 0;
            t.topicIDs.forEach(o => {
              let a = ap.ensureTopicStats(o, n, this.params);
              if (!a || !a.inMesh) return;
              let c = this.params.topics[o];
              if (i && s > i + c.meshMessageDeliveriesWindow) return;
              let u = c.meshMessageDeliveriesCap;
              a.meshMessageDeliveries += 1, a.meshMessageDeliveries > u && (a.meshMessageDeliveries = u)
            })
          }
          _getIPs(e) {
            return this._connectionManager.getAll(ett.default.createFromB58String(e)).map(t => t.remoteAddr.toOptions().host)
          }
          _setIPs(e, t, i) {
            e: for (let n of t) {
              for (let o of i)
                if (n === o) continue e;
              let s = this.peerIPs.get(n);
              s || (s = new Set, this.peerIPs.set(n, s)), s.add(e)
            }
            e: for (let n of i) {
              for (let o of t)
                if (n === o) continue e;
              let s = this.peerIPs.get(n);
              !s || (s.delete(e), s.size || this.peerIPs.delete(n))
            }
          }
          _removeIPs(e, t) {
            t.forEach(i => {
              let n = this.peerIPs.get(i);
              !n || (n.delete(e), n.size || this.peerIPs.delete(i))
            })
          }
          _updateIPs() {
            this.peerStats.forEach((e, t) => {
              let i = this._getIPs(t);
              this._setIPs(t, i, e.ips), e.ips = i
            })
          }
        };
      op.PeerScore = zfe
    });
    var Vfe = y(hu => {
      l();
      "use strict";
      var stt = hu && hu.__createBinding || (Object.create ? function (r, e, t, i) {
        i === void 0 && (i = t), Object.defineProperty(r, i, {
          enumerable: !0,
          get: function () {
            return e[t]
          }
        })
      } : function (r, e, t, i) {
        i === void 0 && (i = t), r[i] = e[t]
      }),
        A7 = hu && hu.__exportStar || function (r, e) {
          for (var t in r) t !== "default" && !Object.prototype.hasOwnProperty.call(e, t) && stt(e, r, t)
        };
      Object.defineProperty(hu, "__esModule", {
        value: !0
      });
      A7(S7(), hu);
      A7(qfe(), hu);
      A7(jfe(), hu)
    });
    var Gfe = y(N_ => {
      l();
      "use strict";
      Object.defineProperty(N_, "__esModule", {
        value: !0
      });
      N_.IWantTracer = void 0;
      var ott = fh(),
        I7 = lh(),
        att = m_(),
        {
          ERR_INVALID_SIGNATURE: ctt,
          ERR_MISSING_SIGNATURE: utt
        } = att.codes,
        Hfe = class {
          constructor(e) {
            this.getMsgId = e, this.promises = new Map
          }
          addPromise(e, t) {
            let i = Math.floor(Math.random() * t.length),
              n = t[i],
              s = I7.messageIdToString(n),
              o = this.promises.get(s);
            o || (o = new Map, this.promises.set(s, o)), o.has(e) || o.set(e, Date.now() + ott.GossipsubIWantFollowupTime)
          }
          getBrokenPromises() {
            let e = Date.now(),
              t = new Map;
            return this.promises.forEach((i, n) => {
              i.forEach((s, o) => {
                s < e && (t.set(o, (t.get(o) || 0) + 1), i.delete(o))
              }), i.size || this.promises.delete(n)
            }), t
          }
          deliverMessage(e) {
            let t = this.getMsgId(e),
              i = I7.messageIdToString(t);
            this.promises.delete(i)
          }
          rejectMessage(e, t) {
            switch (t) {
              case ctt:
              case utt:
                return
            }
            let i = this.getMsgId(e),
              n = I7.messageIdToString(i);
            this.promises.delete(n)
          }
          clear() {
            this.promises.clear()
          }
        };
      N_.IWantTracer = Hfe
    });
    var Xfe = y((A8t, $fe) => {
      l();
      var Wfe = "Expected a function",
        Yfe = 0 / 0,
        ftt = "[object Symbol]",
        ltt = /^\s+|\s+$/g,
        htt = /^[-+]0x[0-9a-f]+$/i,
        dtt = /^0b[01]+$/i,
        ptt = /^0o[0-7]+$/i,
        ytt = parseInt,
        gtt = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis,
        btt = typeof self == "object" && self && self.Object === Object && self,
        mtt = gtt || btt || Function("return this")(),
        vtt = Object.prototype,
        wtt = vtt.toString,
        _tt = Math.max,
        Ett = Math.min,
        T7 = function () {
          return mtt.Date.now()
        };

      function Stt(r, e, t) {
        var i, n, s, o, a, c, u = 0,
          f = !1,
          h = !1,
          d = !0;
        if (typeof r != "function") throw new TypeError(Wfe);
        e = Jfe(e) || 0, q_(t) && (f = !!t.leading, h = "maxWait" in t, s = h ? _tt(Jfe(t.maxWait) || 0, e) : s, d = "trailing" in t ? !!t.trailing : d);

        function p(H) {
          var te = i,
            ae = n;
          return i = n = void 0, u = H, o = r.apply(ae, te), o
        }

        function g(H) {
          return u = H, a = setTimeout(w, e), f ? p(H) : o
        }

        function m(H) {
          var te = H - c,
            ae = H - u,
            oe = e - te;
          return h ? Ett(oe, s - ae) : oe
        }

        function E(H) {
          var te = H - c,
            ae = H - u;
          return c === void 0 || te >= e || te < 0 || h && ae >= s
        }

        function w() {
          var H = T7();
          if (E(H)) return O(H);
          a = setTimeout(w, m(H))
        }

        function O(H) {
          return a = void 0, d && i ? p(H) : (i = n = void 0, o)
        }

        function q() {
          a !== void 0 && clearTimeout(a), u = 0, i = c = n = a = void 0
        }

        function J() {
          return a === void 0 ? o : O(T7())
        }

        function Z() {
          var H = T7(),
            te = E(H);
          if (i = arguments, n = this, c = H, te) {
            if (a === void 0) return g(c);
            if (h) return a = setTimeout(w, e), p(c)
          }
          return a === void 0 && (a = setTimeout(w, e)), o
        }
        return Z.cancel = q, Z.flush = J, Z
      }

      function xtt(r, e, t) {
        var i = !0,
          n = !0;
        if (typeof r != "function") throw new TypeError(Wfe);
        return q_(t) && (i = "leading" in t ? !!t.leading : i, n = "trailing" in t ? !!t.trailing : n), Stt(r, e, {
          leading: i,
          maxWait: e,
          trailing: n
        })
      }

      function q_(r) {
        var e = typeof r;
        return !!r && (e == "object" || e == "function")
      }

      function Att(r) {
        return !!r && typeof r == "object"
      }

      function Itt(r) {
        return typeof r == "symbol" || Att(r) && wtt.call(r) == ftt
      }

      function Jfe(r) {
        if (typeof r == "number") return r;
        if (Itt(r)) return Yfe;
        if (q_(r)) {
          var e = typeof r.valueOf == "function" ? r.valueOf() : r;
          r = q_(e) ? e + "" : e
        }
        if (typeof r != "string") return r === 0 ? r : +r;
        r = r.replace(ltt, "");
        var t = dtt.test(r);
        return t || ptt.test(r) ? ytt(r.slice(2), t ? 2 : 8) : htt.test(r) ? Yfe : +r
      }
      $fe.exports = xtt
    });
    var ele = y((Zfe, Qfe) => {
      l();
      "use strict";
      var Ttt = Xfe();
      Zfe = Qfe.exports = R7;

      function R7(r) {
        if (!(this instanceof R7)) return new R7(r);
        r = r || {};
        let e = r.validity || 30,
          t = new Map,
          i = Ttt(() => {
            t.forEach((n, s) => {
              let o = n.validity || e;
              Rtt(n.timestamp) > o && t.delete(s)
            })
          }, 200);
        this.put = (n, s, o) => {
          this.has(n) || t.set(n, {
            value: s,
            timestamp: new Date,
            validity: o
          }), i()
        }, this.get = n => {
          if (t.has(n)) return t.get(n).value;
          throw new Error("key does not exist")
        }, this.has = n => t.has(n)
      }

      function Rtt(r) {
        let t = new Date().getTime() - r.getTime();
        return Math.floor(t / 1e3)
      }
    });
    var wi = y(k7 => {
      l();
      "use strict";
      k7.messages = {
        NOT_STARTED_YET: "The libp2p node is not started yet",
        DHT_DISABLED: "DHT is not available",
        CONN_ENCRYPTION_REQUIRED: "At least one connection encryption module is required"
      };
      k7.codes = {
        DHT_DISABLED: "ERR_DHT_DISABLED",
        PUBSUB_NOT_STARTED: "ERR_PUBSUB_NOT_STARTED",
        DHT_NOT_STARTED: "ERR_DHT_NOT_STARTED",
        CONN_ENCRYPTION_REQUIRED: "ERR_CONN_ENCRYPTION_REQUIRED",
        ERR_INVALID_PROTOCOLS_FOR_STREAM: "ERR_INVALID_PROTOCOLS_FOR_STREAM",
        ERR_CONNECTION_ENDED: "ERR_CONNECTION_ENDED",
        ERR_CONNECTION_FAILED: "ERR_CONNECTION_FAILED",
        ERR_NODE_NOT_STARTED: "ERR_NODE_NOT_STARTED",
        ERR_ALREADY_ABORTED: "ERR_ALREADY_ABORTED",
        ERR_NO_VALID_ADDRESSES: "ERR_NO_VALID_ADDRESSES",
        ERR_RELAYED_DIAL: "ERR_RELAYED_DIAL",
        ERR_DIALED_SELF: "ERR_DIALED_SELF",
        ERR_DISCOVERED_SELF: "ERR_DISCOVERED_SELF",
        ERR_DUPLICATE_TRANSPORT: "ERR_DUPLICATE_TRANSPORT",
        ERR_ENCRYPTION_FAILED: "ERR_ENCRYPTION_FAILED",
        ERR_HOP_REQUEST_FAILED: "ERR_HOP_REQUEST_FAILED",
        ERR_INVALID_KEY: "ERR_INVALID_KEY",
        ERR_INVALID_MESSAGE: "ERR_INVALID_MESSAGE",
        ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS",
        ERR_INVALID_PEER: "ERR_INVALID_PEER",
        ERR_MUXER_UNAVAILABLE: "ERR_MUXER_UNAVAILABLE",
        ERR_TIMEOUT: "ERR_TIMEOUT",
        ERR_TRANSPORT_UNAVAILABLE: "ERR_TRANSPORT_UNAVAILABLE",
        ERR_TRANSPORT_DIAL_FAILED: "ERR_TRANSPORT_DIAL_FAILED",
        ERR_UNSUPPORTED_PROTOCOL: "ERR_UNSUPPORTED_PROTOCOL",
        ERR_INVALID_MULTIADDR: "ERR_INVALID_MULTIADDR",
        ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
      }
    });
    var ile = y((T8t, tle) => {
      l();
      "use strict";
      var up = bi(),
        rle = up.Reader,
        ktt = up.Writer,
        jr = up.util,
        lb = up.roots["libp2p-envelope"] || (up.roots["libp2p-envelope"] = {});
      lb.Envelope = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.publicKey = jr.newBuffer([]), r.prototype.payloadType = jr.newBuffer([]), r.prototype.payload = jr.newBuffer([]), r.prototype.signature = jr.newBuffer([]), r.encode = function (t, i) {
          return i || (i = ktt.create()), t.publicKey != null && Object.hasOwnProperty.call(t, "publicKey") && i.uint32(10).bytes(t.publicKey), t.payloadType != null && Object.hasOwnProperty.call(t, "payloadType") && i.uint32(18).bytes(t.payloadType), t.payload != null && Object.hasOwnProperty.call(t, "payload") && i.uint32(26).bytes(t.payload), t.signature != null && Object.hasOwnProperty.call(t, "signature") && i.uint32(42).bytes(t.signature), i
        }, r.decode = function (t, i) {
          t instanceof rle || (t = rle.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new lb.Envelope; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.publicKey = t.bytes();
                break;
              case 2:
                s.payloadType = t.bytes();
                break;
              case 3:
                s.payload = t.bytes();
                break;
              case 5:
                s.signature = t.bytes();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof lb.Envelope) return t;
          var i = new lb.Envelope;
          return t.publicKey != null && (typeof t.publicKey == "string" ? jr.base64.decode(t.publicKey, i.publicKey = jr.newBuffer(jr.base64.length(t.publicKey)), 0) : t.publicKey.length && (i.publicKey = t.publicKey)), t.payloadType != null && (typeof t.payloadType == "string" ? jr.base64.decode(t.payloadType, i.payloadType = jr.newBuffer(jr.base64.length(t.payloadType)), 0) : t.payloadType.length && (i.payloadType = t.payloadType)), t.payload != null && (typeof t.payload == "string" ? jr.base64.decode(t.payload, i.payload = jr.newBuffer(jr.base64.length(t.payload)), 0) : t.payload.length && (i.payload = t.payload)), t.signature != null && (typeof t.signature == "string" ? jr.base64.decode(t.signature, i.signature = jr.newBuffer(jr.base64.length(t.signature)), 0) : t.signature.length && (i.signature = t.signature)), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          return i.defaults && (i.bytes === String ? n.publicKey = "" : (n.publicKey = [], i.bytes !== Array && (n.publicKey = jr.newBuffer(n.publicKey))), i.bytes === String ? n.payloadType = "" : (n.payloadType = [], i.bytes !== Array && (n.payloadType = jr.newBuffer(n.payloadType))), i.bytes === String ? n.payload = "" : (n.payload = [], i.bytes !== Array && (n.payload = jr.newBuffer(n.payload))), i.bytes === String ? n.signature = "" : (n.signature = [], i.bytes !== Array && (n.signature = jr.newBuffer(n.signature)))), t.publicKey != null && t.hasOwnProperty("publicKey") && (n.publicKey = i.bytes === String ? jr.base64.encode(t.publicKey, 0, t.publicKey.length) : i.bytes === Array ? Array.prototype.slice.call(t.publicKey) : t.publicKey), t.payloadType != null && t.hasOwnProperty("payloadType") && (n.payloadType = i.bytes === String ? jr.base64.encode(t.payloadType, 0, t.payloadType.length) : i.bytes === Array ? Array.prototype.slice.call(t.payloadType) : t.payloadType), t.payload != null && t.hasOwnProperty("payload") && (n.payload = i.bytes === String ? jr.base64.encode(t.payload, 0, t.payload.length) : i.bytes === Array ? Array.prototype.slice.call(t.payload) : t.payload), t.signature != null && t.hasOwnProperty("signature") && (n.signature = i.bytes === String ? jr.base64.encode(t.signature, 0, t.signature.length) : i.bytes === Array ? Array.prototype.slice.call(t.signature) : t.signature), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, up.util.toJSONOptions)
        }, r
      }();
      tle.exports = lb
    });
    var hb = y((R8t, nle) => {
      l();
      "use strict";
      var Ptt = xe(),
        Ctt = xi(),
        Ott = gt(),
        Ntt = K2(),
        qtt = Et(),
        P7 = Yo(),
        M_ = Lr(),
        {
          codes: Mtt
        } = wi(),
        {
          Envelope: sle
        } = ile(),
        qf = class {
          constructor({
            peerId: e,
            payloadType: t,
            payload: i,
            signature: n
          }) {
            this.peerId = e, this.payloadType = t, this.payload = i, this.signature = n, this._marshal = void 0
          }
          marshal() {
            if (this._marshal) return this._marshal;
            let e = Ntt.marshalPublicKey(this.peerId.pubKey);
            return this._marshal = sle.encode({
              publicKey: e,
              payloadType: this.payloadType,
              payload: this.payload,
              signature: this.signature
            }).finish(), this._marshal
          }
          equals(e) {
            return M_(this.peerId.pubKey.bytes, e.peerId.pubKey.bytes) && M_(this.payloadType, e.payloadType) && M_(this.payload, e.payload) && M_(this.signature, e.signature)
          }
          validate(e) {
            let t = ole(e, this.payloadType, this.payload);
            return this.peerId.pubKey.verify(t, this.signature)
          }
        },
        ole = (r, e, t) => {
          let i = Ott(r),
            n = P7.encode(i.byteLength),
            s = P7.encode(e.length),
            o = P7.encode(t.length);
          return Ctt([new Uint8Array(n), i, new Uint8Array(s), e, new Uint8Array(o), t])
        };
      qf.createFromProtobuf = async r => {
        let e = sle.decode(r),
          t = await qtt.createFromPubKey(e.publicKey);
        return new qf({
          peerId: t,
          payloadType: e.payloadType,
          payload: e.payload,
          signature: e.signature
        })
      };
      qf.seal = async (r, e) => {
        let t = r.domain,
          i = r.codec,
          n = r.marshal(),
          s = ole(t, i, n),
          o = await e.privKey.sign(s);
        return new qf({
          peerId: e,
          payloadType: i,
          payload: n,
          signature: o
        })
      };
      qf.openAndCertify = async (r, e) => {
        let t = await qf.createFromProtobuf(r);
        if (!await t.validate(e)) throw Ptt(new Error("envelope signature is not valid for the given domain"), Mtt.ERR_SIGNATURE_NOT_VALID);
        return t
      };
      nle.exports = qf
    });
    var B7 = y((du, ale) => {
      l();
      "use strict";
      var Btt = du && du.__createBinding || (Object.create ? function (r, e, t, i) {
        i === void 0 && (i = t), Object.defineProperty(r, i, {
          enumerable: !0,
          get: function () {
            return e[t]
          }
        })
      } : function (r, e, t, i) {
        i === void 0 && (i = t), r[i] = e[t]
      }),
        Dtt = du && du.__setModuleDefault || (Object.create ? function (r, e) {
          Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
          })
        } : function (r, e) {
          r.default = e
        }),
        cle = du && du.__importStar || function (r) {
          if (r && r.__esModule) return r;
          var e = {};
          if (r != null)
            for (var t in r) t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && Btt(e, r, t);
          return Dtt(e, r), e
        },
        db = du && du.__awaiter || function (r, e, t, i) {
          function n(s) {
            return s instanceof t ? s : new t(function (o) {
              o(s)
            })
          }
          return new (t || (t = Promise))(function (s, o) {
            function a(f) {
              try {
                u(i.next(f))
              } catch (h) {
                o(h)
              }
            }

            function c(f) {
              try {
                u(i.throw(f))
              } catch (h) {
                o(h)
              }
            }

            function u(f) {
              f.done ? s(f.value) : n(f.value).then(a, c)
            }
            u((i = i.apply(r, e || [])).next())
          })
        },
        C7 = cle(bfe()),
        Ltt = xfe(),
        O7 = Ife(),
        Qt = cle(fh()),
        Ftt = kfe(),
        B_ = w7(),
        en = lh(),
        N7 = Vfe(),
        Utt = Gfe(),
        Ktt = ele(),
        q7 = Et(),
        ztt = hb(),
        M7 = class extends C7.default {
          constructor(e, t = {}) {
            let i = [Qt.GossipsubIDv11, Qt.GossipsubIDv10],
              n = Object.assign(Object.assign({
                gossipIncoming: !0,
                fallbackToFloodsub: !0,
                floodPublish: !0,
                doPX: !1,
                directPeers: [],
                D: Qt.GossipsubD,
                Dlo: Qt.GossipsubDlo,
                Dhi: Qt.GossipsubDhi,
                Dscore: Qt.GossipsubDscore,
                Dout: Qt.GossipsubDout,
                Dlazy: Qt.GossipsubDlazy
              }, t), {
                scoreParams: N7.createPeerScoreParams(t.scoreParams),
                scoreThresholds: N7.createPeerScoreThresholds(t.scoreThresholds)
              });
            n.fallbackToFloodsub && i.push(Qt.FloodsubID), super(Object.assign({
              debugName: "libp2p:gossipsub",
              multicodecs: i,
              libp2p: e
            }, n)), this._options = n, this.direct = new Set(n.directPeers.map(s => s.id.toB58String())), n.directPeers.forEach(s => {
              e.peerStore.addressBook.add(s.id, s.addrs)
            }), this.seenCache = new Ktt, this.mesh = new Map, this.fanout = new Map, this.lastpub = new Map, this.gossip = new Map, this.control = new Map, this.peerhave = new Map, this.iasked = new Map, this.backoff = new Map, this.outbound = new Map, this.messageCache = t.messageCache || new Ltt.MessageCache(Qt.GossipsubHistoryGossip, Qt.GossipsubHistoryLength, this.getMsgId.bind(this)), this.heartbeat = new Ftt.Heartbeat(this), this.heartbeatTicks = 0, this.gossipTracer = new Utt.IWantTracer(this.getMsgId.bind(this)), this._libp2p = e, this.score = new N7.PeerScore(this._options.scoreParams, e.connectionManager, this.getMsgId.bind(this))
          }
          _decodeRpc(e) {
            return O7.RPC.decode(e)
          }
          _encodeRpc(e) {
            return O7.RPC.encode(e).finish()
          }
          _addPeer(e, t) {
            let i = super._addPeer(e, t);
            this.score.addPeer(e.toB58String());
            let n = !1;
            for (let s of this._libp2p.connectionManager.getAll(e))
              if (s.stat.direction === "outbound" && Array.from(s.registry.values()).some(o => t === o.protocol)) {
                n = !0;
                break
              } return this.outbound.set(i.id.toB58String(), n), i
          }
          _removePeer(e) {
            let t = super._removePeer(e),
              i = e.toB58String();
            for (let n of this.mesh.values()) n.delete(i);
            for (let n of this.fanout.values()) n.delete(i);
            return this.gossip.delete(i), this.control.delete(i), this.outbound.delete(i), this.score.removePeer(i), t
          }
          _processRpc(e, t, i) {
            return super._processRpc(e, t, i) ? (i.control && this._processRpcControlMessage(e, i.control), !0) : !1
          }
          _processRpcControlMessage(e, t) {
            if (!t) return;
            let i = t.ihave ? this._handleIHave(e, t.ihave) : [],
              n = t.iwant ? this._handleIWant(e, t.iwant) : [],
              s = t.graft ? this._handleGraft(e, t.graft) : [];
            if (t.prune && this._handlePrune(e, t.prune), !i.length && !n.length && !s.length) return;
            let o = en.createGossipRpc(n, {
              iwant: i,
              prune: s
            });
            this._sendRpc(e, o)
          }
          _processRpcMessage(e) {
            let t = Object.create(null, {
              _processRpcMessage: {
                get: () => super._processRpcMessage
              }
            });
            return db(this, void 0, void 0, function* () {
              let i = this.getMsgId(e),
                n = en.messageIdToString(i);
              if (this.seenCache.has(n)) {
                this.score.duplicateMessage(e);
                return
              }
              this.seenCache.put(n), this.score.validateMessage(e), yield t._processRpcMessage.call(this, e)
            })
          }
          _acceptFrom(e) {
            return this.direct.has(e) || this.score.score(e) >= this._options.scoreThresholds.graylistThreshold
          }
          validate(e) {
            let t = Object.create(null, {
              validate: {
                get: () => super.validate
              }
            });
            return db(this, void 0, void 0, function* () {
              try {
                yield t.validate.call(this, e)
              } catch (i) {
                throw this.score.rejectMessage(e, i.code), this.gossipTracer.rejectMessage(e, i.code), i
              }
            })
          }
          _handleIHave(e, t) {
            if (!t.length) return [];
            let i = this.score.score(e);
            if (i < this._options.scoreThresholds.gossipThreshold) return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", e, i), [];
            let n = (this.peerhave.get(e) || 0) + 1;
            if (this.peerhave.set(e, n), n > Qt.GossipsubMaxIHaveMessages) return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", e, n), [];
            let s = this.iasked.get(e) || 0;
            if (s >= Qt.GossipsubMaxIHaveLength) return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", e, s), [];
            let o = new Map;
            if (t.forEach(({
              topicID: u,
              messageIDs: f
            }) => {
              !u || !f || !this.mesh.has(u) || f.forEach(h => {
                let d = en.messageIdToString(h);
                this.seenCache.has(d) || o.set(d, h)
              })
            }), !o.size) return [];
            let a = o.size;
            a + s > Qt.GossipsubMaxIHaveLength && (a = Qt.GossipsubMaxIHaveLength - s), this.log("IHAVE: Asking for %d out of %d messages from %s", a, o.size, e);
            let c = Array.from(o.values());
            return en.shuffle(c), c = c.slice(0, a), this.iasked.set(e, s + a), this.gossipTracer.addPromise(e, c), [{
              messageIDs: c
            }]
          }
          _handleIWant(e, t) {
            if (!t.length) return [];
            let i = this.score.score(e);
            if (i < this._options.scoreThresholds.gossipThreshold) return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", e, i), [];
            let n = new Map;
            return t.forEach(({
              messageIDs: s
            }) => {
              s && s.forEach(o => {
                let [a, c] = this.messageCache.getForPeer(o, e);
                if (!!a) {
                  if (c > Qt.GossipsubGossipRetransmission) {
                    this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", e, o);
                    return
                  }
                  n.set(en.messageIdToString(o), a)
                }
              })
            }), n.size ? (this.log("IWANT: Sending %d messages to %s", n.size, e), Array.from(n.values()).map(C7.utils.normalizeOutRpcMessage)) : []
          }
          _handleGraft(e, t) {
            let i = [],
              n = this.score.score(e),
              s = this._now(),
              o = this._options.doPX;
            return t.forEach(({
              topicID: a
            }) => {
              var c;
              if (!a) return;
              let u = this.mesh.get(a);
              if (!u) {
                o = !1;
                return
              }
              if (u.has(e)) return;
              if (this.direct.has(e)) {
                this.log("GRAFT: ignoring request from direct peer %s", e), i.push(a), o = !1;
                return
              }
              let f = (c = this.backoff.get(a)) === null || c === void 0 ? void 0 : c.get(e);
              if (typeof f == "number" && s < f) {
                this.log("GRAFT: ignoring backed off peer %s", e), this.score.addPenalty(e, 1), o = !1;
                let h = f + Qt.GossipsubGraftFloodThreshold - Qt.GossipsubPruneBackoff;
                s < h && this.score.addPenalty(e, 1), this._addBackoff(e, a), i.push(a);
                return
              }
              if (n < 0) {
                this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", e, n, a), i.push(a), o = !1, this._addBackoff(e, a);
                return
              }
              if (u.size >= this._options.Dhi && !this.outbound.get(e)) {
                i.push(a), this._addBackoff(e, a);
                return
              }
              this.log("GRAFT: Add mesh link from %s in %s", e, a), this.score.graft(e, a), u.add(e)
            }), i.length ? i.map(a => this._makePrune(e, a, o)) : []
          }
          _handlePrune(e, t) {
            let i = this.score.score(e);
            t.forEach(({
              topicID: n,
              backoff: s,
              peers: o
            }) => {
              if (!n) return;
              let a = this.mesh.get(n);
              if (!!a && (this.log("PRUNE: Remove mesh link to %s in %s", e, n), this.score.prune(e, n), a.delete(e), typeof s == "number" && s > 0 ? this._doAddBackoff(e, n, s * 1e3) : this._addBackoff(e, n), o && o.length)) {
                if (i < this._options.scoreThresholds.acceptPXThreshold) {
                  this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", e, i, n);
                  return
                }
                this._pxConnect(o)
              }
            })
          }
          _addBackoff(e, t) {
            this._doAddBackoff(e, t, Qt.GossipsubPruneBackoff)
          }
          _doAddBackoff(e, t, i) {
            let n = this.backoff.get(t);
            n || (n = new Map, this.backoff.set(t, n));
            let s = this._now() + i;
            (n.get(e) || 0) < s && n.set(e, s)
          }
          _applyIwantPenalties() {
            this.gossipTracer.getBrokenPromises().forEach((e, t) => {
              this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", t, e), this.score.addPenalty(t, e)
            })
          }
          _clearBackoff() {
            if (this.heartbeatTicks % Qt.GossipsubPruneBackoffTicks != 0) return;
            let e = this._now();
            this.backoff.forEach((t, i) => {
              t.forEach((n, s) => {
                n < e && t.delete(s)
              }), t.size === 0 && this.backoff.delete(i)
            })
          }
          _directConnect() {
            if (this.heartbeatTicks % Qt.GossipsubDirectConnectTicks != 0) return;
            let e = [];
            this.direct.forEach(t => {
              let i = this.peers.get(t);
              (!i || !i.isWritable) && e.push(t)
            }), e.length && e.forEach(t => {
              this._connect(t)
            })
          }
          _pxConnect(e) {
            return db(this, void 0, void 0, function* () {
              e.length > Qt.GossipsubPrunePeers && (en.shuffle(e), e = e.slice(0, Qt.GossipsubPrunePeers));
              let t = [];
              yield Promise.all(e.map(i => db(this, void 0, void 0, function* () {
                if (!i.peerID) return;
                let s = q7.createFromBytes(i.peerID).toB58String();
                if (!this.peers.has(s)) {
                  if (!i.signedPeerRecord) {
                    t.push(s);
                    return
                  }
                  try {
                    let o = yield ztt.openAndCertify(i.signedPeerRecord, "libp2p-peer-record"), a = o.peerId.toB58String();
                    if (s !== a) {
                      this.log("bogus peer record obtained through px: peer ID %s doesn't match expected peer %s", a, s);
                      return
                    }
                    if (!this._libp2p.peerStore.addressBook.consumePeerRecord(o)) {
                      this.log("bogus peer record obtained through px: could not add peer record to address book");
                      return
                    }
                    t.push(s)
                  } catch (o) {
                    this.log("bogus peer record obtained through px: invalid signature or not a peer record")
                  }
                }
              }))), !!t.length && t.forEach(i => this._connect(i))
            })
          }
          start() {
            super.start(), this.heartbeat.start(), this.score.start(), this._directPeerInitial = setTimeout(() => {
              this.direct.forEach(e => {
                this._connect(e)
              })
            }, Qt.GossipsubDirectConnectInitialDelay)
          }
          stop() {
            super.stop(), this.heartbeat.stop(), this.score.stop(), this.mesh = new Map, this.fanout = new Map, this.lastpub = new Map, this.gossip = new Map, this.control = new Map, this.peerhave = new Map, this.iasked = new Map, this.backoff = new Map, this.outbound = new Map, this.gossipTracer.clear(), clearTimeout(this._directPeerInitial)
          }
          _connect(e) {
            this.log("Initiating connection with %s", e), this._libp2p.dialProtocol(q7.createFromB58String(e), this.multicodecs)
          }
          subscribe(e) {
            super.subscribe(e), this.join(e)
          }
          unsubscribe(e) {
            super.unsubscribe(e), this.leave(e)
          }
          join(e) {
            if (!this.started) throw new Error("Gossipsub has not started");
            this.log("JOIN %s", e);
            let t = this.fanout.get(e);
            if (t) t.forEach(i => {
              this.score.score(i) < 0 && t.delete(i)
            }), t.size < this._options.D && B_.getGossipPeers(this, e, this._options.D - t.size, i => !t.has(i) && !this.direct.has(i) && this.score.score(i) >= 0).forEach(i => t.add(i)), this.mesh.set(e, t), this.fanout.delete(e), this.lastpub.delete(e);
            else {
              let i = B_.getGossipPeers(this, e, this._options.D, n => !this.direct.has(n) && this.score.score(n) >= 0);
              this.mesh.set(e, i)
            }
            this.mesh.get(e).forEach(i => {
              this.log("JOIN: Add mesh link to %s in %s", i, e), this._sendGraft(i, e)
            })
          }
          leave(e) {
            if (!this.started) throw new Error("Gossipsub has not started");
            this.log("LEAVE %s", e);
            let t = this.mesh.get(e);
            t && (t.forEach(i => {
              this.log("LEAVE: Remove mesh link to %s in %s", i, e), this._sendPrune(i, e)
            }), this.mesh.delete(e))
          }
          _publish(e) {
            return db(this, void 0, void 0, function* () {
              e.receivedFrom !== this.peerId.toB58String() && (this.score.deliverMessage(e), this.gossipTracer.deliverMessage(e));
              let t = this.getMsgId(e),
                i = en.messageIdToString(t);
              this.seenCache.put(i), this.messageCache.put(e);
              let n = new Set;
              e.topicIDs.forEach(o => {
                let a = this.topics.get(o);
                if (!!a)
                  if (this._options.floodPublish && e.from === this.peerId.toB58String()) a.forEach(c => {
                    (this.direct.has(c) || this.score.score(c) >= this._options.scoreThresholds.publishThreshold) && n.add(c)
                  });
                  else {
                    this.direct.forEach(u => {
                      n.add(u)
                    }), a.forEach(u => {
                      let f = this.score.score(u),
                        h = this.peers.get(u);
                      !h || h.protocol === Qt.FloodsubID && f >= this._options.scoreThresholds.publishThreshold && n.add(u)
                    });
                    let c = this.mesh.get(o);
                    if (!c || !c.size) {
                      if (c = this.fanout.get(o), !c) {
                        let u = B_.getGossipPeers(this, o, this._options.D, f => this.score.score(f) >= this._options.scoreThresholds.publishThreshold);
                        u.size > 0 ? (c = u, this.fanout.set(o, u)) : c = new Set
                      }
                      this.lastpub.set(o, this._now())
                    }
                    c.forEach(u => {
                      n.add(u)
                    })
                  }
              });
              let s = en.createGossipRpc([C7.utils.normalizeOutRpcMessage(e)]);
              n.forEach(o => {
                o !== e.from && this._sendRpc(o, s)
              })
            })
          }
          _sendGraft(e, t) {
            let i = [{
              topicID: t
            }],
              n = en.createGossipRpc([], {
                graft: i
              });
            this._sendRpc(e, n)
          }
          _sendPrune(e, t) {
            let i = [this._makePrune(e, t, this._options.doPX)],
              n = en.createGossipRpc([], {
                prune: i
              });
            this._sendRpc(e, n)
          }
          _sendRpc(e, t) {
            let i = this.peers.get(e);
            if (!i || !i.isWritable) return;
            let n = this.control.get(e);
            n && (this._piggybackControl(e, t, n), this.control.delete(e));
            let s = this.gossip.get(e);
            s && (this._piggybackGossip(e, t, s), this.gossip.delete(e)), i.write(O7.RPC.encode(t).finish())
          }
          _piggybackControl(e, t, i) {
            let n = (i.graft || []).filter(({
              topicID: o
            }) => (o && this.mesh.get(o) || new Set).has(e)),
              s = (i.prune || []).filter(({
                topicID: o
              }) => !(o && this.mesh.get(o) || new Set).has(e));
            !n.length && !s.length || (t.control ? (t.control.graft = t.control.graft && t.control.graft.concat(n), t.control.prune = t.control.prune && t.control.prune.concat(s)) : t.control = {
              ihave: [],
              iwant: [],
              graft: n,
              prune: s
            })
          }
          _piggybackGossip(e, t, i) {
            t.control || (t.control = {
              ihave: [],
              iwant: [],
              graft: [],
              prune: []
            }), t.control.ihave = i
          }
          _sendGraftPrune(e, t, i) {
            let n = this._options.doPX;
            for (let [s, o] of e) {
              let a = o.map(h => ({
                topicID: h
              })),
                c = [],
                u = t.get(s);
              u && (c = u.map(h => this._makePrune(s, h, n && !i.get(s))), t.delete(s));
              let f = en.createGossipRpc([], {
                graft: a,
                prune: c
              });
              this._sendRpc(s, f)
            }
            for (let [s, o] of t) {
              let a = o.map(u => this._makePrune(s, u, n && !i.get(s))),
                c = en.createGossipRpc([], {
                  prune: a
                });
              this._sendRpc(s, c)
            }
          }
          _emitGossip(e, t) {
            let i = this.messageCache.getGossipIDs(e);
            if (!i.length) return;
            en.shuffle(i), i.length > Qt.GossipsubMaxIHaveLength && this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", i.length);
            let n = [],
              s = this.topics.get(e);
            if (!s) return;
            s.forEach(c => {
              let u = this.peers.get(c);
              !u || !t.has(c) && !this.direct.has(c) && en.hasGossipProtocol(u.protocol) && this.score.score(c) >= this._options.scoreThresholds.gossipThreshold && n.push(c)
            });
            let o = this._options.Dlazy,
              a = Qt.GossipsubGossipFactor * n.length;
            a > o && (o = a), o > n.length ? o = n.length : en.shuffle(n), n.slice(0, o).forEach(c => {
              let u = i;
              i.length > Qt.GossipsubMaxIHaveLength && (u = en.shuffle(u.slice()).slice(0, Qt.GossipsubMaxIHaveLength)), this._pushGossip(c, {
                topicID: e,
                messageIDs: u
              })
            })
          }
          _flush() {
            for (let [e, t] of this.gossip.entries()) {
              this.gossip.delete(e);
              let i = en.createGossipRpc([], {
                ihave: t
              });
              this._sendRpc(e, i)
            }
            for (let [e, t] of this.control.entries()) {
              this.control.delete(e);
              let i = en.createGossipRpc([], {
                graft: t.graft,
                prune: t.prune
              });
              this._sendRpc(e, i)
            }
          }
          _pushGossip(e, t) {
            this.log("Add gossip to %s", e);
            let i = this.gossip.get(e) || [];
            this.gossip.set(e, i.concat(t))
          }
          _now() {
            return Date.now()
          }
          _makePrune(e, t, i) {
            if (this.peers.get(e).protocol === Qt.GossipsubIDv10) return {
              topicID: t,
              peers: []
            };
            let n = Qt.GossipsubPruneBackoff / 1e3,
              s = [];
            return i && B_.getGossipPeers(this, t, Qt.GossipsubPrunePeers, a => a !== e && this.score.score(a) >= 0).forEach(a => {
              let c = q7.createFromB58String(a);
              s.push({
                peerID: c.toBytes(),
                signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(c)
              })
            }), {
              topicID: t,
              peers: s,
              backoff: n
            }
          }
        };
      M7.multicodec = Qt.GossipsubIDv11;
      ale.exports = M7
    });
    var fle = y((k8t, ule) => {
      l();
      "use strict";
      ule.exports = {
        gossipsub: B7()
      }
    });
    var hle = y((P8t, lle) => {
      l();
      "use strict";
      var jtt = async function* (r, e) {
        let t = 0;
        if (!(e < 1)) {
          for await (let i of r) if (yield i, t++, t === e) return
        }
      };
      lle.exports = jtt
    });
    var D7 = y((C8t, dle) => {
      l();
      "use strict";
      var Vtt = xe(),
        Htt = xl(),
        Gtt = Qc(),
        $tt = hle();

      function Wtt(r, e) {
        return Gtt(r, t => (e.addressBook.add(t.id, t.multiaddrs), t))
      }

      function Ytt(r) {
        let e = new Set;
        return Htt(r, t => e.has(t.id.toString()) ? !1 : (e.add(t.id.toString()), !0))
      }
      async function* Jtt(r, e = 1) {
        let t = 0;
        for await (let i of r) t++, yield i;
        if (t < e) throw Vtt(new Error("not found"), "NOT_FOUND")
      }

      function Xtt(r, e) {
        return e ? $tt(r, e) : r
      }
      dle.exports = {
        storeAddresses: Wtt,
        uniquePeers: Ytt,
        requirePeers: Jtt,
        maybeLimitSource: Xtt
      }
    });
    var L7 = y((O8t, ple) => {
      l();
      "use strict";
      var Ztt = eu(),
        Qtt = async function* (...r) {
          let e = Ztt();
          setTimeout(async () => {
            try {
              await Promise.all(r.map(async t => {
                for await (let i of t) e.push(i)
              })), e.end()
            } catch (t) {
              e.end(t)
            }
          }, 0), yield* e
        };
      ple.exports = Qtt
    });
    var F7 = y((N8t, yle) => {
      l();
      "use strict";
      var fp = new Map,
        ert = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
      async function trt(r, e, t) {
        for (; fp.get(t);) {
          try {
            await r()
          } catch (i) {
            setTimeout(() => {
              throw i
            }, 1);
            break
          }
          if (!fp.get(t)) break;
          await new Promise(i => {
            let n = setTimeout(i, e);
            fp.set(t, n)
          })
        }
      }

      function rrt(r, e, t) {
        t = t || e;
        let i = ert(),
          n = setTimeout(() => {
            trt(r, e, i)
          }, t);
        return fp.set(i, n), i
      }

      function irt(r) {
        let e = fp.get(r);
        e && (clearTimeout(e), fp.delete(r))
      }
      yle.exports = {
        setDelayedInterval: rrt,
        clearDelayedInterval: irt
      }
    });
    var Ele = y((q8t, gle) => {
      l();
      "use strict";
      var ble = Oe(),
        nrt = Object.assign(ble("libp2p:peer-routing"), {
          error: ble("libp2p:peer-routing:err")
        }),
        D_ = xe(),
        {
          storeAddresses: mle,
          uniquePeers: srt,
          requirePeers: ort
        } = D7(),
        vle = L7(),
        {
          pipe: wle
        } = vi(),
        art = r0(),
        crt = Vd(),
        urt = xl(),
        {
          setDelayedInterval: frt,
          clearDelayedInterval: lrt
        } = F7(),
        _le = class {
          constructor(e) {
            this._peerId = e.peerId, this._peerStore = e.peerStore, this._routers = e._modules.peerRouting || [], e._dht && e._config.dht.enabled && this._routers.push(e._dht), this._refreshManagerOptions = e._options.peerRouting.refreshManager, this._findClosestPeersTask = this._findClosestPeersTask.bind(this)
          }
          start() {
            !this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled || (this._timeoutId = frt(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay))
          }
          async _findClosestPeersTask() {
            try {
              await crt(this.getClosestPeers(this._peerId.id))
            } catch (e) {
              nrt.error(e)
            }
          }
          stop() {
            lrt(this._timeoutId)
          }
          async findPeer(e, t) {
            if (!this._routers.length) throw D_(new Error("No peer routers available"), "NO_ROUTERS_AVAILABLE");
            if (e.toB58String() === this._peerId.toB58String()) throw D_(new Error("Should not try to find self"), "ERR_FIND_SELF");
            let i = await wle(vle(...this._routers.map(n => [n.findPeer(e, t)])), n => urt(n, Boolean), n => mle(n, this._peerStore), n => art(n));
            if (i) return i;
            throw D_(new Error("not found"), "NOT_FOUND")
          }
          async *getClosestPeers(e, t = {
            timeout: 3e4
          }) {
            if (!this._routers.length) throw D_(new Error("No peer routers available"), "NO_ROUTERS_AVAILABLE");
            yield* wle(vle(...this._routers.map(i => i.getClosestPeers(e, t))), i => mle(i, this._peerStore), i => srt(i), i => ort(i))
          }
        };
      gle.exports = _le
    });
    var Ale = y((M8t, Sle) => {
      l();
      "use strict";
      var pb = xe(),
        {
          messages: U7,
          codes: K7
        } = wi(),
        {
          storeAddresses: hrt,
          uniquePeers: drt,
          requirePeers: prt,
          maybeLimitSource: yrt
        } = D7(),
        grt = L7(),
        {
          pipe: brt
        } = vi(),
        xle = class {
          constructor(e) {
            this.libp2p = e, this.routers = e._modules.contentRouting || [], this.dht = e._dht, this.dht && e._config.dht.enabled && this.routers.push(this.dht)
          }
          async *findProviders(e, t = {}) {
            if (!this.routers.length) throw pb(new Error("No content this.routers available"), "NO_ROUTERS_AVAILABLE");
            yield* brt(grt(...this.routers.map(i => i.findProviders(e, t))), i => hrt(i, this.libp2p.peerStore), i => drt(i), i => yrt(i, t.maxNumProviders), i => prt(i))
          }
          async provide(e) {
            if (!this.routers.length) throw pb(new Error("No content routers available"), "NO_ROUTERS_AVAILABLE");
            await Promise.all(this.routers.map(t => t.provide(e)))
          }
          put(e, t, i) {
            if (!this.libp2p.isStarted() || !this.dht.isStarted) throw pb(new Error(U7.NOT_STARTED_YET), K7.DHT_NOT_STARTED);
            return this.dht.put(e, t, i)
          }
          get(e, t) {
            if (!this.libp2p.isStarted() || !this.dht.isStarted) throw pb(new Error(U7.NOT_STARTED_YET), K7.DHT_NOT_STARTED);
            return this.dht.get(e, t)
          }
          async getMany(e, t, i) {
            if (!this.libp2p.isStarted() || !this.dht.isStarted) throw pb(new Error(U7.NOT_STARTED_YET), K7.DHT_NOT_STARTED);
            return this.dht.getMany(e, t, i)
          }
        };
      Sle.exports = xle
    });
    var z7 = y((B8t, Ile) => {
      l();
      "use strict";
      var mrt = Et(),
        {
          Multiaddr: Tle
        } = pr(),
        Rle = xe(),
        {
          codes: kle
        } = wi();

      function vrt(r) {
        typeof r == "string" && (r = new Tle(r));
        let e;
        if (Tle.isMultiaddr(r)) {
          e = r;
          let t = r.getPeerId();
          if (!t) throw Rle(new Error(`${r} does not have a valid peer type`), kle.ERR_INVALID_MULTIADDR);
          try {
            r = mrt.createFromB58String(t)
          } catch (i) {
            throw Rle(new Error(`${r} is not a valid peer type`), kle.ERR_INVALID_MULTIADDR)
          }
        }
        return {
          id: r,
          multiaddrs: e ? [e] : void 0
        }
      }
      Ile.exports = vrt
    });
    var Cle = y((D8t, Ple) => {
      l();
      var lp = 1e3,
        hp = lp * 60,
        dp = hp * 60,
        hh = dp * 24,
        wrt = hh * 7,
        _rt = hh * 365.25;
      Ple.exports = function (r, e) {
        e = e || {};
        var t = typeof r;
        if (t === "string" && r.length > 0) return Ert(r);
        if (t === "number" && isFinite(r)) return e.long ? xrt(r) : Srt(r);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(r))
      };

      function Ert(r) {
        if (r = String(r), !(r.length > 100)) {
          var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);
          if (!!e) {
            var t = parseFloat(e[1]),
              i = (e[2] || "ms").toLowerCase();
            switch (i) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return t * _rt;
              case "weeks":
              case "week":
              case "w":
                return t * wrt;
              case "days":
              case "day":
              case "d":
                return t * hh;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return t * dp;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return t * hp;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return t * lp;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return t;
              default:
                return
            }
          }
        }
      }

      function Srt(r) {
        var e = Math.abs(r);
        return e >= hh ? Math.round(r / hh) + "d" : e >= dp ? Math.round(r / dp) + "h" : e >= hp ? Math.round(r / hp) + "m" : e >= lp ? Math.round(r / lp) + "s" : r + "ms"
      }

      function xrt(r) {
        var e = Math.abs(r);
        return e >= hh ? L_(r, e, hh, "day") : e >= dp ? L_(r, e, dp, "hour") : e >= hp ? L_(r, e, hp, "minute") : e >= lp ? L_(r, e, lp, "second") : r + " ms"
      }

      function L_(r, e, t, i) {
        var n = e >= t * 1.5;
        return Math.round(r / t) + " " + i + (n ? "s" : "")
      }
    });
    var qle = y((L8t, Ole) => {
      l();
      "use strict";
      Ole.exports = Nle;
      var Art = Cle(),
        Mf = Nle.prototype,
        Irt = new Date % 1e9;

      function Trt() {
        return (Math.random() * 1e9 >>> 0) + Irt++
      }

      function Nle(r) {
        r = r || {}, this.id = r.id || Trt(), this.max = r.max || Infinity, this.items = r.items || [], this._lookup = {}, this.size = this.items.length, this.lastModified = new Date(r.lastModified || new Date);
        for (var e, t, i = this.items.length; i--;) e = this.items[i], t = new Date(e.expires) - new Date, this._lookup[e.key] = e, t > 0 ? this.expire(e.key, t) : t <= 0 && this.delete(e.key)
      }
      Mf.has = function (r) {
        return r in this._lookup
      };
      Mf.get = function (r) {
        if (!this.has(r)) return null;
        var e = this._lookup[r];
        return e.refresh && this.expire(r, e.refresh), this.items.splice(this.items.indexOf(e), 1), this.items.push(e), e.value
      };
      Mf.meta = function (r) {
        if (!this.has(r)) return null;
        var e = this._lookup[r];
        return "meta" in e ? e.meta : null
      };
      Mf.set = function (r, e, t) {
        var i = this._lookup[r],
          n = this._lookup[r] = {
            key: r,
            value: e
          };
        return this.lastModified = new Date, i ? (clearTimeout(i.timeout), this.items.splice(this.items.indexOf(i), 1, n)) : (this.size >= this.max && this.delete(this.items[0].key), this.items.push(n), this.size++), t && ("ttl" in t && this.expire(r, t.ttl), "meta" in t && (n.meta = t.meta), t.refresh && (n.refresh = t.ttl)), this
      };
      Mf.delete = function (r) {
        var e = this._lookup[r];
        return e ? (this.lastModified = new Date, this.items.splice(this.items.indexOf(e), 1), clearTimeout(e.timeout), delete this._lookup[r], this.size--, this) : !1
      };
      Mf.expire = function (r, e) {
        var t = e || 0,
          i = this._lookup[r];
        if (!i) return this;
        if (typeof t == "string" && (t = Art(e)), typeof t != "number") throw new TypeError("Expiration time must be a string or number.");
        return clearTimeout(i.timeout), i.timeout = setTimeout(this.delete.bind(this, i.key), t), i.expires = Number(new Date) + t, this
      };
      Mf.clear = function () {
        for (var r = this.items.length; r--;) this.delete(this.items[r].key);
        return this
      };
      Mf.toJSON = function () {
        for (var r = new Array(this.items.length), e, t = r.length; t--;) e = this.items[t], r[t] = {
          key: e.key,
          meta: e.meta,
          value: e.value,
          expires: e.expires,
          refresh: e.refresh
        };
        return {
          id: this.id,
          max: isFinite(this.max) ? this.max : void 0,
          lastModified: this.lastModified,
          items: r
        }
      }
    });
    var Ble = y((F8t, Mle) => {
      l();
      "use strict";
      var {
        default: Rrt,
        Headers: krt
      } = sE();

      function Prt({
        serverResolver: r,
        hostname: e,
        recordType: t
      }) {
        return `${r}?name=${e}&type=${t}`
      }

      function Crt(r) {
        return Rrt(r, {
          headers: new krt({
            accept: "application/dns-json"
          })
        })
      }

      function Ort(r, e) {
        return `${e}_${r}`
      }
      Mle.exports = {
        buildResource: Prt,
        fetch: Crt,
        getCacheKey: Ort
      }
    });
    var Fle = y((U8t, Dle) => {
      l();
      "use strict";
      var Lle = Oe(),
        F_ = Lle("dns-over-http-resolver");
      F_.error = Lle("dns-over-http-resolver:error");
      var Nrt = qle(),
        So = Ble(),
        U_ = class {
          constructor({
            maxCache: e = 100
          } = {}) {
            this._cache = new Nrt({
              max: e
            }), this._servers = ["https://cloudflare-dns.com/dns-query", "https://dns.google/resolve"]
          }
          getServers() {
            return this._servers
          }
          _getShuffledServers() {
            let e = [].concat(this._servers);
            for (let t = e.length - 1; t > 0; t--) {
              let i = Math.floor(Math.random() * t),
                n = e[t];
              e[t] = e[i], e[i] = n
            }
            return e
          }
          setServers(e) {
            this._servers = e
          }
          resolve(e, t = "A") {
            switch (t) {
              case "A":
                return this.resolve4(e);
              case "AAAA":
                return this.resolve6(e);
              case "TXT":
                return this.resolveTxt(e);
              default:
                throw new Error(`${t} is not supported`)
            }
          }
          async resolve4(e) {
            let t = "A",
              i = this._cache.get(So.getCacheKey(e, t));
            if (i) return i;
            for (let n of this._getShuffledServers()) try {
              let o = await (await So.fetch(So.buildResource({
                serverResolver: n,
                hostname: e,
                recordType: t
              }))).json(),
                a = o.Answer.map(u => u.data),
                c = Math.min(o.Answer.map(u => u.TTL));
              return this._cache.set(So.getCacheKey(e, t), a, {
                ttl: c
              }), a
            } catch (s) {
              F_.error(`${n} could not resolve ${e} record ${t}`)
            }
            throw new Error(`Could not resolve ${e} record ${t}`)
          }
          async resolve6(e) {
            let t = "AAAA",
              i = this._cache.get(So.getCacheKey(e, t));
            if (i) return i;
            for (let n of this._getShuffledServers()) try {
              let o = await (await So.fetch(So.buildResource({
                serverResolver: n,
                hostname: e,
                recordType: t
              }))).json(),
                a = o.Answer.map(u => u.data),
                c = Math.min(o.Answer.map(u => u.TTL));
              return this._cache.set(So.getCacheKey(e, t), a, {
                ttl: c
              }), a
            } catch (s) {
              F_.error(`${n} could not resolve ${e} record ${t}`)
            }
            throw new Error(`Could not resolve ${e} record ${t}`)
          }
          async resolveTxt(e) {
            let t = "TXT",
              i = this._cache.get(So.getCacheKey(e, t));
            if (i) return i;
            for (let n of this._getShuffledServers()) try {
              let o = await (await So.fetch(So.buildResource({
                serverResolver: n,
                hostname: e,
                recordType: t
              }))).json(),
                a = o.Answer.map(u => [u.data.replace(/['"]+/g, "")]),
                c = Math.min(o.Answer.map(u => u.TTL));
              return this._cache.set(So.getCacheKey(e, t), a, {
                ttl: c
              }), a
            } catch (s) {
              F_.error(`${n} could not resolve ${e} record ${t}`)
            }
            throw new Error(`Could not resolve ${e} record ${t}`)
          }
        };
      U_.Resolver = U_;
      Dle.exports = U_
    });
    var Kle = y((K8t, Ule) => {
      l();
      "use strict";
      var qrt = Fle();
      Ule.exports = qrt
    });
    var jle = y((z8t, zle) => {
      l();
      "use strict";
      var Mrt = sy(),
        {
          code: Brt
        } = Mrt("dnsaddr");
      async function Drt(r) {
        let e = Kle(),
          t = new e,
          i = r.getPeerId(),
          [, n] = r.stringTuples().find(([a]) => a === Brt) || [],
          o = (await t.resolveTxt(`_dnsaddr.${n}`)).flat().map(a => a.split("=")[1]);
        return i && (o = o.filter(a => a.includes(i))), o
      }
      zle.exports = {
        dnsaddrResolver: Drt
      }
    });
    var K_ = y((j8t, Vle) => {
      l();
      "use strict";
      Vle.exports = {
        DIAL_TIMEOUT: 3e4,
        MAX_PARALLEL_DIALS: 100,
        MAX_PER_PEER_DIALS: 4,
        METRICS: {
          computeThrottleMaxQueueSize: 1e3,
          computeThrottleTimeout: 2e3,
          movingAverageIntervals: [60 * 1e3, 5 * 60 * 1e3, 15 * 60 * 1e3],
          maxOldPeersRetention: 50
        }
      }
    });
    var j7 = y((V8t, Hle) => {
      Hle.exports = {
        _args: [
          ["libp2p@0.31.6", "/Users/alex/Documents/Workspaces/ipfs/js-ipfs"]
        ],
        _from: "libp2p@0.31.6",
        _id: "libp2p@0.31.6",
        _inBundle: !1,
        _integrity: "sha512-fTxbE/vgrYeObZUICTGqKqW2E3qBctRZymT5kTVtBFxBKrOStgceCc0WSOtgbqN/QBzYYt66Tl5wjJ6Y3tSHYQ==",
        _location: "/libp2p",
        _phantomChildren: {
          "abort-controller": "3.0.0",
          "any-signal": "2.1.2",
          buffer: "6.0.3",
          "electron-fetch": "1.7.3",
          "err-code": "3.0.1",
          "is-electron": "2.2.0",
          "iso-url": "1.1.5",
          "it-glob": "0.0.11",
          "it-pushable": "1.4.2",
          "it-to-stream": "1.0.0",
          "merge-options": "3.0.4",
          nanoid: "3.1.23",
          "native-abort-controller": "1.0.3",
          "native-fetch": "3.0.0",
          "node-fetch": "2.6.6",
          "stream-to-it": "0.2.3"
        },
        _requested: {
          type: "version",
          registry: !0,
          raw: "libp2p@0.31.6",
          name: "libp2p",
          escapedName: "libp2p",
          rawSpec: "0.31.6",
          saveSpec: null,
          fetchSpec: "0.31.6"
        },
        _requiredBy: ["/"],
        _resolved: "https://registry.npmjs.org/libp2p/-/libp2p-0.31.6.tgz",
        _spec: "0.31.6",
        _where: "/Users/alex/Documents/Workspaces/ipfs/js-ipfs",
        browser: {
          "@motrix/nat-api": !1
        },
        bugs: {
          url: "https://github.com/libp2p/js-libp2p/issues"
        },
        contributors: [{
          name: "David Dias",
          email: "daviddias.p@gmail.com"
        }, {
          name: "Vasco Santos",
          email: "vasco.santos@moxy.studio"
        }, {
          name: "Jacob Heun",
          email: "jacobheun@gmail.com"
        }, {
          name: "Alex Potsides",
          email: "alex@achingbrain.net"
        }, {
          name: "Alan Shaw",
          email: "alan@tableflip.io"
        }, {
          name: "Cayman",
          email: "caymannava@gmail.com"
        }, {
          name: "Pedro Teixeira",
          email: "i@pgte.me"
        }, {
          name: "Friedel Ziegelmayer",
          email: "dignifiedquire@gmail.com"
        }, {
          name: "Maciej Kr\xFCger",
          email: "mkg20001@gmail.com"
        }, {
          name: "Hugo Dias",
          email: "mail@hugodias.me"
        }, {
          name: "Volker Mische",
          email: "volker.mische@gmail.com"
        }, {
          name: "dirkmc",
          email: "dirkmdev@gmail.com"
        }, {
          name: "Richard Littauer",
          email: "richard.littauer@gmail.com"
        }, {
          name: "a1300",
          email: "matthias-knopp@gmx.net"
        }, {
          name: "\u1D20\u026A\u1D04\u1D1B\u1D0F\u0280 \u0299\u1D0A\u1D07\u029F\u1D0B\u029C\u1D0F\u029F\u1D0D",
          email: "victorbjelkholm@gmail.com"
        }, {
          name: "Andrew Nesbitt",
          email: "andrewnez@gmail.com"
        }, {
          name: "Elven",
          email: "mon.samuel@qq.com"
        }, {
          name: "Giovanni T. Parra",
          email: "fiatjaf@gmail.com"
        }, {
          name: "Ryan Bell",
          email: "ryan@piing.net"
        }, {
          name: "Samlior",
          email: "samlior@foxmail.com"
        }, {
          name: "Thomas Eizinger",
          email: "thomas@eizinger.io"
        }, {
          name: "Didrik Nordstr\xF6m",
          email: "didrik@betamos.se"
        }, {
          name: "Felipe Martins",
          email: "felipebrasil93@gmail.com"
        }, {
          name: "Fei Liu",
          email: "liu.feiwood@gmail.com"
        }, {
          name: "Joel Gustafson",
          email: "joelg@mit.edu"
        }, {
          name: "Julien Bouquillon",
          email: "contact@revolunet.com"
        }, {
          name: "Kevin Kwok",
          email: "antimatter15@gmail.com"
        }, {
          name: "Kevin Lacker",
          email: "lacker@gmail.com"
        }, {
          name: "Ethan Lam",
          email: "elmemphis2000@gmail.com"
        }, {
          name: "Miguel Mota",
          email: "miguelmota2@gmail.com"
        }, {
          name: "Nuno Nogueira",
          email: "nunofmn@gmail.com"
        }, {
          name: "Dmitriy Ryajov",
          email: "dryajov@gmail.com"
        }, {
          name: "Philipp Muens",
          email: "raute1337@gmx.de"
        }, {
          name: "RasmusErik Voel Jensen",
          email: "github@solsort.com"
        }, {
          name: "Diogo Silva",
          email: "fsdiogo@gmail.com"
        }, {
          name: "robertkiel",
          email: "robert.kiel@validitylabs.org"
        }, {
          name: "Smite Chow",
          email: "xiaopengyou@live.com"
        }, {
          name: "Soeren",
          email: "nikorpoulsen@gmail.com"
        }, {
          name: "S\xF6nke Hahn",
          email: "soenkehahn@gmail.com"
        }, {
          name: "TJKoury",
          email: "TJKoury@gmail.com"
        }, {
          name: "Tiago Alves",
          email: "alvesjtiago@gmail.com"
        }, {
          name: "Daijiro Wachi",
          email: "daijiro.wachi@gmail.com"
        }, {
          name: "Yusef Napora",
          email: "yusef@napora.org"
        }, {
          name: "Zane Starr",
          email: "zcstarr@gmail.com"
        }, {
          name: "Aleksei",
          email: "vozhdb@gmail.com"
        }, {
          name: "Cindy Wu",
          email: "ciindy.wu@gmail.com"
        }, {
          name: "Chris Bratlien",
          email: "chrisbratlien@gmail.com"
        }, {
          name: "ebinks",
          email: "elizabethjbinks@gmail.com"
        }, {
          name: "Bernd Strehl",
          email: "bernd.strehl@gmail.com"
        }, {
          name: "Francis Gulotta",
          email: "wizard@roborooter.com"
        }, {
          name: "Franck Royer",
          email: "franck@royer.one"
        }, {
          name: "Florian-Merle",
          email: "florian.david.merle@gmail.com"
        }, {
          name: "isan_rivkin",
          email: "isanrivkin@gmail.com"
        }, {
          name: "Henrique Dias",
          email: "hacdias@gmail.com"
        }, {
          name: "Irakli Gozalishvili",
          email: "rfobic@gmail.com"
        }],
        dependencies: {
          "@motrix/nat-api": "^0.3.1",
          "@vascosantos/moving-average": "^1.1.0",
          "abort-controller": "^3.0.0",
          "aggregate-error": "^3.1.0",
          "any-signal": "^2.1.1",
          "bignumber.js": "^9.0.1",
          cids: "^1.1.5",
          "class-is": "^1.1.0",
          debug: "^4.3.1",
          "err-code": "^3.0.0",
          "es6-promisify": "^6.1.1",
          events: "^3.3.0",
          hashlru: "^2.3.0",
          "interface-datastore": "^4.0.0",
          "ipfs-utils": "^7.0.0",
          "it-all": "^1.0.4",
          "it-buffer": "^0.1.2",
          "it-drain": "^1.0.3",
          "it-filter": "^1.0.1",
          "it-first": "^1.0.4",
          "it-handshake": "^2.0.0",
          "it-length-prefixed": "^5.0.2",
          "it-map": "^1.0.4",
          "it-merge": "1.0.0",
          "it-pipe": "^1.1.0",
          "it-take": "1.0.0",
          "libp2p-crypto": "^0.19.4",
          "libp2p-interfaces": "^0.10.4",
          "libp2p-utils": "^0.3.1",
          mafmt: "^9.0.0",
          "merge-options": "^3.0.4",
          multiaddr: "^9.0.1",
          multicodec: "^3.0.1",
          "multihashing-async": "^2.1.2",
          "multistream-select": "^2.0.0",
          "mutable-proxy": "^1.0.0",
          "node-forge": "^0.10.0",
          "p-any": "^3.0.0",
          "p-fifo": "^1.0.0",
          "p-retry": "^4.4.0",
          "p-settle": "^4.1.1",
          "peer-id": "^0.14.2",
          "private-ip": "^2.1.0",
          protobufjs: "^6.10.2",
          retimer: "^3.0.0",
          "sanitize-filename": "^1.6.3",
          "set-delayed-interval": "^1.0.0",
          "streaming-iterables": "^5.0.2",
          "timeout-abort-controller": "^1.1.1",
          varint: "^6.0.0",
          xsalsa20: "^1.1.0"
        },
        description: "JavaScript implementation of libp2p, a modular peer to peer network stack",
        devDependencies: {
          "@nodeutils/defaults-deep": "^1.1.0",
          "@types/es6-promisify": "^6.0.0",
          "@types/node-forge": "^0.9.7",
          "@types/varint": "^6.0.0",
          "abortable-iterator": "^3.0.0",
          aegir: "^33.1.1",
          buffer: "^6.0.3",
          delay: "^5.0.0",
          "interop-libp2p": "^0.4.0",
          "into-stream": "^6.0.0",
          "ipfs-http-client": "^49.0.4",
          "it-concat": "^1.0.0",
          "it-pair": "^1.0.0",
          "it-pushable": "^1.4.0",
          libp2p: ".",
          "libp2p-bootstrap": "^0.12.3",
          "libp2p-delegated-content-routing": "^0.10.0",
          "libp2p-delegated-peer-routing": "^0.9.0",
          "libp2p-floodsub": "^0.25.0",
          "libp2p-gossipsub": "^0.9.0",
          "libp2p-kad-dht": "^0.22.0",
          "libp2p-mdns": "^0.16.0",
          "libp2p-mplex": "^0.10.1",
          "libp2p-noise": "^3.0.0",
          "libp2p-tcp": "^0.15.4",
          "libp2p-webrtc-star": "^0.22.2",
          "libp2p-websockets": "^0.15.6",
          multihashes: "^4.0.2",
          nock: "^13.0.3",
          "p-defer": "^3.0.0",
          "p-times": "^3.0.0",
          "p-wait-for": "^3.2.0",
          rimraf: "^3.0.2",
          sinon: "^10.0.0",
          uint8arrays: "^2.1.3",
          util: "^0.12.3"
        },
        engines: {
          node: ">=14.0.0"
        },
        eslintConfig: {
          extends: "ipfs",
          ignorePatterns: ["!.aegir.js", "test/ts-use"]
        },
        files: ["dist", "src"],
        homepage: "https://libp2p.io",
        keywords: ["libp2p", "network", "p2p", "peer", "peer-to-peer", "IPFS"],
        leadMaintainer: "Jacob Heun <jacobheun@gmail.com>",
        license: "MIT",
        main: "src/index.js",
        name: "libp2p",
        repository: {
          type: "git",
          url: "git+https://github.com/libp2p/js-libp2p.git"
        },
        scripts: {
          build: "aegir build",
          "build:proto": "npm run build:proto:circuit && npm run build:proto:identify && npm run build:proto:plaintext && npm run build:proto:address-book && npm run build:proto:proto-book && npm run build:proto:peer-record && npm run build:proto:envelope",
          "build:proto-types": "npm run build:proto-types:circuit && npm run build:proto-types:identify && npm run build:proto-types:plaintext && npm run build:proto-types:address-book && npm run build:proto-types:proto-book && npm run build:proto-types:peer-record && npm run build:proto-types:envelope",
          "build:proto-types:address-book": "pbts -o src/peer-store/persistent/pb/address-book.d.ts src/peer-store/persistent/pb/address-book.js",
          "build:proto-types:circuit": "pbts -o src/circuit/protocol/index.d.ts src/circuit/protocol/index.js",
          "build:proto-types:envelope": "pbts -o src/record/envelope/envelope.d.ts src/record/envelope/envelope.js",
          "build:proto-types:identify": "pbts -o src/identify/message.d.ts src/identify/message.js",
          "build:proto-types:peer-record": "pbts -o src/record/peer-record/peer-record.d.ts src/record/peer-record/peer-record.js",
          "build:proto-types:plaintext": "pbts -o src/insecure/proto.d.ts src/insecure/proto.js",
          "build:proto-types:proto-book": "pbts -o src/peer-store/persistent/pb/proto-book.d.ts src/peer-store/persistent/pb/proto-book.js",
          "build:proto:address-book": "pbjs -t static-module -w commonjs -r libp2p-address-book --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/peer-store/persistent/pb/address-book.js ./src/peer-store/persistent/pb/address-book.proto",
          "build:proto:circuit": "pbjs -t static-module -w commonjs -r libp2p-circuit --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/circuit/protocol/index.js ./src/circuit/protocol/index.proto",
          "build:proto:envelope": "pbjs -t static-module -w commonjs -r libp2p-envelope --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/record/envelope/envelope.js ./src/record/envelope/envelope.proto",
          "build:proto:identify": "pbjs -t static-module -w commonjs -r libp2p-identify --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/identify/message.js ./src/identify/message.proto",
          "build:proto:peer-record": "pbjs -t static-module -w commonjs -r libp2p-peer-record --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/record/peer-record/peer-record.js ./src/record/peer-record/peer-record.proto",
          "build:proto:plaintext": "pbjs -t static-module -w commonjs -r libp2p-plaintext --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/insecure/proto.js ./src/insecure/proto.proto",
          "build:proto:proto-book": "pbjs -t static-module -w commonjs -r libp2p-proto-book --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/peer-store/persistent/pb/proto-book.js ./src/peer-store/persistent/pb/proto-book.proto",
          coverage: "nyc --reporter=text --reporter=lcov npm run test:node",
          lint: "aegir lint",
          prepare: "aegir build --no-bundle",
          release: "aegir release -t node -t browser",
          "release-major": "aegir release --type major -t node -t browser",
          "release-minor": "aegir release --type minor -t node -t browser",
          test: "aegir test",
          "test:browser": "aegir test -t browser",
          "test:examples": "cd examples && npm run test:all",
          "test:node": 'aegir test -t node -f "./test/**/*.{node,spec}.js"',
          "test:ts": "aegir build --no-bundle && npm run test --prefix test/ts-use"
        },
        types: "dist/src/index.d.ts",
        typesVersions: {
          "*": {
            "src/*": ["dist/src/*", "dist/src/*/index"]
          }
        },
        version: "0.31.6"
      }
    });
    var V7 = y((H8t, yb) => {
      l();
      "use strict";
      var Lrt = j7().version;
      yb.exports.PROTOCOL_VERSION = "ipfs/0.1.0";
      yb.exports.AGENT_VERSION = `js-libp2p/${Lrt}`;
      yb.exports.MULTICODEC_IDENTIFY = "/ipfs/id/1.0.0";
      yb.exports.MULTICODEC_IDENTIFY_PUSH = "/ipfs/id/push/1.0.0"
    });
    var z_ = y((G8t, Gle) => {
      l();
      "use strict";
      var $le = 60 * 1e3;
      Gle.exports = {
        ADVERTISE_BOOT_DELAY: 15 * $le,
        ADVERTISE_TTL: 30 * $le,
        CIRCUIT_PROTO_CODE: 290,
        HOP_METADATA_KEY: "hop_relay",
        HOP_METADATA_VALUE: "true",
        RELAY_RENDEZVOUS_NS: "/libp2p/relay"
      }
    });
    var Wle = y(gb => {
      l();
      (function () {
        var r, e, t, i, n, s, o, a;
        a = function (c) {
          var u, f, h, d;
          return u = (c & 255 << 24) >>> 24, f = (c & 255 << 16) >>> 16, h = (c & 255 << 8) >>> 8, d = c & 255, [u, f, h, d].join(".")
        }, o = function (c) {
          var u, f, h, d, p, g;
          for (u = [], h = d = 0; d <= 3 && c.length !== 0; h = ++d) {
            if (h > 0) {
              if (c[0] !== ".") throw new Error("Invalid IP");
              c = c.substring(1)
            }
            g = e(c), p = g[0], f = g[1], c = c.substring(f), u.push(p)
          }
          if (c.length !== 0) throw new Error("Invalid IP");
          switch (u.length) {
            case 1:
              if (u[0] > 4294967295) throw new Error("Invalid IP");
              return u[0] >>> 0;
            case 2:
              if (u[0] > 255 || u[1] > 16777215) throw new Error("Invalid IP");
              return (u[0] << 24 | u[1]) >>> 0;
            case 3:
              if (u[0] > 255 || u[1] > 255 || u[2] > 65535) throw new Error("Invalid IP");
              return (u[0] << 24 | u[1] << 16 | u[2]) >>> 0;
            case 4:
              if (u[0] > 255 || u[1] > 255 || u[2] > 255 || u[3] > 255) throw new Error("Invalid IP");
              return (u[0] << 24 | u[1] << 16 | u[2] << 8 | u[3]) >>> 0;
            default:
              throw new Error("Invalid IP")
          }
        }, t = function (c) {
          return c.charCodeAt(0)
        }, i = t("0"), s = t("a"), n = t("A"), e = function (c) {
          var u, f, h, d, p;
          for (d = 0, u = 10, f = "9", h = 0, c.length > 1 && c[h] === "0" && (c[h + 1] === "x" || c[h + 1] === "X" ? (h += 2, u = 16) : "0" <= c[h + 1] && c[h + 1] <= "9" && (h++, u = 8, f = "7")), p = h; h < c.length;) {
            if ("0" <= c[h] && c[h] <= f) d = d * u + (t(c[h]) - i) >>> 0;
            else if (u === 16)
              if ("a" <= c[h] && c[h] <= "f") d = d * u + (10 + t(c[h]) - s) >>> 0;
              else if ("A" <= c[h] && c[h] <= "F") d = d * u + (10 + t(c[h]) - n) >>> 0;
              else break;
            else break;
            if (d > 4294967295) throw new Error("too large");
            h++
          }
          if (h === p) throw new Error("empty octet");
          return [d, h]
        }, r = function () {
          function c(u, f) {
            var h, d, p, g;
            if (typeof u != "string") throw new Error("Missing `net' parameter");
            if (f || (g = u.split("/", 2), u = g[0], f = g[1]), f || (f = 32), typeof f == "string" && f.indexOf(".") > -1) {
              try {
                this.maskLong = o(f)
              } catch (m) {
                throw h = m, new Error("Invalid mask: " + f)
              }
              for (d = p = 32; p >= 0; d = --p)
                if (this.maskLong === 4294967295 << 32 - d >>> 0) {
                  this.bitmask = d;
                  break
                }
            } else if (f || f === 0) this.bitmask = parseInt(f, 10), this.maskLong = 0, this.bitmask > 0 && (this.maskLong = 4294967295 << 32 - this.bitmask >>> 0);
            else throw new Error("Invalid mask: empty");
            try {
              this.netLong = (o(u) & this.maskLong) >>> 0
            } catch (m) {
              throw h = m, new Error("Invalid net address: " + u)
            }
            if (!(this.bitmask <= 32)) throw new Error("Invalid mask for ip4: " + f);
            this.size = Math.pow(2, 32 - this.bitmask), this.base = a(this.netLong), this.mask = a(this.maskLong), this.hostmask = a(~this.maskLong), this.first = this.bitmask <= 30 ? a(this.netLong + 1) : this.base, this.last = this.bitmask <= 30 ? a(this.netLong + this.size - 2) : a(this.netLong + this.size - 1), this.broadcast = this.bitmask <= 30 ? a(this.netLong + this.size - 1) : void 0
          }
          return c.prototype.contains = function (u) {
            return typeof u == "string" && (u.indexOf("/") > 0 || u.split(".").length !== 4) && (u = new c(u)), u instanceof c ? this.contains(u.base) && this.contains(u.broadcast || u.last) : (o(u) & this.maskLong) >>> 0 == (this.netLong & this.maskLong) >>> 0
          }, c.prototype.next = function (u) {
            return u == null && (u = 1), new c(a(this.netLong + this.size * u), this.mask)
          }, c.prototype.forEach = function (u) {
            var f, h, d;
            for (d = o(this.first), h = o(this.last), f = 0; d <= h;) u(a(d), d, f), f++, d++
          }, c.prototype.toString = function () {
            return this.base + "/" + this.bitmask
          }, c
        }(), gb.ip2long = o, gb.long2ip = a, gb.Netmask = r
      }).call(gb)
    });
    var Xle = y((W8t, Yle) => {
      l();
      var Frt = Wle().Netmask,
        Jle = XS(),
        Urt = ["0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.0.0/29", "192.0.0.8/32", "192.0.0.9/32", "192.0.0.10/32", "192.0.0.170/32", "192.0.0.171/32", "192.0.2.0/24", "192.31.196.0/24", "192.52.193.0/24", "192.88.99.0/24", "192.168.0.0/16", "192.175.48.0/24", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "240.0.0.0/4", "255.255.255.255/32"],
        Krt = Urt.map(r => new Frt(r));

      function zrt(r) {
        for (let e of Krt)
          if (e.contains(r)) return !0;
        return !1
      }

      function jrt(r) {
        return /^::$/.test(r) || /^::1$/.test(r) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r) || /^ff([0-9a-fA-F]{2,2}):/i.test(r)
      }
      Yle.exports = r => Jle.v6().test(r) ? jrt(r) : Jle().test(r) || r.startsWith("0") ? zrt(r) : !1
    });
    var H7 = y((Y8t, Zle) => {
      l();
      "use strict";
      Zle.exports = Xle()
    });
    var ehe = y((J8t, Qle) => {
      l();
      "use strict";
      var Vrt = H7();

      function Hrt(r) {
        let {
          address: e
        } = r.nodeAddress();
        return Vrt(e)
      }
      Qle.exports = Hrt
    });
    var G7 = y((X8t, the) => {
      l();
      "use strict";
      var rhe = ehe();

      function Grt(r, e) {
        let t = rhe(r.multiaddr),
          i = rhe(e.multiaddr);
        return t && !i ? 1 : !t && i || r.isCertified && !e.isCertified ? -1 : !r.isCertified && e.isCertified ? 1 : 0
      }

      function $rt(r) {
        return [...r].sort(Grt)
      }
      the.exports.publicAddressesFirst = $rt
    });
    var nhe = y((Z8t, $7) => {
      l();
      "use strict";
      var ihe = async r => {
        try {
          let e = await r;
          return {
            isFulfilled: !0,
            isRejected: !1,
            value: e
          }
        } catch (e) {
          return {
            isFulfilled: !1,
            isRejected: !0,
            reason: e
          }
        }
      };
      $7.exports = ihe;
      $7.exports.default = ihe
    });
    var ohe = y((Q8t, W7) => {
      l();
      "use strict";
      var she = (r, ...e) => new Promise(t => {
        t(r(...e))
      });
      W7.exports = she;
      W7.exports.default = she
    });
    var che = y((ext, Y7) => {
      l();
      "use strict";
      var Wrt = ohe(),
        ahe = r => {
          if (!((Number.isInteger(r) || r === Infinity) && r > 0)) return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
          let e = [],
            t = 0,
            i = () => {
              t--, e.length > 0 && e.shift()()
            },
            n = (a, c, ...u) => {
              t++;
              let f = Wrt(a, ...u);
              c(f), f.then(i, i)
            },
            s = (a, c, ...u) => {
              t < r ? n(a, c, ...u) : e.push(n.bind(null, a, c, ...u))
            },
            o = (a, ...c) => new Promise(u => s(a, u, ...c));
          return Object.defineProperties(o, {
            activeCount: {
              get: () => t
            },
            pendingCount: {
              get: () => e.length
            },
            clearQueue: {
              value: () => {
                e.length = 0
              }
            }
          }), o
        };
      Y7.exports = ahe;
      Y7.exports.default = ahe
    });
    var fhe = y((txt, uhe) => {
      l();
      "use strict";
      var J7 = nhe(),
        Yrt = che();
      uhe.exports = async (r, e = {}) => {
        let {
          concurrency: t = Infinity
        } = e, i = Yrt(t);
        return Promise.all(r.map(n => n && typeof n.then == "function" ? J7(n) : typeof n == "function" ? J7(i(() => n())) : J7(Promise.resolve(n))))
      }
    });
    var hhe = y((rxt, lhe) => {
      l();
      "use strict";

      function Jrt(r, e) {
        return r.length === e.length && e.sort() && r.sort().every((t, i) => e[i].equals(t))
      }
      lhe.exports = Jrt
    });
    var yhe = y((ixt, dhe) => {
      l();
      "use strict";
      var dh = bi(),
        j_ = dh.Reader,
        phe = dh.Writer,
        ii = dh.util,
        xo = dh.roots["libp2p-peer-record"] || (dh.roots["libp2p-peer-record"] = {});
      xo.PeerRecord = function () {
        function r(e) {
          if (this.addresses = [], e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.peerId = ii.newBuffer([]), r.prototype.seq = ii.Long ? ii.Long.fromBits(0, 0, !0) : 0, r.prototype.addresses = ii.emptyArray, r.encode = function (t, i) {
          if (i || (i = phe.create()), t.peerId != null && Object.hasOwnProperty.call(t, "peerId") && i.uint32(10).bytes(t.peerId), t.seq != null && Object.hasOwnProperty.call(t, "seq") && i.uint32(16).uint64(t.seq), t.addresses != null && t.addresses.length)
            for (var n = 0; n < t.addresses.length; ++n) xo.PeerRecord.AddressInfo.encode(t.addresses[n], i.uint32(26).fork()).ldelim();
          return i
        }, r.decode = function (t, i) {
          t instanceof j_ || (t = j_.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new xo.PeerRecord; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.peerId = t.bytes();
                break;
              case 2:
                s.seq = t.uint64();
                break;
              case 3:
                s.addresses && s.addresses.length || (s.addresses = []), s.addresses.push(xo.PeerRecord.AddressInfo.decode(t, t.uint32()));
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof xo.PeerRecord) return t;
          var i = new xo.PeerRecord;
          if (t.peerId != null && (typeof t.peerId == "string" ? ii.base64.decode(t.peerId, i.peerId = ii.newBuffer(ii.base64.length(t.peerId)), 0) : t.peerId.length && (i.peerId = t.peerId)), t.seq != null && (ii.Long ? (i.seq = ii.Long.fromValue(t.seq)).unsigned = !0 : typeof t.seq == "string" ? i.seq = parseInt(t.seq, 10) : typeof t.seq == "number" ? i.seq = t.seq : typeof t.seq == "object" && (i.seq = new ii.LongBits(t.seq.low >>> 0, t.seq.high >>> 0).toNumber(!0))), t.addresses) {
            if (!Array.isArray(t.addresses)) throw TypeError(".PeerRecord.addresses: array expected");
            i.addresses = [];
            for (var n = 0; n < t.addresses.length; ++n) {
              if (typeof t.addresses[n] != "object") throw TypeError(".PeerRecord.addresses: object expected");
              i.addresses[n] = xo.PeerRecord.AddressInfo.fromObject(t.addresses[n])
            }
          }
          return i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if ((i.arrays || i.defaults) && (n.addresses = []), i.defaults)
            if (i.bytes === String ? n.peerId = "" : (n.peerId = [], i.bytes !== Array && (n.peerId = ii.newBuffer(n.peerId))), ii.Long) {
              var s = new ii.Long(0, 0, !0);
              n.seq = i.longs === String ? s.toString() : i.longs === Number ? s.toNumber() : s
            } else n.seq = i.longs === String ? "0" : 0;
          if (t.peerId != null && t.hasOwnProperty("peerId") && (n.peerId = i.bytes === String ? ii.base64.encode(t.peerId, 0, t.peerId.length) : i.bytes === Array ? Array.prototype.slice.call(t.peerId) : t.peerId), t.seq != null && t.hasOwnProperty("seq") && (typeof t.seq == "number" ? n.seq = i.longs === String ? String(t.seq) : t.seq : n.seq = i.longs === String ? ii.Long.prototype.toString.call(t.seq) : i.longs === Number ? new ii.LongBits(t.seq.low >>> 0, t.seq.high >>> 0).toNumber(!0) : t.seq), t.addresses && t.addresses.length) {
            n.addresses = [];
            for (var o = 0; o < t.addresses.length; ++o) n.addresses[o] = xo.PeerRecord.AddressInfo.toObject(t.addresses[o], i)
          }
          return n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, dh.util.toJSONOptions)
        }, r.AddressInfo = function () {
          function e(t) {
            if (t)
              for (var i = Object.keys(t), n = 0; n < i.length; ++n) t[i[n]] != null && (this[i[n]] = t[i[n]])
          }
          return e.prototype.multiaddr = ii.newBuffer([]), e.encode = function (i, n) {
            return n || (n = phe.create()), i.multiaddr != null && Object.hasOwnProperty.call(i, "multiaddr") && n.uint32(10).bytes(i.multiaddr), n
          }, e.decode = function (i, n) {
            i instanceof j_ || (i = j_.create(i));
            for (var s = n === void 0 ? i.len : i.pos + n, o = new xo.PeerRecord.AddressInfo; i.pos < s;) {
              var a = i.uint32();
              switch (a >>> 3) {
                case 1:
                  o.multiaddr = i.bytes();
                  break;
                default:
                  i.skipType(a & 7);
                  break
              }
            }
            return o
          }, e.fromObject = function (i) {
            if (i instanceof xo.PeerRecord.AddressInfo) return i;
            var n = new xo.PeerRecord.AddressInfo;
            return i.multiaddr != null && (typeof i.multiaddr == "string" ? ii.base64.decode(i.multiaddr, n.multiaddr = ii.newBuffer(ii.base64.length(i.multiaddr)), 0) : i.multiaddr.length && (n.multiaddr = i.multiaddr)), n
          }, e.toObject = function (i, n) {
            n || (n = {});
            var s = {};
            return n.defaults && (n.bytes === String ? s.multiaddr = "" : (s.multiaddr = [], n.bytes !== Array && (s.multiaddr = ii.newBuffer(s.multiaddr)))), i.multiaddr != null && i.hasOwnProperty("multiaddr") && (s.multiaddr = n.bytes === String ? ii.base64.encode(i.multiaddr, 0, i.multiaddr.length) : n.bytes === Array ? Array.prototype.slice.call(i.multiaddr) : i.multiaddr), s
          }, e.prototype.toJSON = function () {
            return this.constructor.toObject(this, dh.util.toJSONOptions)
          }, e
        }(), r
      }();
      dhe.exports = xo
    });
    var mhe = y((nxt, ghe) => {
      l();
      "use strict";
      var bhe = Jr(),
        Xrt = bhe.getName(bhe.LIBP2P_PEER_RECORD) || "libp2p-peer-record",
        Zrt = Uint8Array.from([3, 1]);
      ghe.exports = {
        ENVELOPE_DOMAIN_PEER_RECORD: Xrt,
        ENVELOPE_PAYLOAD_TYPE_PEER_RECORD: Zrt
      }
    });
    var V_ = y((sxt, vhe) => {
      l();
      "use strict";
      var {
        Multiaddr: Qrt
      } = pr(), eit = Et(), tit = hhe(), {
        PeerRecord: whe
      } = yhe(), {
        ENVELOPE_DOMAIN_PEER_RECORD: _he,
        ENVELOPE_PAYLOAD_TYPE_PEER_RECORD: rit
      } = mhe(), ph = class {
        constructor({
          peerId: e,
          multiaddrs: t = [],
          seqNumber: i = Date.now()
        }) {
          this.domain = _he, this.codec = rit, this.peerId = e, this.multiaddrs = t, this.seqNumber = i, this._marshal = void 0
        }
        marshal() {
          return this._marshal ? this._marshal : (this._marshal = whe.encode({
            peerId: this.peerId.toBytes(),
            seq: this.seqNumber,
            addresses: this.multiaddrs.map(e => ({
              multiaddr: e.bytes
            }))
          }).finish(), this._marshal)
        }
        equals(e) {
          return !(!(e instanceof ph) || !this.peerId.equals(e.peerId) || this.seqNumber !== e.seqNumber || !tit(this.multiaddrs, e.multiaddrs))
        }
      };
      ph.createFromProtobuf = r => {
        let e = whe.decode(r),
          t = eit.createFromBytes(e.peerId),
          i = (e.addresses || []).map(s => new Qrt(s.multiaddr)),
          n = Number(e.seq);
        return new ph({
          peerId: t,
          multiaddrs: i,
          seqNumber: n
        })
      };
      ph.DOMAIN = _he;
      vhe.exports = ph
    });
    var X7 = y((oxt, Ehe) => {
      l();
      "use strict";
      var iit = hb(),
        nit = V_();
      async function sit(r) {
        let e = new nit({
          peerId: r.peerId,
          multiaddrs: r.multiaddrs
        }),
          t = await iit.seal(e, r.peerId);
        r.peerStore.addressBook.consumePeerRecord(t)
      }
      Ehe.exports.updateSelfPeerRecord = sit
    });
    var Q7 = y((axt, She) => {
      l();
      "use strict";
      var xhe = Oe(),
        yh = Object.assign(xhe("libp2p:transports"), {
          error: xhe("libp2p:transports:err")
        }),
        oit = fhe(),
        {
          codes: pp
        } = wi(),
        bb = xe(),
        {
          updateSelfPeerRecord: Ahe
        } = X7(),
        Z7 = class {
          constructor({
            libp2p: e,
            upgrader: t,
            faultTolerance: i = H_.FATAL_ALL
          }) {
            this.libp2p = e, this.upgrader = t, this._transports = new Map, this._listeners = new Map, this._listenerOptions = new Map, this.faultTolerance = i
          }
          add(e, t, i = {}) {
            if (yh("adding %s", e), !e) throw bb(new Error(`Transport must have a valid key, was given '${e}'`), pp.ERR_INVALID_KEY);
            if (this._transports.has(e)) throw bb(new Error("There is already a transport with this key"), pp.ERR_DUPLICATE_TRANSPORT);
            let n = new t({
              ...i,
              libp2p: this.libp2p,
              upgrader: this.upgrader
            });
            this._transports.set(e, n), this._listenerOptions.set(e, i.listenerOptions || {}), this._listeners.has(e) || this._listeners.set(e, [])
          }
          async close() {
            let e = [];
            for (let [t, i] of this._listeners)
              for (yh("closing listeners for %s", t); i.length;) {
                let n = i.pop();
                n.removeAllListeners("listening"), n.removeAllListeners("close"), e.push(n.close())
              }
            await Promise.all(e), yh("all listeners closed");
            for (let t of this._listeners.keys()) this._listeners.set(t, [])
          }
          async dial(e, t) {
            let i = this.transportForMultiaddr(e);
            if (!i) throw bb(new Error(`No transport available for address ${String(e)}`), pp.ERR_TRANSPORT_UNAVAILABLE);
            try {
              return await i.dial(e, t)
            } catch (n) {
              throw n.code || (n.code = pp.ERR_TRANSPORT_DIAL_FAILED), n
            }
          }
          getAddrs() {
            let e = [];
            for (let t of this._listeners.values())
              for (let i of t) e = [...e, ...i.getAddrs()];
            return e
          }
          getTransports() {
            return this._transports.values()
          }
          transportForMultiaddr(e) {
            for (let t of this._transports.values())
              if (t.filter([e]).length) return t;
            return null
          }
          async listen(e) {
            if (!e || e.length === 0) {
              yh("no addresses were provided for listening, this node is dial only");
              return
            }
            let t = [];
            for (let [i, n] of this._transports.entries()) {
              let s = n.filter(e),
                o = [];
              for (let u of s) {
                yh("creating listener for %s on %s", i, u);
                let f = n.createListener(this._listenerOptions.get(i));
                this._listeners.get(i).push(f), f.on("listening", () => Ahe(this.libp2p)), f.on("close", () => Ahe(this.libp2p)), o.push(f.listen(u))
              }
              if (o.length === 0) {
                t.push(i);
                continue
              }
              if (!(await oit(o)).find(u => u.isFulfilled === !0) && this.faultTolerance !== H_.NO_FATAL) throw bb(new Error(`Transport (${i}) could not listen on any available address`), pp.ERR_NO_VALID_ADDRESSES)
            }
            if (t.length === this._transports.size) {
              let i = `no valid addresses were provided for transports [${t}]`;
              if (this.faultTolerance === H_.FATAL_ALL) throw bb(new Error(i), pp.ERR_NO_VALID_ADDRESSES);
              yh(`libp2p in dial mode only: ${i}`)
            }
          }
          async remove(e) {
            if (yh("removing %s", e), this._listeners.has(e))
              for (let t of this._listeners.get(e)) t.removeAllListeners("listening"), t.removeAllListeners("close"), await t.close();
            this._transports.delete(e), this._listeners.delete(e)
          }
          async removeAll() {
            let e = [];
            for (let t of this._transports.keys()) e.push(this.remove(t));
            await Promise.all(e)
          }
        },
        H_ = {
          FATAL_ALL: 0,
          NO_FATAL: 1
        };
      Z7.FaultTolerance = H_;
      She.exports = Z7
    });
    var Rhe = y((cxt, Ihe) => {
      l();
      "use strict";
      var ait = Yr(),
        {
          dnsaddrResolver: cit
        } = jle(),
        eR = K_(),
        {
          AGENT_VERSION: uit
        } = V7(),
        The = z_(),
        {
          publicAddressesFirst: fit
        } = G7(),
        {
          FaultTolerance: lit
        } = Q7(),
        hit = {
          addresses: {
            listen: [],
            announce: [],
            noAnnounce: [],
            announceFilter: r => r
          },
          connectionManager: {
            minConnections: 25
          },
          transportManager: {
            faultTolerance: lit.FATAL_ALL
          },
          dialer: {
            maxParallelDials: eR.MAX_PARALLEL_DIALS,
            maxDialsPerPeer: eR.MAX_PER_PEER_DIALS,
            dialTimeout: eR.DIAL_TIMEOUT,
            resolvers: {
              dnsaddr: cit
            },
            addressSorter: fit
          },
          host: {
            agentVersion: uit
          },
          metrics: {
            enabled: !1
          },
          peerStore: {
            persistence: !1,
            threshold: 5
          },
          peerRouting: {
            refreshManager: {
              enabled: !0,
              interval: 6e5,
              bootDelay: 1e4
            }
          },
          config: {
            dht: {
              enabled: !1,
              kBucketSize: 20,
              randomWalk: {
                enabled: !1,
                queriesPerPeriod: 1,
                interval: 3e5,
                timeout: 1e4
              }
            },
            nat: {
              enabled: !0,
              ttl: 7200,
              keepAlive: !0,
              gateway: null,
              externalIp: null,
              pmp: {
                enabled: !1
              }
            },
            peerDiscovery: {
              autoDial: !0
            },
            pubsub: {
              enabled: !0
            },
            relay: {
              enabled: !0,
              advertise: {
                bootDelay: The.ADVERTISE_BOOT_DELAY,
                enabled: !1,
                ttl: The.ADVERTISE_TTL
              },
              hop: {
                enabled: !1,
                active: !1
              },
              autoRelay: {
                enabled: !1,
                maxListeners: 2
              }
            },
            transport: {}
          }
        };
      Ihe.exports.validate = r => {
        let e = ait(hit, r);
        if (e.modules.transport.length < 1) throw new Error("'options.modules.transport' must contain at least 1 transport");
        return e
      }
    });
    var Che = y((uxt, khe) => {
      l();
      "use strict";
      var {
        EventEmitter: dit
      } = Br(), {
        Multiaddr: mb
      } = pr(), pit = Et(), Phe = class extends dit {
        constructor(e, {
          listen: t = [],
          announce: i = []
        } = {}) {
          super();
          this.peerId = e, this.listen = new Set(t.map(n => n.toString())), this.announce = new Set(i.map(n => n.toString())), this.observed = new Set
        }
        getListenAddrs() {
          return Array.from(this.listen).map(e => new mb(e))
        }
        getAnnounceAddrs() {
          return Array.from(this.announce).map(e => new mb(e))
        }
        getObservedAddrs() {
          return Array.from(this.observed).map(e => new mb(e))
        }
        addObservedAddr(e) {
          let t = new mb(e),
            i = t.getPeerId();
          i && pit.createFromB58String(i).equals(this.peerId) && (t = t.decapsulate(new mb(`/p2p/${this.peerId}`)));
          let n = t.toString();
          this.observed.has(n) || (this.observed.add(n), this.emit("change:addresses"))
        }
      };
      khe.exports = Phe
    });
    var qhe = y((fxt, Ohe) => {
      l();
      "use strict";
      var {
        EventEmitter: yit
      } = Br(), tR = Oe()("latency-monitor:VisibilityChangeEmitter"), Nhe = class extends yit {
        constructor() {
          super();
          if (typeof document == "undefined") {
            tR('This is not a browser, no "document" found. Stopping.');
            return
          }
          this._initializeVisibilityVarNames(), this._addVisibilityChangeListener()
        }
        _initializeVisibilityVarNames() {
          let e, t;
          typeof document.hidden != "undefined" ? (e = "hidden", t = "visibilitychange") : typeof document.mozHidden != "undefined" ? (e = "mozHidden", t = "mozvisibilitychange") : typeof document.msHidden != "undefined" ? (e = "msHidden", t = "msvisibilitychange") : typeof document.webkitHidden != "undefined" && (e = "webkitHidden", t = "webkitvisibilitychange"), this._hidden = e, this._visibilityChange = t
        }
        _addVisibilityChangeListener() {
          typeof document.addEventListener == "undefined" || typeof document[this._hidden] == "undefined" ? tR("Checking page visibility requires a browser that supports the Page Visibility API.") : document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), !1)
        }
        isVisible() {
          if (!(this._hidden === void 0 || document[this._hidden] === void 0)) return !document[this._hidden]
        }
        _handleVisibilityChange() {
          let e = !document[this._hidden];
          tR(e ? "Page Visible" : "Page Hidden"), this.emit("visibilityChange", e)
        }
      };
      Ohe.exports = Nhe
    });
    var Dhe = y((lxt, Mhe) => {
      l();
      "use strict";
      var {
        EventEmitter: git
      } = Br(), bit = qhe(), pu = Oe()("latency-monitor:LatencyMonitor"), Bhe = class extends git {
        constructor({
          latencyCheckIntervalMs: e,
          dataEmitIntervalMs: t,
          asyncTestFn: i,
          latencyRandomPercentage: n
        } = {}) {
          super();
          let s = this;
          s.latencyCheckIntervalMs = e || 500, s.latencyRandomPercentage = n || 10, s._latecyCheckMultiply = 2 * (s.latencyRandomPercentage / 100) * s.latencyCheckIntervalMs, s._latecyCheckSubtract = s._latecyCheckMultiply / 2, s.dataEmitIntervalMs = t === null || t === 0 ? void 0 : t || 5 * 1e3, pu("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", s.latencyCheckIntervalMs, s.dataEmitIntervalMs), s.dataEmitIntervalMs ? pu("Expecting ~%s events per summary", s.latencyCheckIntervalMs / s.dataEmitIntervalMs) : pu("Not emitting summaries"), s.asyncTestFn = i, globalThis.process && globalThis.process.hrtime ? (pu("Using process.hrtime for timing"), s.now = globalThis.process.hrtime, s.getDeltaMS = o => {
            let a = s.now(o);
            return a[0] * 1e3 + a[1] / 1e6
          }) : typeof window != "undefined" && window.performance && window.performance.now ? (pu("Using performance.now for timing"), s.now = window.performance.now.bind(window.performance), s.getDeltaMS = o => Math.round(s.now() - o)) : (pu("Using Date.now for timing"), s.now = Date.now, s.getDeltaMS = o => s.now() - o), s._latencyData = s._initLatencyData(), mit() && (s._visibilityChangeEmitter = new bit, s._visibilityChangeEmitter.on("visibilityChange", o => {
            o ? s._startTimers() : (s._emitSummary(), s._stopTimers())
          })), (!s._visibilityChangeEmitter || s._visibilityChangeEmitter.isVisible()) && s._startTimers()
        }
        _startTimers() {
          this._checkLatencyID || (this._checkLatency(), this.dataEmitIntervalMs && (this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs), typeof this._emitIntervalID.unref == "function" && this._emitIntervalID.unref()))
        }
        _stopTimers() {
          this._checkLatencyID && (clearTimeout(this._checkLatencyID), this._checkLatencyID = void 0), this._emitIntervalID && (clearInterval(this._emitIntervalID), this._emitIntervalID = void 0)
        }
        _emitSummary() {
          let e = this.getSummary();
          e.events > 0 && this.emit("data", e)
        }
        getSummary() {
          let e = {
            events: this._latencyData.events,
            minMs: this._latencyData.minMs,
            maxMs: this._latencyData.maxMs,
            avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY,
            lengthMs: this.getDeltaMS(this._latencyData.startTime)
          };
          return this._latencyData = this._initLatencyData(), pu("Summary: %O", e), e
        }
        _checkLatency() {
          let e = this,
            t = Math.random() * e._latecyCheckMultiply - e._latecyCheckSubtract,
            i = {
              deltaOffset: Math.ceil(e.latencyCheckIntervalMs + t),
              startTime: e.now()
            },
            n = () => {
              if (!this._checkLatencyID) return;
              let s = e.getDeltaMS(i.startTime) - i.deltaOffset;
              e._checkLatency(), e._latencyData.events++, e._latencyData.minMs = Math.min(e._latencyData.minMs, s), e._latencyData.maxMs = Math.max(e._latencyData.maxMs, s), e._latencyData.totalMs += s, pu("MS: %s Data: %O", s, e._latencyData)
            };
          pu("localData: %O", i), this._checkLatencyID = setTimeout(() => {
            e.asyncTestFn ? (i.deltaOffset = 0, i.startTime = e.now(), e.asyncTestFn(n)) : (i.deltaOffset -= 1, n())
          }, i.deltaOffset), typeof this._checkLatencyID.unref == "function" && this._checkLatencyID.unref()
        }
        _initLatencyData() {
          return {
            startTime: this.now(),
            minMs: Number.POSITIVE_INFINITY,
            maxMs: Number.NEGATIVE_INFINITY,
            events: 0,
            totalMs: 0
          }
        }
      };

      function mit() {
        return typeof window != "undefined"
      }
      Mhe.exports = Bhe
    });
    var Fhe = y((hxt, Lhe) => {
      l();
      "use strict";
      Lhe.exports = function () {
        return Date.now()
      }
    });
    var rR = y((dxt, Uhe) => {
      l();
      "use strict";
      var G_ = Fhe(),
        Khe = class {
          constructor(e, t, i) {
            let n = this;
            this._started = G_(), this._rescheduled = 0, this._scheduled = t, this._args = i, this._triggered = !1, this._timerWrapper = () => {
              n._rescheduled > 0 ? (n._scheduled = n._rescheduled - (G_() - n._started), n._schedule(n._scheduled)) : (n._triggered = !0, e.apply(null, n._args))
            }, this._timer = setTimeout(this._timerWrapper, t)
          }
          reschedule(e) {
            e || (e = this._scheduled);
            let t = G_();
            t + e - (this._started + this._scheduled) < 0 ? (clearTimeout(this._timer), this._schedule(e)) : this._triggered ? this._schedule(e) : (this._started = t, this._rescheduled = e)
          }
          _schedule(e) {
            this._triggered = !1, this._started = G_(), this._rescheduled = 0, this._scheduled = e, this._timer = setTimeout(this._timerWrapper, e)
          }
          clear() {
            clearTimeout(this._timer)
          }
        };

      function vit() {
        if (typeof arguments[0] != "function") throw new Error("callback needed");
        if (typeof arguments[1] != "number") throw new Error("timeout needed");
        let r;
        if (arguments.length > 0) {
          r = new Array(arguments.length - 2);
          for (var e = 0; e < r.length; e++) r[e] = arguments[e + 2]
        }
        return new Khe(arguments[0], arguments[1], r)
      }
      Uhe.exports = vit
    });
    var $he = y((pxt, zhe) => {
      l();
      "use strict";
      var jhe = Oe(),
        ga = Object.assign(jhe("libp2p:connection-manager"), {
          error: jhe("libp2p:connection-manager:err")
        }),
        Vhe = xe(),
        wit = Yr(),
        _it = Dhe(),
        $_ = rR(),
        {
          EventEmitter: Eit
        } = Br(),
        Sit = Et(),
        {
          codes: {
            ERR_INVALID_PARAMETERS: Hhe
          }
        } = wi(),
        xit = {
          maxConnections: Infinity,
          minConnections: 0,
          maxData: Infinity,
          maxSentData: Infinity,
          maxReceivedData: Infinity,
          maxEventLoopDelay: Infinity,
          pollInterval: 2e3,
          autoDialInterval: 1e4,
          movingAverageInterval: 6e4,
          defaultPeerValue: 1
        },
        Ghe = class extends Eit {
          constructor(e, t = {}) {
            super();
            if (this._libp2p = e, this._peerId = e.peerId.toB58String(), this._options = wit.call({
              ignoreUndefined: !0
            }, xit, t), this._options.maxConnections < this._options.minConnections) throw Vhe(new Error("Connection Manager maxConnections must be greater than minConnections"), Hhe);
            ga("options: %j", this._options), this._peerValues = new Map, this.connections = new Map, this._started = !1, this._timer = null, this._autoDialTimeout = null, this._checkMetrics = this._checkMetrics.bind(this), this._autoDial = this._autoDial.bind(this)
          }
          get size() {
            return Array.from(this.connections.values()).reduce((e, t) => e + t.length, 0)
          }
          start() {
            this._libp2p.metrics && (this._timer = this._timer || $_(this._checkMetrics, this._options.pollInterval)), this._latencyMonitor = new _it({
              latencyCheckIntervalMs: this._options.pollInterval,
              dataEmitIntervalMs: this._options.pollInterval
            }), this._onLatencyMeasure = this._onLatencyMeasure.bind(this), this._latencyMonitor.on("data", this._onLatencyMeasure), this._started = !0, ga("started"), this._options.autoDial && this._autoDial()
          }
          async stop() {
            this._autoDialTimeout && this._autoDialTimeout.clear(), this._timer && this._timer.clear(), this._latencyMonitor && this._latencyMonitor.removeListener("data", this._onLatencyMeasure), this._started = !1, await this._close(), ga("stopped")
          }
          async _close() {
            let e = [];
            for (let t of this.connections.values())
              for (let i of t) e.push(i.close());
            await Promise.all(e), this.connections.clear()
          }
          setPeerValue(e, t) {
            if (t < 0 || t > 1) throw new Error("value should be a number between 0 and 1");
            this._peerValues.set(e.toB58String(), t)
          }
          _checkMetrics() {
            if (this._libp2p.metrics) {
              let e = this._libp2p.metrics.global.movingAverages,
                t = e.dataReceived[this._options.movingAverageInterval].movingAverage();
              this._checkMaxLimit("maxReceivedData", t);
              let i = e.dataSent[this._options.movingAverageInterval].movingAverage();
              this._checkMaxLimit("maxSentData", i);
              let n = t + i;
              this._checkMaxLimit("maxData", n), ga("metrics update", n), this._timer = $_(this._checkMetrics, this._options.pollInterval)
            }
          }
          onConnect(e) {
            let t = e.remotePeer,
              i = t.toB58String(),
              n = this.connections.get(i);
            this.emit("peer:connect", e), n ? n.push(e) : this.connections.set(i, [e]), this._libp2p.peerStore.keyBook.set(t, t.pubKey), this._peerValues.has(i) || this._peerValues.set(i, this._options.defaultPeerValue), this._checkMaxLimit("maxConnections", this.size)
          }
          onDisconnect(e) {
            let t = e.remotePeer.toB58String(),
              i = this.connections.get(t);
            i && i.length > 1 ? (i = i.filter(n => n.id !== e.id), this.connections.set(t, i)) : i && (this.connections.delete(t), this._peerValues.delete(e.remotePeer.toB58String()), this.emit("peer:disconnect", e))
          }
          get(e) {
            let t = this.getAll(e);
            return t.length ? t[0] : null
          }
          getAll(e) {
            if (!Sit.isPeerId(e)) throw Vhe(new Error("peerId must be an instance of peer-id"), Hhe);
            let t = e.toB58String(),
              i = this.connections.get(t);
            return i ? i.filter(n => n.stat.status === "open") : []
          }
          _onLatencyMeasure(e) {
            this._checkMaxLimit("maxEventLoopDelay", e.avgMs)
          }
          _checkMaxLimit(e, t) {
            let i = this._options[e];
            ga("checking limit of %s. current value: %d of %d", e, t, i), t > i && (ga("%s: limit exceeded: %s, %d", this._peerId, e, t), this._maybeDisconnectOne())
          }
          async _autoDial() {
            let e = this._options.minConnections;
            if (this.size >= e) {
              this._autoDialTimeout = $_(this._autoDial, this._options.autoDialInterval);
              return
            }
            let t = Array.from(this._libp2p.peerStore.peers.values()).sort((i, n) => n.protocols && n.protocols.length && (!i.protocols || !i.protocols.length) || n.id.pubKey && !i.id.pubKey ? 1 : -1);
            for (let i = 0; i < t.length && this.size < e; i++)
              if (!this.get(t[i].id)) {
                ga("connecting to a peerStore stored peer %s", t[i].id.toB58String());
                try {
                  if (await this._libp2p.dialer.connectToPeer(t[i].id), !this._started) return
                } catch (n) {
                  ga.error("could not connect to peerStore stored peer", n)
                }
              } this._autoDialTimeout = $_(this._autoDial, this._options.autoDialInterval)
          }
          _maybeDisconnectOne() {
            if (this._options.minConnections < this.connections.size) {
              let e = Array.from(new Map([...this._peerValues.entries()].sort((i, n) => i[1] - n[1])));
              ga("%s: sorted peer values: %j", this._peerId, e);
              let t = e[0];
              if (t) {
                let i = t[0];
                ga("%s: lowest value peer is %s", this._peerId, i), ga("%s: closing a connection to %j", this._peerId, i);
                for (let n of this.connections.values())
                  if (n[0].remotePeer.toB58String() === i) {
                    n[0].close();
                    break
                  }
              }
            }
          }
        };
      zhe.exports = Ghe
    });
    var yp = y((yxt, Whe) => {
      l();
      "use strict";
      var gh = bi(),
        W_ = gh.Reader,
        Yhe = gh.Writer,
        Ao = gh.util,
        tn = gh.roots["libp2p-circuit"] || (gh.roots["libp2p-circuit"] = {});
      tn.CircuitRelay = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.type = 1, r.prototype.srcPeer = null, r.prototype.dstPeer = null, r.prototype.code = 100, r.encode = function (t, i) {
          return i || (i = Yhe.create()), t.type != null && Object.hasOwnProperty.call(t, "type") && i.uint32(8).int32(t.type), t.srcPeer != null && Object.hasOwnProperty.call(t, "srcPeer") && tn.CircuitRelay.Peer.encode(t.srcPeer, i.uint32(18).fork()).ldelim(), t.dstPeer != null && Object.hasOwnProperty.call(t, "dstPeer") && tn.CircuitRelay.Peer.encode(t.dstPeer, i.uint32(26).fork()).ldelim(), t.code != null && Object.hasOwnProperty.call(t, "code") && i.uint32(32).int32(t.code), i
        }, r.decode = function (t, i) {
          t instanceof W_ || (t = W_.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new tn.CircuitRelay; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.type = t.int32();
                break;
              case 2:
                s.srcPeer = tn.CircuitRelay.Peer.decode(t, t.uint32());
                break;
              case 3:
                s.dstPeer = tn.CircuitRelay.Peer.decode(t, t.uint32());
                break;
              case 4:
                s.code = t.int32();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof tn.CircuitRelay) return t;
          var i = new tn.CircuitRelay;
          switch (t.type) {
            case "HOP":
            case 1:
              i.type = 1;
              break;
            case "STOP":
            case 2:
              i.type = 2;
              break;
            case "STATUS":
            case 3:
              i.type = 3;
              break;
            case "CAN_HOP":
            case 4:
              i.type = 4;
              break
          }
          if (t.srcPeer != null) {
            if (typeof t.srcPeer != "object") throw TypeError(".CircuitRelay.srcPeer: object expected");
            i.srcPeer = tn.CircuitRelay.Peer.fromObject(t.srcPeer)
          }
          if (t.dstPeer != null) {
            if (typeof t.dstPeer != "object") throw TypeError(".CircuitRelay.dstPeer: object expected");
            i.dstPeer = tn.CircuitRelay.Peer.fromObject(t.dstPeer)
          }
          switch (t.code) {
            case "SUCCESS":
            case 100:
              i.code = 100;
              break;
            case "HOP_SRC_ADDR_TOO_LONG":
            case 220:
              i.code = 220;
              break;
            case "HOP_DST_ADDR_TOO_LONG":
            case 221:
              i.code = 221;
              break;
            case "HOP_SRC_MULTIADDR_INVALID":
            case 250:
              i.code = 250;
              break;
            case "HOP_DST_MULTIADDR_INVALID":
            case 251:
              i.code = 251;
              break;
            case "HOP_NO_CONN_TO_DST":
            case 260:
              i.code = 260;
              break;
            case "HOP_CANT_DIAL_DST":
            case 261:
              i.code = 261;
              break;
            case "HOP_CANT_OPEN_DST_STREAM":
            case 262:
              i.code = 262;
              break;
            case "HOP_CANT_SPEAK_RELAY":
            case 270:
              i.code = 270;
              break;
            case "HOP_CANT_RELAY_TO_SELF":
            case 280:
              i.code = 280;
              break;
            case "STOP_SRC_ADDR_TOO_LONG":
            case 320:
              i.code = 320;
              break;
            case "STOP_DST_ADDR_TOO_LONG":
            case 321:
              i.code = 321;
              break;
            case "STOP_SRC_MULTIADDR_INVALID":
            case 350:
              i.code = 350;
              break;
            case "STOP_DST_MULTIADDR_INVALID":
            case 351:
              i.code = 351;
              break;
            case "STOP_RELAY_REFUSED":
            case 390:
              i.code = 390;
              break;
            case "MALFORMED_MESSAGE":
            case 400:
              i.code = 400;
              break
          }
          return i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          return i.defaults && (n.type = i.enums === String ? "HOP" : 1, n.srcPeer = null, n.dstPeer = null, n.code = i.enums === String ? "SUCCESS" : 100), t.type != null && t.hasOwnProperty("type") && (n.type = i.enums === String ? tn.CircuitRelay.Type[t.type] : t.type), t.srcPeer != null && t.hasOwnProperty("srcPeer") && (n.srcPeer = tn.CircuitRelay.Peer.toObject(t.srcPeer, i)), t.dstPeer != null && t.hasOwnProperty("dstPeer") && (n.dstPeer = tn.CircuitRelay.Peer.toObject(t.dstPeer, i)), t.code != null && t.hasOwnProperty("code") && (n.code = i.enums === String ? tn.CircuitRelay.Status[t.code] : t.code), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, gh.util.toJSONOptions)
        }, r.Status = function () {
          var e = {},
            t = Object.create(e);
          return t[e[100] = "SUCCESS"] = 100, t[e[220] = "HOP_SRC_ADDR_TOO_LONG"] = 220, t[e[221] = "HOP_DST_ADDR_TOO_LONG"] = 221, t[e[250] = "HOP_SRC_MULTIADDR_INVALID"] = 250, t[e[251] = "HOP_DST_MULTIADDR_INVALID"] = 251, t[e[260] = "HOP_NO_CONN_TO_DST"] = 260, t[e[261] = "HOP_CANT_DIAL_DST"] = 261, t[e[262] = "HOP_CANT_OPEN_DST_STREAM"] = 262, t[e[270] = "HOP_CANT_SPEAK_RELAY"] = 270, t[e[280] = "HOP_CANT_RELAY_TO_SELF"] = 280, t[e[320] = "STOP_SRC_ADDR_TOO_LONG"] = 320, t[e[321] = "STOP_DST_ADDR_TOO_LONG"] = 321, t[e[350] = "STOP_SRC_MULTIADDR_INVALID"] = 350, t[e[351] = "STOP_DST_MULTIADDR_INVALID"] = 351, t[e[390] = "STOP_RELAY_REFUSED"] = 390, t[e[400] = "MALFORMED_MESSAGE"] = 400, t
        }(), r.Type = function () {
          var e = {},
            t = Object.create(e);
          return t[e[1] = "HOP"] = 1, t[e[2] = "STOP"] = 2, t[e[3] = "STATUS"] = 3, t[e[4] = "CAN_HOP"] = 4, t
        }(), r.Peer = function () {
          function e(t) {
            if (this.addrs = [], t)
              for (var i = Object.keys(t), n = 0; n < i.length; ++n) t[i[n]] != null && (this[i[n]] = t[i[n]])
          }
          return e.prototype.id = Ao.newBuffer([]), e.prototype.addrs = Ao.emptyArray, e.encode = function (i, n) {
            if (n || (n = Yhe.create()), n.uint32(10).bytes(i.id), i.addrs != null && i.addrs.length)
              for (var s = 0; s < i.addrs.length; ++s) n.uint32(18).bytes(i.addrs[s]);
            return n
          }, e.decode = function (i, n) {
            i instanceof W_ || (i = W_.create(i));
            for (var s = n === void 0 ? i.len : i.pos + n, o = new tn.CircuitRelay.Peer; i.pos < s;) {
              var a = i.uint32();
              switch (a >>> 3) {
                case 1:
                  o.id = i.bytes();
                  break;
                case 2:
                  o.addrs && o.addrs.length || (o.addrs = []), o.addrs.push(i.bytes());
                  break;
                default:
                  i.skipType(a & 7);
                  break
              }
            }
            if (!o.hasOwnProperty("id")) throw Ao.ProtocolError("missing required 'id'", {
              instance: o
            });
            return o
          }, e.fromObject = function (i) {
            if (i instanceof tn.CircuitRelay.Peer) return i;
            var n = new tn.CircuitRelay.Peer;
            if (i.id != null && (typeof i.id == "string" ? Ao.base64.decode(i.id, n.id = Ao.newBuffer(Ao.base64.length(i.id)), 0) : i.id.length && (n.id = i.id)), i.addrs) {
              if (!Array.isArray(i.addrs)) throw TypeError(".CircuitRelay.Peer.addrs: array expected");
              n.addrs = [];
              for (var s = 0; s < i.addrs.length; ++s) typeof i.addrs[s] == "string" ? Ao.base64.decode(i.addrs[s], n.addrs[s] = Ao.newBuffer(Ao.base64.length(i.addrs[s])), 0) : i.addrs[s].length && (n.addrs[s] = i.addrs[s])
            }
            return n
          }, e.toObject = function (i, n) {
            n || (n = {});
            var s = {};
            if ((n.arrays || n.defaults) && (s.addrs = []), n.defaults && (n.bytes === String ? s.id = "" : (s.id = [], n.bytes !== Array && (s.id = Ao.newBuffer(s.id)))), i.id != null && i.hasOwnProperty("id") && (s.id = n.bytes === String ? Ao.base64.encode(i.id, 0, i.id.length) : n.bytes === Array ? Array.prototype.slice.call(i.id) : i.id), i.addrs && i.addrs.length) {
              s.addrs = [];
              for (var o = 0; o < i.addrs.length; ++o) s.addrs[o] = n.bytes === String ? Ao.base64.encode(i.addrs[o], 0, i.addrs[o].length) : n.bytes === Array ? Array.prototype.slice.call(i.addrs[o]) : i.addrs[o]
            }
            return s
          }, e.prototype.toJSON = function () {
            return this.constructor.toObject(this, gh.util.toJSONOptions)
          }, e
        }(), r
      }();
      Whe.exports = tn
    });
    var Zhe = y((gxt, Jhe) => {
      l();
      "use strict";
      var {
        source: Xhe
      } = au(), Ait = Oe(), Iit = Ait("libp2p:stream:converter");

      function Tit({
        stream: r,
        remoteAddr: e,
        localAddr: t
      }, i = {}) {
        let {
          sink: n,
          source: s
        } = r, o = {
          async sink(c) {
            i.signal && (c = Xhe(c, i.signal));
            try {
              await n(c)
            } catch (u) {
              u.type !== "aborted" && Iit(u)
            }
            a()
          },
          source: i.signal ? Xhe(s, i.signal) : s,
          conn: r,
          localAddr: t,
          remoteAddr: e,
          timeline: {
            open: Date.now(),
            close: void 0
          },
          close() {
            return n(new Uint8Array(0)), a()
          }
        };

        function a() {
          return o.timeline.close || (o.timeline.close = Date.now()), Promise.resolve()
        }
        return o
      }
      Jhe.exports = Tit
    });
    var vb = y((bxt, Qhe) => {
      l();
      "use strict";
      Qhe.exports = {
        relay: "/libp2p/circuit/relay/0.1.0"
      }
    });
    var tde = y((mxt, ede) => {
      l();
      "use strict";
      var {
        EventEmitter: Rit
      } = Br(), {
        Multiaddr: kit
      } = pr();
      ede.exports = r => {
        let e = new Map;
        async function t(s) {
          let o = String(s).split("/p2p-circuit").find(u => u !== ""),
            a = await r.dial(new kit(o)),
            c = a.remoteAddr.encapsulate("/p2p-circuit");
          e.set(a.remotePeer.toB58String(), c), n.emit("listening")
        }

        function i() {
          let s = [];
          for (let o of e.values()) s.push(o);
          return s
        }
        let n = Object.assign(new Rit, {
          close: () => Promise.resolve(),
          listen: t,
          getAddrs: i
        });
        return r.connectionManager.on("peer:disconnect", s => {
          e.delete(s.remotePeer.toB58String()) && n.emit("close")
        }), n
      }
    });
    var iR = y((vxt, rde) => {
      l();
      "use strict";
      var {
        Multiaddr: ide
      } = pr(), {
        CircuitRelay: bh
      } = yp();

      function nde(r, e) {
        r.write({
          type: bh.Type.STATUS,
          code: e
        })
      }

      function Pit(r, e) {
        try {
          r.dstPeer && r.dstPeer.addrs && r.dstPeer.addrs.forEach(t => new ide(t))
        } catch (t) {
          throw nde(e, r.type === bh.Type.HOP ? bh.Status.HOP_DST_MULTIADDR_INVALID : bh.Status.STOP_DST_MULTIADDR_INVALID), t
        }
        try {
          r.srcPeer && r.srcPeer.addrs && r.srcPeer.addrs.forEach(t => new ide(t))
        } catch (t) {
          throw nde(e, r.type === bh.Type.HOP ? bh.Status.HOP_SRC_MULTIADDR_INVALID : bh.Status.STOP_SRC_MULTIADDR_INVALID), t
        }
      }
      rde.exports = {
        validateAddrs: Pit
      }
    });
    var sR = y((wxt, sde) => {
      l();
      var nR = go();
      sde.exports = r => {
        let e = async function* () {
          let t = yield,
            i = new nR;
          for await (let n of r) {
            if (!t) {
              t = yield i.append(n), i = new nR;
              continue
            }
            for (i.append(n); i.length >= t;) {
              let s = i.shallowSlice(0, t);
              if (i.consume(t), t = yield s, !t) {
                i.length && (t = yield i, i = new nR);
                break
              }
            }
          }
          if (t) throw Object.assign(new Error(`stream ended before ${t} bytes became available`), {
            code: "ERR_UNDER_READ",
            buffer: i
          })
        }();
        return e.next(), e
      }
    });
    var wb = y((_xt, ode) => {
      l();
      "use strict";
      var Cit = () => {
        let r = {};
        return r.promise = new Promise((e, t) => {
          r.resolve = e, r.reject = t
        }), r
      };
      ode.exports = Cit
    });
    var gp = y((Ext, ade) => {
      l();
      "use strict";
      var Oit = sR(),
        Nit = eu(),
        qit = wb();
      ade.exports = r => {
        let e = Nit(),
          t = Oit(r.source),
          i = qit(),
          n, s = r.sink(async function* () {
            yield* e, yield* await i.promise
          }());
        return s.catch(a => {
          n = a
        }), {
          reader: t,
          writer: e,
          stream: {
            sink: a => n ? Promise.reject(n) : (i.resolve(a), s),
            source: t
          },
          rest: () => e.end(),
          write: e.push,
          read: async () => (await t.next()).value
        }
      }
    });
    var J_ = y((Sxt, cde) => {
      l();
      "use strict";
      var ude = Oe(),
        Y_ = Object.assign(ude("libp2p:circuit:stream-handler"), {
          error: ude("libp2p:circuit:stream-handler:err")
        }),
        fde = da(),
        Mit = gp(),
        {
          CircuitRelay: lde
        } = yp(),
        hde = class {
          constructor({
            stream: e,
            maxLength: t = 4096
          }) {
            this.stream = e, this.shake = Mit(this.stream), this.decoder = fde.decode.fromReader(this.shake.reader, {
              maxDataLength: t
            })
          }
          async read() {
            let e = await this.decoder.next();
            if (e.value) {
              let t = lde.decode(e.value.slice());
              return Y_("read message type", t.type), t
            }
            Y_("read received no value, closing stream"), this.close()
          }
          write(e) {
            Y_("write message type %s", e.type), this.shake.write(fde.encode.single(lde.encode(e).finish()))
          }
          rest() {
            return this.shake.rest(), this.shake.stream
          }
          end(e) {
            this.write(e), this.close()
          }
          close() {
            Y_("closing the stream"), this.rest().sink([])
          }
        };
      cde.exports = hde
    });
    var cR = y((xxt, oR) => {
      l();
      "use strict";
      var dde = Oe(),
        _b = Object.assign(dde("libp2p:circuit:stop"), {
          error: dde("libp2p:circuit:stop:err")
        }),
        {
          CircuitRelay: aR
        } = yp(),
        Bit = vb(),
        Dit = J_(),
        {
          validateAddrs: Lit
        } = iR();
      oR.exports.handleStop = function ({
        connection: e,
        request: t,
        streamHandler: i
      }) {
        try {
          Lit(t, i)
        } catch (n) {
          return _b.error("invalid stop request via peer %s", e.remotePeer.toB58String(), n)
        }
        return _b("stop request is valid"), i.write({
          type: aR.Type.STATUS,
          code: aR.Status.SUCCESS
        }), i.rest()
      };
      oR.exports.stop = async function ({
        connection: e,
        request: t
      }) {
        let {
          stream: i
        } = await e.newStream([Bit.relay]);
        _b("starting stop request to %s", e.remotePeer.toB58String());
        let n = new Dit({
          stream: i
        });
        n.write(t);
        let s = await n.read();
        if (!s) return n.close();
        if (s.code === aR.Status.SUCCESS) return _b("stop request to %s was successful", e.remotePeer.toB58String()), n.rest();
        _b("stop request failed with code %d", s.code), n.close()
      }
    });
    var uR = y((Axt, pde) => {
      l();
      "use strict";
      var yde = Oe(),
        yu = Object.assign(yde("libp2p:circuit:hop"), {
          error: yde("libp2p:circuit:hop:err")
        }),
        gde = xe(),
        Fit = Et(),
        {
          validateAddrs: Uit
        } = iR(),
        bde = J_(),
        {
          CircuitRelay: zs
        } = yp(),
        {
          pipe: Kit
        } = vi(),
        {
          codes: mde
        } = wi(),
        {
          stop: zit
        } = cR(),
        vde = vb();
      async function jit({
        connection: r,
        request: e,
        streamHandler: t,
        circuit: i
      }) {
        if (!i._options.hop.enabled) return yu("HOP request received but we are not acting as a relay"), t.end({
          type: zs.Type.STATUS,
          code: zs.Status.HOP_CANT_SPEAK_RELAY
        });
        try {
          Uit(e, t)
        } catch (u) {
          return yu.error("invalid hop request via peer %s", r.remotePeer.toB58String(), u)
        }
        if (!e.dstPeer) {
          yu("HOP request received but we do not receive a dstPeer");
          return
        }
        let n = new Fit(e.dstPeer.id),
          s = i._connectionManager.get(n);
        if (!s && !i._options.hop.active) return yu("HOP request received but we are not connected to the destination peer"), t.end({
          type: zs.Type.STATUS,
          code: zs.Status.HOP_NO_CONN_TO_DST
        });
        if (!s) return;
        let o = {
          type: zs.Type.STOP,
          dstPeer: e.dstPeer,
          srcPeer: e.srcPeer
        },
          a;
        try {
          a = await zit({
            connection: s,
            request: o
          })
        } catch (u) {
          return yu.error(u)
        }
        yu("hop request from %s is valid", r.remotePeer.toB58String()), t.write({
          type: zs.Type.STATUS,
          code: zs.Status.SUCCESS
        });
        let c = t.rest();
        return Kit(c, a, c)
      }
      async function Vit({
        connection: r,
        request: e
      }) {
        let {
          stream: t
        } = await r.newStream([vde.relay]), i = new bde({
          stream: t
        });
        i.write(e);
        let n = await i.read();
        if (!n) throw gde(new Error("HOP request had no response"), mde.ERR_HOP_REQUEST_FAILED);
        if (n.code === zs.Status.SUCCESS) return yu("hop request was successful"), i.rest();
        throw yu("hop request failed with code %d, closing stream", n.code), i.close(), gde(new Error(`HOP request failed with code ${n.code}`), mde.ERR_HOP_REQUEST_FAILED)
      }
      async function Hit({
        connection: r
      }) {
        let {
          stream: e
        } = await r.newStream([vde.relay]), t = new bde({
          stream: e
        });
        t.write({
          type: zs.Type.CAN_HOP
        });
        let i = await t.read();
        return await t.close(), !(!i || i.code !== zs.Status.SUCCESS)
      }

      function Git({
        connection: r,
        streamHandler: e,
        circuit: t
      }) {
        let i = t._options.hop.enabled;
        yu("can hop (%s) request from %s", i, r.remotePeer.toB58String()), e.end({
          type: zs.Type.STATUS,
          code: i ? zs.Status.SUCCESS : zs.Status.HOP_CANT_SPEAK_RELAY
        })
      }
      pde.exports = {
        handleHop: jit,
        hop: Vit,
        canHop: Hit,
        handleCanHop: Git
      }
    });
    var Ade = y((Ixt, wde) => {
      l();
      "use strict";
      var _de = Oe(),
        gu = Object.assign(_de("libp2p:circuit"), {
          error: _de("libp2p:circuit:err")
        }),
        $it = xe(),
        Wit = El(),
        {
          Multiaddr: Eb
        } = pr(),
        Ede = Et(),
        {
          CircuitRelay: Sb
        } = yp(),
        {
          codes: Yit
        } = wi(),
        Sde = Zhe(),
        {
          relay: Jit
        } = vb(),
        Xit = tde(),
        {
          handleCanHop: Zit,
          handleHop: Qit,
          hop: ent
        } = uR(),
        {
          handleStop: tnt
        } = cR(),
        rnt = J_(),
        int = Symbol.for("@libp2p/js-libp2p-circuit/circuit"),
        xde = class {
          constructor({
            libp2p: e,
            upgrader: t
          }) {
            this._dialer = e.dialer, this._registrar = e.registrar, this._connectionManager = e.connectionManager, this._upgrader = t, this._options = e._config.relay, this._libp2p = e, this.peerId = e.peerId, this._registrar.handle(Jit, this._onProtocol.bind(this))
          }
          async _onProtocol({
            connection: e,
            stream: t
          }) {
            let i = new rnt({
              stream: t
            }),
              n = await i.read();
            if (!n) return;
            let s = this,
              o;
            switch (n.type) {
              case Sb.Type.CAN_HOP: {
                gu("received CAN_HOP request from %s", e.remotePeer.toB58String()), await Zit({
                  circuit: s,
                  connection: e,
                  streamHandler: i
                });
                break
              }
              case Sb.Type.HOP: {
                gu("received HOP request from %s", e.remotePeer.toB58String()), o = await Qit({
                  connection: e,
                  request: n,
                  streamHandler: i,
                  circuit: s
                });
                break
              }
              case Sb.Type.STOP: {
                gu("received STOP request from %s", e.remotePeer.toB58String()), o = await tnt({
                  connection: e,
                  request: n,
                  streamHandler: i
                });
                break
              }
              default:
                gu("Request of type %s not supported", n.type)
            }
            if (o) {
              let a = new Eb(n.dstPeer.addrs[0]),
                c = new Eb(n.srcPeer.addrs[0]),
                u = Sde({
                  stream: o,
                  remoteAddr: a,
                  localAddr: c
                }),
                f = n.type === Sb.Type.HOP ? "relay" : "inbound";
              gu("new %s connection %s", f, u.remoteAddr);
              let h = await this._upgrader.upgradeInbound(u);
              gu("%s connection %s upgraded", f, u.remoteAddr), this.handler && this.handler(h)
            }
          }
          async dial(e, t) {
            let i = e.toString().split("/p2p-circuit"),
              n = new Eb(i[0]),
              s = new Eb(i[i.length - 1]),
              o = n.getPeerId(),
              a = s.getPeerId();
            if (!o || !a) {
              let d = "Circuit relay dial failed as addresses did not have peer id";
              throw gu.error(d), $it(new Error(d), Yit.ERR_RELAYED_DIAL)
            }
            let c = Ede.createFromCID(o),
              u = Ede.createFromCID(a),
              f = !1,
              h = this._connectionManager.get(c);
            h || (h = await this._dialer.connectToPeer(n, t), f = !0);
            try {
              let d = await ent({
                connection: h,
                request: {
                  type: Sb.Type.HOP,
                  srcPeer: {
                    id: this.peerId.toBytes(),
                    addrs: this._libp2p.multiaddrs.map(m => m.bytes)
                  },
                  dstPeer: {
                    id: u.toBytes(),
                    addrs: [new Eb(s).bytes]
                  }
                }
              }),
                p = n.encapsulate(`/p2p-circuit/p2p/${this.peerId.toB58String()}`),
                g = Sde({
                  stream: d,
                  remoteAddr: e,
                  localAddr: p
                });
              return gu("new outbound connection %s", g.remoteAddr), this._upgrader.upgradeOutbound(g)
            } catch (d) {
              throw gu.error("Circuit relay dial failed", d), f && await h.close(), d
            }
          }
          createListener(e, t) {
            return typeof e == "function" && (t = e, e = {}), this.handler = t, Xit(this._libp2p)
          }
          filter(e) {
            return e = Array.isArray(e) ? e : [e], e.filter(t => Wit.Circuit.matches(t))
          }
          get [Symbol.toStringTag]() {
            return "Circuit"
          }
          static isTransport(e) {
            return Boolean(e && e[int])
          }
        };
      wde.exports = xde
    });
    var Tde = y((Txt, Ide) => {
      l();
      "use strict";
      Ide.exports = TextEncoder
    });
    var fR = y((Rxt, Rde) => {
      l();
      "use strict";
      var nnt = at(),
        snt = cr(),
        ont = Tde();
      Rde.exports.namespaceToCid = async r => {
        let e = new ont().encode(r),
          t = await snt(e, "sha2-256");
        return new nnt(t)
      }
    });
    var Mde = y((kxt, kde) => {
      l();
      "use strict";
      var Pde = Oe(),
        Cde = Object.assign(Pde("libp2p:auto-relay"), {
          error: Pde("libp2p:auto-relay:err")
        }),
        ant = gt(),
        cnt = ct(),
        {
          Multiaddr: unt
        } = pr(),
        fnt = Et(),
        {
          relay: lnt
        } = vb(),
        {
          canHop: hnt
        } = uR(),
        {
          namespaceToCid: dnt
        } = fR(),
        {
          CIRCUIT_PROTO_CODE: pnt,
          HOP_METADATA_KEY: Ode,
          HOP_METADATA_VALUE: Nde,
          RELAY_RENDEZVOUS_NS: ynt
        } = z_(),
        qde = class {
          constructor({
            libp2p: e,
            maxListeners: t = 1,
            onError: i
          }) {
            this._libp2p = e, this._peerId = e.peerId, this._peerStore = e.peerStore, this._connectionManager = e.connectionManager, this._transportManager = e.transportManager, this._addressSorter = e.dialer.addressSorter, this.maxListeners = t, this._listenRelays = new Set, this._onProtocolChange = this._onProtocolChange.bind(this), this._onPeerDisconnected = this._onPeerDisconnected.bind(this), this._peerStore.on("change:protocols", this._onProtocolChange), this._connectionManager.on("peer:disconnect", this._onPeerDisconnected), this._onError = (n, s) => {
              Cde.error(s || n), i && i(n, s)
            }
          }
          async _onProtocolChange({
            peerId: e,
            protocols: t
          }) {
            let i = e.toB58String(),
              n = t.find(s => s === lnt);
            if (!n && this._listenRelays.has(i)) {
              this._removeListenRelay(i);
              return
            } else if (!n || this._listenRelays.has(i)) return;
            try {
              let s = this._connectionManager.get(e);
              if (!s) return;
              if (s.remoteAddr.protoCodes().includes(pnt)) {
                Cde(`relayed connection to ${i} will not be used to hop on`);
                return
              }
              await hnt({
                connection: s
              }) && (this._peerStore.metadataBook.set(e, Ode, ant(Nde)), await this._addListenRelay(s, i))
            } catch (s) {
              this._onError(s)
            }
          }
          _onPeerDisconnected(e) {
            let i = e.remotePeer.toB58String();
            !this._listenRelays.has(i) || this._removeListenRelay(i)
          }
          async _addListenRelay(e, t) {
            if (this._listenRelays.size >= this.maxListeners) return;
            let i = this._peerStore.addressBook.getMultiaddrsForPeer(e.remotePeer, this._addressSorter);
            if (!i || !i.length) return;
            let n = `${i[0].toString()}/p2p-circuit`;
            this._listenRelays.add(t);
            try {
              await this._transportManager.listen([new unt(n)])
            } catch (s) {
              this._onError(s), this._listenRelays.delete(t)
            }
          }
          _removeListenRelay(e) {
            this._listenRelays.delete(e) && this._listenOnAvailableHopRelays([e])
          }
          async _listenOnAvailableHopRelays(e = []) {
            if (this._listenRelays.size >= this.maxListeners) return;
            let t = [];
            for (let [i, n] of this._peerStore.metadataBook.data.entries()) {
              if (this._listenRelays.has(i) || e.includes(i)) continue;
              let s = n.get(Ode);
              if (!s || cnt(s) !== Nde) continue;
              let o = fnt.createFromCID(i),
                a = this._connectionManager.get(o);
              if (!a) {
                t.push(o);
                continue
              }
              if (await this._addListenRelay(a, i), this._listenRelays.size >= this.maxListeners) return
            }
            for (let i of t)
              if (await this._tryToListenOnRelay(i), this._listenRelays.size >= this.maxListeners) return;
            try {
              let i = await dnt(ynt);
              for await (let n of this._libp2p.contentRouting.findProviders(i)) {
                if (!n.multiaddrs.length) continue;
                let s = n.id;
                if (this._peerStore.addressBook.add(s, n.multiaddrs), await this._tryToListenOnRelay(s), this._listenRelays.size >= this.maxListeners) return
              }
            } catch (i) {
              this._onError(i)
            }
          }
          async _tryToListenOnRelay(e) {
            try {
              let t = await this._libp2p.dial(e);
              await this._addListenRelay(t, e.toB58String())
            } catch (t) {
              this._onError(t, `could not connect and listen on known hop relay ${e.toB58String()}`)
            }
          }
        };
      kde.exports = qde
    });
    var Ude = y((Pxt, Bde) => {
      l();
      "use strict";
      var Dde = Oe(),
        Lde = Object.assign(Dde("libp2p:relay"), {
          error: Dde("libp2p:relay:err")
        }),
        {
          setDelayedInterval: gnt,
          clearDelayedInterval: bnt
        } = F7(),
        mnt = Mde(),
        {
          namespaceToCid: vnt
        } = fR(),
        {
          RELAY_RENDEZVOUS_NS: wnt
        } = z_(),
        Fde = class {
          constructor(e) {
            this._libp2p = e, this._options = {
              ...e._config.relay
            }, this._autoRelay = this._options.autoRelay.enabled && new mnt({
              libp2p: e,
              ...this._options.autoRelay
            }), this._advertiseService = this._advertiseService.bind(this)
          }
          start() {
            this._options.hop.enabled && this._options.advertise.enabled && (this._timeout = gnt(this._advertiseService, this._options.advertise.ttl, this._options.advertise.bootDelay))
          }
          stop() {
            bnt(this._timeout)
          }
          async _advertiseService() {
            try {
              let e = await vnt(wnt);
              await this._libp2p.contentRouting.provide(e)
            } catch (e) {
              e.code === "NO_ROUTERS_AVAILABLE" ? (Lde.error("a content router, such as a DHT, must be provided in order to advertise the relay service", e), this.stop()) : Lde.error(e)
            }
          }
        };
      Bde.exports = Fde
    });
    var Vde = y((Oxt, Kde) => {
      l();
      var zde = ax(),
        jde = wb();
      Kde.exports = class {
        constructor() {
          this._buffer = new zde, this._waitingConsumers = new zde
        }
        push(e) {
          let {
            promise: t,
            resolve: i
          } = jde();
          return this._buffer.push({
            chunk: e,
            resolve: i
          }), this._consume(), t
        }
        _consume() {
          for (; !this._waitingConsumers.isEmpty() && !this._buffer.isEmpty();) {
            let e = this._waitingConsumers.shift(),
              t = this._buffer.shift();
            e.resolve(t.chunk), t.resolve()
          }
        }
        shift() {
          let {
            promise: e,
            resolve: t
          } = jde();
          return this._waitingConsumers.push({
            resolve: t
          }), this._consume(), e
        }
        isEmpty() {
          return this._buffer.isEmpty()
        }
      }
    });
    var Gde = y((Nxt, Hde) => {
      l();
      "use strict";
      Hde.exports = (r, e = 1, t) => {
        if (t = {
          indent: " ",
          includeEmptyLines: !1,
          ...t
        }, typeof r != "string") throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof r}\``);
        if (typeof e != "number") throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof e}\``);
        if (typeof t.indent != "string") throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t.indent}\``);
        if (e === 0) return r;
        let i = t.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return r.replace(i, t.indent.repeat(e))
      }
    });
    var $de = y(() => {
      l()
    });
    var Xde = y((Bxt, Wde) => {
      l();
      "use strict";
      var Yde = $de(),
        Jde = /\s+at.*(?:\(|\s)(.*)\)?/,
        _nt = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/,
        Ent = typeof Yde.homedir == "undefined" ? "" : Yde.homedir();
      Wde.exports = (r, e) => (e = Object.assign({
        pretty: !1
      }, e), r.replace(/\\/g, "/").split(`
`).filter(t => {
        let i = t.match(Jde);
        if (i === null || !i[1]) return !0;
        let n = i[1];
        return n.includes(".app/Contents/Resources/electron.asar") || n.includes(".app/Contents/Resources/default_app.asar") ? !1 : !_nt.test(n)
      }).filter(t => t.trim() !== "").map(t => e.pretty ? t.replace(Jde, (i, n) => i.replace(n, n.replace(Ent, "~"))) : t).join(`
`))
    });
    var lR = y((Dxt, Zde) => {
      l();
      "use strict";
      var Snt = Gde(),
        xnt = Xde(),
        Ant = r => r.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, ""),
        Qde = class extends Error {
          constructor(e) {
            if (!Array.isArray(e)) throw new TypeError(`Expected input to be an Array, got ${typeof e}`);
            e = [...e].map(i => i instanceof Error ? i : i !== null && typeof i == "object" ? Object.assign(new Error(i.message), i) : new Error(i));
            let t = e.map(i => typeof i.stack == "string" ? Ant(xnt(i.stack)) : String(i)).join(`
`);
            t = `
` + Snt(t, 4), super(t), this.name = "AggregateError", Object.defineProperty(this, "_errors", {
              value: e
            })
          } *[Symbol.iterator]() {
            for (let e of this._errors) yield e
          }
        };
      Zde.exports = Qde
    });
    var e0e = y((Lxt, hR) => {
      l();
      "use strict";
      var dR = class extends Error {
        constructor(e) {
          super(e || "Promise was canceled");
          this.name = "CancelError"
        }
        get isCanceled() {
          return !0
        }
      },
        xb = class {
          static fn(e) {
            return (...t) => new xb((i, n, s) => {
              t.push(s), e(...t).then(i, n)
            })
          }
          constructor(e) {
            this._cancelHandlers = [], this._isPending = !0, this._isCanceled = !1, this._rejectOnCancel = !0, this._promise = new Promise((t, i) => {
              this._reject = i;
              let n = a => {
                (!this._isCanceled || !o.shouldReject) && (this._isPending = !1, t(a))
              },
                s = a => {
                  this._isPending = !1, i(a)
                },
                o = a => {
                  if (!this._isPending) throw new Error("The `onCancel` handler was attached after the promise settled.");
                  this._cancelHandlers.push(a)
                };
              return Object.defineProperties(o, {
                shouldReject: {
                  get: () => this._rejectOnCancel,
                  set: a => {
                    this._rejectOnCancel = a
                  }
                }
              }), e(n, s, o)
            })
          }
          then(e, t) {
            return this._promise.then(e, t)
          } catch(e) {
            return this._promise.catch(e)
          } finally(e) {
            return this._promise.finally(e)
          }
          cancel(e) {
            if (!(!this._isPending || this._isCanceled)) {
              if (this._isCanceled = !0, this._cancelHandlers.length > 0) try {
                for (let t of this._cancelHandlers) t()
              } catch (t) {
                this._reject(t);
                return
              }
              this._rejectOnCancel && this._reject(new dR(e))
            }
          }
          get isCanceled() {
            return this._isCanceled
          }
        };
      Object.setPrototypeOf(xb.prototype, Promise.prototype);
      hR.exports = xb;
      hR.exports.CancelError = dR
    });
    var r0e = y((Fxt, X_) => {
      l();
      "use strict";
      var t0e = lR(),
        Int = e0e(),
        pR = class extends Error { },
        Tnt = (r, e) => new Int((t, i, n) => {
          let {
            count: s,
            filter: o = () => !0
          } = e;
          if (!Number.isFinite(s)) {
            i(new TypeError(`Expected a finite number, got ${typeof e.count}`));
            return
          }
          let a = [],
            c = [],
            u = 0,
            f = !1,
            h = new Set,
            d = () => (a.length === s && (t(a), f = !0), u - c.length < s && (i(new t0e(c)), f = !0), f),
            p = () => {
              for (let g of r) !h.has(g) && typeof g.cancel == "function" && g.cancel()
            };
          n(p);
          for (let g of r) u++, (async () => {
            try {
              let m = await g;
              if (f) return;
              if (!o(m)) throw new pR("Value does not satisfy filter");
              a.push(m)
            } catch (m) {
              c.push(m)
            } finally {
              h.add(g), !f && d() && p()
            }
          })();
          s > u && (i(new RangeError(`Expected input to contain at least ${e.count} items, but contains ${u} items`)), p())
        });
      X_.exports = Tnt;
      X_.exports.AggregateError = t0e;
      X_.exports.FilterError = pR
    });
    var i0e = y((Uxt, yR) => {
      l();
      "use strict";
      var gR = class extends Error {
        constructor(e) {
          super(e || "Promise was canceled");
          this.name = "CancelError"
        }
        get isCanceled() {
          return !0
        }
      },
        Ab = class {
          static fn(e) {
            return (...t) => new Ab((i, n, s) => {
              t.push(s), e(...t).then(i, n)
            })
          }
          constructor(e) {
            this._cancelHandlers = [], this._isPending = !0, this._isCanceled = !1, this._rejectOnCancel = !0, this._promise = new Promise((t, i) => {
              this._reject = i;
              let n = a => {
                (!this._isCanceled || !o.shouldReject) && (this._isPending = !1, t(a))
              },
                s = a => {
                  this._isPending = !1, i(a)
                },
                o = a => {
                  if (!this._isPending) throw new Error("The `onCancel` handler was attached after the promise settled.");
                  this._cancelHandlers.push(a)
                };
              return Object.defineProperties(o, {
                shouldReject: {
                  get: () => this._rejectOnCancel,
                  set: a => {
                    this._rejectOnCancel = a
                  }
                }
              }), e(n, s, o)
            })
          }
          then(e, t) {
            return this._promise.then(e, t)
          } catch(e) {
            return this._promise.catch(e)
          } finally(e) {
            return this._promise.finally(e)
          }
          cancel(e) {
            if (!(!this._isPending || this._isCanceled)) {
              if (this._isCanceled = !0, this._cancelHandlers.length > 0) try {
                for (let t of this._cancelHandlers) t()
              } catch (t) {
                this._reject(t);
                return
              }
              this._rejectOnCancel && this._reject(new gR(e))
            }
          }
          get isCanceled() {
            return this._isCanceled
          }
        };
      Object.setPrototypeOf(Ab.prototype, Promise.prototype);
      yR.exports = Ab;
      yR.exports.CancelError = gR
    });
    var s0e = y((Kxt, bR) => {
      l();
      "use strict";
      var n0e = r0e(),
        Rnt = i0e();
      bR.exports = (r, e) => {
        let t = n0e(r, {
          ...e,
          count: 1
        });
        return Rnt.fn(async i => {
          i(() => {
            t.cancel()
          });
          let [n] = await t;
          return n
        })()
      };
      bR.exports.AggregateError = n0e.AggregateError
    });
    var c0e = y((zxt, o0e) => {
      l();
      "use strict";
      var knt = xe(),
        Pnt = Zf().default,
        {
          anySignal: Cnt
        } = ed(),
        Ont = Vde(),
        Nnt = s0e(),
        a0e = class {
          constructor({
            addrs: e,
            dialAction: t,
            dialer: i
          }) {
            this.addrs = e, this.dialer = i, this.dialAction = t
          }
          async run(e = {}) {
            let t = this.dialer.getTokens(this.addrs.length);
            if (t.length < 1) throw knt(new Error("No dial tokens available"), "ERR_NO_DIAL_TOKENS");
            let i = new Ont;
            t.forEach(o => i.push(o));
            let n = this.addrs.map(() => new Pnt),
              s = 0;
            try {
              return await Nnt(this.addrs.map(async (o, a) => {
                let c = await i.shift(),
                  u;
                try {
                  let f = n[a].signal;
                  u = await this.dialAction(o, {
                    ...e,
                    signal: e.signal ? Cnt([f, e.signal]) : f
                  }), n.splice(a, 1)
                } finally {
                  s++, this.addrs.length - s >= t.length ? i.push(c) : this.dialer.releaseToken(t.splice(t.indexOf(c), 1)[0])
                }
                return u
              }))
            } finally {
              n.map(o => o.abort()), t.forEach(o => this.dialer.releaseToken(o))
            }
          }
        };
      o0e.exports = a0e
    });
    var d0e = y((jxt, u0e) => {
      l();
      "use strict";
      var f0e = Oe(),
        bp = Object.assign(f0e("libp2p:dialer"), {
          error: f0e("libp2p:dialer:err")
        }),
        l0e = xe(),
        {
          Multiaddr: mR
        } = pr(),
        qnt = R5(),
        {
          anySignal: Mnt
        } = ed(),
        Bnt = c0e(),
        {
          publicAddressesFirst: Dnt
        } = G7(),
        Lnt = z7(),
        {
          codes: vR
        } = wi(),
        {
          DIAL_TIMEOUT: Fnt,
          MAX_PARALLEL_DIALS: Unt,
          MAX_PER_PEER_DIALS: Knt
        } = K_(),
        h0e = class {
          constructor({
            transportManager: e,
            peerStore: t,
            addressSorter: i = Dnt,
            maxParallelDials: n = Unt,
            dialTimeout: s = Fnt,
            maxDialsPerPeer: o = Knt,
            resolvers: a = {}
          }) {
            this.transportManager = e, this.peerStore = t, this.addressSorter = i, this.maxParallelDials = n, this.timeout = s, this.maxDialsPerPeer = o, this.tokens = [...new Array(n)].map((c, u) => u), this._pendingDials = new Map;
            for (let [c, u] of Object.entries(a)) mR.resolvers.set(c, u)
          }
          destroy() {
            for (let e of this._pendingDials.values()) try {
              e.controller.abort()
            } catch (t) {
              bp.error(t)
            }
            this._pendingDials.clear()
          }
          async connectToPeer(e, t = {}) {
            let i = await this._createDialTarget(e);
            if (!i.addrs.length) throw l0e(new Error("The dial request has no valid addresses"), vR.ERR_NO_VALID_ADDRESSES);
            let n = this._pendingDials.get(i.id) || this._createPendingDial(i, t);
            try {
              let s = await n.promise;
              return bp("dial succeeded to %s", i.id), s
            } catch (s) {
              throw n.controller.signal.aborted && (s.code = vR.ERR_TIMEOUT), bp.error(s), s
            } finally {
              n.destroy()
            }
          }
          async _createDialTarget(e) {
            let {
              id: t,
              multiaddrs: i
            } = Lnt(e);
            i && this.peerStore.addressBook.add(t, i);
            let n = this.peerStore.addressBook.getMultiaddrsForPeer(t, this.addressSorter) || [];
            mR.isMultiaddr(e) && (n = n.filter(a => !e.equals(a)), n.unshift(e));
            let s = [];
            for (let a of n) (await this._resolve(a)).forEach(u => s.push(u));
            let o = s.filter(a => this.transportManager.transportForMultiaddr(a));
            return {
              id: t.toB58String(),
              addrs: o
            }
          }
          _createPendingDial(e, t = {}) {
            let i = (u, f) => {
              if (f.signal.aborted) throw l0e(new Error("already aborted"), vR.ERR_ALREADY_ABORTED);
              return this.transportManager.dial(u, f)
            },
              n = new Bnt({
                addrs: e.addrs,
                dialAction: i,
                dialer: this
              }),
              s = new qnt(this.timeout),
              o = [s.signal];
            t.signal && o.push(t.signal);
            let a = Mnt(o),
              c = {
                dialRequest: n,
                controller: s,
                promise: n.run({
                  ...t,
                  signal: a
                }),
                destroy: () => {
                  s.clear(), this._pendingDials.delete(e.id)
                }
              };
            return this._pendingDials.set(e.id, c), c
          }
          getTokens(e) {
            let t = Math.min(e, this.maxDialsPerPeer, this.tokens.length),
              i = this.tokens.splice(0, t);
            return bp("%d tokens request, returning %d, %d remaining", e, t, this.tokens.length), i
          }
          releaseToken(e) {
            this.tokens.indexOf(e) > -1 || (bp("token %d released", e), this.tokens.push(e))
          }
          async _resolve(e) {
            if (!e.protoNames().includes("dnsaddr")) return [e];
            let i = await this._resolveRecord(e);
            return (await Promise.all(i.map(o => this._resolve(o)))).flat().reduce((o, a) => (o.find(c => c.equals(a)) || o.push(a), o), [])
          }
          async _resolveRecord(e) {
            try {
              return e = new mR(e.toString()), await e.resolve()
            } catch (t) {
              return bp.error(`multiaddr ${e} could not be resolved`), []
            }
          }
        };
      u0e.exports = h0e
    });
    var y0e = y((Vxt, p0e) => {
      l();
      "use strict";

      function znt(r) {
        return r >= 55296 && r <= 56319
      }

      function jnt(r) {
        return r >= 56320 && r <= 57343
      }
      p0e.exports = function (e, t, i) {
        if (typeof t != "string") throw new Error("Input must be string");
        for (var n = t.length, s = 0, o, a, c = 0; c < n; c += 1) {
          if (o = t.charCodeAt(c), a = t[c], znt(o) && jnt(t.charCodeAt(c + 1)) && (c += 1, a += t[c]), s += e(a), s === i) return t.slice(0, c + 1);
          if (s > i) return t.slice(0, c - a.length + 1)
        }
        return t
      }
    });
    var b0e = y((Hxt, g0e) => {
      l();
      "use strict";

      function Vnt(r) {
        return r >= 55296 && r <= 56319
      }

      function Hnt(r) {
        return r >= 56320 && r <= 57343
      }
      g0e.exports = function (e) {
        if (typeof e != "string") throw new Error("Input must be string");
        for (var t = e.length, i = 0, n = null, s = null, o = 0; o < t; o++) n = e.charCodeAt(o), Hnt(n) ? s != null && Vnt(s) ? i += 1 : i += 3 : n <= 127 ? i += 1 : n >= 128 && n <= 2047 ? i += 2 : n >= 2048 && n <= 65535 && (i += 3), s = n;
        return i
      }
    });
    var v0e = y((Gxt, m0e) => {
      l();
      "use strict";
      var Gnt = y0e(),
        $nt = b0e();
      m0e.exports = Gnt.bind(null, $nt)
    });
    var E0e = y(($xt, w0e) => {
      l();
      "use strict";
      var Wnt = v0e(),
        Ynt = /[\/\?<>\\:\*\|"]/g,
        Jnt = /[\x00-\x1f\x80-\x9f]/g,
        Xnt = /^\.+$/,
        Znt = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i,
        Qnt = /[\. ]+$/;

      function _0e(r, e) {
        if (typeof r != "string") throw new Error("Input must be string");
        var t = r.replace(Ynt, e).replace(Jnt, e).replace(Xnt, e).replace(Znt, e).replace(Qnt, e);
        return Wnt(t, 255)
      }
      w0e.exports = function (r, e) {
        var t = e && e.replacement || "",
          i = _0e(r, t);
        return t === "" ? i : _0e(i, "")
      }
    });
    var I0e = y((Wxt, S0e) => {
      l();
      var mp = At();
      Bc();
      wr();
      var Xe = mp.asn1,
        vp = S0e.exports = mp.pkcs7asn1 = mp.pkcs7asn1 || {};
      mp.pkcs7 = mp.pkcs7 || {};
      mp.pkcs7.asn1 = vp;
      var x0e = {
        name: "ContentInfo",
        tagClass: Xe.Class.UNIVERSAL,
        type: Xe.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "ContentInfo.ContentType",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.OID,
          constructed: !1,
          capture: "contentType"
        }, {
          name: "ContentInfo.content",
          tagClass: Xe.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: !0,
          optional: !0,
          captureAsn1: "content"
        }]
      };
      vp.contentInfoValidator = x0e;
      var A0e = {
        name: "EncryptedContentInfo",
        tagClass: Xe.Class.UNIVERSAL,
        type: Xe.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "EncryptedContentInfo.contentType",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.OID,
          constructed: !1,
          capture: "contentType"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
            tagClass: Xe.Class.UNIVERSAL,
            type: Xe.Type.OID,
            constructed: !1,
            capture: "encAlgorithm"
          }, {
            name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
            tagClass: Xe.Class.UNIVERSAL,
            captureAsn1: "encParameter"
          }]
        }, {
          name: "EncryptedContentInfo.encryptedContent",
          tagClass: Xe.Class.CONTEXT_SPECIFIC,
          type: 0,
          capture: "encryptedContent",
          captureAsn1: "encryptedContentAsn1"
        }]
      };
      vp.envelopedDataValidator = {
        name: "EnvelopedData",
        tagClass: Xe.Class.UNIVERSAL,
        type: Xe.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "EnvelopedData.Version",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.INTEGER,
          constructed: !1,
          capture: "version"
        }, {
          name: "EnvelopedData.RecipientInfos",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.SET,
          constructed: !0,
          captureAsn1: "recipientInfos"
        }].concat(A0e)
      };
      vp.encryptedDataValidator = {
        name: "EncryptedData",
        tagClass: Xe.Class.UNIVERSAL,
        type: Xe.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "EncryptedData.Version",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.INTEGER,
          constructed: !1,
          capture: "version"
        }].concat(A0e)
      };
      var est = {
        name: "SignerInfo",
        tagClass: Xe.Class.UNIVERSAL,
        type: Xe.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "SignerInfo.version",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.INTEGER,
          constructed: !1
        }, {
          name: "SignerInfo.issuerAndSerialNumber",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "SignerInfo.issuerAndSerialNumber.issuer",
            tagClass: Xe.Class.UNIVERSAL,
            type: Xe.Type.SEQUENCE,
            constructed: !0,
            captureAsn1: "issuer"
          }, {
            name: "SignerInfo.issuerAndSerialNumber.serialNumber",
            tagClass: Xe.Class.UNIVERSAL,
            type: Xe.Type.INTEGER,
            constructed: !1,
            capture: "serial"
          }]
        }, {
          name: "SignerInfo.digestAlgorithm",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "SignerInfo.digestAlgorithm.algorithm",
            tagClass: Xe.Class.UNIVERSAL,
            type: Xe.Type.OID,
            constructed: !1,
            capture: "digestAlgorithm"
          }, {
            name: "SignerInfo.digestAlgorithm.parameter",
            tagClass: Xe.Class.UNIVERSAL,
            constructed: !1,
            captureAsn1: "digestParameter",
            optional: !0
          }]
        }, {
          name: "SignerInfo.authenticatedAttributes",
          tagClass: Xe.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: !0,
          optional: !0,
          capture: "authenticatedAttributes"
        }, {
          name: "SignerInfo.digestEncryptionAlgorithm",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.SEQUENCE,
          constructed: !0,
          capture: "signatureAlgorithm"
        }, {
          name: "SignerInfo.encryptedDigest",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.OCTETSTRING,
          constructed: !1,
          capture: "signature"
        }, {
          name: "SignerInfo.unauthenticatedAttributes",
          tagClass: Xe.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: !0,
          optional: !0,
          capture: "unauthenticatedAttributes"
        }]
      };
      vp.signedDataValidator = {
        name: "SignedData",
        tagClass: Xe.Class.UNIVERSAL,
        type: Xe.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "SignedData.Version",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.INTEGER,
          constructed: !1,
          capture: "version"
        }, {
          name: "SignedData.DigestAlgorithms",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.SET,
          constructed: !0,
          captureAsn1: "digestAlgorithms"
        }, x0e, {
          name: "SignedData.Certificates",
          tagClass: Xe.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: !0,
          captureAsn1: "certificates"
        }, {
          name: "SignedData.CertificateRevocationLists",
          tagClass: Xe.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: !0,
          captureAsn1: "crls"
        }, {
          name: "SignedData.SignerInfos",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.SET,
          capture: "signerInfos",
          optional: !0,
          value: [est]
        }]
      };
      vp.recipientInfoValidator = {
        name: "RecipientInfo",
        tagClass: Xe.Class.UNIVERSAL,
        type: Xe.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "RecipientInfo.version",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.INTEGER,
          constructed: !1,
          capture: "version"
        }, {
          name: "RecipientInfo.issuerAndSerial",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "RecipientInfo.issuerAndSerial.issuer",
            tagClass: Xe.Class.UNIVERSAL,
            type: Xe.Type.SEQUENCE,
            constructed: !0,
            captureAsn1: "issuer"
          }, {
            name: "RecipientInfo.issuerAndSerial.serialNumber",
            tagClass: Xe.Class.UNIVERSAL,
            type: Xe.Type.INTEGER,
            constructed: !1,
            capture: "serial"
          }]
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
            tagClass: Xe.Class.UNIVERSAL,
            type: Xe.Type.OID,
            constructed: !1,
            capture: "encAlgorithm"
          }, {
            name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
            tagClass: Xe.Class.UNIVERSAL,
            constructed: !1,
            captureAsn1: "encParameter"
          }]
        }, {
          name: "RecipientInfo.encryptedKey",
          tagClass: Xe.Class.UNIVERSAL,
          type: Xe.Type.OCTETSTRING,
          constructed: !1,
          capture: "encKey"
        }]
      }
    });
    var R0e = y((Yxt, T0e) => {
      l();
      var mh = At();
      wr();
      mh.mgf = mh.mgf || {};
      var tst = T0e.exports = mh.mgf.mgf1 = mh.mgf1 = mh.mgf1 || {};
      tst.create = function (r) {
        var e = {
          generate: function (t, i) {
            for (var n = new mh.util.ByteBuffer, s = Math.ceil(i / r.digestLength), o = 0; o < s; o++) {
              var a = new mh.util.ByteBuffer;
              a.putInt32(o), r.start(), r.update(t + a.getBytes()), n.putBuffer(r.digest())
            }
            return n.truncate(n.length() - i), n.getBytes()
          }
        };
        return e
      }
    });
    var P0e = y((Jxt, k0e) => {
      l();
      var Z_ = At();
      R0e();
      k0e.exports = Z_.mgf = Z_.mgf || {};
      Z_.mgf.mgf1 = Z_.mgf1
    });
    var O0e = y((Xxt, C0e) => {
      l();
      var vh = At();
      Fu();
      wr();
      var rst = C0e.exports = vh.pss = vh.pss || {};
      rst.create = function (r) {
        arguments.length === 3 && (r = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        });
        var e = r.md,
          t = r.mgf,
          i = e.digestLength,
          n = r.salt || null;
        typeof n == "string" && (n = vh.util.createBuffer(n));
        var s;
        if ("saltLength" in r) s = r.saltLength;
        else if (n !== null) s = n.length();
        else throw new Error("Salt length not specified or specific salt not given.");
        if (n !== null && n.length() !== s) throw new Error("Given salt length does not match length of given salt.");
        var o = r.prng || vh.random,
          a = {};
        return a.encode = function (c, u) {
          var f, h = u - 1,
            d = Math.ceil(h / 8),
            p = c.digest().getBytes();
          if (d < i + s + 2) throw new Error("Message is too long to encrypt.");
          var g;
          n === null ? g = o.getBytesSync(s) : g = n.bytes();
          var m = new vh.util.ByteBuffer;
          m.fillWithByte(0, 8), m.putBytes(p), m.putBytes(g), e.start(), e.update(m.getBytes());
          var E = e.digest().getBytes(),
            w = new vh.util.ByteBuffer;
          w.fillWithByte(0, d - s - i - 2), w.putByte(1), w.putBytes(g);
          var O = w.getBytes(),
            q = d - i - 1,
            J = t.generate(E, q),
            Z = "";
          for (f = 0; f < q; f++) Z += String.fromCharCode(O.charCodeAt(f) ^ J.charCodeAt(f));
          var H = 65280 >> 8 * d - h & 255;
          return Z = String.fromCharCode(Z.charCodeAt(0) & ~H) + Z.substr(1), Z + E + String.fromCharCode(188)
        }, a.verify = function (c, u, f) {
          var h, d = f - 1,
            p = Math.ceil(d / 8);
          if (u = u.substr(-p), p < i + s + 2) throw new Error("Inconsistent parameters to PSS signature verification.");
          if (u.charCodeAt(p - 1) !== 188) throw new Error("Encoded message does not end in 0xBC.");
          var g = p - i - 1,
            m = u.substr(0, g),
            E = u.substr(g, i),
            w = 65280 >> 8 * p - d & 255;
          if ((m.charCodeAt(0) & w) != 0) throw new Error("Bits beyond keysize not zero as expected.");
          var O = t.generate(E, g),
            q = "";
          for (h = 0; h < g; h++) q += String.fromCharCode(m.charCodeAt(h) ^ O.charCodeAt(h));
          q = String.fromCharCode(q.charCodeAt(0) & ~w) + q.substr(1);
          var J = p - i - s - 2;
          for (h = 0; h < J; h++)
            if (q.charCodeAt(h) !== 0) throw new Error("Leftmost octets not zero as expected");
          if (q.charCodeAt(J) !== 1) throw new Error("Inconsistent PSS signature, 0x01 marker not found");
          var Z = q.substr(-s),
            H = new vh.util.ByteBuffer;
          H.fillWithByte(0, 8), H.putBytes(c), H.putBytes(Z), e.start(), e.update(H.getBytes());
          var te = e.digest().getBytes();
          return E === te
        }, a
      }
    });
    var _R = y((Zxt, N0e) => {
      l();
      var Ue = At();
      cd();
      Bc();
      i2();
      Lu();
      P0e();
      sd();
      a2();
      O0e();
      K1();
      wr();
      var M = Ue.asn1,
        Be = N0e.exports = Ue.pki = Ue.pki || {},
        bt = Be.oids,
        ni = {};
      ni.CN = bt.commonName;
      ni.commonName = "CN";
      ni.C = bt.countryName;
      ni.countryName = "C";
      ni.L = bt.localityName;
      ni.localityName = "L";
      ni.ST = bt.stateOrProvinceName;
      ni.stateOrProvinceName = "ST";
      ni.O = bt.organizationName;
      ni.organizationName = "O";
      ni.OU = bt.organizationalUnitName;
      ni.organizationalUnitName = "OU";
      ni.E = bt.emailAddress;
      ni.emailAddress = "E";
      var q0e = Ue.pki.rsa.publicKeyValidator,
        ist = {
          name: "Certificate",
          tagClass: M.Class.UNIVERSAL,
          type: M.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "Certificate.TBSCertificate",
            tagClass: M.Class.UNIVERSAL,
            type: M.Type.SEQUENCE,
            constructed: !0,
            captureAsn1: "tbsCertificate",
            value: [{
              name: "Certificate.TBSCertificate.version",
              tagClass: M.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: !0,
              optional: !0,
              value: [{
                name: "Certificate.TBSCertificate.version.integer",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.INTEGER,
                constructed: !1,
                capture: "certVersion"
              }]
            }, {
              name: "Certificate.TBSCertificate.serialNumber",
              tagClass: M.Class.UNIVERSAL,
              type: M.Type.INTEGER,
              constructed: !1,
              capture: "certSerialNumber"
            }, {
              name: "Certificate.TBSCertificate.signature",
              tagClass: M.Class.UNIVERSAL,
              type: M.Type.SEQUENCE,
              constructed: !0,
              value: [{
                name: "Certificate.TBSCertificate.signature.algorithm",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.OID,
                constructed: !1,
                capture: "certinfoSignatureOid"
              }, {
                name: "Certificate.TBSCertificate.signature.parameters",
                tagClass: M.Class.UNIVERSAL,
                optional: !0,
                captureAsn1: "certinfoSignatureParams"
              }]
            }, {
              name: "Certificate.TBSCertificate.issuer",
              tagClass: M.Class.UNIVERSAL,
              type: M.Type.SEQUENCE,
              constructed: !0,
              captureAsn1: "certIssuer"
            }, {
              name: "Certificate.TBSCertificate.validity",
              tagClass: M.Class.UNIVERSAL,
              type: M.Type.SEQUENCE,
              constructed: !0,
              value: [{
                name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.UTCTIME,
                constructed: !1,
                optional: !0,
                capture: "certValidity1UTCTime"
              }, {
                name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.GENERALIZEDTIME,
                constructed: !1,
                optional: !0,
                capture: "certValidity2GeneralizedTime"
              }, {
                name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.UTCTIME,
                constructed: !1,
                optional: !0,
                capture: "certValidity3UTCTime"
              }, {
                name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.GENERALIZEDTIME,
                constructed: !1,
                optional: !0,
                capture: "certValidity4GeneralizedTime"
              }]
            }, {
              name: "Certificate.TBSCertificate.subject",
              tagClass: M.Class.UNIVERSAL,
              type: M.Type.SEQUENCE,
              constructed: !0,
              captureAsn1: "certSubject"
            }, q0e, {
              name: "Certificate.TBSCertificate.issuerUniqueID",
              tagClass: M.Class.CONTEXT_SPECIFIC,
              type: 1,
              constructed: !0,
              optional: !0,
              value: [{
                name: "Certificate.TBSCertificate.issuerUniqueID.id",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.BITSTRING,
                constructed: !1,
                captureBitStringValue: "certIssuerUniqueId"
              }]
            }, {
              name: "Certificate.TBSCertificate.subjectUniqueID",
              tagClass: M.Class.CONTEXT_SPECIFIC,
              type: 2,
              constructed: !0,
              optional: !0,
              value: [{
                name: "Certificate.TBSCertificate.subjectUniqueID.id",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.BITSTRING,
                constructed: !1,
                captureBitStringValue: "certSubjectUniqueId"
              }]
            }, {
              name: "Certificate.TBSCertificate.extensions",
              tagClass: M.Class.CONTEXT_SPECIFIC,
              type: 3,
              constructed: !0,
              captureAsn1: "certExtensions",
              optional: !0
            }]
          }, {
            name: "Certificate.signatureAlgorithm",
            tagClass: M.Class.UNIVERSAL,
            type: M.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "Certificate.signatureAlgorithm.algorithm",
              tagClass: M.Class.UNIVERSAL,
              type: M.Type.OID,
              constructed: !1,
              capture: "certSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: M.Class.UNIVERSAL,
              optional: !0,
              captureAsn1: "certSignatureParams"
            }]
          }, {
            name: "Certificate.signatureValue",
            tagClass: M.Class.UNIVERSAL,
            type: M.Type.BITSTRING,
            constructed: !1,
            captureBitStringValue: "certSignature"
          }]
        },
        nst = {
          name: "rsapss",
          tagClass: M.Class.UNIVERSAL,
          type: M.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "rsapss.hashAlgorithm",
            tagClass: M.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: !0,
            value: [{
              name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
              tagClass: M.Class.UNIVERSAL,
              type: M.Class.SEQUENCE,
              constructed: !0,
              optional: !0,
              value: [{
                name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.OID,
                constructed: !1,
                capture: "hashOid"
              }]
            }]
          }, {
            name: "rsapss.maskGenAlgorithm",
            tagClass: M.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: !0,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
              tagClass: M.Class.UNIVERSAL,
              type: M.Class.SEQUENCE,
              constructed: !0,
              optional: !0,
              value: [{
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.OID,
                constructed: !1,
                capture: "maskGenOid"
              }, {
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.SEQUENCE,
                constructed: !0,
                value: [{
                  name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                  tagClass: M.Class.UNIVERSAL,
                  type: M.Type.OID,
                  constructed: !1,
                  capture: "maskGenHashOid"
                }]
              }]
            }]
          }, {
            name: "rsapss.saltLength",
            tagClass: M.Class.CONTEXT_SPECIFIC,
            type: 2,
            optional: !0,
            value: [{
              name: "rsapss.saltLength.saltLength",
              tagClass: M.Class.UNIVERSAL,
              type: M.Class.INTEGER,
              constructed: !1,
              capture: "saltLength"
            }]
          }, {
            name: "rsapss.trailerField",
            tagClass: M.Class.CONTEXT_SPECIFIC,
            type: 3,
            optional: !0,
            value: [{
              name: "rsapss.trailer.trailer",
              tagClass: M.Class.UNIVERSAL,
              type: M.Class.INTEGER,
              constructed: !1,
              capture: "trailer"
            }]
          }]
        },
        sst = {
          name: "CertificationRequestInfo",
          tagClass: M.Class.UNIVERSAL,
          type: M.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "certificationRequestInfo",
          value: [{
            name: "CertificationRequestInfo.integer",
            tagClass: M.Class.UNIVERSAL,
            type: M.Type.INTEGER,
            constructed: !1,
            capture: "certificationRequestInfoVersion"
          }, {
            name: "CertificationRequestInfo.subject",
            tagClass: M.Class.UNIVERSAL,
            type: M.Type.SEQUENCE,
            constructed: !0,
            captureAsn1: "certificationRequestInfoSubject"
          }, q0e, {
            name: "CertificationRequestInfo.attributes",
            tagClass: M.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: !0,
            optional: !0,
            capture: "certificationRequestInfoAttributes",
            value: [{
              name: "CertificationRequestInfo.attributes",
              tagClass: M.Class.UNIVERSAL,
              type: M.Type.SEQUENCE,
              constructed: !0,
              value: [{
                name: "CertificationRequestInfo.attributes.type",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.OID,
                constructed: !1
              }, {
                name: "CertificationRequestInfo.attributes.value",
                tagClass: M.Class.UNIVERSAL,
                type: M.Type.SET,
                constructed: !0
              }]
            }]
          }]
        },
        ost = {
          name: "CertificationRequest",
          tagClass: M.Class.UNIVERSAL,
          type: M.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "csr",
          value: [sst, {
            name: "CertificationRequest.signatureAlgorithm",
            tagClass: M.Class.UNIVERSAL,
            type: M.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "CertificationRequest.signatureAlgorithm.algorithm",
              tagClass: M.Class.UNIVERSAL,
              type: M.Type.OID,
              constructed: !1,
              capture: "csrSignatureOid"
            }, {
              name: "CertificationRequest.signatureAlgorithm.parameters",
              tagClass: M.Class.UNIVERSAL,
              optional: !0,
              captureAsn1: "csrSignatureParams"
            }]
          }, {
              name: "CertificationRequest.signature",
              tagClass: M.Class.UNIVERSAL,
              type: M.Type.BITSTRING,
              constructed: !1,
              captureBitStringValue: "csrSignature"
            }]
        };
      Be.RDNAttributesAsArray = function (r, e) {
        for (var t = [], i, n, s, o = 0; o < r.value.length; ++o) {
          i = r.value[o];
          for (var a = 0; a < i.value.length; ++a) s = {}, n = i.value[a], s.type = M.derToOid(n.value[0].value), s.value = n.value[1].value, s.valueTagClass = n.value[1].type, s.type in bt && (s.name = bt[s.type], s.name in ni && (s.shortName = ni[s.name])), e && (e.update(s.type), e.update(s.value)), t.push(s)
        }
        return t
      };
      Be.CRIAttributesAsArray = function (r) {
        for (var e = [], t = 0; t < r.length; ++t)
          for (var i = r[t], n = M.derToOid(i.value[0].value), s = i.value[1].value, o = 0; o < s.length; ++o) {
            var a = {};
            if (a.type = n, a.value = s[o].value, a.valueTagClass = s[o].type, a.type in bt && (a.name = bt[a.type], a.name in ni && (a.shortName = ni[a.name])), a.type === bt.extensionRequest) {
              a.extensions = [];
              for (var c = 0; c < a.value.length; ++c) a.extensions.push(Be.certificateExtensionFromAsn1(a.value[c]))
            }
            e.push(a)
          }
        return e
      };

      function Bf(r, e) {
        typeof e == "string" && (e = {
          shortName: e
        });
        for (var t = null, i, n = 0; t === null && n < r.attributes.length; ++n) i = r.attributes[n], (e.type && e.type === i.type || e.name && e.name === i.name || e.shortName && e.shortName === i.shortName) && (t = i);
        return t
      }
      var Q_ = function (r, e, t) {
        var i = {};
        if (r !== bt["RSASSA-PSS"]) return i;
        t && (i = {
          hash: {
            algorithmOid: bt.sha1
          },
          mgf: {
            algorithmOid: bt.mgf1,
            hash: {
              algorithmOid: bt.sha1
            }
          },
          saltLength: 20
        });
        var n = {},
          s = [];
        if (!M.validate(e, nst, n, s)) {
          var o = new Error("Cannot read RSASSA-PSS parameter block.");
          throw o.errors = s, o
        }
        return n.hashOid !== void 0 && (i.hash = i.hash || {}, i.hash.algorithmOid = M.derToOid(n.hashOid)), n.maskGenOid !== void 0 && (i.mgf = i.mgf || {}, i.mgf.algorithmOid = M.derToOid(n.maskGenOid), i.mgf.hash = i.mgf.hash || {}, i.mgf.hash.algorithmOid = M.derToOid(n.maskGenHashOid)), n.saltLength !== void 0 && (i.saltLength = n.saltLength.charCodeAt(0)), i
      };
      Be.certificateFromPem = function (r, e, t) {
        var i = Ue.pem.decode(r)[0];
        if (i.type !== "CERTIFICATE" && i.type !== "X509 CERTIFICATE" && i.type !== "TRUSTED CERTIFICATE") {
          var n = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
          throw n.headerType = i.type, n
        }
        if (i.procType && i.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
        var s = M.fromDer(i.body, t);
        return Be.certificateFromAsn1(s, e)
      };
      Be.certificateToPem = function (r, e) {
        var t = {
          type: "CERTIFICATE",
          body: M.toDer(Be.certificateToAsn1(r)).getBytes()
        };
        return Ue.pem.encode(t, {
          maxline: e
        })
      };
      Be.publicKeyFromPem = function (r) {
        var e = Ue.pem.decode(r)[0];
        if (e.type !== "PUBLIC KEY" && e.type !== "RSA PUBLIC KEY") {
          var t = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
          throw t.headerType = e.type, t
        }
        if (e.procType && e.procType.type === "ENCRYPTED") throw new Error("Could not convert public key from PEM; PEM is encrypted.");
        var i = M.fromDer(e.body);
        return Be.publicKeyFromAsn1(i)
      };
      Be.publicKeyToPem = function (r, e) {
        var t = {
          type: "PUBLIC KEY",
          body: M.toDer(Be.publicKeyToAsn1(r)).getBytes()
        };
        return Ue.pem.encode(t, {
          maxline: e
        })
      };
      Be.publicKeyToRSAPublicKeyPem = function (r, e) {
        var t = {
          type: "RSA PUBLIC KEY",
          body: M.toDer(Be.publicKeyToRSAPublicKey(r)).getBytes()
        };
        return Ue.pem.encode(t, {
          maxline: e
        })
      };
      Be.getPublicKeyFingerprint = function (r, e) {
        e = e || {};
        var t = e.md || Ue.md.sha1.create(),
          i = e.type || "RSAPublicKey",
          n;
        switch (i) {
          case "RSAPublicKey":
            n = M.toDer(Be.publicKeyToRSAPublicKey(r)).getBytes();
            break;
          case "SubjectPublicKeyInfo":
            n = M.toDer(Be.publicKeyToAsn1(r)).getBytes();
            break;
          default:
            throw new Error('Unknown fingerprint type "' + e.type + '".')
        }
        t.start(), t.update(n);
        var s = t.digest();
        if (e.encoding === "hex") {
          var o = s.toHex();
          return e.delimiter ? o.match(/.{2}/g).join(e.delimiter) : o
        } else {
          if (e.encoding === "binary") return s.getBytes();
          if (e.encoding) throw new Error('Unknown encoding "' + e.encoding + '".')
        }
        return s
      };
      Be.certificationRequestFromPem = function (r, e, t) {
        var i = Ue.pem.decode(r)[0];
        if (i.type !== "CERTIFICATE REQUEST") {
          var n = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
          throw n.headerType = i.type, n
        }
        if (i.procType && i.procType.type === "ENCRYPTED") throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
        var s = M.fromDer(i.body, t);
        return Be.certificationRequestFromAsn1(s, e)
      };
      Be.certificationRequestToPem = function (r, e) {
        var t = {
          type: "CERTIFICATE REQUEST",
          body: M.toDer(Be.certificationRequestToAsn1(r)).getBytes()
        };
        return Ue.pem.encode(t, {
          maxline: e
        })
      };
      Be.createCertificate = function () {
        var r = {};
        return r.version = 2, r.serialNumber = "00", r.signatureOid = null, r.signature = null, r.siginfo = {}, r.siginfo.algorithmOid = null, r.validity = {}, r.validity.notBefore = new Date, r.validity.notAfter = new Date, r.issuer = {}, r.issuer.getField = function (e) {
          return Bf(r.issuer, e)
        }, r.issuer.addField = function (e) {
          Io([e]), r.issuer.attributes.push(e)
        }, r.issuer.attributes = [], r.issuer.hash = null, r.subject = {}, r.subject.getField = function (e) {
          return Bf(r.subject, e)
        }, r.subject.addField = function (e) {
          Io([e]), r.subject.attributes.push(e)
        }, r.subject.attributes = [], r.subject.hash = null, r.extensions = [], r.publicKey = null, r.md = null, r.setSubject = function (e, t) {
          Io(e), r.subject.attributes = e, delete r.subject.uniqueId, t && (r.subject.uniqueId = t), r.subject.hash = null
        }, r.setIssuer = function (e, t) {
          Io(e), r.issuer.attributes = e, delete r.issuer.uniqueId, t && (r.issuer.uniqueId = t), r.issuer.hash = null
        }, r.setExtensions = function (e) {
          for (var t = 0; t < e.length; ++t) M0e(e[t], {
            cert: r
          });
          r.extensions = e
        }, r.getExtension = function (e) {
          typeof e == "string" && (e = {
            name: e
          });
          for (var t = null, i, n = 0; t === null && n < r.extensions.length; ++n) i = r.extensions[n], (e.id && i.id === e.id || e.name && i.name === e.name) && (t = i);
          return t
        }, r.sign = function (e, t) {
          r.md = t || Ue.md.sha1.create();
          var i = bt[r.md.algorithm + "WithRSAEncryption"];
          if (!i) {
            var n = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
            throw n.algorithm = r.md.algorithm, n
          }
          r.signatureOid = r.siginfo.algorithmOid = i, r.tbsCertificate = Be.getTBSCertificate(r);
          var s = M.toDer(r.tbsCertificate);
          r.md.update(s.getBytes()), r.signature = e.sign(r.md)
        }, r.verify = function (e) {
          var t = !1;
          if (!r.issued(e)) {
            var i = e.issuer,
              n = r.subject,
              s = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
            throw s.expectedIssuer = i.attributes, s.actualIssuer = n.attributes, s
          }
          var o = e.md;
          if (o === null) {
            if (e.signatureOid in bt) {
              var a = bt[e.signatureOid];
              switch (a) {
                case "sha1WithRSAEncryption":
                  o = Ue.md.sha1.create();
                  break;
                case "md5WithRSAEncryption":
                  o = Ue.md.md5.create();
                  break;
                case "sha256WithRSAEncryption":
                  o = Ue.md.sha256.create();
                  break;
                case "sha384WithRSAEncryption":
                  o = Ue.md.sha384.create();
                  break;
                case "sha512WithRSAEncryption":
                  o = Ue.md.sha512.create();
                  break;
                case "RSASSA-PSS":
                  o = Ue.md.sha256.create();
                  break
              }
            }
            if (o === null) {
              var s = new Error("Could not compute certificate digest. Unknown signature OID.");
              throw s.signatureOid = e.signatureOid, s
            }
            var c = e.tbsCertificate || Be.getTBSCertificate(e),
              u = M.toDer(c);
            o.update(u.getBytes())
          }
          if (o !== null) {
            var f;
            switch (e.signatureOid) {
              case bt.sha1WithRSAEncryption:
                f = void 0;
                break;
              case bt["RSASSA-PSS"]:
                var h, d;
                if (h = bt[e.signatureParameters.mgf.hash.algorithmOid], h === void 0 || Ue.md[h] === void 0) {
                  var s = new Error("Unsupported MGF hash function.");
                  throw s.oid = e.signatureParameters.mgf.hash.algorithmOid, s.name = h, s
                }
                if (d = bt[e.signatureParameters.mgf.algorithmOid], d === void 0 || Ue.mgf[d] === void 0) {
                  var s = new Error("Unsupported MGF function.");
                  throw s.oid = e.signatureParameters.mgf.algorithmOid, s.name = d, s
                }
                if (d = Ue.mgf[d].create(Ue.md[h].create()), h = bt[e.signatureParameters.hash.algorithmOid], h === void 0 || Ue.md[h] === void 0) throw {
                  message: "Unsupported RSASSA-PSS hash function.",
                  oid: e.signatureParameters.hash.algorithmOid,
                  name: h
                };
                f = Ue.pss.create(Ue.md[h].create(), d, e.signatureParameters.saltLength);
                break
            }
            t = r.publicKey.verify(o.digest().getBytes(), e.signature, f)
          }
          return t
        }, r.isIssuer = function (e) {
          var t = !1,
            i = r.issuer,
            n = e.subject;
          if (i.hash && n.hash) t = i.hash === n.hash;
          else if (i.attributes.length === n.attributes.length) {
            t = !0;
            for (var s, o, a = 0; t && a < i.attributes.length; ++a) s = i.attributes[a], o = n.attributes[a], (s.type !== o.type || s.value !== o.value) && (t = !1)
          }
          return t
        }, r.issued = function (e) {
          return e.isIssuer(r)
        }, r.generateSubjectKeyIdentifier = function () {
          return Be.getPublicKeyFingerprint(r.publicKey, {
            type: "RSAPublicKey"
          })
        }, r.verifySubjectKeyIdentifier = function () {
          for (var e = bt.subjectKeyIdentifier, t = 0; t < r.extensions.length; ++t) {
            var i = r.extensions[t];
            if (i.id === e) {
              var n = r.generateSubjectKeyIdentifier().getBytes();
              return Ue.util.hexToBytes(i.subjectKeyIdentifier) === n
            }
          }
          return !1
        }, r
      };
      Be.certificateFromAsn1 = function (r, e) {
        var t = {},
          i = [];
        if (!M.validate(r, ist, t, i)) {
          var n = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
          throw n.errors = i, n
        }
        var s = M.derToOid(t.publicKeyOid);
        if (s !== Be.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
        var o = Be.createCertificate();
        o.version = t.certVersion ? t.certVersion.charCodeAt(0) : 0;
        var a = Ue.util.createBuffer(t.certSerialNumber);
        o.serialNumber = a.toHex(), o.signatureOid = Ue.asn1.derToOid(t.certSignatureOid), o.signatureParameters = Q_(o.signatureOid, t.certSignatureParams, !0), o.siginfo.algorithmOid = Ue.asn1.derToOid(t.certinfoSignatureOid), o.siginfo.parameters = Q_(o.siginfo.algorithmOid, t.certinfoSignatureParams, !1), o.signature = t.certSignature;
        var c = [];
        if (t.certValidity1UTCTime !== void 0 && c.push(M.utcTimeToDate(t.certValidity1UTCTime)), t.certValidity2GeneralizedTime !== void 0 && c.push(M.generalizedTimeToDate(t.certValidity2GeneralizedTime)), t.certValidity3UTCTime !== void 0 && c.push(M.utcTimeToDate(t.certValidity3UTCTime)), t.certValidity4GeneralizedTime !== void 0 && c.push(M.generalizedTimeToDate(t.certValidity4GeneralizedTime)), c.length > 2) throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
        if (c.length < 2) throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
        if (o.validity.notBefore = c[0], o.validity.notAfter = c[1], o.tbsCertificate = t.tbsCertificate, e) {
          if (o.md = null, o.signatureOid in bt) {
            var s = bt[o.signatureOid];
            switch (s) {
              case "sha1WithRSAEncryption":
                o.md = Ue.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                o.md = Ue.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                o.md = Ue.md.sha256.create();
                break;
              case "sha384WithRSAEncryption":
                o.md = Ue.md.sha384.create();
                break;
              case "sha512WithRSAEncryption":
                o.md = Ue.md.sha512.create();
                break;
              case "RSASSA-PSS":
                o.md = Ue.md.sha256.create();
                break
            }
          }
          if (o.md === null) {
            var n = new Error("Could not compute certificate digest. Unknown signature OID.");
            throw n.signatureOid = o.signatureOid, n
          }
          var u = M.toDer(o.tbsCertificate);
          o.md.update(u.getBytes())
        }
        var f = Ue.md.sha1.create();
        o.issuer.getField = function (d) {
          return Bf(o.issuer, d)
        }, o.issuer.addField = function (d) {
          Io([d]), o.issuer.attributes.push(d)
        }, o.issuer.attributes = Be.RDNAttributesAsArray(t.certIssuer, f), t.certIssuerUniqueId && (o.issuer.uniqueId = t.certIssuerUniqueId), o.issuer.hash = f.digest().toHex();
        var h = Ue.md.sha1.create();
        return o.subject.getField = function (d) {
          return Bf(o.subject, d)
        }, o.subject.addField = function (d) {
          Io([d]), o.subject.attributes.push(d)
        }, o.subject.attributes = Be.RDNAttributesAsArray(t.certSubject, h), t.certSubjectUniqueId && (o.subject.uniqueId = t.certSubjectUniqueId), o.subject.hash = h.digest().toHex(), t.certExtensions ? o.extensions = Be.certificateExtensionsFromAsn1(t.certExtensions) : o.extensions = [], o.publicKey = Be.publicKeyFromAsn1(t.subjectPublicKeyInfo), o
      };
      Be.certificateExtensionsFromAsn1 = function (r) {
        for (var e = [], t = 0; t < r.value.length; ++t)
          for (var i = r.value[t], n = 0; n < i.value.length; ++n) e.push(Be.certificateExtensionFromAsn1(i.value[n]));
        return e
      };
      Be.certificateExtensionFromAsn1 = function (r) {
        var e = {};
        if (e.id = M.derToOid(r.value[0].value), e.critical = !1, r.value[1].type === M.Type.BOOLEAN ? (e.critical = r.value[1].value.charCodeAt(0) !== 0, e.value = r.value[2].value) : e.value = r.value[1].value, e.id in bt) {
          if (e.name = bt[e.id], e.name === "keyUsage") {
            var t = M.fromDer(e.value),
              i = 0,
              n = 0;
            t.value.length > 1 && (i = t.value.charCodeAt(1), n = t.value.length > 2 ? t.value.charCodeAt(2) : 0), e.digitalSignature = (i & 128) == 128, e.nonRepudiation = (i & 64) == 64, e.keyEncipherment = (i & 32) == 32, e.dataEncipherment = (i & 16) == 16, e.keyAgreement = (i & 8) == 8, e.keyCertSign = (i & 4) == 4, e.cRLSign = (i & 2) == 2, e.encipherOnly = (i & 1) == 1, e.decipherOnly = (n & 128) == 128
          } else if (e.name === "basicConstraints") {
            var t = M.fromDer(e.value);
            t.value.length > 0 && t.value[0].type === M.Type.BOOLEAN ? e.cA = t.value[0].value.charCodeAt(0) !== 0 : e.cA = !1;
            var s = null;
            t.value.length > 0 && t.value[0].type === M.Type.INTEGER ? s = t.value[0].value : t.value.length > 1 && (s = t.value[1].value), s !== null && (e.pathLenConstraint = M.derToInteger(s))
          } else if (e.name === "extKeyUsage")
            for (var t = M.fromDer(e.value), o = 0; o < t.value.length; ++o) {
              var a = M.derToOid(t.value[o].value);
              a in bt ? e[bt[a]] = !0 : e[a] = !0
            } else if (e.name === "nsCertType") {
              var t = M.fromDer(e.value),
                i = 0;
              t.value.length > 1 && (i = t.value.charCodeAt(1)), e.client = (i & 128) == 128, e.server = (i & 64) == 64, e.email = (i & 32) == 32, e.objsign = (i & 16) == 16, e.reserved = (i & 8) == 8, e.sslCA = (i & 4) == 4, e.emailCA = (i & 2) == 2, e.objCA = (i & 1) == 1
            } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
              e.altNames = [];
              for (var c, t = M.fromDer(e.value), u = 0; u < t.value.length; ++u) {
                c = t.value[u];
                var f = {
                  type: c.type,
                  value: c.value
                };
                switch (e.altNames.push(f), c.type) {
                  case 1:
                  case 2:
                  case 6:
                    break;
                  case 7:
                    f.ip = Ue.util.bytesToIP(c.value);
                    break;
                  case 8:
                    f.oid = M.derToOid(c.value);
                    break;
                  default:
                }
              }
            } else if (e.name === "subjectKeyIdentifier") {
              var t = M.fromDer(e.value);
              e.subjectKeyIdentifier = Ue.util.bytesToHex(t.value)
            }
        }
        return e
      };
      Be.certificationRequestFromAsn1 = function (r, e) {
        var t = {},
          i = [];
        if (!M.validate(r, ost, t, i)) {
          var n = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
          throw n.errors = i, n
        }
        var s = M.derToOid(t.publicKeyOid);
        if (s !== Be.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
        var o = Be.createCertificationRequest();
        if (o.version = t.csrVersion ? t.csrVersion.charCodeAt(0) : 0, o.signatureOid = Ue.asn1.derToOid(t.csrSignatureOid), o.signatureParameters = Q_(o.signatureOid, t.csrSignatureParams, !0), o.siginfo.algorithmOid = Ue.asn1.derToOid(t.csrSignatureOid), o.siginfo.parameters = Q_(o.siginfo.algorithmOid, t.csrSignatureParams, !1), o.signature = t.csrSignature, o.certificationRequestInfo = t.certificationRequestInfo, e) {
          if (o.md = null, o.signatureOid in bt) {
            var s = bt[o.signatureOid];
            switch (s) {
              case "sha1WithRSAEncryption":
                o.md = Ue.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                o.md = Ue.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                o.md = Ue.md.sha256.create();
                break;
              case "sha384WithRSAEncryption":
                o.md = Ue.md.sha384.create();
                break;
              case "sha512WithRSAEncryption":
                o.md = Ue.md.sha512.create();
                break;
              case "RSASSA-PSS":
                o.md = Ue.md.sha256.create();
                break
            }
          }
          if (o.md === null) {
            var n = new Error("Could not compute certification request digest. Unknown signature OID.");
            throw n.signatureOid = o.signatureOid, n
          }
          var a = M.toDer(o.certificationRequestInfo);
          o.md.update(a.getBytes())
        }
        var c = Ue.md.sha1.create();
        return o.subject.getField = function (u) {
          return Bf(o.subject, u)
        }, o.subject.addField = function (u) {
          Io([u]), o.subject.attributes.push(u)
        }, o.subject.attributes = Be.RDNAttributesAsArray(t.certificationRequestInfoSubject, c), o.subject.hash = c.digest().toHex(), o.publicKey = Be.publicKeyFromAsn1(t.subjectPublicKeyInfo), o.getAttribute = function (u) {
          return Bf(o, u)
        }, o.addAttribute = function (u) {
          Io([u]), o.attributes.push(u)
        }, o.attributes = Be.CRIAttributesAsArray(t.certificationRequestInfoAttributes || []), o
      };
      Be.createCertificationRequest = function () {
        var r = {};
        return r.version = 0, r.signatureOid = null, r.signature = null, r.siginfo = {}, r.siginfo.algorithmOid = null, r.subject = {}, r.subject.getField = function (e) {
          return Bf(r.subject, e)
        }, r.subject.addField = function (e) {
          Io([e]), r.subject.attributes.push(e)
        }, r.subject.attributes = [], r.subject.hash = null, r.publicKey = null, r.attributes = [], r.getAttribute = function (e) {
          return Bf(r, e)
        }, r.addAttribute = function (e) {
          Io([e]), r.attributes.push(e)
        }, r.md = null, r.setSubject = function (e) {
          Io(e), r.subject.attributes = e, r.subject.hash = null
        }, r.setAttributes = function (e) {
          Io(e), r.attributes = e
        }, r.sign = function (e, t) {
          r.md = t || Ue.md.sha1.create();
          var i = bt[r.md.algorithm + "WithRSAEncryption"];
          if (!i) {
            var n = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
            throw n.algorithm = r.md.algorithm, n
          }
          r.signatureOid = r.siginfo.algorithmOid = i, r.certificationRequestInfo = Be.getCertificationRequestInfo(r);
          var s = M.toDer(r.certificationRequestInfo);
          r.md.update(s.getBytes()), r.signature = e.sign(r.md)
        }, r.verify = function () {
          var e = !1,
            t = r.md;
          if (t === null) {
            if (r.signatureOid in bt) {
              var i = bt[r.signatureOid];
              switch (i) {
                case "sha1WithRSAEncryption":
                  t = Ue.md.sha1.create();
                  break;
                case "md5WithRSAEncryption":
                  t = Ue.md.md5.create();
                  break;
                case "sha256WithRSAEncryption":
                  t = Ue.md.sha256.create();
                  break;
                case "sha384WithRSAEncryption":
                  t = Ue.md.sha384.create();
                  break;
                case "sha512WithRSAEncryption":
                  t = Ue.md.sha512.create();
                  break;
                case "RSASSA-PSS":
                  t = Ue.md.sha256.create();
                  break
              }
            }
            if (t === null) {
              var n = new Error("Could not compute certification request digest. Unknown signature OID.");
              throw n.signatureOid = r.signatureOid, n
            }
            var s = r.certificationRequestInfo || Be.getCertificationRequestInfo(r),
              o = M.toDer(s);
            t.update(o.getBytes())
          }
          if (t !== null) {
            var a;
            switch (r.signatureOid) {
              case bt.sha1WithRSAEncryption:
                break;
              case bt["RSASSA-PSS"]:
                var c, u;
                if (c = bt[r.signatureParameters.mgf.hash.algorithmOid], c === void 0 || Ue.md[c] === void 0) {
                  var n = new Error("Unsupported MGF hash function.");
                  throw n.oid = r.signatureParameters.mgf.hash.algorithmOid, n.name = c, n
                }
                if (u = bt[r.signatureParameters.mgf.algorithmOid], u === void 0 || Ue.mgf[u] === void 0) {
                  var n = new Error("Unsupported MGF function.");
                  throw n.oid = r.signatureParameters.mgf.algorithmOid, n.name = u, n
                }
                if (u = Ue.mgf[u].create(Ue.md[c].create()), c = bt[r.signatureParameters.hash.algorithmOid], c === void 0 || Ue.md[c] === void 0) {
                  var n = new Error("Unsupported RSASSA-PSS hash function.");
                  throw n.oid = r.signatureParameters.hash.algorithmOid, n.name = c, n
                }
                a = Ue.pss.create(Ue.md[c].create(), u, r.signatureParameters.saltLength);
                break
            }
            e = r.publicKey.verify(t.digest().getBytes(), r.signature, a)
          }
          return e
        }, r
      };

      function wp(r) {
        for (var e = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, []), t, i, n = r.attributes, s = 0; s < n.length; ++s) {
          t = n[s];
          var o = t.value,
            a = M.Type.PRINTABLESTRING;
          "valueTagClass" in t && (a = t.valueTagClass, a === M.Type.UTF8 && (o = Ue.util.encodeUtf8(o))), i = M.create(M.Class.UNIVERSAL, M.Type.SET, !0, [M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(t.type).getBytes()), M.create(M.Class.UNIVERSAL, a, !1, o)])]), e.value.push(i)
        }
        return e
      }

      function Io(r) {
        for (var e, t = 0; t < r.length; ++t) {
          if (e = r[t], typeof e.name == "undefined" && (e.type && e.type in Be.oids ? e.name = Be.oids[e.type] : e.shortName && e.shortName in ni && (e.name = Be.oids[ni[e.shortName]])), typeof e.type == "undefined")
            if (e.name && e.name in Be.oids) e.type = Be.oids[e.name];
            else {
              var i = new Error("Attribute type not specified.");
              throw i.attribute = e, i
            } if (typeof e.shortName == "undefined" && e.name && e.name in ni && (e.shortName = ni[e.name]), e.type === bt.extensionRequest && (e.valueConstructed = !0, e.valueTagClass = M.Type.SEQUENCE, !e.value && e.extensions)) {
              e.value = [];
              for (var n = 0; n < e.extensions.length; ++n) e.value.push(Be.certificateExtensionToAsn1(M0e(e.extensions[n])))
            }
          if (typeof e.value == "undefined") {
            var i = new Error("Attribute value not specified.");
            throw i.attribute = e, i
          }
        }
      }

      function M0e(r, e) {
        if (e = e || {}, typeof r.name == "undefined" && r.id && r.id in Be.oids && (r.name = Be.oids[r.id]), typeof r.id == "undefined")
          if (r.name && r.name in Be.oids) r.id = Be.oids[r.name];
          else {
            var t = new Error("Extension ID not specified.");
            throw t.extension = r, t
          } if (typeof r.value != "undefined") return r;
        if (r.name === "keyUsage") {
          var i = 0,
            n = 0,
            s = 0;
          r.digitalSignature && (n |= 128, i = 7), r.nonRepudiation && (n |= 64, i = 6), r.keyEncipherment && (n |= 32, i = 5), r.dataEncipherment && (n |= 16, i = 4), r.keyAgreement && (n |= 8, i = 3), r.keyCertSign && (n |= 4, i = 2), r.cRLSign && (n |= 2, i = 1), r.encipherOnly && (n |= 1, i = 0), r.decipherOnly && (s |= 128, i = 7);
          var o = String.fromCharCode(i);
          s !== 0 ? o += String.fromCharCode(n) + String.fromCharCode(s) : n !== 0 && (o += String.fromCharCode(n)), r.value = M.create(M.Class.UNIVERSAL, M.Type.BITSTRING, !1, o)
        } else if (r.name === "basicConstraints") r.value = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, []), r.cA && r.value.value.push(M.create(M.Class.UNIVERSAL, M.Type.BOOLEAN, !1, String.fromCharCode(255))), "pathLenConstraint" in r && r.value.value.push(M.create(M.Class.UNIVERSAL, M.Type.INTEGER, !1, M.integerToDer(r.pathLenConstraint).getBytes()));
        else if (r.name === "extKeyUsage") {
          r.value = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, []);
          var a = r.value.value;
          for (var c in r) r[c] === !0 && (c in bt ? a.push(M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(bt[c]).getBytes())) : c.indexOf(".") !== -1 && a.push(M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(c).getBytes())))
        } else if (r.name === "nsCertType") {
          var i = 0,
            n = 0;
          r.client && (n |= 128, i = 7), r.server && (n |= 64, i = 6), r.email && (n |= 32, i = 5), r.objsign && (n |= 16, i = 4), r.reserved && (n |= 8, i = 3), r.sslCA && (n |= 4, i = 2), r.emailCA && (n |= 2, i = 1), r.objCA && (n |= 1, i = 0);
          var o = String.fromCharCode(i);
          n !== 0 && (o += String.fromCharCode(n)), r.value = M.create(M.Class.UNIVERSAL, M.Type.BITSTRING, !1, o)
        } else if (r.name === "subjectAltName" || r.name === "issuerAltName") {
          r.value = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, []);
          for (var u, f = 0; f < r.altNames.length; ++f) {
            u = r.altNames[f];
            var o = u.value;
            if (u.type === 7 && u.ip) {
              if (o = Ue.util.bytesFromIP(u.ip), o === null) {
                var t = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
                throw t.extension = r, t
              }
            } else u.type === 8 && (u.oid ? o = M.oidToDer(M.oidToDer(u.oid)) : o = M.oidToDer(o));
            r.value.value.push(M.create(M.Class.CONTEXT_SPECIFIC, u.type, !1, o))
          }
        } else if (r.name === "nsComment" && e.cert) {
          if (!/^[\x00-\x7F]*$/.test(r.comment) || r.comment.length < 1 || r.comment.length > 128) throw new Error('Invalid "nsComment" content.');
          r.value = M.create(M.Class.UNIVERSAL, M.Type.IA5STRING, !1, r.comment)
        } else if (r.name === "subjectKeyIdentifier" && e.cert) {
          var h = e.cert.generateSubjectKeyIdentifier();
          r.subjectKeyIdentifier = h.toHex(), r.value = M.create(M.Class.UNIVERSAL, M.Type.OCTETSTRING, !1, h.getBytes())
        } else if (r.name === "authorityKeyIdentifier" && e.cert) {
          r.value = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, []);
          var a = r.value.value;
          if (r.keyIdentifier) {
            var d = r.keyIdentifier === !0 ? e.cert.generateSubjectKeyIdentifier().getBytes() : r.keyIdentifier;
            a.push(M.create(M.Class.CONTEXT_SPECIFIC, 0, !1, d))
          }
          if (r.authorityCertIssuer) {
            var p = [M.create(M.Class.CONTEXT_SPECIFIC, 4, !0, [wp(r.authorityCertIssuer === !0 ? e.cert.issuer : r.authorityCertIssuer)])];
            a.push(M.create(M.Class.CONTEXT_SPECIFIC, 1, !0, p))
          }
          if (r.serialNumber) {
            var g = Ue.util.hexToBytes(r.serialNumber === !0 ? e.cert.serialNumber : r.serialNumber);
            a.push(M.create(M.Class.CONTEXT_SPECIFIC, 2, !1, g))
          }
        } else if (r.name === "cRLDistributionPoints") {
          r.value = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, []);
          for (var a = r.value.value, m = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, []), E = M.create(M.Class.CONTEXT_SPECIFIC, 0, !0, []), u, f = 0; f < r.altNames.length; ++f) {
            u = r.altNames[f];
            var o = u.value;
            if (u.type === 7 && u.ip) {
              if (o = Ue.util.bytesFromIP(u.ip), o === null) {
                var t = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
                throw t.extension = r, t
              }
            } else u.type === 8 && (u.oid ? o = M.oidToDer(M.oidToDer(u.oid)) : o = M.oidToDer(o));
            E.value.push(M.create(M.Class.CONTEXT_SPECIFIC, u.type, !1, o))
          }
          m.value.push(M.create(M.Class.CONTEXT_SPECIFIC, 0, !0, [E])), a.push(m)
        }
        if (typeof r.value == "undefined") {
          var t = new Error("Extension value not specified.");
          throw t.extension = r, t
        }
        return r
      }

      function wR(r, e) {
        switch (r) {
          case bt["RSASSA-PSS"]:
            var t = [];
            return e.hash.algorithmOid !== void 0 && t.push(M.create(M.Class.CONTEXT_SPECIFIC, 0, !0, [M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(e.hash.algorithmOid).getBytes()), M.create(M.Class.UNIVERSAL, M.Type.NULL, !1, "")])])), e.mgf.algorithmOid !== void 0 && t.push(M.create(M.Class.CONTEXT_SPECIFIC, 1, !0, [M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(e.mgf.algorithmOid).getBytes()), M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(e.mgf.hash.algorithmOid).getBytes()), M.create(M.Class.UNIVERSAL, M.Type.NULL, !1, "")])])])), e.saltLength !== void 0 && t.push(M.create(M.Class.CONTEXT_SPECIFIC, 2, !0, [M.create(M.Class.UNIVERSAL, M.Type.INTEGER, !1, M.integerToDer(e.saltLength).getBytes())])), M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, t);
          default:
            return M.create(M.Class.UNIVERSAL, M.Type.NULL, !1, "")
        }
      }

      function ast(r) {
        var e = M.create(M.Class.CONTEXT_SPECIFIC, 0, !0, []);
        if (r.attributes.length === 0) return e;
        for (var t = r.attributes, i = 0; i < t.length; ++i) {
          var n = t[i],
            s = n.value,
            o = M.Type.UTF8;
          "valueTagClass" in n && (o = n.valueTagClass), o === M.Type.UTF8 && (s = Ue.util.encodeUtf8(s));
          var a = !1;
          "valueConstructed" in n && (a = n.valueConstructed);
          var c = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(n.type).getBytes()), M.create(M.Class.UNIVERSAL, M.Type.SET, !0, [M.create(M.Class.UNIVERSAL, o, a, s)])]);
          e.value.push(c)
        }
        return e
      }
      var cst = new Date("1950-01-01T00:00:00Z"),
        ust = new Date("2050-01-01T00:00:00Z");

      function B0e(r) {
        return r >= cst && r < ust ? M.create(M.Class.UNIVERSAL, M.Type.UTCTIME, !1, M.dateToUtcTime(r)) : M.create(M.Class.UNIVERSAL, M.Type.GENERALIZEDTIME, !1, M.dateToGeneralizedTime(r))
      }
      Be.getTBSCertificate = function (r) {
        var e = B0e(r.validity.notBefore),
          t = B0e(r.validity.notAfter),
          i = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [M.create(M.Class.CONTEXT_SPECIFIC, 0, !0, [M.create(M.Class.UNIVERSAL, M.Type.INTEGER, !1, M.integerToDer(r.version).getBytes())]), M.create(M.Class.UNIVERSAL, M.Type.INTEGER, !1, Ue.util.hexToBytes(r.serialNumber)), M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(r.siginfo.algorithmOid).getBytes()), wR(r.siginfo.algorithmOid, r.siginfo.parameters)]), wp(r.issuer), M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [e, t]), wp(r.subject), Be.publicKeyToAsn1(r.publicKey)]);
        return r.issuer.uniqueId && i.value.push(M.create(M.Class.CONTEXT_SPECIFIC, 1, !0, [M.create(M.Class.UNIVERSAL, M.Type.BITSTRING, !1, String.fromCharCode(0) + r.issuer.uniqueId)])), r.subject.uniqueId && i.value.push(M.create(M.Class.CONTEXT_SPECIFIC, 2, !0, [M.create(M.Class.UNIVERSAL, M.Type.BITSTRING, !1, String.fromCharCode(0) + r.subject.uniqueId)])), r.extensions.length > 0 && i.value.push(Be.certificateExtensionsToAsn1(r.extensions)), i
      };
      Be.getCertificationRequestInfo = function (r) {
        var e = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [M.create(M.Class.UNIVERSAL, M.Type.INTEGER, !1, M.integerToDer(r.version).getBytes()), wp(r.subject), Be.publicKeyToAsn1(r.publicKey), ast(r)]);
        return e
      };
      Be.distinguishedNameToAsn1 = function (r) {
        return wp(r)
      };
      Be.certificateToAsn1 = function (r) {
        var e = r.tbsCertificate || Be.getTBSCertificate(r);
        return M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [e, M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(r.signatureOid).getBytes()), wR(r.signatureOid, r.signatureParameters)]), M.create(M.Class.UNIVERSAL, M.Type.BITSTRING, !1, String.fromCharCode(0) + r.signature)])
      };
      Be.certificateExtensionsToAsn1 = function (r) {
        var e = M.create(M.Class.CONTEXT_SPECIFIC, 3, !0, []),
          t = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, []);
        e.value.push(t);
        for (var i = 0; i < r.length; ++i) t.value.push(Be.certificateExtensionToAsn1(r[i]));
        return e
      };
      Be.certificateExtensionToAsn1 = function (r) {
        var e = M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, []);
        e.value.push(M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(r.id).getBytes())), r.critical && e.value.push(M.create(M.Class.UNIVERSAL, M.Type.BOOLEAN, !1, String.fromCharCode(255)));
        var t = r.value;
        return typeof r.value != "string" && (t = M.toDer(t).getBytes()), e.value.push(M.create(M.Class.UNIVERSAL, M.Type.OCTETSTRING, !1, t)), e
      };
      Be.certificationRequestToAsn1 = function (r) {
        var e = r.certificationRequestInfo || Be.getCertificationRequestInfo(r);
        return M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [e, M.create(M.Class.UNIVERSAL, M.Type.SEQUENCE, !0, [M.create(M.Class.UNIVERSAL, M.Type.OID, !1, M.oidToDer(r.signatureOid).getBytes()), wR(r.signatureOid, r.signatureParameters)]), M.create(M.Class.UNIVERSAL, M.Type.BITSTRING, !1, String.fromCharCode(0) + r.signature)])
      };
      Be.createCaStore = function (r) {
        var e = {
          certs: {}
        };
        e.getIssuer = function (o) {
          var a = t(o.issuer);
          return a
        }, e.addCertificate = function (o) {
          if (typeof o == "string" && (o = Ue.pki.certificateFromPem(o)), i(o.subject), !e.hasCertificate(o))
            if (o.subject.hash in e.certs) {
              var a = e.certs[o.subject.hash];
              Ue.util.isArray(a) || (a = [a]), a.push(o), e.certs[o.subject.hash] = a
            } else e.certs[o.subject.hash] = o
        }, e.hasCertificate = function (o) {
          typeof o == "string" && (o = Ue.pki.certificateFromPem(o));
          var a = t(o.subject);
          if (!a) return !1;
          Ue.util.isArray(a) || (a = [a]);
          for (var c = M.toDer(Be.certificateToAsn1(o)).getBytes(), u = 0; u < a.length; ++u) {
            var f = M.toDer(Be.certificateToAsn1(a[u])).getBytes();
            if (c === f) return !0
          }
          return !1
        }, e.listAllCertificates = function () {
          var o = [];
          for (var a in e.certs)
            if (e.certs.hasOwnProperty(a)) {
              var c = e.certs[a];
              if (!Ue.util.isArray(c)) o.push(c);
              else
                for (var u = 0; u < c.length; ++u) o.push(c[u])
            } return o
        }, e.removeCertificate = function (o) {
          var a;
          if (typeof o == "string" && (o = Ue.pki.certificateFromPem(o)), i(o.subject), !e.hasCertificate(o)) return null;
          var c = t(o.subject);
          if (!Ue.util.isArray(c)) return a = e.certs[o.subject.hash], delete e.certs[o.subject.hash], a;
          for (var u = M.toDer(Be.certificateToAsn1(o)).getBytes(), f = 0; f < c.length; ++f) {
            var h = M.toDer(Be.certificateToAsn1(c[f])).getBytes();
            u === h && (a = c[f], c.splice(f, 1))
          }
          return c.length === 0 && delete e.certs[o.subject.hash], a
        };

        function t(o) {
          return i(o), e.certs[o.hash] || null
        }

        function i(o) {
          if (!o.hash) {
            var a = Ue.md.sha1.create();
            o.attributes = Be.RDNAttributesAsArray(wp(o), a), o.hash = a.digest().toHex()
          }
        }
        if (r)
          for (var n = 0; n < r.length; ++n) {
            var s = r[n];
            e.addCertificate(s)
          }
        return e
      };
      Be.certificateError = {
        bad_certificate: "forge.pki.BadCertificate",
        unsupported_certificate: "forge.pki.UnsupportedCertificate",
        certificate_revoked: "forge.pki.CertificateRevoked",
        certificate_expired: "forge.pki.CertificateExpired",
        certificate_unknown: "forge.pki.CertificateUnknown",
        unknown_ca: "forge.pki.UnknownCertificateAuthority"
      };
      Be.verifyCertificateChain = function (r, e, t) {
        typeof t == "function" && (t = {
          verify: t
        }), t = t || {}, e = e.slice(0);
        var i = e.slice(0),
          n = t.validityCheckDate;
        typeof n == "undefined" && (n = new Date);
        var s = !0,
          o = null,
          a = 0;
        do {
          var c = e.shift(),
            u = null,
            f = !1;
          if (n && (n < c.validity.notBefore || n > c.validity.notAfter) && (o = {
            message: "Certificate is not valid yet or has expired.",
            error: Be.certificateError.certificate_expired,
            notBefore: c.validity.notBefore,
            notAfter: c.validity.notAfter,
            now: n
          }), o === null) {
            if (u = e[0] || r.getIssuer(c), u === null && c.isIssuer(c) && (f = !0, u = c), u) {
              var h = u;
              Ue.util.isArray(h) || (h = [h]);
              for (var d = !1; !d && h.length > 0;) {
                u = h.shift();
                try {
                  d = u.verify(c)
                } catch (Z) { }
              }
              d || (o = {
                message: "Certificate signature is invalid.",
                error: Be.certificateError.bad_certificate
              })
            }
            o === null && (!u || f) && !r.hasCertificate(c) && (o = {
              message: "Certificate is not trusted.",
              error: Be.certificateError.unknown_ca
            })
          }
          if (o === null && u && !c.isIssuer(u) && (o = {
            message: "Certificate issuer is invalid.",
            error: Be.certificateError.bad_certificate
          }), o === null)
            for (var p = {
              keyUsage: !0,
              basicConstraints: !0
            }, g = 0; o === null && g < c.extensions.length; ++g) {
              var m = c.extensions[g];
              m.critical && !(m.name in p) && (o = {
                message: "Certificate has an unsupported critical extension.",
                error: Be.certificateError.unsupported_certificate
              })
            }
          if (o === null && (!s || e.length === 0 && (!u || f))) {
            var E = c.getExtension("basicConstraints"),
              w = c.getExtension("keyUsage");
            if (w !== null && (!w.keyCertSign || E === null) && (o = {
              message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
              error: Be.certificateError.bad_certificate
            }), o === null && E !== null && !E.cA && (o = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: Be.certificateError.bad_certificate
            }), o === null && w !== null && "pathLenConstraint" in E) {
              var O = a - 1;
              O > E.pathLenConstraint && (o = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: Be.certificateError.bad_certificate
              })
            }
          }
          var q = o === null ? !0 : o.error,
            J = t.verify ? t.verify(q, a, i) : q;
          if (J === !0) o = null;
          else throw q === !0 && (o = {
            message: "The application rejected the certificate.",
            error: Be.certificateError.bad_certificate
          }), (J || J === 0) && (typeof J == "object" && !Ue.util.isArray(J) ? (J.message && (o.message = J.message), J.error && (o.error = J.error)) : typeof J == "string" && (o.error = J)), o;
          s = !1, ++a
        } while (e.length > 0);
        return !0
      }
    });
    var F0e = y((Qxt, D0e) => {
      l();
      var He = At();
      cd();
      Bc();
      i2();
      sd();
      a2();
      I0e();
      Fu();
      wr();
      _R();
      var ce = He.asn1,
        Xn = D0e.exports = He.pkcs7 = He.pkcs7 || {};
      Xn.messageFromPem = function (r) {
        var e = He.pem.decode(r)[0];
        if (e.type !== "PKCS7") {
          var t = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
          throw t.headerType = e.type, t
        }
        if (e.procType && e.procType.type === "ENCRYPTED") throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
        var i = ce.fromDer(e.body);
        return Xn.messageFromAsn1(i)
      };
      Xn.messageToPem = function (r, e) {
        var t = {
          type: "PKCS7",
          body: ce.toDer(r.toAsn1()).getBytes()
        };
        return He.pem.encode(t, {
          maxline: e
        })
      };
      Xn.messageFromAsn1 = function (r) {
        var e = {},
          t = [];
        if (!ce.validate(r, Xn.asn1.contentInfoValidator, e, t)) {
          var i = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
          throw i.errors = t, i
        }
        var n = ce.derToOid(e.contentType),
          s;
        switch (n) {
          case He.pki.oids.envelopedData:
            s = Xn.createEnvelopedData();
            break;
          case He.pki.oids.encryptedData:
            s = Xn.createEncryptedData();
            break;
          case He.pki.oids.signedData:
            s = Xn.createSignedData();
            break;
          default:
            throw new Error("Cannot read PKCS#7 message. ContentType with OID " + n + " is not (yet) supported.")
        }
        return s.fromAsn1(e.content.value[0]), s
      };
      Xn.createSignedData = function () {
        var r = null;
        return r = {
          type: He.pki.oids.signedData,
          version: 1,
          certificates: [],
          crls: [],
          signers: [],
          digestAlgorithmIdentifiers: [],
          contentInfo: null,
          signerInfos: [],
          fromAsn1: function (i) {
            if (SR(r, i, Xn.asn1.signedDataValidator), r.certificates = [], r.crls = [], r.digestAlgorithmIdentifiers = [], r.contentInfo = null, r.signerInfos = [], r.rawCapture.certificates)
              for (var n = r.rawCapture.certificates.value, s = 0; s < n.length; ++s) r.certificates.push(He.pki.certificateFromAsn1(n[s]))
          },
          toAsn1: function () {
            r.contentInfo || r.sign();
            for (var i = [], n = 0; n < r.certificates.length; ++n) i.push(He.pki.certificateToAsn1(r.certificates[n]));
            var s = [],
              o = ce.create(ce.Class.CONTEXT_SPECIFIC, 0, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.INTEGER, !1, ce.integerToDer(r.version).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.SET, !0, r.digestAlgorithmIdentifiers), r.contentInfo])]);
            return i.length > 0 && o.value[0].value.push(ce.create(ce.Class.CONTEXT_SPECIFIC, 0, !0, i)), s.length > 0 && o.value[0].value.push(ce.create(ce.Class.CONTEXT_SPECIFIC, 1, !0, s)), o.value[0].value.push(ce.create(ce.Class.UNIVERSAL, ce.Type.SET, !0, r.signerInfos)), ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(r.type).getBytes()), o])
          },
          addSigner: function (i) {
            var n = i.issuer,
              s = i.serialNumber;
            if (i.certificate) {
              var o = i.certificate;
              typeof o == "string" && (o = He.pki.certificateFromPem(o)), n = o.issuer.attributes, s = o.serialNumber
            }
            var a = i.key;
            if (!a) throw new Error("Could not add PKCS#7 signer; no private key specified.");
            typeof a == "string" && (a = He.pki.privateKeyFromPem(a));
            var c = i.digestAlgorithm || He.pki.oids.sha1;
            switch (c) {
              case He.pki.oids.sha1:
              case He.pki.oids.sha256:
              case He.pki.oids.sha384:
              case He.pki.oids.sha512:
              case He.pki.oids.md5:
                break;
              default:
                throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + c)
            }
            var u = i.authenticatedAttributes || [];
            if (u.length > 0) {
              for (var f = !1, h = !1, d = 0; d < u.length; ++d) {
                var p = u[d];
                if (!f && p.type === He.pki.oids.contentType) {
                  if (f = !0, h) break;
                  continue
                }
                if (!h && p.type === He.pki.oids.messageDigest) {
                  if (h = !0, f) break;
                  continue
                }
              }
              if (!f || !h) throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.")
            }
            r.signers.push({
              key: a,
              version: 1,
              issuer: n,
              serialNumber: s,
              digestAlgorithm: c,
              signatureAlgorithm: He.pki.oids.rsaEncryption,
              signature: null,
              authenticatedAttributes: u,
              unauthenticatedAttributes: []
            })
          },
          sign: function (i) {
            if (i = i || {}, (typeof r.content != "object" || r.contentInfo === null) && (r.contentInfo = ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(He.pki.oids.data).getBytes())]), "content" in r)) {
              var n;
              r.content instanceof He.util.ByteBuffer ? n = r.content.bytes() : typeof r.content == "string" && (n = He.util.encodeUtf8(r.content)), i.detached ? r.detachedContent = ce.create(ce.Class.UNIVERSAL, ce.Type.OCTETSTRING, !1, n) : r.contentInfo.value.push(ce.create(ce.Class.CONTEXT_SPECIFIC, 0, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OCTETSTRING, !1, n)]))
            }
            if (r.signers.length !== 0) {
              var s = e();
              t(s)
            }
          },
          verify: function () {
            throw new Error("PKCS#7 signature verification not yet implemented.")
          },
          addCertificate: function (i) {
            typeof i == "string" && (i = He.pki.certificateFromPem(i)), r.certificates.push(i)
          },
          addCertificateRevokationList: function (i) {
            throw new Error("PKCS#7 CRL support not yet implemented.")
          }
        }, r;

        function e() {
          for (var i = {}, n = 0; n < r.signers.length; ++n) {
            var s = r.signers[n],
              o = s.digestAlgorithm;
            o in i || (i[o] = He.md[He.pki.oids[o]].create()), s.authenticatedAttributes.length === 0 ? s.md = i[o] : s.md = He.md[He.pki.oids[o]].create()
          }
          r.digestAlgorithmIdentifiers = [];
          for (var o in i) r.digestAlgorithmIdentifiers.push(ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(o).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.NULL, !1, "")]));
          return i
        }

        function t(i) {
          var n;
          if (r.detachedContent ? n = r.detachedContent : (n = r.contentInfo.value[1], n = n.value[0]), !n) throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
          var s = ce.derToOid(r.contentInfo.value[0].value),
            o = ce.toDer(n);
          o.getByte(), ce.getBerValueLength(o), o = o.getBytes();
          for (var a in i) i[a].start().update(o);
          for (var c = new Date, u = 0; u < r.signers.length; ++u) {
            var f = r.signers[u];
            if (f.authenticatedAttributes.length === 0) {
              if (s !== He.pki.oids.data) throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.")
            } else {
              f.authenticatedAttributesAsn1 = ce.create(ce.Class.CONTEXT_SPECIFIC, 0, !0, []);
              for (var h = ce.create(ce.Class.UNIVERSAL, ce.Type.SET, !0, []), d = 0; d < f.authenticatedAttributes.length; ++d) {
                var p = f.authenticatedAttributes[d];
                p.type === He.pki.oids.messageDigest ? p.value = i[f.digestAlgorithm].digest() : p.type === He.pki.oids.signingTime && (p.value || (p.value = c)), h.value.push(ER(p)), f.authenticatedAttributesAsn1.value.push(ER(p))
              }
              o = ce.toDer(h).getBytes(), f.md.start().update(o)
            }
            f.signature = f.key.sign(f.md, "RSASSA-PKCS1-V1_5")
          }
          r.signerInfos = fst(r.signers)
        }
      };
      Xn.createEncryptedData = function () {
        var r = null;
        return r = {
          type: He.pki.oids.encryptedData,
          version: 0,
          encryptedContent: {
            algorithm: He.pki.oids["aes256-CBC"]
          },
          fromAsn1: function (e) {
            SR(r, e, Xn.asn1.encryptedDataValidator)
          },
          decrypt: function (e) {
            e !== void 0 && (r.encryptedContent.key = e), L0e(r)
          }
        }, r
      };
      Xn.createEnvelopedData = function () {
        var r = null;
        return r = {
          type: He.pki.oids.envelopedData,
          version: 0,
          recipients: [],
          encryptedContent: {
            algorithm: He.pki.oids["aes256-CBC"]
          },
          fromAsn1: function (e) {
            var t = SR(r, e, Xn.asn1.envelopedDataValidator);
            r.recipients = lst(t.recipientInfos.value)
          },
          toAsn1: function () {
            return ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(r.type).getBytes()), ce.create(ce.Class.CONTEXT_SPECIFIC, 0, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.INTEGER, !1, ce.integerToDer(r.version).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.SET, !0, hst(r.recipients)), ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, dst(r.encryptedContent))])])])
          },
          findRecipient: function (e) {
            for (var t = e.issuer.attributes, i = 0; i < r.recipients.length; ++i) {
              var n = r.recipients[i],
                s = n.issuer;
              if (n.serialNumber === e.serialNumber && s.length === t.length) {
                for (var o = !0, a = 0; a < t.length; ++a)
                  if (s[a].type !== t[a].type || s[a].value !== t[a].value) {
                    o = !1;
                    break
                  } if (o) return n
              }
            }
            return null
          },
          decrypt: function (e, t) {
            if (r.encryptedContent.key === void 0 && e !== void 0 && t !== void 0) switch (e.encryptedContent.algorithm) {
              case He.pki.oids.rsaEncryption:
              case He.pki.oids.desCBC:
                var i = t.decrypt(e.encryptedContent.content);
                r.encryptedContent.key = He.util.createBuffer(i);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + e.encryptedContent.algorithm)
            }
            L0e(r)
          },
          addRecipient: function (e) {
            r.recipients.push({
              version: 0,
              issuer: e.issuer.attributes,
              serialNumber: e.serialNumber,
              encryptedContent: {
                algorithm: He.pki.oids.rsaEncryption,
                key: e.publicKey
              }
            })
          },
          encrypt: function (e, t) {
            if (r.encryptedContent.content === void 0) {
              t = t || r.encryptedContent.algorithm, e = e || r.encryptedContent.key;
              var i, n, s;
              switch (t) {
                case He.pki.oids["aes128-CBC"]:
                  i = 16, n = 16, s = He.aes.createEncryptionCipher;
                  break;
                case He.pki.oids["aes192-CBC"]:
                  i = 24, n = 16, s = He.aes.createEncryptionCipher;
                  break;
                case He.pki.oids["aes256-CBC"]:
                  i = 32, n = 16, s = He.aes.createEncryptionCipher;
                  break;
                case He.pki.oids["des-EDE3-CBC"]:
                  i = 24, n = 8, s = He.des.createEncryptionCipher;
                  break;
                default:
                  throw new Error("Unsupported symmetric cipher, OID " + t)
              }
              if (e === void 0) e = He.util.createBuffer(He.random.getBytes(i));
              else if (e.length() != i) throw new Error("Symmetric key has wrong length; got " + e.length() + " bytes, expected " + i + ".");
              r.encryptedContent.algorithm = t, r.encryptedContent.key = e, r.encryptedContent.parameter = He.util.createBuffer(He.random.getBytes(n));
              var o = s(e);
              if (o.start(r.encryptedContent.parameter.copy()), o.update(r.content), !o.finish()) throw new Error("Symmetric encryption failed.");
              r.encryptedContent.content = o.output
            }
            for (var a = 0; a < r.recipients.length; ++a) {
              var c = r.recipients[a];
              if (c.encryptedContent.content === void 0) switch (c.encryptedContent.algorithm) {
                case He.pki.oids.rsaEncryption:
                  c.encryptedContent.content = c.encryptedContent.key.encrypt(r.encryptedContent.key.data);
                  break;
                default:
                  throw new Error("Unsupported asymmetric cipher, OID " + c.encryptedContent.algorithm)
              }
            }
          }
        }, r
      };

      function pst(r) {
        var e = {},
          t = [];
        if (!ce.validate(r, Xn.asn1.recipientInfoValidator, e, t)) {
          var i = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
          throw i.errors = t, i
        }
        return {
          version: e.version.charCodeAt(0),
          issuer: He.pki.RDNAttributesAsArray(e.issuer),
          serialNumber: He.util.createBuffer(e.serial).toHex(),
          encryptedContent: {
            algorithm: ce.derToOid(e.encAlgorithm),
            parameter: e.encParameter.value,
            content: e.encKey
          }
        }
      }

      function yst(r) {
        return ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.INTEGER, !1, ce.integerToDer(r.version).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [He.pki.distinguishedNameToAsn1({
          attributes: r.issuer
        }), ce.create(ce.Class.UNIVERSAL, ce.Type.INTEGER, !1, He.util.hexToBytes(r.serialNumber))]), ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(r.encryptedContent.algorithm).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.NULL, !1, "")]), ce.create(ce.Class.UNIVERSAL, ce.Type.OCTETSTRING, !1, r.encryptedContent.content)])
      }

      function lst(r) {
        for (var e = [], t = 0; t < r.length; ++t) e.push(pst(r[t]));
        return e
      }

      function hst(r) {
        for (var e = [], t = 0; t < r.length; ++t) e.push(yst(r[t]));
        return e
      }

      function gst(r) {
        var e = ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.INTEGER, !1, ce.integerToDer(r.version).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [He.pki.distinguishedNameToAsn1({
          attributes: r.issuer
        }), ce.create(ce.Class.UNIVERSAL, ce.Type.INTEGER, !1, He.util.hexToBytes(r.serialNumber))]), ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(r.digestAlgorithm).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.NULL, !1, "")])]);
        if (r.authenticatedAttributesAsn1 && e.value.push(r.authenticatedAttributesAsn1), e.value.push(ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(r.signatureAlgorithm).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.NULL, !1, "")])), e.value.push(ce.create(ce.Class.UNIVERSAL, ce.Type.OCTETSTRING, !1, r.signature)), r.unauthenticatedAttributes.length > 0) {
          for (var t = ce.create(ce.Class.CONTEXT_SPECIFIC, 1, !0, []), i = 0; i < r.unauthenticatedAttributes.length; ++i) {
            var n = r.unauthenticatedAttributes[i];
            t.values.push(ER(n))
          }
          e.value.push(t)
        }
        return e
      }

      function fst(r) {
        for (var e = [], t = 0; t < r.length; ++t) e.push(gst(r[t]));
        return e
      }

      function ER(r) {
        var e;
        if (r.type === He.pki.oids.contentType) e = ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(r.value).getBytes());
        else if (r.type === He.pki.oids.messageDigest) e = ce.create(ce.Class.UNIVERSAL, ce.Type.OCTETSTRING, !1, r.value.bytes());
        else if (r.type === He.pki.oids.signingTime) {
          var t = new Date("1950-01-01T00:00:00Z"),
            i = new Date("2050-01-01T00:00:00Z"),
            n = r.value;
          if (typeof n == "string") {
            var s = Date.parse(n);
            isNaN(s) ? n.length === 13 ? n = ce.utcTimeToDate(n) : n = ce.generalizedTimeToDate(n) : n = new Date(s)
          }
          n >= t && n < i ? e = ce.create(ce.Class.UNIVERSAL, ce.Type.UTCTIME, !1, ce.dateToUtcTime(n)) : e = ce.create(ce.Class.UNIVERSAL, ce.Type.GENERALIZEDTIME, !1, ce.dateToGeneralizedTime(n))
        }
        return ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(r.type).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.SET, !0, [e])])
      }

      function dst(r) {
        return [ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(He.pki.oids.data).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.SEQUENCE, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OID, !1, ce.oidToDer(r.algorithm).getBytes()), ce.create(ce.Class.UNIVERSAL, ce.Type.OCTETSTRING, !1, r.parameter.getBytes())]), ce.create(ce.Class.CONTEXT_SPECIFIC, 0, !0, [ce.create(ce.Class.UNIVERSAL, ce.Type.OCTETSTRING, !1, r.content.getBytes())])]
      }

      function SR(r, e, t) {
        var i = {},
          n = [];
        if (!ce.validate(e, t, i, n)) {
          var s = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
          throw s.errors = s, s
        }
        var o = ce.derToOid(i.contentType);
        if (o !== He.pki.oids.data) throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
        if (i.encryptedContent) {
          var a = "";
          if (He.util.isArray(i.encryptedContent))
            for (var c = 0; c < i.encryptedContent.length; ++c) {
              if (i.encryptedContent[c].type !== ce.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
              a += i.encryptedContent[c].value
            } else a = i.encryptedContent;
          r.encryptedContent = {
            algorithm: ce.derToOid(i.encAlgorithm),
            parameter: He.util.createBuffer(i.encParameter.value),
            content: He.util.createBuffer(a)
          }
        }
        if (i.content) {
          var a = "";
          if (He.util.isArray(i.content))
            for (var c = 0; c < i.content.length; ++c) {
              if (i.content[c].type !== ce.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
              a += i.content[c].value
            } else a = i.content;
          r.content = He.util.createBuffer(a)
        }
        return r.version = i.version.charCodeAt(0), r.rawCapture = i, i
      }

      function L0e(r) {
        if (r.encryptedContent.key === void 0) throw new Error("Symmetric key not available.");
        if (r.content === void 0) {
          var e;
          switch (r.encryptedContent.algorithm) {
            case He.pki.oids["aes128-CBC"]:
            case He.pki.oids["aes192-CBC"]:
            case He.pki.oids["aes256-CBC"]:
              e = He.aes.createDecryptionCipher(r.encryptedContent.key);
              break;
            case He.pki.oids.desCBC:
            case He.pki.oids["des-EDE3-CBC"]:
              e = He.des.createDecryptionCipher(r.encryptedContent.key);
              break;
            default:
              throw new Error("Unsupported symmetric cipher, OID " + r.encryptedContent.algorithm)
          }
          if (e.start(r.encryptedContent.parameter), e.update(r.encryptedContent.content), !e.finish()) throw new Error("Symmetric decryption failed.");
          r.content = e.output
        }
      }
    });
    var z0e = y((eAt, U0e) => {
      l();
      "use strict";
      _R();
      var bst = At(),
        K0e = bst.pki,
        mst = (r, e) => {
          let t = K0e.setRsaPublicKey(e.n, e.e),
            i = K0e.createCertificate();
          i.publicKey = t, i.serialNumber = "01", i.validity.notBefore = new Date, i.validity.notAfter = new Date, i.validity.notAfter.setFullYear(i.validity.notBefore.getFullYear() + 10);
          let n = [{
            name: "organizationName",
            value: "ipfs"
          }, {
            shortName: "OU",
            value: "keystore"
          }, {
            name: "commonName",
            value: r.id
          }];
          return i.setSubject(n), i.setIssuer(n), i.setExtensions([{
            name: "basicConstraints",
            cA: !0
          }, {
            name: "keyUsage",
            keyCertSign: !0,
            digitalSignature: !0,
            nonRepudiation: !0,
            keyEncipherment: !0,
            dataEncipherment: !0
          }, {
            name: "extKeyUsage",
            serverAuth: !0,
            clientAuth: !0,
            codeSigning: !0,
            emailProtection: !0,
            timeStamping: !0
          }, {
            name: "nsCertType",
            client: !0,
            server: !0,
            email: !0,
            objsign: !0,
            sslCA: !0,
            emailCA: !0,
            objCA: !0
          }]), i.sign(e), i
        };
      async function vst(r, e) {
        let t = r.map(e),
          n = (await Promise.all(t)).findIndex(s => s);
        return r[n]
      }
      U0e.exports = {
        certificateForKey: mst,
        findAsync: vst
      }
    });
    var G0e = y((tAt, j0e) => {
      l();
      "use strict";
      F0e();
      iS();
      var Df = At(),
        {
          certificateForKey: wst,
          findAsync: _st
        } = z0e(),
        _p = xe(),
        V0e = gt(),
        Est = ct(),
        xR = new WeakMap,
        H0e = class {
          constructor(e, t) {
            if (!e) throw _p(new Error("keychain is required"), "ERR_KEYCHAIN_REQUIRED");
            this.keychain = e, xR.set(this, {
              dek: t
            })
          }
          async encrypt(e, t) {
            if (!(t instanceof Uint8Array)) throw _p(new Error("Plain data must be a Uint8Array"), "ERR_INVALID_PARAMS");
            let i = await this.keychain.findKeyByName(e),
              n = await this.keychain._getPrivateKey(e),
              s = xR.get(this).dek,
              o = Df.pki.decryptRsaPrivateKey(n, s),
              a = await wst(i, o),
              c = Df.pkcs7.createEnvelopedData();
            c.addRecipient(a), c.content = Df.util.createBuffer(t), c.encrypt();
            let u = Df.asn1.toDer(c.toAsn1()).getBytes();
            return V0e(u, "ascii")
          }
          async decrypt(e) {
            if (!(e instanceof Uint8Array)) throw _p(new Error("CMS data is required"), "ERR_INVALID_PARAMS");
            let t;
            try {
              let u = Df.util.createBuffer(Est(e, "ascii")),
                f = Df.asn1.fromDer(u);
              t = Df.pkcs7.messageFromAsn1(f)
            } catch (u) {
              throw _p(new Error("Invalid CMS: " + u.message), "ERR_INVALID_CMS")
            }
            let i = t.recipients.filter(u => u.issuer.find(f => f.shortName === "O" && f.value === "ipfs")).filter(u => u.issuer.find(f => f.shortName === "CN")).map(u => ({
              recipient: u,
              keyId: u.issuer.find(f => f.shortName === "CN").value
            })),
              n = await _st(i, async u => {
                try {
                  if (await this.keychain.findKeyById(u.keyId)) return !0
                } catch (f) {
                  return !1
                }
                return !1
              });
            if (!n) {
              let u = i.map(f => f.keyId);
              throw _p(new Error("Decryption needs one of the key(s): " + u.join(", ")), "ERR_MISSING_KEYS", {
                missingKeys: u
              })
            }
            let s = await this.keychain.findKeyById(n.keyId);
            if (!s) throw _p(new Error("No key available to decrypto"), "ERR_NO_KEY");
            let o = await this.keychain._getPrivateKey(s.name),
              a = xR.get(this).dek,
              c = Df.pki.decryptRsaPrivateKey(o, a);
            return t.decrypt(n.recipient, c), V0e(t.content.getBytes(), "ascii")
          }
        };
      j0e.exports = H0e
    });
    var Q0e = y((rAt, $0e) => {
      l();
      "use strict";
      var W0e = Oe(),
        Y0e = Object.assign(W0e("libp2p:keychain"), {
          error: W0e("libp2p:keychain:err")
        }),
        Sst = E0e(),
        xst = Yr(),
        wh = Ja(),
        {
          Key: J0e
        } = fr(),
        Ast = G0e(),
        Vr = xe(),
        _h = ct(),
        bu = gt();
      d2();
      var Ist = "/pkcs8/",
        X0e = "/info/",
        Lf = new WeakMap,
        Eh = {
          minKeyLength: 112 / 8,
          minSaltLength: 128 / 8,
          minIterationCount: 1e3
        },
        AR = {
          dek: {
            keyLength: 512 / 8,
            iterationCount: 1e4,
            salt: "you should override this value with a crypto secure random number",
            hash: "sha2-512"
          }
        };

      function mu(r) {
        return !r || typeof r != "string" ? !1 : r === Sst(r.trim())
      }
      async function lr(r) {
        let e = 200,
          t = 1e3,
          i = Math.random() * (t - e) + e;
        throw await new Promise(n => setTimeout(n, i)), r
      }

      function yc(r) {
        return new J0e(Ist + r)
      }

      function Ff(r) {
        return new J0e(X0e + r)
      }
      var Z0e = class {
        constructor(e, t) {
          if (!e) throw new Error("store is required");
          if (this.store = e, this.opts = xst(AR, t), this.opts.pass && this.opts.pass.length < 20) throw new Error("pass must be least 20 characters");
          if (this.opts.dek.keyLength < Eh.minKeyLength) throw new Error(`dek.keyLength must be least ${Eh.minKeyLength} bytes`);
          if (this.opts.dek.salt.length < Eh.minSaltLength) throw new Error(`dek.saltLength must be least ${Eh.minSaltLength} bytes`);
          if (this.opts.dek.iterationCount < Eh.minIterationCount) throw new Error(`dek.iterationCount must be least ${Eh.minIterationCount}`);
          let i = this.opts.pass ? wh.pbkdf2(this.opts.pass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : "";
          Lf.set(this, {
            dek: i
          })
        }
        get cms() {
          return new Ast(this, Lf.get(this).dek)
        }
        static generateOptions() {
          let e = Object.assign({}, AR),
            t = Math.ceil(Eh.minSaltLength / 3) * 3;
          return e.dek.salt = _h(wh.randomBytes(t), "base64"), e
        }
        static get options() {
          return AR
        }
        async createKey(e, t, i = 2048) {
          let n = this;
          if (!mu(e) || e === "self") return lr(Vr(new Error(`Invalid key name '${e}'`), "ERR_INVALID_KEY_NAME"));
          if (typeof t != "string") return lr(Vr(new Error(`Invalid key type '${t}'`), "ERR_INVALID_KEY_TYPE"));
          let s = yc(e);
          if (await n.store.has(s)) return lr(Vr(new Error(`Key '${e}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
          switch (t.toLowerCase()) {
            case "rsa":
              if (!Number.isSafeInteger(i) || i < 2048) return lr(Vr(new Error(`Invalid RSA key size ${i}`), "ERR_INVALID_KEY_SIZE"));
              break;
            default:
              break
          }
          let a;
          try {
            let c = await wh.keys.generateKeyPair(t, i),
              u = await c.id(),
              f = Lf.get(this).dek,
              h = await c.export(f);
            a = {
              name: e,
              id: u
            };
            let d = n.store.batch();
            d.put(s, bu(h)), d.put(Ff(e), bu(JSON.stringify(a))), await d.commit()
          } catch (c) {
            return lr(c)
          }
          return a
        }
        async listKeys() {
          let e = this,
            t = {
              prefix: X0e
            },
            i = [];
          for await (let n of e.store.query(t)) i.push(JSON.parse(_h(n.value)));
          return i
        }
        async findKeyById(e) {
          try {
            return (await this.listKeys()).find(i => i.id === e)
          } catch (t) {
            return lr(t)
          }
        }
        async findKeyByName(e) {
          if (!mu(e)) return lr(Vr(new Error(`Invalid key name '${e}'`), "ERR_INVALID_KEY_NAME"));
          let t = Ff(e);
          try {
            let i = await this.store.get(t);
            return JSON.parse(_h(i))
          } catch (i) {
            return lr(Vr(new Error(`Key '${e}' does not exist. ${i.message}`), "ERR_KEY_NOT_FOUND"))
          }
        }
        async removeKey(e) {
          let t = this;
          if (!mu(e) || e === "self") return lr(Vr(new Error(`Invalid key name '${e}'`), "ERR_INVALID_KEY_NAME"));
          let i = yc(e),
            n = await t.findKeyByName(e),
            s = t.store.batch();
          return s.delete(i), s.delete(Ff(e)), await s.commit(), n
        }
        async renameKey(e, t) {
          let i = this;
          if (!mu(e) || e === "self") return lr(Vr(new Error(`Invalid old key name '${e}'`), "ERR_OLD_KEY_NAME_INVALID"));
          if (!mu(t) || t === "self") return lr(Vr(new Error(`Invalid new key name '${t}'`), "ERR_NEW_KEY_NAME_INVALID"));
          let n = yc(e),
            s = yc(t),
            o = Ff(e),
            a = Ff(t);
          if (await i.store.has(s)) return lr(Vr(new Error(`Key '${t}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
          try {
            let u = await i.store.get(n),
              f = await i.store.get(o),
              h = JSON.parse(_h(f));
            h.name = t;
            let d = i.store.batch();
            return d.put(s, u), d.put(a, bu(JSON.stringify(h))), d.delete(n), d.delete(o), await d.commit(), h
          } catch (u) {
            return lr(u)
          }
        }
        async exportKey(e, t) {
          if (!mu(e)) return lr(Vr(new Error(`Invalid key name '${e}'`), "ERR_INVALID_KEY_NAME"));
          if (!t) return lr(Vr(new Error("Password is required"), "ERR_PASSWORD_REQUIRED"));
          let i = yc(e);
          try {
            let n = await this.store.get(i),
              s = _h(n),
              o = Lf.get(this).dek;
            return (await wh.keys.import(s, o)).export(t)
          } catch (n) {
            return lr(n)
          }
        }
        async importKey(e, t, i) {
          let n = this;
          if (!mu(e) || e === "self") return lr(Vr(new Error(`Invalid key name '${e}'`), "ERR_INVALID_KEY_NAME"));
          if (!t) return lr(Vr(new Error("PEM encoded key is required"), "ERR_PEM_REQUIRED"));
          let s = yc(e);
          if (await n.store.has(s)) return lr(Vr(new Error(`Key '${e}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
          let a;
          try {
            a = await wh.keys.import(t, i)
          } catch (h) {
            return lr(Vr(new Error("Cannot read the key, most likely the password is wrong"), "ERR_CANNOT_READ_KEY"))
          }
          let c;
          try {
            c = await a.id();
            let h = Lf.get(this).dek;
            t = await a.export(h)
          } catch (h) {
            return lr(h)
          }
          let u = {
            name: e,
            id: c
          },
            f = n.store.batch();
          return f.put(s, bu(t)), f.put(Ff(e), bu(JSON.stringify(u))), await f.commit(), u
        }
        async importPeer(e, t) {
          let i = this;
          if (!mu(e)) return lr(Vr(new Error(`Invalid key name '${e}'`), "ERR_INVALID_KEY_NAME"));
          if (!t || !t.privKey) return lr(Vr(new Error("Peer.privKey is required"), "ERR_MISSING_PRIVATE_KEY"));
          let n = t.privKey,
            s = yc(e);
          if (await i.store.has(s)) return lr(Vr(new Error(`Key '${e}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
          try {
            let a = await n.id(),
              c = Lf.get(this).dek,
              u = await n.export(c),
              f = {
                name: e,
                id: a
              },
              h = i.store.batch();
            return h.put(s, bu(u)), h.put(Ff(e), bu(JSON.stringify(f))), await h.commit(), f
          } catch (a) {
            return lr(a)
          }
        }
        async _getPrivateKey(e) {
          if (!mu(e)) return lr(Vr(new Error(`Invalid key name '${e}'`), "ERR_INVALID_KEY_NAME"));
          try {
            let t = yc(e),
              i = await this.store.get(t);
            return _h(i)
          } catch (t) {
            return lr(Vr(new Error(`Key '${e}' does not exist. ${t.message}`), "ERR_KEY_NOT_FOUND"))
          }
        }
        async rotateKeychainPass(e, t) {
          if (typeof e != "string") return lr(Vr(new Error(`Invalid old pass type '${typeof e}'`), "ERR_INVALID_OLD_PASS_TYPE"));
          if (typeof t != "string") return lr(Vr(new Error(`Invalid new pass type '${typeof t}'`), "ERR_INVALID_NEW_PASS_TYPE"));
          if (t.length < 20) return lr(Vr(new Error(`Invalid pass length ${t.length}`), "ERR_INVALID_PASS_LENGTH"));
          Y0e("recreating keychain");
          let i = Lf.get(this).dek;
          this.opts.pass = t;
          let n = t ? wh.pbkdf2(t, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : "";
          Lf.set(this, {
            dek: n
          });
          let s = await this.listKeys();
          for (let o of s) {
            let a = await this.store.get(yc(o.name)),
              c = _h(a),
              u = await wh.keys.import(c, i),
              f = n.toString(),
              h = await u.export(f),
              d = this.store.batch(),
              p = {
                name: o.name,
                id: o.id
              };
            d.put(yc(o.name), bu(h)), d.put(Ff(o.name), bu(JSON.stringify(p))), await d.commit()
          }
          Y0e("keychain reconstructed")
        }
      };
      $0e.exports = Z0e
    });
    var tpe = y((iAt, epe) => {
      l();
      "use strict";
      var Tst = ky();
      epe.exports = r => {
        let e = Tst(r);
        return e.delete = e.remove, e
      }
    });
    var IR = y((rpe, ipe) => {
      l();
      "use strict";
      var Rst = Math.exp;
      rpe = ipe.exports = function (e) {
        if (typeof e != "number") throw new Error("must provide a timespan to the moving average constructor");
        if (e <= 0) throw new Error("must provide a timespan > 0 to the moving average constructor");
        let t, i = 0,
          n = 0,
          s = 0,
          o, a = {};

        function c(u, f) {
          return 1 - Rst(-(u - f) / e)
        }
        return a.push = function (f, h) {
          if (o) {
            let d = c(f, o),
              p = h - t,
              g = d * p;
            t = d * h + (1 - d) * t, i = (1 - d) * (i + p * g), n = Math.sqrt(i), s = t + d * p
          } else t = h;
          o = f
        }, a.movingAverage = function () {
          return t
        }, a.variance = function () {
          return i
        }, a.deviation = function () {
          return n
        }, a.forecast = function () {
          return s
        }, a
      }
    });
    var ape = y((nAt, npe) => {
      l();
      "use strict";
      var {
        EventEmitter: kst
      } = Br(), {
        BigNumber: e6
      } = tc(), spe = IR(), Pst = rR(), ope = class extends kst {
        constructor(e, t) {
          super();
          this._options = t, this._queue = [], this._stats = {
            dataReceived: e6(0),
            dataSent: e6(0)
          }, this._frequencyLastTime = Date.now(), this._frequencyAccumulators = {}, this._movingAverages = {}, this._update = this._update.bind(this);
          let i = this._options.movingAverageIntervals;
          for (let n = 0; n < e.length; n++) {
            let s = e[n];
            this._stats[s] = e6(0), this._movingAverages[s] = {};
            for (let o = 0; o < i.length; o++) {
              let a = i[o];
              (this._movingAverages[s][a] = spe(a)).push(this._frequencyLastTime, 0)
            }
          }
        }
        start() {
          this._queue.length && this._resetComputeTimeout()
        }
        stop() {
          this._timeout && (this._timeout.clear(), this._timeout = null)
        }
        get snapshot() {
          return Object.assign({}, this._stats)
        }
        get movingAverages() {
          return Object.assign({}, this._movingAverages)
        }
        toJSON() {
          let e = this.snapshot,
            t = this.movingAverages,
            i = {
              dataReceived: e.dataReceived.toString(),
              dataSent: e.dataSent.toString(),
              movingAverages: {}
            },
            n = Object.keys(t);
          for (let s of n) {
            i.movingAverages[s] = {};
            for (let o of Object.keys(t[s])) i.movingAverages[s][o] = t[s][o].movingAverage()
          }
          return i
        }
        push(e, t) {
          this._queue.push([e, t, Date.now()]), this._resetComputeTimeout()
        }
        _resetComputeTimeout() {
          this._timeout = Pst(this._update, this._nextTimeout())
        }
        _nextTimeout() {
          let e = this._queue.length / this._options.computeThrottleMaxQueueSize;
          return Math.max(this._options.computeThrottleTimeout * (1 - e), 0)
        }
        _update() {
          if (this._timeout = null, this._queue.length) {
            let e;
            for (e of this._queue) this._applyOp(e);
            this._queue = [], this._updateFrequency(e[2]), this.emit("update", this._stats)
          }
        }
        _updateFrequency(e) {
          let t = e - this._frequencyLastTime;
          Object.keys(this._stats).forEach(i => {
            this._updateFrequencyFor(i, t, e)
          }), this._frequencyLastTime = e
        }
        _updateFrequencyFor(e, t, i) {
          let n = this._frequencyAccumulators[e] || 0;
          this._frequencyAccumulators[e] = 0;
          let o = n / (t || 1) * 1e3,
            a = this._movingAverages[e];
          a || (a = this._movingAverages[e] = {});
          let c = this._options.movingAverageIntervals;
          for (let u = 0; u < c.length; u++) {
            let f = c[u],
              h = a[f];
            h || (h = a[f] = spe(f)), h.push(i, o)
          }
        }
        _applyOp(e) {
          let t = e[0],
            i = e[1];
          if (typeof i != "number") throw new Error(`invalid increment number: ${i}`);
          let n;
          Object.prototype.hasOwnProperty.call(this._stats, t) ? n = this._stats[t] : n = this._stats[t] = e6(0), this._stats[t] = n.plus(i), this._frequencyAccumulators[t] || (this._frequencyAccumulators[t] = 0), this._frequencyAccumulators[t] += i
        }
      };
      npe.exports = ope
    });
    var fpe = y((sAt, cpe) => {
      l();
      "use strict";
      var Cst = Yr(),
        {
          pipe: Ost
        } = vi(),
        {
          tap: upe
        } = Ml(),
        Nst = tpe(),
        {
          METRICS: qst
        } = K_(),
        TR = ape(),
        RR = ["dataReceived", "dataSent"],
        Mst = {
          in: "dataReceived",
          out: "dataSent"
        },
        t6 = class {
          constructor(e) {
            this._options = Cst(qst, e), this._globalStats = new TR(RR, this._options), this._peerStats = new Map, this._protocolStats = new Map, this._oldPeers = Nst(this._options.maxOldPeersRetention), this._running = !1, this._onMessage = this._onMessage.bind(this), this._connectionManager = e.connectionManager, this._connectionManager.on("peer:disconnect", t => {
              this.onPeerDisconnected(t.remotePeer)
            })
          }
          start() {
            this._running = !0
          }
          stop() {
            this._running = !1, this._globalStats.stop();
            for (let e of this._peerStats.values()) e.stop();
            for (let e of this._protocolStats.values()) e.stop()
          }
          get global() {
            return this._globalStats
          }
          get peers() {
            return Array.from(this._peerStats.keys())
          }
          forPeer(e) {
            let t = e.toB58String();
            return this._peerStats.get(t) || this._oldPeers.get(t)
          }
          get protocols() {
            return Array.from(this._protocolStats.keys())
          }
          forProtocol(e) {
            return this._protocolStats.get(e)
          }
          onPeerDisconnected(e) {
            let t = e.toB58String(),
              i = this._peerStats.get(t);
            i && (i.stop(), this._peerStats.delete(t), this._oldPeers.set(t, i))
          }
          _onMessage({
            remotePeer: e,
            protocol: t,
            direction: i,
            dataLength: n
          }) {
            if (!this._running) return;
            let s = Mst[i],
              o = this.forPeer(e);
            if (o || (o = new TR(RR, this._options), this._peerStats.set(e.toB58String(), o)), o.push(s, n), this._globalStats.push(s, n), t) {
              let a = this.forProtocol(t);
              a || (a = new TR(RR, this._options), this._protocolStats.set(t, a)), a.push(s, n)
            }
          }
          updatePlaceholder(e, t) {
            if (!this._running) return;
            let i = this.forPeer(e),
              n = t.toB58String(),
              s = this.forPeer(t),
              o = i;
            s && (o = t6.mergeStats(s, o), this._oldPeers.delete(n)), this._peerStats.delete(e.toB58String()), this._peerStats.set(n, o), o.start()
          }
          trackStream({
            stream: e,
            remotePeer: t,
            protocol: i
          }) {
            let n = this,
              s = e.source;
            e.source = upe(a => n._onMessage({
              remotePeer: t,
              protocol: i,
              direction: "in",
              dataLength: a.length
            }))(s);
            let o = e.sink;
            return e.sink = a => Ost(a, upe(c => n._onMessage({
              remotePeer: t,
              protocol: i,
              direction: "out",
              dataLength: c.length
            })), o), e
          }
          static mergeStats(e, t) {
            return e.stop(), t.stop(), e._queue = [...e._queue, ...t._queue], e
          }
        };
      cpe.exports = t6
    });
    var r6 = y(Sh => {
      l();
      "use strict";
      var lpe = go(),
        hpe = da(),
        Bst = vi(),
        Dst = xe(),
        Lst = gt(),
        Fst = r0(),
        dpe = Lst(`
`);
      Sh.encode = r => hpe.encode.single(new lpe([r, dpe]));
      Sh.write = (r, e) => r.push(Sh.encode(e));
      Sh.writeAll = (r, e) => {
        r.push(e.reduce((t, i) => t.append(Sh.encode(i)), new lpe))
      };
      Sh.read = async r => {
        let e = 1,
          t = {
            [Symbol.asyncIterator]() {
              return this
            },
            next: () => r.next(e)
          },
          i = s => {
            e = s
          },
          n = await Bst(t, hpe.decode({
            onLength: i
          }), Fst);
        if (n.get(n.length - 1) !== dpe[0]) throw Dst(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
        return n.shallowSlice(0, -1)
      }
    });
    var ype = y((aAt, ppe) => {
      l();
      "use strict";
      var Ep = Oe()("mss:select"),
        Ust = xe(),
        Sp = r6(),
        Kst = gp();
      ppe.exports = async (r, e, t) => {
        e = Array.isArray(e) ? [...e] : [e];
        let {
          reader: i,
          writer: n,
          rest: s,
          stream: o
        } = Kst(r), a = e.shift();
        t ? (Ep('select: write ["%s", "%s"]', t, a), Sp.writeAll(n, [t, a])) : (Ep('select: write "%s"', a), Sp.write(n, a));
        let c = (await Sp.read(i)).toString();
        if (Ep('select: read "%s"', c), c === t && (c = (await Sp.read(i)).toString(), Ep('select: read "%s"', c)), c === a) return s(), {
          stream: o,
          protocol: a
        };
        for (let u of e) {
          Ep('select: write "%s"', u), Sp.write(n, u);
          let f = (await Sp.read(i)).toString();
          if (Ep('select: read "%s" for "%s"', f, u), f === u) return s(), {
            stream: o,
            protocol: u
          }
        }
        throw s(), Ust(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL")
      }
    });
    var kR = y(gpe => {
      l();
      "use strict";
      gpe.PROTOCOL_ID = "/multistream/1.0.0"
    });
    var mpe = y((uAt, bpe) => {
      l();
      "use strict";
      var Ib = Oe()("mss:handle"),
        zst = go(),
        xp = r6(),
        jst = gp(),
        {
          PROTOCOL_ID: PR
        } = kR();
      bpe.exports = async (r, e) => {
        e = Array.isArray(e) ? e : [e];
        let {
          writer: t,
          reader: i,
          rest: n,
          stream: s
        } = jst(r);
        for (; ;) {
          let o = (await xp.read(i)).toString();
          if (Ib('read "%s"', o), o === PR) {
            Ib('respond with "%s" for "%s"', PR, o), xp.write(t, PR);
            continue
          }
          if (e.includes(o)) return xp.write(t, o), Ib('respond with "%s" for "%s"', o, o), n(), {
            stream: s,
            protocol: o
          };
          if (o === "ls") {
            xp.write(t, new zst(e.map(a => xp.encode(a)))), Ib('respond with "%s" for %s', e, o);
            continue
          }
          xp.write(t, "na"), Ib('respond with "na" for "%s"', o)
        }
      }
    });
    var _pe = y((fAt, vpe) => {
      l();
      "use strict";
      var Vst = sR(),
        Hst = Oe()("it-multistream-select:ls"),
        wpe = r6(),
        Gst = gp(),
        $st = da(),
        Wst = vi();
      vpe.exports = async r => {
        let {
          reader: e,
          writer: t,
          rest: i,
          stream: n
        } = Gst(r);
        Hst('write "ls"'), wpe.write(t, "ls"), i();
        let s = await wpe.read(e),
          o = Vst([s]),
          a = [];
        return await Wst(o, $st.decode(), async c => {
          for await (let u of c) a.push(u.shallowSlice(0, -1).toString())
        }), {
          stream: n,
          protocols: a
        }
      }
    });
    var Ape = y(i6 => {
      l();
      "use strict";
      var Epe = ype(),
        Yst = mpe(),
        Jst = _pe(),
        {
          PROTOCOL_ID: CR
        } = kR();
      i6.PROTOCOL_ID = CR;
      var OR = class {
        constructor(e) {
          this._stream = e, this._shaken = !1
        }
        async _handshake() {
          if (this._shaken) return;
          let {
            stream: e
          } = await Epe(this._stream, CR);
          this._stream = e, this._shaken = !0
        }
      },
        Spe = class extends OR {
          select(e) {
            return Epe(this._stream, e, this._shaken ? null : CR)
          }
          async ls() {
            await this._handshake();
            let {
              stream: e,
              protocols: t
            } = await Jst(this._stream);
            return this._stream = e, t
          }
        };
      i6.Dialer = Spe;
      var xpe = class extends OR {
        handle(e) {
          return Yst(this._stream, e)
        }
      };
      i6.Listener = xpe
    });
    var Tpe = y((hAt, Ipe) => {
      l();
      "use strict";
      var Xst = {
        OPEN: "open",
        CLOSING: "closing",
        CLOSED: "closed"
      };
      Ipe.exports = Xst
    });
    var Npe = y((dAt, Rpe) => {
      l();
      "use strict";
      var kpe = Et(),
        {
          Multiaddr: Zst
        } = pr(),
        js = xe(),
        {
          OPEN: Qst,
          CLOSING: Ppe,
          CLOSED: NR
        } = Tpe(),
        Cpe = Symbol.for("@libp2p/interface-connection/connection"),
        Ope = class {
          constructor({
            localAddr: e,
            remoteAddr: t,
            localPeer: i,
            remotePeer: n,
            newStream: s,
            close: o,
            getStreams: a,
            stat: c
          }) {
            eot(e, i, n, s, o, a, c), this.id = parseInt(String(Math.random() * 1e9)).toString(36) + Date.now(), this.localAddr = e, this.remoteAddr = t, this.localPeer = i, this.remotePeer = n, this._stat = {
              ...c,
              status: Qst
            }, this._newStream = s, this._close = o, this._getStreams = a, this.registry = new Map, this.tags = []
          }
          get [Symbol.toStringTag]() {
            return "Connection"
          }
          get [Cpe]() {
            return !0
          }
          static isConnection(e) {
            return Boolean(e && e[Cpe])
          }
          get stat() {
            return this._stat
          }
          get streams() {
            return this._getStreams()
          }
          async newStream(e) {
            if (this.stat.status === Ppe) throw js(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
            if (this.stat.status === NR) throw js(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
            Array.isArray(e) || (e = [e]);
            let {
              stream: t,
              protocol: i
            } = await this._newStream(e);
            return this.addStream(t, {
              protocol: i
            }), {
              stream: t,
              protocol: i
            }
          }
          addStream(e, {
            protocol: t,
            metadata: i = {}
          }) {
            this.registry.set(e.id, {
              protocol: t,
              ...i
            })
          }
          removeStream(e) {
            this.registry.delete(e)
          }
          async close() {
            if (this.stat.status !== NR) {
              if (this._closing) return this._closing;
              this.stat.status = Ppe, this._closing = await this._close(), this._stat.timeline.close = Date.now(), this.stat.status = NR
            }
          }
        };
      Rpe.exports = Ope;

      function eot(r, e, t, i, n, s, o) {
        if (r && !Zst.isMultiaddr(r)) throw js(new Error("localAddr must be an instance of multiaddr"), "ERR_INVALID_PARAMETERS");
        if (!kpe.isPeerId(e)) throw js(new Error("localPeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS");
        if (!kpe.isPeerId(t)) throw js(new Error("remotePeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS");
        if (typeof i != "function") throw js(new Error("new stream must be a function"), "ERR_INVALID_PARAMETERS");
        if (typeof n != "function") throw js(new Error("close must be a function"), "ERR_INVALID_PARAMETERS");
        if (typeof s != "function") throw js(new Error("getStreams must be a function"), "ERR_INVALID_PARAMETERS");
        if (!o) throw js(new Error("connection metadata object must be provided"), "ERR_INVALID_PARAMETERS");
        if (o.direction !== "inbound" && o.direction !== "outbound") throw js(new Error('direction must be "inbound" or "outbound"'), "ERR_INVALID_PARAMETERS");
        if (!o.timeline) throw js(new Error("connection timeline object must be provided in the stat object"), "ERR_INVALID_PARAMETERS");
        if (!o.timeline.open) throw js(new Error("connection open timestamp must be provided"), "ERR_INVALID_PARAMETERS");
        if (!o.timeline.upgraded) throw js(new Error("connection upgraded timestamp must be provided"), "ERR_INVALID_PARAMETERS")
      }
    });
    var Mpe = y(qpe => {
      l();
      "use strict";
      qpe.Connection = Npe()
    });
    var Dpe = y((yAt, Bpe) => {
      l();
      "use strict";

      function tot(r) {
        if (Array.isArray(r)) {
          for (var e = 0, t = Array(r.length); e < r.length; e++) t[e] = r[e];
          return t
        } else return Array.from(r)
      }
      Bpe.exports = function (e) {
        var t = void 0,
          i = void 0;

        function n(a) {
          if (!(a instanceof Object)) throw new Error('Target "' + a + '" is not an object');
          i = a
        }

        function s(a) {
          Object.keys(a).forEach(function (c) {
            var u = a[c];
            if (typeof u != "function") throw new Error('Trap "' + c + ": " + u + '" is not a function');
            if (!Reflect[c]) throw new Error('Trap "' + c + ": " + u + '" is not a valid trap')
          }), t = a
        }
        n(function () { }), e && n(e), s(Reflect);
        var o = new Proxy({}, {
          get: function (c, u) {
            return function () {
              for (var f = arguments.length, h = Array(f), d = 0; d < f; d++) h[d] = arguments[d];
              return t[u].apply(null, [i].concat(tot(h.slice(1))))
            }
          }
        });
        return {
          setTarget: n,
          setHandler: s,
          getTarget: function () {
            return i
          },
          getHandler: function () {
            return t
          },
          proxy: new Proxy(i, o)
        }
      }
    });
    var zpe = y((gAt, Lpe) => {
      l();
      "use strict";
      var Fpe = Oe(),
        qi = Object.assign(Fpe("libp2p:upgrader"), {
          error: Fpe("libp2p:upgrader:err")
        }),
        xh = xe(),
        Ap = Ape(),
        {
          Connection: rot
        } = Mpe(),
        iot = Et(),
        {
          pipe: not
        } = vi(),
        Upe = Dpe(),
        {
          codes: Ip
        } = wi(),
        Kpe = class {
          constructor({
            localPeer: e,
            metrics: t,
            cryptos: i = new Map,
            muxers: n = new Map,
            onConnectionEnd: s = () => { },
            onConnection: o = () => { }
          }) {
            this.localPeer = e, this.metrics = t, this.cryptos = i, this.muxers = n, this.protector = null, this.protocols = new Map, this.onConnection = o, this.onConnectionEnd = s
          }
          async upgradeInbound(e) {
            let t, i, n, s, o, a, c;
            if (this.metrics) {
              ({
                setTarget: a,
                proxy: c
              } = Upe());
              let f = (Math.random() * 1e9).toString(36) + Date.now();
              a({
                toB58String: () => f
              }), e = this.metrics.trackStream({
                stream: e,
                remotePeer: c
              })
            }
            qi("Starting the inbound connection upgrade");
            let u = e;
            this.protector && (u = await this.protector.protect(e));
            try {
              ({
                conn: t,
                remotePeer: i,
                protocol: o
              } = await this._encryptInbound(this.localPeer, u, this.cryptos)), this.muxers.size ? {
                stream: n,
                Muxer: s
              } = await this._multiplexInbound(t, this.muxers) : n = t
            } catch (f) {
              throw qi.error("Failed to upgrade inbound connection", f), await e.close(f), f
            }
            return this.metrics && (this.metrics.updatePlaceholder(c, i), a(i)), qi("Successfully upgraded inbound connection"), this._createConnection({
              cryptoProtocol: o,
              direction: "inbound",
              maConn: e,
              upgradedConn: n,
              Muxer: s,
              remotePeer: i
            })
          }
          async upgradeOutbound(e) {
            let t = e.remoteAddr.getPeerId();
            if (!t) throw xh(new Error("outbound connection must have a peer id"), Ip.ERR_INVALID_MULTIADDR);
            let i = iot.createFromB58String(t),
              n, s, o, a, c, u, f;
            if (this.metrics) {
              ({
                setTarget: u,
                proxy: f
              } = Upe());
              let d = (Math.random() * 1e9).toString(36) + Date.now();
              u({
                toB58String: () => d
              }), e = this.metrics.trackStream({
                stream: e,
                remotePeer: f
              })
            }
            qi("Starting the outbound connection upgrade");
            let h = e;
            this.protector && (h = await this.protector.protect(e));
            try {
              ({
                conn: n,
                remotePeer: s,
                protocol: a
              } = await this._encryptOutbound(this.localPeer, h, i, this.cryptos)), this.muxers.size ? {
                stream: o,
                Muxer: c
              } = await this._multiplexOutbound(n, this.muxers) : o = n
            } catch (d) {
              throw qi.error("Failed to upgrade outbound connection", d), await e.close(d), d
            }
            return this.metrics && (this.metrics.updatePlaceholder(f, s), u(s)), qi("Successfully upgraded outbound connection"), this._createConnection({
              cryptoProtocol: a,
              direction: "outbound",
              maConn: e,
              upgradedConn: o,
              Muxer: c,
              remotePeer: s
            })
          }
          _createConnection({
            cryptoProtocol: e,
            direction: t,
            maConn: i,
            upgradedConn: n,
            Muxer: s,
            remotePeer: o
          }) {
            let a, c, u;
            s && (a = new s({
              onStream: async d => {
                if (!u) return;
                let p = new Ap.Listener(d);
                try {
                  let {
                    stream: g,
                    protocol: m
                  } = await p.handle(Array.from(this.protocols.keys()));
                  qi("%s: incoming stream opened on %s", t, m), this.metrics && this.metrics.trackStream({
                    stream: g,
                    remotePeer: o,
                    protocol: m
                  }), u.addStream(d, {
                    protocol: m
                  }), this._onStream({
                    connection: u,
                    stream: {
                      ...d,
                      ...g
                    },
                    protocol: m
                  })
                } catch (g) {
                  qi.error(g)
                }
              },
              onStreamEnd: d => {
                u.removeStream(d.id)
              }
            }), c = async d => {
              qi("%s: starting new stream on %s", t, d);
              let p = a.newStream(),
                g = new Ap.Dialer(p);
              try {
                let {
                  stream: m,
                  protocol: E
                } = await g.select(d);
                return this.metrics && this.metrics.trackStream({
                  stream: m,
                  remotePeer: o,
                  protocol: E
                }), {
                  stream: {
                    ...p,
                    ...m
                  },
                  protocol: E
                }
              } catch (m) {
                throw qi.error("could not create new stream", m), xh(m, Ip.ERR_UNSUPPORTED_PROTOCOL)
              }
            }, not(n, a, n).catch(qi.error));
            let f = i.timeline;
            i.timeline = new Proxy(f, {
              set: (...d) => (u && d[1] === "close" && d[2] && !f.close && (async () => {
                try {
                  u.stat.status === "open" && await u.close()
                } catch (p) {
                  qi.error(p)
                } finally {
                  this.onConnectionEnd(u)
                }
              })(), Reflect.set(...d))
            }), i.timeline.upgraded = Date.now();
            let h = () => {
              throw xh(new Error("connection is not multiplexed"), "ERR_CONNECTION_NOT_MULTIPLEXED")
            };
            return u = new rot({
              localAddr: i.localAddr,
              remoteAddr: i.remoteAddr,
              localPeer: this.localPeer,
              remotePeer: o,
              stat: {
                direction: t,
                timeline: i.timeline,
                multiplexer: s && s.multicodec,
                encryption: e
              },
              newStream: c || h,
              getStreams: () => a ? a.streams : h(),
              close: async () => {
                await i.close(), a && a.streams.map(d => d.abort())
              }
            }), this.onConnection(u), u
          }
          _onStream({
            connection: e,
            stream: t,
            protocol: i
          }) {
            this.protocols.get(i)({
              connection: e,
              stream: t,
              protocol: i
            })
          }
          async _encryptInbound(e, t, i) {
            let n = new Ap.Listener(t),
              s = Array.from(i.keys());
            qi("handling inbound crypto protocol selection", s);
            try {
              let {
                stream: o,
                protocol: a
              } = await n.handle(s), c = i.get(a);
              if (qi("encrypting inbound connection..."), !c) throw new Error(`no crypto module found for ${a}`);
              return {
                ...await c.secureInbound(e, o),
                protocol: a
              }
            } catch (o) {
              throw xh(o, Ip.ERR_ENCRYPTION_FAILED)
            }
          }
          async _encryptOutbound(e, t, i, n) {
            let s = new Ap.Dialer(t),
              o = Array.from(n.keys());
            qi("selecting outbound crypto protocol", o);
            try {
              let {
                stream: a,
                protocol: c
              } = await s.select(o), u = n.get(c);
              if (qi("encrypting outbound connection to %j", i), !u) throw new Error(`no crypto module found for ${c}`);
              return {
                ...await u.secureOutbound(e, a, i),
                protocol: c
              }
            } catch (a) {
              throw xh(a, Ip.ERR_ENCRYPTION_FAILED)
            }
          }
          async _multiplexOutbound(e, t) {
            let i = new Ap.Dialer(e),
              n = Array.from(t.keys());
            qi("outbound selecting muxer %s", n);
            try {
              let {
                stream: s,
                protocol: o
              } = await i.select(n);
              qi("%s selected as muxer protocol", o);
              let a = t.get(o);
              return {
                stream: s,
                Muxer: a
              }
            } catch (s) {
              throw xh(s, Ip.ERR_MUXER_UNAVAILABLE)
            }
          }
          async _multiplexInbound(e, t) {
            let i = new Ap.Listener(e),
              n = Array.from(t.keys());
            qi("inbound handling muxers %s", n);
            try {
              let {
                stream: s,
                protocol: o
              } = await i.handle(n), a = t.get(o);
              return {
                stream: s,
                Muxer: a
              }
            } catch (s) {
              throw xh(s, Ip.ERR_MUXER_UNAVAILABLE)
            }
          }
        };
      Lpe.exports = Kpe
    });
    var Tb = y((bAt, jpe) => {
      l();
      "use strict";
      var qR = xe(),
        Vpe = Et(),
        {
          codes: {
            ERR_INVALID_PARAMETERS: Hpe
          }
        } = wi(),
        sot = r => r,
        Gpe = class {
          constructor({
            peerStore: e,
            eventName: t,
            eventProperty: i,
            eventTransformer: n = sot
          }) {
            this._ps = e, this.eventName = t, this.eventProperty = i, this.eventTransformer = n, this.data = new Map
          }
          set(e, t) {
            throw qR(new Error("set must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED")
          }
          _setData(e, t, {
            emit: i = !0
          } = {}) {
            let n = e.toB58String();
            this.data.set(n, t), i && this._emit(e, t)
          }
          _emit(e, t) {
            this._ps.emit(this.eventName, {
              peerId: e,
              [this.eventProperty]: this.eventTransformer(t)
            })
          }
          get(e) {
            if (!Vpe.isPeerId(e)) throw qR(new Error("peerId must be an instance of peer-id"), Hpe);
            let t = this.data.get(e.toB58String());
            return t ? [...t] : void 0
          }
          delete(e) {
            if (!Vpe.isPeerId(e)) throw qR(new Error("peerId must be an instance of peer-id"), Hpe);
            return this.data.delete(e.toB58String()) ? (this._emit(e, []), !0) : !1
          }
        };
      jpe.exports = Gpe
    });
    var Jpe = y((mAt, $pe) => {
      l();
      "use strict";
      var Wpe = Oe(),
        ba = Object.assign(Wpe("libp2p:peer-store:address-book"), {
          error: Wpe("libp2p:peer-store:address-book:err")
        }),
        Tp = xe(),
        {
          Multiaddr: oot
        } = pr(),
        n6 = Et(),
        aot = Tb(),
        cot = V_(),
        {
          codes: {
            ERR_INVALID_PARAMETERS: Rp
          }
        } = wi(),
        uot = hb(),
        Ype = class extends aot {
          constructor(e) {
            super({
              peerStore: e,
              eventName: "change:multiaddrs",
              eventProperty: "multiaddrs",
              eventTransformer: t => t.addresses ? t.addresses.map(i => i.multiaddr) : []
            });
            this.data = new Map
          }
          consumePeerRecord(e) {
            let t;
            try {
              t = cot.createFromProtobuf(e.payload)
            } catch (c) {
              return ba.error("invalid peer record received"), !1
            }
            if (!t.peerId.equals(e.peerId)) return ba("signing key does not match PeerId in the PeerRecord"), !1;
            if (!t.multiaddrs || !t.multiaddrs.length) return !1;
            let i = t.peerId,
              n = i.toB58String(),
              o = (this.data.get(n) || {
                record: void 0
              }).record;
            if (o && o.seqNumber >= t.seqNumber) return !1;
            let a = this._toAddresses(t.multiaddrs, !0);
            return this._setData(i, {
              addresses: a,
              record: {
                raw: e.marshal(),
                seqNumber: t.seqNumber
              }
            }), ba(`stored provided peer record for ${n}`), !0
          }
          getRawEnvelope(e) {
            let t = this.data.get(e.toB58String());
            if (!(!t || !t.record || !t.record.raw)) return t.record.raw
          }
          getPeerRecord(e) {
            let t = this.getRawEnvelope(e);
            if (!!t) return uot.createFromProtobuf(t)
          }
          set(e, t) {
            if (!n6.isPeerId(e)) throw ba.error("peerId must be an instance of peer-id to store data"), Tp(new Error("peerId must be an instance of peer-id"), Rp);
            let i = this._toAddresses(t);
            if (!i.length) return this;
            let n = e.toB58String(),
              s = this.data.get(n);
            return s && s.addresses && s.addresses.length === i.length && s.addresses.filter(a => i.some(c => a.multiaddr.equals(c.multiaddr))).length === s.addresses.length ? (ba(`the addresses provided to store are equal to the already stored for ${n}`), this) : (this._setData(e, {
              addresses: i,
              record: s && s.record
            }), ba(`stored provided multiaddrs for ${n}`), s || this._ps.emit("peer", e), this)
          }
          add(e, t) {
            if (!n6.isPeerId(e)) throw ba.error("peerId must be an instance of peer-id to store data"), Tp(new Error("peerId must be an instance of peer-id"), Rp);
            let i = this._toAddresses(t),
              n = e.toB58String();
            if (!i.length) return this;
            let s = this.data.get(n);
            return s && s.addresses && (s.addresses.forEach(o => {
              i.find(a => a.multiaddr.equals(o.multiaddr)) || i.push(o)
            }), s.addresses.length === i.length) ? (ba(`the addresses provided to store are already stored for ${n}`), this) : (this._setData(e, {
              addresses: i,
              record: s && s.record
            }), ba(`added provided multiaddrs for ${n}`), s && s.addresses || this._ps.emit("peer", e), this)
          }
          get(e) {
            if (!n6.isPeerId(e)) throw Tp(new Error("peerId must be an instance of peer-id"), Rp);
            let t = this.data.get(e.toB58String());
            return t && t.addresses ? [...t.addresses] : void 0
          }
          _toAddresses(e, t = !1) {
            if (!e) throw ba.error("multiaddrs must be provided to store data"), Tp(new Error("multiaddrs must be provided"), Rp);
            let i = [];
            return e.forEach(n => {
              if (!oot.isMultiaddr(n)) throw ba.error(`multiaddr ${n} must be an instance of multiaddr`), Tp(new Error(`multiaddr ${n} must be an instance of multiaddr`), Rp);
              i.find(s => s.multiaddr.equals(n)) || i.push({
                multiaddr: n,
                isCertified: t
              })
            }), i
          }
          getMultiaddrsForPeer(e, t = i => i) {
            if (!n6.isPeerId(e)) throw Tp(new Error("peerId must be an instance of peer-id"), Rp);
            let i = this.data.get(e.toB58String());
            if (!(!i || !i.addresses)) return t(i.addresses || []).map(n => {
              let s = n.multiaddr,
                o = s.getPeerId();
              return o && o === e.toB58String() ? s : s.encapsulate(`/p2p/${e.toB58String()}`)
            })
          }
        };
      $pe.exports = Ype
    });
    var n1e = y((vAt, Xpe) => {
      l();
      "use strict";
      var Zpe = Oe(),
        Qpe = Object.assign(Zpe("libp2p:peer-store:key-book"), {
          error: Zpe("libp2p:peer-store:key-book:err")
        }),
        e1e = xe(),
        t1e = Et(),
        fot = Tb(),
        {
          codes: {
            ERR_INVALID_PARAMETERS: r1e
          }
        } = wi(),
        i1e = class extends fot {
          constructor(e) {
            super({
              peerStore: e,
              eventName: "change:pubkey",
              eventProperty: "pubkey",
              eventTransformer: t => t.pubKey
            });
            this.data = new Map
          }
          set(e, t) {
            if (!t1e.isPeerId(e)) throw Qpe.error("peerId must be an instance of peer-id to store data"), e1e(new Error("peerId must be an instance of peer-id"), r1e);
            let i = e.toB58String();
            return !this.data.get(i) && t && (e.pubKey = t, this._setData(e, e), Qpe(`stored provided public key for ${i}`)), this
          }
          get(e) {
            if (!t1e.isPeerId(e)) throw e1e(new Error("peerId must be an instance of peer-id"), r1e);
            let t = this.data.get(e.toB58String());
            return t ? t.pubKey : void 0
          }
        };
      Xpe.exports = i1e
    });
    var c1e = y((wAt, s1e) => {
      l();
      "use strict";
      var o1e = Oe(),
        MR = Object.assign(o1e("libp2p:peer-store:proto-book"), {
          error: o1e("libp2p:peer-store:proto-book:err")
        }),
        kp = xe(),
        lot = Lr(),
        Rb = Et(),
        hot = Tb(),
        {
          codes: {
            ERR_INVALID_PARAMETERS: Pp
          }
        } = wi(),
        a1e = class extends hot {
          constructor(e) {
            super({
              peerStore: e,
              eventName: "change:metadata",
              eventProperty: "metadata"
            });
            this.data = new Map
          }
          set(e, t, i) {
            if (!Rb.isPeerId(e)) throw MR.error("peerId must be an instance of peer-id to store data"), kp(new Error("peerId must be an instance of peer-id"), Pp);
            if (typeof t != "string" || !(i instanceof Uint8Array)) throw MR.error("valid key and value must be provided to store data"), kp(new Error("valid key and value must be provided"), Pp);
            return this._setValue(e, t, i), this
          }
          _setValue(e, t, i, {
            emit: n = !0
          } = {}) {
            let s = e.toB58String(),
              o = this.data.get(s) || new Map,
              a = o.get(t);
            if (a && lot(i, a)) {
              MR(`the metadata provided to store is equal to the already stored for ${s} on ${t}`);
              return
            }
            o.set(t, i), this.data.set(s, o), n && this._emit(e, t)
          }
          get(e) {
            if (!Rb.isPeerId(e)) throw kp(new Error("peerId must be an instance of peer-id"), Pp);
            return this.data.get(e.toB58String())
          }
          getValue(e, t) {
            if (!Rb.isPeerId(e)) throw kp(new Error("peerId must be an instance of peer-id"), Pp);
            let i = this.data.get(e.toB58String());
            return i && i.get(t)
          }
          delete(e) {
            if (!Rb.isPeerId(e)) throw kp(new Error("peerId must be an instance of peer-id"), Pp);
            return this.data.delete(e.toB58String()) ? (this._emit(e), !0) : !1
          }
          deleteValue(e, t) {
            if (!Rb.isPeerId(e)) throw kp(new Error("peerId must be an instance of peer-id"), Pp);
            let i = this.data.get(e.toB58String());
            return !i || !i.delete(t) ? !1 : (this._emit(e, t), !0)
          }
        };
      s1e.exports = a1e
    });
    var h1e = y((_At, u1e) => {
      l();
      "use strict";
      var f1e = Oe(),
        ma = Object.assign(f1e("libp2p:peer-store:proto-book"), {
          error: f1e("libp2p:peer-store:proto-book:err")
        }),
        Cp = xe(),
        BR = Et(),
        dot = Tb(),
        {
          codes: {
            ERR_INVALID_PARAMETERS: Op
          }
        } = wi(),
        l1e = class extends dot {
          constructor(e) {
            super({
              peerStore: e,
              eventName: "change:protocols",
              eventProperty: "protocols",
              eventTransformer: t => Array.from(t)
            });
            this.data = new Map
          }
          set(e, t) {
            if (!BR.isPeerId(e)) throw ma.error("peerId must be an instance of peer-id to store data"), Cp(new Error("peerId must be an instance of peer-id"), Op);
            if (!t) throw ma.error("protocols must be provided to store data"), Cp(new Error("protocols must be provided"), Op);
            let i = e.toB58String(),
              n = this.data.get(i),
              s = new Set(t);
            return n && ((a, c) => a.size === c.size && [...a].every(u => c.has(u)))(n, s) ? (ma(`the protocols provided to store are equal to the already stored for ${i}`), this) : (this._setData(e, s), ma(`stored provided protocols for ${i}`), this)
          }
          add(e, t) {
            if (!BR.isPeerId(e)) throw ma.error("peerId must be an instance of peer-id to store data"), Cp(new Error("peerId must be an instance of peer-id"), Op);
            if (!t) throw ma.error("protocols must be provided to store data"), Cp(new Error("protocols must be provided"), Op);
            let i = e.toB58String(),
              n = this.data.get(i) || new Set,
              s = new Set([...n, ...t]);
            return n.size === s.size ? (ma(`the protocols provided to store are already stored for ${i}`), this) : (this._setData(e, s), ma(`added provided protocols for ${i}`), this)
          }
          remove(e, t) {
            if (!BR.isPeerId(e)) throw ma.error("peerId must be an instance of peer-id to store data"), Cp(new Error("peerId must be an instance of peer-id"), Op);
            if (!t) throw ma.error("protocols must be provided to store data"), Cp(new Error("protocols must be provided"), Op);
            let i = e.toB58String(),
              n = this.data.get(i);
            if (n) {
              let s = new Set([...n].filter(o => !t.includes(o)));
              if (n.size === s.size) return this;
              this._setData(e, s), ma(`removed provided protocols for ${i}`)
            }
            return this
          }
        };
      u1e.exports = l1e
    });
    var DR = y((EAt, d1e) => {
      l();
      "use strict";
      var pot = xe(),
        {
          EventEmitter: yot
        } = Br(),
        p1e = Et(),
        got = Jpe(),
        bot = n1e(),
        mot = c1e(),
        vot = h1e(),
        {
          codes: {
            ERR_INVALID_PARAMETERS: wot
          }
        } = wi(),
        y1e = class extends yot {
          constructor({
            peerId: e
          }) {
            super();
            this._peerId = e, this.addressBook = new got(this), this.keyBook = new bot(this), this.metadataBook = new mot(this), this.protoBook = new vot(this)
          }
          start() { }
          stop() { }
          get peers() {
            let e = new Set([...this.addressBook.data.keys(), ...this.keyBook.data.keys(), ...this.protoBook.data.keys(), ...this.metadataBook.data.keys()]);
            this._peerId && e.delete(this._peerId.toB58String());
            let t = new Map;
            return e.forEach(i => {
              t.set(i, this.get(p1e.createFromCID(i)))
            }), t
          }
          delete(e) {
            let t = this.addressBook.delete(e),
              i = this.keyBook.delete(e),
              n = this.protoBook.delete(e),
              s = this.metadataBook.delete(e);
            return t || i || n || s
          }
          get(e) {
            if (!p1e.isPeerId(e)) throw pot(new Error("peerId must be an instance of peer-id"), wot);
            let t = this.keyBook.data.get(e.toB58String()),
              i = this.addressBook.get(e),
              n = this.metadataBook.get(e),
              s = this.protoBook.get(e);
            if (!(!t && !i && !n && !s)) return {
              id: t || e,
              addresses: i || [],
              protocols: s || [],
              metadata: n
            }
          }
        };
      d1e.exports = y1e
    });
    var b1e = y((SAt, g1e) => {
      l();
      "use strict";

      function _ot(r, e, t) {
        let i = new r(e, t);
        i._subscribeAdapter = i.subscribe, i._unsubscribeAdapter = i.unsubscribe;

        function n(o, a) {
          a && i.on(o, a), i._subscribeAdapter(o)
        }

        function s(o, a) {
          a ? i.removeListener(o, a) : i.removeAllListeners(o), i.listenerCount(o) === 0 && i._unsubscribeAdapter(o)
        }
        return i.subscribe = n, i.unsubscribe = s, i
      }
      g1e.exports = _ot
    });
    var m1e = y((xAt, Np) => {
      l();
      "use strict";
      Np.exports.NAMESPACE_COMMON = "/peers/";
      Np.exports.NAMESPACE_ADDRESS = "/peers/addrs/";
      Np.exports.NAMESPACE_KEYS = "/peers/keys/";
      Np.exports.NAMESPACE_METADATA = "/peers/metadata/";
      Np.exports.NAMESPACE_PROTOCOL = "/peers/protos/"
    });
    var w1e = y((AAt, v1e) => {
      l();
      "use strict";
      var Uf = bi(),
        qp = Uf.Reader,
        LR = Uf.Writer,
        si = Uf.util,
        Mi = Uf.roots["libp2p-address-book"] || (Uf.roots["libp2p-address-book"] = {});
      Mi.Addresses = function () {
        function r(e) {
          if (this.addrs = [], e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.addrs = si.emptyArray, r.prototype.certifiedRecord = null, r.encode = function (t, i) {
          if (i || (i = LR.create()), t.addrs != null && t.addrs.length)
            for (var n = 0; n < t.addrs.length; ++n) Mi.Addresses.Address.encode(t.addrs[n], i.uint32(10).fork()).ldelim();
          return t.certifiedRecord != null && Object.hasOwnProperty.call(t, "certifiedRecord") && Mi.Addresses.CertifiedRecord.encode(t.certifiedRecord, i.uint32(18).fork()).ldelim(), i
        }, r.decode = function (t, i) {
          t instanceof qp || (t = qp.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Mi.Addresses; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.addrs && s.addrs.length || (s.addrs = []), s.addrs.push(Mi.Addresses.Address.decode(t, t.uint32()));
                break;
              case 2:
                s.certifiedRecord = Mi.Addresses.CertifiedRecord.decode(t, t.uint32());
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Mi.Addresses) return t;
          var i = new Mi.Addresses;
          if (t.addrs) {
            if (!Array.isArray(t.addrs)) throw TypeError(".Addresses.addrs: array expected");
            i.addrs = [];
            for (var n = 0; n < t.addrs.length; ++n) {
              if (typeof t.addrs[n] != "object") throw TypeError(".Addresses.addrs: object expected");
              i.addrs[n] = Mi.Addresses.Address.fromObject(t.addrs[n])
            }
          }
          if (t.certifiedRecord != null) {
            if (typeof t.certifiedRecord != "object") throw TypeError(".Addresses.certifiedRecord: object expected");
            i.certifiedRecord = Mi.Addresses.CertifiedRecord.fromObject(t.certifiedRecord)
          }
          return i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if ((i.arrays || i.defaults) && (n.addrs = []), i.defaults && (n.certifiedRecord = null), t.addrs && t.addrs.length) {
            n.addrs = [];
            for (var s = 0; s < t.addrs.length; ++s) n.addrs[s] = Mi.Addresses.Address.toObject(t.addrs[s], i)
          }
          return t.certifiedRecord != null && t.hasOwnProperty("certifiedRecord") && (n.certifiedRecord = Mi.Addresses.CertifiedRecord.toObject(t.certifiedRecord, i)), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, Uf.util.toJSONOptions)
        }, r.Address = function () {
          function e(t) {
            if (t)
              for (var i = Object.keys(t), n = 0; n < i.length; ++n) t[i[n]] != null && (this[i[n]] = t[i[n]])
          }
          return e.prototype.multiaddr = si.newBuffer([]), e.prototype.isCertified = !1, e.encode = function (i, n) {
            return n || (n = LR.create()), i.multiaddr != null && Object.hasOwnProperty.call(i, "multiaddr") && n.uint32(10).bytes(i.multiaddr), i.isCertified != null && Object.hasOwnProperty.call(i, "isCertified") && n.uint32(16).bool(i.isCertified), n
          }, e.decode = function (i, n) {
            i instanceof qp || (i = qp.create(i));
            for (var s = n === void 0 ? i.len : i.pos + n, o = new Mi.Addresses.Address; i.pos < s;) {
              var a = i.uint32();
              switch (a >>> 3) {
                case 1:
                  o.multiaddr = i.bytes();
                  break;
                case 2:
                  o.isCertified = i.bool();
                  break;
                default:
                  i.skipType(a & 7);
                  break
              }
            }
            return o
          }, e.fromObject = function (i) {
            if (i instanceof Mi.Addresses.Address) return i;
            var n = new Mi.Addresses.Address;
            return i.multiaddr != null && (typeof i.multiaddr == "string" ? si.base64.decode(i.multiaddr, n.multiaddr = si.newBuffer(si.base64.length(i.multiaddr)), 0) : i.multiaddr.length && (n.multiaddr = i.multiaddr)), i.isCertified != null && (n.isCertified = Boolean(i.isCertified)), n
          }, e.toObject = function (i, n) {
            n || (n = {});
            var s = {};
            return n.defaults && (n.bytes === String ? s.multiaddr = "" : (s.multiaddr = [], n.bytes !== Array && (s.multiaddr = si.newBuffer(s.multiaddr))), s.isCertified = !1), i.multiaddr != null && i.hasOwnProperty("multiaddr") && (s.multiaddr = n.bytes === String ? si.base64.encode(i.multiaddr, 0, i.multiaddr.length) : n.bytes === Array ? Array.prototype.slice.call(i.multiaddr) : i.multiaddr), i.isCertified != null && i.hasOwnProperty("isCertified") && (s.isCertified = i.isCertified), s
          }, e.prototype.toJSON = function () {
            return this.constructor.toObject(this, Uf.util.toJSONOptions)
          }, e
        }(), r.CertifiedRecord = function () {
          function e(t) {
            if (t)
              for (var i = Object.keys(t), n = 0; n < i.length; ++n) t[i[n]] != null && (this[i[n]] = t[i[n]])
          }
          return e.prototype.seq = si.Long ? si.Long.fromBits(0, 0, !0) : 0, e.prototype.raw = si.newBuffer([]), e.encode = function (i, n) {
            return n || (n = LR.create()), i.seq != null && Object.hasOwnProperty.call(i, "seq") && n.uint32(8).uint64(i.seq), i.raw != null && Object.hasOwnProperty.call(i, "raw") && n.uint32(18).bytes(i.raw), n
          }, e.decode = function (i, n) {
            i instanceof qp || (i = qp.create(i));
            for (var s = n === void 0 ? i.len : i.pos + n, o = new Mi.Addresses.CertifiedRecord; i.pos < s;) {
              var a = i.uint32();
              switch (a >>> 3) {
                case 1:
                  o.seq = i.uint64();
                  break;
                case 2:
                  o.raw = i.bytes();
                  break;
                default:
                  i.skipType(a & 7);
                  break
              }
            }
            return o
          }, e.fromObject = function (i) {
            if (i instanceof Mi.Addresses.CertifiedRecord) return i;
            var n = new Mi.Addresses.CertifiedRecord;
            return i.seq != null && (si.Long ? (n.seq = si.Long.fromValue(i.seq)).unsigned = !0 : typeof i.seq == "string" ? n.seq = parseInt(i.seq, 10) : typeof i.seq == "number" ? n.seq = i.seq : typeof i.seq == "object" && (n.seq = new si.LongBits(i.seq.low >>> 0, i.seq.high >>> 0).toNumber(!0))), i.raw != null && (typeof i.raw == "string" ? si.base64.decode(i.raw, n.raw = si.newBuffer(si.base64.length(i.raw)), 0) : i.raw.length && (n.raw = i.raw)), n
          }, e.toObject = function (i, n) {
            n || (n = {});
            var s = {};
            if (n.defaults) {
              if (si.Long) {
                var o = new si.Long(0, 0, !0);
                s.seq = n.longs === String ? o.toString() : n.longs === Number ? o.toNumber() : o
              } else s.seq = n.longs === String ? "0" : 0;
              n.bytes === String ? s.raw = "" : (s.raw = [], n.bytes !== Array && (s.raw = si.newBuffer(s.raw)))
            }
            return i.seq != null && i.hasOwnProperty("seq") && (typeof i.seq == "number" ? s.seq = n.longs === String ? String(i.seq) : i.seq : s.seq = n.longs === String ? si.Long.prototype.toString.call(i.seq) : n.longs === Number ? new si.LongBits(i.seq.low >>> 0, i.seq.high >>> 0).toNumber(!0) : i.seq), i.raw != null && i.hasOwnProperty("raw") && (s.raw = n.bytes === String ? si.base64.encode(i.raw, 0, i.raw.length) : n.bytes === Array ? Array.prototype.slice.call(i.raw) : i.raw), s
          }, e.prototype.toJSON = function () {
            return this.constructor.toObject(this, Uf.util.toJSONOptions)
          }, e
        }(), r
      }();
      v1e.exports = Mi
    });
    var S1e = y((IAt, _1e) => {
      l();
      "use strict";
      var Mp = bi(),
        E1e = Mp.Reader,
        Eot = Mp.Writer,
        Sot = Mp.util,
        kb = Mp.roots["libp2p-proto-book"] || (Mp.roots["libp2p-proto-book"] = {});
      kb.Protocols = function () {
        function r(e) {
          if (this.protocols = [], e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.protocols = Sot.emptyArray, r.encode = function (t, i) {
          if (i || (i = Eot.create()), t.protocols != null && t.protocols.length)
            for (var n = 0; n < t.protocols.length; ++n) i.uint32(10).string(t.protocols[n]);
          return i
        }, r.decode = function (t, i) {
          t instanceof E1e || (t = E1e.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new kb.Protocols; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.protocols && s.protocols.length || (s.protocols = []), s.protocols.push(t.string());
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof kb.Protocols) return t;
          var i = new kb.Protocols;
          if (t.protocols) {
            if (!Array.isArray(t.protocols)) throw TypeError(".Protocols.protocols: array expected");
            i.protocols = [];
            for (var n = 0; n < t.protocols.length; ++n) i.protocols[n] = String(t.protocols[n])
          }
          return i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if ((i.arrays || i.defaults) && (n.protocols = []), t.protocols && t.protocols.length) {
            n.protocols = [];
            for (var s = 0; s < t.protocols.length; ++s) n.protocols[s] = t.protocols[s]
          }
          return n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, Mp.util.toJSONOptions)
        }, r
      }();
      _1e.exports = kb
    });
    var k1e = y((TAt, x1e) => {
      l();
      "use strict";
      var A1e = Oe(),
        rn = Object.assign(A1e("libp2p:persistent-peer-store"), {
          error: A1e("libp2p:persistent-peer-store:err")
        }),
        {
          Key: s6
        } = fr(),
        {
          Multiaddr: xot
        } = pr(),
        FR = Et(),
        Aot = DR(),
        {
          NAMESPACE_ADDRESS: Iot,
          NAMESPACE_COMMON: Tot,
          NAMESPACE_KEYS: Rot,
          NAMESPACE_METADATA: kot,
          NAMESPACE_PROTOCOL: Pot
        } = m1e(),
        {
          Addresses: I1e
        } = w1e(),
        {
          Protocols: T1e
        } = S1e(),
        R1e = class extends Aot {
          constructor({
            peerId: e,
            datastore: t,
            threshold: i = 5
          }) {
            super({
              peerId: e
            });
            this._datastore = t, this._dirtyPeers = new Set, this._dirtyMetadata = new Map, this.threshold = i, this._addDirtyPeer = this._addDirtyPeer.bind(this)
          }
          async start() {
            rn("PeerStore is starting"), this.on("change:protocols", this._addDirtyPeer), this.on("change:multiaddrs", this._addDirtyPeer), this.on("change:pubkey", this._addDirtyPeerKey), this.on("change:metadata", this._addDirtyPeerMetadata);
            for await (let e of this._datastore.query({
              prefix: Tot
            })) await this._processDatastoreEntry(e);
            rn("PeerStore started")
          }
          async stop() {
            rn("PeerStore is stopping"), this.removeAllListeners(), await this._commitData(), rn("PeerStore stopped")
          }
          _addDirtyPeer({
            peerId: e
          }) {
            let t = e.toB58String();
            rn("add dirty peer", t), this._dirtyPeers.add(t), this._dirtyPeers.size >= this.threshold && this._commitData().catch(i => {
              rn.error("error committing data", i)
            })
          }
          _addDirtyPeerKey({
            peerId: e
          }) {
            if (e.hasInlinePublicKey()) return;
            let t = e.toB58String();
            rn("add dirty peer key", t), this._dirtyPeers.add(t), this._dirtyPeers.size >= this.threshold && this._commitData().catch(i => {
              rn.error("error committing data", i)
            })
          }
          _addDirtyPeerMetadata({
            peerId: e,
            metadata: t
          }) {
            let i = e.toB58String();
            rn("add dirty metadata peer", i), this._dirtyPeers.add(i);
            let n = this._dirtyMetadata.get(i) || new Set;
            n.add(t), this._dirtyMetadata.set(i, n), this._dirtyPeers.size >= this.threshold && this._commitData().catch(s => {
              rn.error("error committing data", s)
            })
          }
          async _commitData() {
            let e = Array.from(this._dirtyPeers);
            if (!e.length) return;
            this._dirtyPeers.clear(), rn("create batch commit");
            let t = this._datastore.batch();
            for (let i of e) {
              let n = this.keyBook.data.get(i) || FR.createFromCID(i);
              this._batchAddressBook(n, t), !n.hasInlinePublicKey() && this._batchKeyBook(n, t), this._batchMetadataBook(n, t), this._batchProtoBook(n, t)
            }
            await t.commit(), rn("batch committed")
          }
          _batchAddressBook(e, t) {
            let i = e.toString(),
              n = new s6(`${Iot}${i}`),
              s = this.addressBook.data.get(e.toB58String());
            try {
              if (!s) {
                t.delete(n);
                return
              }
              let o = I1e.encode({
                addrs: s.addresses.map(a => ({
                  multiaddr: a.multiaddr.bytes,
                  isCertified: a.isCertified
                })),
                certifiedRecord: s.record ? {
                  seq: s.record.seqNumber,
                  raw: s.record.raw
                } : void 0
              }).finish();
              t.put(n, o)
            } catch (o) {
              rn.error(o)
            }
          }
          _batchKeyBook(e, t) {
            let i = e.toString(),
              n = new s6(`${Rot}${i}`);
            try {
              if (!e.pubKey) {
                t.delete(n);
                return
              }
              let s = e.marshalPubKey();
              t.put(n, s)
            } catch (s) {
              rn.error(s)
            }
          }
          _batchMetadataBook(e, t) {
            let i = e.toString(),
              n = this._dirtyMetadata.get(e.toB58String()) || [];
            try {
              n.forEach(s => {
                let o = new s6(`${kot}${i}/${s}`),
                  a = this.metadataBook.getValue(e, s);
                a ? t.put(o, a) : t.delete(o)
              })
            } catch (s) {
              rn.error(s)
            }
          }
          _batchProtoBook(e, t) {
            let i = e.toString(),
              n = new s6(`${Pot}${i}`),
              s = this.protoBook.get(e);
            try {
              if (!s) {
                t.delete(n);
                return
              }
              let o = T1e.encode({
                protocols: s
              }).finish();
              t.put(n, o)
            } catch (o) {
              rn.error(o)
            }
          }
          async _processDatastoreEntry({
            key: e,
            value: t
          }) {
            try {
              let i = e.toString().split("/"),
                n = FR.createFromCID(i[3]),
                s;
              switch (i[2]) {
                case "addrs":
                  s = I1e.decode(t), this.addressBook._setData(n, {
                    addresses: s.addrs.map(o => ({
                      multiaddr: new xot(o.multiaddr),
                      isCertified: Boolean(o.isCertified)
                    })),
                    record: s.certifiedRecord ? {
                      raw: s.certifiedRecord.raw,
                      seqNumber: s.certifiedRecord.seq
                    } : void 0
                  }, {
                    emit: !1
                  });
                  break;
                case "keys":
                  s = await FR.createFromPubKey(t), this.keyBook._setData(s, s, {
                    emit: !1
                  });
                  break;
                case "metadata":
                  this.metadataBook._setValue(n, i[4], t, {
                    emit: !1
                  });
                  break;
                case "protos":
                  s = T1e.decode(t), this.protoBook._setData(n, new Set(s.protocols), {
                    emit: !1
                  });
                  break;
                default:
                  rn("invalid data persisted for: ", e.toString())
              }
            } catch (i) {
              rn.error(i)
            }
          }
        };
      x1e.exports = R1e
    });
    var N1e = y((RAt, P1e) => {
      l();
      "use strict";
      var C1e = Oe(),
        Cot = Object.assign(C1e("libp2p:registrar"), {
          error: C1e("libp2p:registrar:err")
        }),
        Oot = xe(),
        {
          codes: {
            ERR_INVALID_PARAMETERS: Not
          }
        } = wi(),
        qot = c7(),
        O1e = class {
          constructor({
            peerStore: e,
            connectionManager: t
          }) {
            this.peerStore = e, this.connectionManager = t, this.topologies = new Map, this._handle = void 0, this._onDisconnect = this._onDisconnect.bind(this), this.connectionManager.on("peer:disconnect", this._onDisconnect)
          }
          get handle() {
            return this._handle
          }
          set handle(e) {
            this._handle = e
          }
          getConnection(e) {
            return this.connectionManager.get(e)
          }
          register(e) {
            if (!qot.isTopology(e)) throw Cot.error("topology must be an instance of interfaces/topology"), Oot(new Error("topology must be an instance of interfaces/topology"), Not);
            let t = (Math.random() * 1e9).toString(36) + Date.now();
            return this.topologies.set(t, e), e.registrar = this, t
          }
          unregister(e) {
            return this.topologies.delete(e)
          }
          _onDisconnect(e) {
            for (let [, t] of this.topologies) t.disconnect(e.remotePeer)
          }
        };
      P1e.exports = O1e
    });
    var c6 = y((kAt, Pb) => {
      l();
      "use strict";
      var {
        Buffer: o6
      } = Wt(), a6 = go();
      Pb.exports = async function* (r) {
        for await (let e of r) o6.isBuffer(e) ? yield e : a6.isBufferList(e) ? yield e.slice() : yield o6.from(e)
      };
      Pb.exports.toBuffer = Pb.exports;
      Pb.exports.toList = async function* (r) {
        for await (let e of r) o6.isBuffer(e) ? yield new a6().append(e) : a6.isBufferList(e) ? yield e : yield new a6().append(o6.from(e))
      }
    });
    var M1e = y((PAt, q1e) => {
      l();
      "use strict";
      q1e.exports = {
        PROTOCOL: "/ipfs/ping/1.0.0",
        PING_LENGTH: 32
      }
    });
    var F1e = y((u6, B1e) => {
      l();
      "use strict";
      var D1e = Oe(),
        Mot = Object.assign(D1e("libp2p:ping"), {
          error: D1e("libp2p:ping:err")
        }),
        Bot = xe(),
        Dot = Ja(),
        {
          pipe: L1e
        } = vi(),
        {
          toBuffer: Lot
        } = c6(),
        {
          collect: Fot,
          take: Uot
        } = Ml(),
        Kot = Lr(),
        {
          PROTOCOL: f6,
          PING_LENGTH: zot
        } = M1e();
      async function jot(r, e) {
        Mot("dialing %s to %s", f6, e.toB58String ? e.toB58String() : e);
        let t = await r.dial(e),
          {
            stream: i
          } = await t.newStream(f6),
          n = Date.now(),
          s = Dot.randomBytes(zot),
          [o] = await L1e([s], i, c => Uot(1, c), Lot, Fot),
          a = Date.now();
        if (!Kot(s, o)) throw Bot(new Error("Received wrong ping ack"), "ERR_WRONG_PING_ACK");
        return a - n
      }

      function Vot(r) {
        r.handle(f6, ({
          stream: e
        }) => L1e(e, e))
      }

      function Hot(r) {
        r.unhandle(f6)
      }
      u6 = B1e.exports = jot;
      u6.mount = Vot;
      u6.unmount = Hot
    });
    var z1e = y((CAt, U1e) => {
      l();
      "use strict";
      var Bp = bi(),
        K1e = Bp.Reader,
        Got = Bp.Writer,
        Hr = Bp.util,
        Cb = Bp.roots["libp2p-identify"] || (Bp.roots["libp2p-identify"] = {});
      Cb.Identify = function () {
        function r(e) {
          if (this.listenAddrs = [], this.protocols = [], e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.protocolVersion = "", r.prototype.agentVersion = "", r.prototype.publicKey = Hr.newBuffer([]), r.prototype.listenAddrs = Hr.emptyArray, r.prototype.observedAddr = Hr.newBuffer([]), r.prototype.protocols = Hr.emptyArray, r.prototype.signedPeerRecord = Hr.newBuffer([]), r.encode = function (t, i) {
          if (i || (i = Got.create()), t.publicKey != null && Object.hasOwnProperty.call(t, "publicKey") && i.uint32(10).bytes(t.publicKey), t.listenAddrs != null && t.listenAddrs.length)
            for (var n = 0; n < t.listenAddrs.length; ++n) i.uint32(18).bytes(t.listenAddrs[n]);
          if (t.protocols != null && t.protocols.length)
            for (var n = 0; n < t.protocols.length; ++n) i.uint32(26).string(t.protocols[n]);
          return t.observedAddr != null && Object.hasOwnProperty.call(t, "observedAddr") && i.uint32(34).bytes(t.observedAddr), t.protocolVersion != null && Object.hasOwnProperty.call(t, "protocolVersion") && i.uint32(42).string(t.protocolVersion), t.agentVersion != null && Object.hasOwnProperty.call(t, "agentVersion") && i.uint32(50).string(t.agentVersion), t.signedPeerRecord != null && Object.hasOwnProperty.call(t, "signedPeerRecord") && i.uint32(66).bytes(t.signedPeerRecord), i
        }, r.decode = function (t, i) {
          t instanceof K1e || (t = K1e.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Cb.Identify; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 5:
                s.protocolVersion = t.string();
                break;
              case 6:
                s.agentVersion = t.string();
                break;
              case 1:
                s.publicKey = t.bytes();
                break;
              case 2:
                s.listenAddrs && s.listenAddrs.length || (s.listenAddrs = []), s.listenAddrs.push(t.bytes());
                break;
              case 4:
                s.observedAddr = t.bytes();
                break;
              case 3:
                s.protocols && s.protocols.length || (s.protocols = []), s.protocols.push(t.string());
                break;
              case 8:
                s.signedPeerRecord = t.bytes();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Cb.Identify) return t;
          var i = new Cb.Identify;
          if (t.protocolVersion != null && (i.protocolVersion = String(t.protocolVersion)), t.agentVersion != null && (i.agentVersion = String(t.agentVersion)), t.publicKey != null && (typeof t.publicKey == "string" ? Hr.base64.decode(t.publicKey, i.publicKey = Hr.newBuffer(Hr.base64.length(t.publicKey)), 0) : t.publicKey.length && (i.publicKey = t.publicKey)), t.listenAddrs) {
            if (!Array.isArray(t.listenAddrs)) throw TypeError(".Identify.listenAddrs: array expected");
            i.listenAddrs = [];
            for (var n = 0; n < t.listenAddrs.length; ++n) typeof t.listenAddrs[n] == "string" ? Hr.base64.decode(t.listenAddrs[n], i.listenAddrs[n] = Hr.newBuffer(Hr.base64.length(t.listenAddrs[n])), 0) : t.listenAddrs[n].length && (i.listenAddrs[n] = t.listenAddrs[n])
          }
          if (t.observedAddr != null && (typeof t.observedAddr == "string" ? Hr.base64.decode(t.observedAddr, i.observedAddr = Hr.newBuffer(Hr.base64.length(t.observedAddr)), 0) : t.observedAddr.length && (i.observedAddr = t.observedAddr)), t.protocols) {
            if (!Array.isArray(t.protocols)) throw TypeError(".Identify.protocols: array expected");
            i.protocols = [];
            for (var n = 0; n < t.protocols.length; ++n) i.protocols[n] = String(t.protocols[n])
          }
          return t.signedPeerRecord != null && (typeof t.signedPeerRecord == "string" ? Hr.base64.decode(t.signedPeerRecord, i.signedPeerRecord = Hr.newBuffer(Hr.base64.length(t.signedPeerRecord)), 0) : t.signedPeerRecord.length && (i.signedPeerRecord = t.signedPeerRecord)), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if ((i.arrays || i.defaults) && (n.listenAddrs = [], n.protocols = []), i.defaults && (i.bytes === String ? n.publicKey = "" : (n.publicKey = [], i.bytes !== Array && (n.publicKey = Hr.newBuffer(n.publicKey))), i.bytes === String ? n.observedAddr = "" : (n.observedAddr = [], i.bytes !== Array && (n.observedAddr = Hr.newBuffer(n.observedAddr))), n.protocolVersion = "", n.agentVersion = "", i.bytes === String ? n.signedPeerRecord = "" : (n.signedPeerRecord = [], i.bytes !== Array && (n.signedPeerRecord = Hr.newBuffer(n.signedPeerRecord)))), t.publicKey != null && t.hasOwnProperty("publicKey") && (n.publicKey = i.bytes === String ? Hr.base64.encode(t.publicKey, 0, t.publicKey.length) : i.bytes === Array ? Array.prototype.slice.call(t.publicKey) : t.publicKey), t.listenAddrs && t.listenAddrs.length) {
            n.listenAddrs = [];
            for (var s = 0; s < t.listenAddrs.length; ++s) n.listenAddrs[s] = i.bytes === String ? Hr.base64.encode(t.listenAddrs[s], 0, t.listenAddrs[s].length) : i.bytes === Array ? Array.prototype.slice.call(t.listenAddrs[s]) : t.listenAddrs[s]
          }
          if (t.protocols && t.protocols.length) {
            n.protocols = [];
            for (var s = 0; s < t.protocols.length; ++s) n.protocols[s] = t.protocols[s]
          }
          return t.observedAddr != null && t.hasOwnProperty("observedAddr") && (n.observedAddr = i.bytes === String ? Hr.base64.encode(t.observedAddr, 0, t.observedAddr.length) : i.bytes === Array ? Array.prototype.slice.call(t.observedAddr) : t.observedAddr), t.protocolVersion != null && t.hasOwnProperty("protocolVersion") && (n.protocolVersion = t.protocolVersion), t.agentVersion != null && t.hasOwnProperty("agentVersion") && (n.agentVersion = t.agentVersion), t.signedPeerRecord != null && t.hasOwnProperty("signedPeerRecord") && (n.signedPeerRecord = i.bytes === String ? Hr.base64.encode(t.signedPeerRecord, 0, t.signedPeerRecord.length) : i.bytes === Array ? Array.prototype.slice.call(t.signedPeerRecord) : t.signedPeerRecord), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, Bp.util.toJSONOptions)
        }, r
      }();
      U1e.exports = Cb
    });
    var X1e = y((OAt, j1e) => {
      l();
      "use strict";
      var V1e = Oe(),
        gc = Object.assign(V1e("libp2p:identify"), {
          error: V1e("libp2p:identify:err")
        }),
        UR = xe(),
        l6 = da(),
        {
          pipe: h6
        } = vi(),
        {
          collect: H1e,
          take: G1e,
          consume: $1e
        } = Ml(),
        Dp = gt(),
        $ot = Et(),
        {
          Multiaddr: KR
        } = pr(),
        {
          toBuffer: W1e
        } = c6(),
        Ob = z1e(),
        Y1e = hb(),
        J1e = V_(),
        {
          MULTICODEC_IDENTIFY: zR,
          MULTICODEC_IDENTIFY_PUSH: d6,
          PROTOCOL_VERSION: Wot
        } = V7(),
        {
          codes: jR
        } = wi(),
        Lp = class {
          constructor({
            libp2p: e
          }) {
            this._libp2p = e, this.peerStore = e.peerStore, this.addressManager = e.addressManager, this.connectionManager = e.connectionManager, this.peerId = e.peerId, this.handleMessage = this.handleMessage.bind(this), this._host = {
              protocolVersion: Wot,
              ...e._options.host
            }, this.peerStore.metadataBook.set(this.peerId, "AgentVersion", Dp(this._host.agentVersion)), this.peerStore.metadataBook.set(this.peerId, "ProtocolVersion", Dp(this._host.protocolVersion)), this.connectionManager.on("peer:connect", t => {
              this.identify(t).catch(gc.error)
            }), this.peerStore.on("change:multiaddrs", ({
              peerId: t
            }) => {
              t.toString() === this.peerId.toString() && this.pushToPeerStore()
            }), this.peerStore.on("change:protocols", ({
              peerId: t
            }) => {
              t.toString() === this.peerId.toString() && this.pushToPeerStore()
            })
          }
          async push(e) {
            let t = await this.peerStore.addressBook.getRawEnvelope(this.peerId),
              i = this._libp2p.multiaddrs.map(o => o.bytes),
              n = this.peerStore.protoBook.get(this.peerId) || [],
              s = e.map(async o => {
                try {
                  let {
                    stream: a
                  } = await o.newStream(d6);
                  await h6([Ob.Identify.encode({
                    listenAddrs: i,
                    signedPeerRecord: t,
                    protocols: n
                  }).finish()], l6.encode(), a, $1e)
                } catch (a) {
                  gc.error("could not push identify update to peer", a)
                }
              });
            return Promise.all(s)
          }
          pushToPeerStore() {
            if (!this._libp2p.isStarted()) return;
            let e = [],
              t;
            for (let i of this.peerStore.peers.values()) i.protocols.includes(d6) && (t = this.connectionManager.get(i.id)) && e.push(t);
            this.push(e)
          }
          async identify(e) {
            let {
              stream: t
            } = await e.newStream(zR), [i] = await h6([], t, l6.decode(), G1e(1), W1e, H1e);
            if (!i) throw UR(new Error("No data could be retrieved"), jR.ERR_CONNECTION_ENDED);
            let n;
            try {
              n = Ob.Identify.decode(i)
            } catch (d) {
              throw UR(d, jR.ERR_INVALID_MESSAGE)
            }
            let {
              publicKey: s,
              listenAddrs: o,
              protocols: a,
              observedAddr: c,
              signedPeerRecord: u
            } = n, f = await $ot.createFromPubKey(s);
            if (e.remotePeer.toB58String() !== f.toB58String()) throw UR(new Error("identified peer does not match the expected peer"), jR.ERR_INVALID_PEER);
            let h = Lp.getCleanMultiaddr(c);
            try {
              let d = await Y1e.openAndCertify(u, J1e.DOMAIN);
              if (this.peerStore.addressBook.consumePeerRecord(d)) {
                this.peerStore.protoBook.set(f, a), this.peerStore.metadataBook.set(f, "AgentVersion", Dp(n.agentVersion)), this.peerStore.metadataBook.set(f, "ProtocolVersion", Dp(n.protocolVersion));
                return
              }
            } catch (d) {
              gc("received invalid envelope, discard it and fallback to listenAddrs is available", d)
            }
            try {
              this.peerStore.addressBook.set(f, o.map(d => new KR(d)))
            } catch (d) {
              gc.error("received invalid addrs", d)
            }
            this.peerStore.protoBook.set(f, a), this.peerStore.metadataBook.set(f, "AgentVersion", Dp(n.agentVersion)), this.peerStore.metadataBook.set(f, "ProtocolVersion", Dp(n.protocolVersion)), gc("received observed address of %s", h)
          }
          handleMessage({
            connection: e,
            stream: t,
            protocol: i
          }) {
            switch (i) {
              case zR:
                return this._handleIdentify({
                  connection: e,
                  stream: t
                });
              case d6:
                return this._handlePush({
                  connection: e,
                  stream: t
                });
              default:
                gc.error("cannot handle unknown protocol %s", i)
            }
          }
          async _handleIdentify({
            connection: e,
            stream: t
          }) {
            let i = new Uint8Array(0);
            this.peerId.pubKey && (i = this.peerId.pubKey.bytes);
            let n = await this.peerStore.addressBook.getRawEnvelope(this.peerId),
              s = this.peerStore.protoBook.get(this.peerId) || [],
              o = Ob.Identify.encode({
                protocolVersion: this._host.protocolVersion,
                agentVersion: this._host.agentVersion,
                publicKey: i,
                listenAddrs: this._libp2p.multiaddrs.map(a => a.bytes),
                signedPeerRecord: n,
                observedAddr: e.remoteAddr.bytes,
                protocols: s
              }).finish();
            try {
              await h6([o], l6.encode(), t, $1e)
            } catch (a) {
              gc.error("could not respond to identify request", a)
            }
          }
          async _handlePush({
            connection: e,
            stream: t
          }) {
            let i;
            try {
              let [s] = await h6([], t, l6.decode(), G1e(1), W1e, H1e);
              i = Ob.Identify.decode(s)
            } catch (s) {
              return gc.error("received invalid message", s)
            }
            let n = e.remotePeer;
            try {
              let s = await Y1e.openAndCertify(i.signedPeerRecord, J1e.DOMAIN);
              if (this.peerStore.addressBook.consumePeerRecord(s)) {
                this.peerStore.protoBook.set(n, i.protocols);
                return
              }
            } catch (s) {
              gc("received invalid envelope, discard it and fallback to listenAddrs is available", s)
            }
            try {
              this.peerStore.addressBook.set(n, i.listenAddrs.map(s => new KR(s)))
            } catch (s) {
              gc.error("received invalid addrs", s)
            }
            this.peerStore.protoBook.set(n, i.protocols)
          }
          static getCleanMultiaddr(e) {
            if (e && e.length > 0) try {
              return new KR(e)
            } catch (t) {
              return null
            }
            return null
          }
        },
        Yot = {
          IDENTIFY: zR,
          IDENTIFY_PUSH: d6
        };
      Lp.multicodecs = Yot;
      Lp.Messsage = Ob;
      j1e.exports = Lp
    });
    var Z1e = y(() => {
      l()
    });
    var eye = y(VR => {
      l();
      "use strict";
      Object.defineProperty(VR, "__esModule", {
        value: !0
      });
      VR.promisify = p6;
      var Q1e = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__";

      function p6(r) {
        if (typeof r != "function") throw new TypeError("Argument to promisify must be a function");
        var e = r[Q1e],
          t = p6.Promise || Promise;
        if (typeof t != "function") throw new Error("No Promise implementation found; do you need a polyfill?");
        return function () {
          for (var i = this, n = arguments.length, s = new Array(n), o = 0; o < n; o++) s[o] = arguments[o];
          return new t(function (a, c) {
            s.push(function (f) {
              if (f) return c(f);
              for (var h = arguments.length, d = new Array(h > 1 ? h - 1 : 0), p = 1; p < h; p++) d[p - 1] = arguments[p];
              if (d.length === 1 || !e) return a(d[0]);
              var g = {};
              d.forEach(function (m, E) {
                var w = e[E];
                w && (g[w] = m)
              }), a(g)
            }), r.apply(i, s)
          })
        }
      }
      p6.argumentNames = Q1e;
      p6.Promise = void 0
    });
    var rye = y((BAt, tye) => {
      l();
      "use strict";
      var Jot = km(),
        y6 = typeof window == "object" && typeof document == "object" && document.nodeType === 9,
        Nb = Jot(),
        Xot = y6 && !Nb,
        Zot = Nb && !y6,
        Qot = Nb && y6,
        eat = typeof process != "undefined" && typeof process.release != "undefined" && process.release.name === "node" && !Nb,
        tat = typeof importScripts == "function" && typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope,
        rat = typeof process != "undefined" && typeof process.env != "undefined" && process.env.NODE_ENV === "test";
      tye.exports = {
        isTest: rat,
        isElectron: Nb,
        isElectronMain: Zot,
        isElectronRenderer: Qot,
        isNode: eat,
        isBrowser: Xot,
        isWebWorker: tat,
        isEnvWithDom: y6
      }
    });
    var nye = y((DAt, iye) => {
      l();

      function To(r, e) {
        typeof e == "boolean" && (e = {
          forever: e
        }), this._originalTimeouts = JSON.parse(JSON.stringify(r)), this._timeouts = r, this._options = e || {}, this._maxRetryTime = e && e.maxRetryTime || Infinity, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0))
      }
      iye.exports = To;
      To.prototype.reset = function () {
        this._attempts = 1, this._timeouts = this._originalTimeouts
      };
      To.prototype.stop = function () {
        this._timeout && clearTimeout(this._timeout), this._timeouts = [], this._cachedTimeouts = null
      };
      To.prototype.retry = function (r) {
        if (this._timeout && clearTimeout(this._timeout), !r) return !1;
        var e = new Date().getTime();
        if (r && e - this._operationStart >= this._maxRetryTime) return this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
        this._errors.push(r);
        var t = this._timeouts.shift();
        if (t === void 0)
          if (this._cachedTimeouts) this._errors.splice(this._errors.length - 1, this._errors.length), this._timeouts = this._cachedTimeouts.slice(0), t = this._timeouts.shift();
          else return !1;
        var i = this,
          n = setTimeout(function () {
            i._attempts++, i._operationTimeoutCb && (i._timeout = setTimeout(function () {
              i._operationTimeoutCb(i._attempts)
            }, i._operationTimeout), i._options.unref && i._timeout.unref()), i._fn(i._attempts)
          }, t);
        return this._options.unref && n.unref(), !0
      };
      To.prototype.attempt = function (r, e) {
        this._fn = r, e && (e.timeout && (this._operationTimeout = e.timeout), e.cb && (this._operationTimeoutCb = e.cb));
        var t = this;
        this._operationTimeoutCb && (this._timeout = setTimeout(function () {
          t._operationTimeoutCb()
        }, t._operationTimeout)), this._operationStart = new Date().getTime(), this._fn(this._attempts)
      };
      To.prototype.try = function (r) {
        console.log("Using RetryOperation.try() is deprecated"), this.attempt(r)
      };
      To.prototype.start = function (r) {
        console.log("Using RetryOperation.start() is deprecated"), this.attempt(r)
      };
      To.prototype.start = To.prototype.try;
      To.prototype.errors = function () {
        return this._errors
      };
      To.prototype.attempts = function () {
        return this._attempts
      };
      To.prototype.mainError = function () {
        if (this._errors.length === 0) return null;
        for (var r = {}, e = null, t = 0, i = 0; i < this._errors.length; i++) {
          var n = this._errors[i],
            s = n.message,
            o = (r[s] || 0) + 1;
          r[s] = o, o >= t && (e = n, t = o)
        }
        return e
      }
    });
    var sye = y(Ah => {
      l();
      var iat = nye();
      Ah.operation = function (r) {
        var e = Ah.timeouts(r);
        return new iat(e, {
          forever: r && r.forever,
          unref: r && r.unref,
          maxRetryTime: r && r.maxRetryTime
        })
      };
      Ah.timeouts = function (r) {
        if (r instanceof Array) return [].concat(r);
        var e = {
          retries: 10,
          factor: 2,
          minTimeout: 1 * 1e3,
          maxTimeout: Infinity,
          randomize: !1
        };
        for (var t in r) e[t] = r[t];
        if (e.minTimeout > e.maxTimeout) throw new Error("minTimeout is greater than maxTimeout");
        for (var i = [], n = 0; n < e.retries; n++) i.push(this.createTimeout(n, e));
        return r && r.forever && !i.length && i.push(this.createTimeout(n, e)), i.sort(function (s, o) {
          return s - o
        }), i
      };
      Ah.createTimeout = function (r, e) {
        var t = e.randomize ? Math.random() + 1 : 1,
          i = Math.round(t * e.minTimeout * Math.pow(e.factor, r));
        return i = Math.min(i, e.maxTimeout), i
      };
      Ah.wrap = function (r, e, t) {
        if (e instanceof Array && (t = e, e = null), !t) {
          t = [];
          for (var i in r) typeof r[i] == "function" && t.push(i)
        }
        for (var n = 0; n < t.length; n++) {
          var s = t[n],
            o = r[s];
          r[s] = function (c) {
            var u = Ah.operation(e),
              f = Array.prototype.slice.call(arguments, 1),
              h = f.pop();
            f.push(function (d) {
              u.retry(d) || (d && (arguments[0] = u.mainError()), h.apply(this, arguments))
            }), u.attempt(function () {
              c.apply(r, f)
            })
          }.bind(r, o), r[s].options = e
        }
      }
    });
    var aye = y((FAt, oye) => {
      l();
      oye.exports = sye()
    });
    var uye = y((UAt, g6) => {
      l();
      "use strict";
      var nat = aye(),
        sat = ["Failed to fetch", "NetworkError when attempting to fetch resource", "The Internet connection appears to be offline", "Network request failed"],
        HR = class extends Error {
          constructor(e) {
            super();
            e instanceof Error ? (this.originalError = e, {
              message: e
            } = e) : (this.originalError = new Error(e), this.originalError.stack = this.stack), this.name = "AbortError", this.message = e
          }
        },
        oat = (r, e, t) => {
          let i = t.retries - (e - 1);
          return r.attemptNumber = e, r.retriesLeft = i, r
        },
        aat = r => sat.includes(r),
        cye = (r, e) => new Promise((t, i) => {
          e = {
            onFailedAttempt: () => { },
            retries: 10,
            ...e
          };
          let n = nat.operation(e);
          n.attempt(async s => {
            try {
              t(await r(s))
            } catch (o) {
              if (!(o instanceof Error)) {
                i(new TypeError(`Non-error was thrown: "${o}". You should only throw errors.`));
                return
              }
              if (o instanceof HR) n.stop(), i(o.originalError);
              else if (o instanceof TypeError && !aat(o.message)) n.stop(), i(o);
              else {
                oat(o, s, e);
                try {
                  await e.onFailedAttempt(o)
                } catch (a) {
                  i(a);
                  return
                }
                n.retry(o) || i(n.mainError())
              }
            }
          })
        });
      g6.exports = cye;
      g6.exports.default = cye;
      g6.exports.AbortError = HR
    });
    var lye = y((KAt, fye) => {
      l();
      "use strict";

      function cat(r) {
        return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r) || /^::1$/.test(r)
      }
      fye.exports = cat
    });
    var dye = y((zAt, hye) => {
      l();
      "use strict";
      var uat = lye();

      function fat(r) {
        let {
          address: e
        } = r.nodeAddress();
        return uat(e)
      }
      hye.exports = fat
    });
    var vye = y((jAt, pye) => {
      l();
      "use strict";
      var lat = Z1e(),
        yye = Oe(),
        {
          promisify: GR
        } = eye(),
        {
          Multiaddr: hat
        } = pr(),
        Fp = Object.assign(yye("libp2p:nat"), {
          error: yye("libp2p:nat:err")
        }),
        {
          isBrowser: gye
        } = rye(),
        $R = uye(),
        dat = H7(),
        bye = j7(),
        pat = xe(),
        {
          codes: {
            ERR_INVALID_PARAMETERS: yat
          }
        } = wi(),
        gat = dye(),
        WR = 7200;

      function bat(r = 1024, e = 65535) {
        return Math.floor(Math.random() * (e - r + 1) + r)
      }
      var mye = class {
        constructor({
          peerId: e,
          addressManager: t,
          transportManager: i,
          ...n
        }) {
          if (this._peerId = e, this._addressManager = t, this._transportManager = i, this._enabled = n.enabled, this._externalIp = n.externalIp, this._options = {
            description: n.description || `${bye.name}@${bye.version} ${this._peerId}`,
            ttl: n.ttl || WR,
            autoUpdate: n.keepAlive || !0,
            gateway: n.gateway,
            enablePMP: Boolean(n.pmp && n.pmp.enabled)
          }, this._options.ttl < WR) throw pat(new Error(`NatManager ttl should be at least ${WR} seconds`), yat)
        }
        start() {
          gye || !this._enabled || this._start().catch(e => {
            Fp.error(e)
          })
        }
        async _start() {
          let e = this._transportManager.getAddrs();
          for (let t of e) {
            let {
              family: i,
              host: n,
              port: s,
              transport: o
            } = t.toOptions();
            if (!t.isThinWaistAddress() || o !== "tcp" || gat(t) || i !== 4) continue;
            let a = this._getClient(),
              c = this._externalIp || await a.externalIp();
            if (dat(c)) throw new Error(`${c} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
            let u = bat();
            Fp(`opening uPnP connection from ${c}:${u} to ${n}:${s}`), await a.map({
              publicPort: u,
              privatePort: s,
              protocol: o.toUpperCase()
            }), this._addressManager.addObservedAddr(hat.fromNodeAddress({
              family: 4,
              address: c,
              port: u
            }, o))
          }
        }
        _getClient() {
          if (this._client) return this._client;
          let e = new lat(this._options),
            t = GR(e.map.bind(e)),
            i = GR(e.destroy.bind(e)),
            n = GR(e.externalIp.bind(e));
          return this._client = {
            map: (...s) => $R(() => t(...s), {
              onFailedAttempt: Fp.error,
              unref: !0
            }),
            destroy: (...s) => $R(() => i(...s), {
              onFailedAttempt: Fp.error,
              unref: !0
            }),
            externalIp: (...s) => $R(() => n(...s), {
              onFailedAttempt: Fp.error,
              unref: !0
            })
          }, this._client
        }
        async stop() {
          if (!(gye || !this._client)) try {
            await this._client.destroy(), this._client = null
          } catch (e) {
            Fp.error(e)
          }
        }
      };
      pye.exports = mye
    });
    var Aye = y((VAt, wye) => {
      l();
      "use strict";
      var _ye = Oe(),
        Vs = Object.assign(_ye("libp2p"), {
          error: _ye("libp2p:err")
        }),
        {
          EventEmitter: mat
        } = Br(),
        YR = xe(),
        vat = Et(),
        {
          Multiaddr: wat
        } = pr(),
        _at = Ele(),
        Eat = Ale(),
        JR = z7(),
        {
          validate: Sat
        } = Rhe(),
        {
          codes: b6,
          messages: xat
        } = wi(),
        Aat = Che(),
        Iat = $he(),
        Eye = Ade(),
        Tat = Ude(),
        Rat = d0e(),
        Sye = Q0e(),
        kat = fpe(),
        Pat = Q7(),
        Cat = zpe(),
        Oat = DR(),
        Nat = b1e(),
        qat = k1e(),
        Mat = N1e(),
        m6 = F1e(),
        xye = X1e(),
        Bat = xye.multicodecs,
        Dat = vye(),
        {
          updateSelfPeerRecord: Lat
        } = X7(),
        qb = class extends mat {
          static async create(e) {
            if (e.peerId) return new qb(e);
            let t = await vat.create();
            return e.peerId = t, new qb(e)
          }
          constructor(e) {
            super();
            if (this._options = Sat(e), this.peerId = this._options.peerId, this.datastore = this._options.datastore, this.peerStore = this.datastore && this._options.peerStore.persistence ? new qat({
              peerId: this.peerId,
              datastore: this.datastore,
              ...this._options.peerStore
            }) : new Oat({
              peerId: this.peerId
            }), this.addresses = this._options.addresses, this.addressManager = new Aat(this.peerId, this._options.addresses), this.addressManager.on("change:addresses", () => {
              Lat(this).catch(i => {
                Vs.error("Error updating self peer record", i)
              })
            }), this._modules = this._options.modules, this._config = this._options.config, this._transport = [], this._discovery = new Map, this.connectionManager = new Iat(this, {
              autoDial: this._config.peerDiscovery.autoDial,
              ...this._options.connectionManager
            }), this._options.metrics.enabled && (this.metrics = new kat({
              ...this._options.metrics,
              connectionManager: this.connectionManager
            })), this._options.keychain && this._options.keychain.datastore) {
              Vs("creating keychain");
              let i = Sye.generateOptions();
              this.keychain = new Sye(this._options.keychain.datastore, {
                ...i,
                ...this._options.keychain
              }), Vs("keychain constructed")
            }
            if (this.upgrader = new Cat({
              localPeer: this.peerId,
              metrics: this.metrics,
              onConnection: i => this.connectionManager.onConnect(i),
              onConnectionEnd: i => this.connectionManager.onDisconnect(i)
            }), this.transportManager = new Pat({
              libp2p: this,
              upgrader: this.upgrader,
              faultTolerance: this._options.transportManager.faultTolerance
            }), this.natManager = new Dat({
              peerId: this.peerId,
              addressManager: this.addressManager,
              transportManager: this.transportManager,
              ...this._options.config.nat
            }), this.registrar = new Mat({
              peerStore: this.peerStore,
              connectionManager: this.connectionManager
            }), this.handle = this.handle.bind(this), this.registrar.handle = this.handle, !this._modules.connEncryption || !this._modules.connEncryption.length) throw YR(new Error(xat.CONN_ENCRYPTION_REQUIRED), b6.CONN_ENCRYPTION_REQUIRED);
            if (this._modules.connEncryption.forEach(i => {
              this.upgrader.cryptos.set(i.protocol, i)
            }), this.dialer = new Rat({
              transportManager: this.transportManager,
              peerStore: this.peerStore,
              ...this._options.dialer
            }), this._modules.transport.forEach(i => {
              let n = i.prototype[Symbol.toStringTag],
                s = this._config.transport[n];
              this.transportManager.add(n, i, s)
            }), this._config.relay.enabled && (this.transportManager.add(Eye.prototype[Symbol.toStringTag], Eye), this.relay = new Tat(this)), this._modules.streamMuxer && (this._modules.streamMuxer.forEach(n => {
              this.upgrader.muxers.set(n.multicodec, n)
            }), this.identifyService = new xye({
              libp2p: this
            }), this.handle(Object.values(Bat), this.identifyService.handleMessage)), this._modules.connProtector) this.upgrader.protector = this._modules.connProtector;
            else if (globalThis.process !== void 0 && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) throw new Error("Private network is enforced, but no protector was provided");
            if (this._modules.dht) {
              let i = this._modules.dht;
              this._dht = new i({
                libp2p: this,
                dialer: this.dialer,
                peerId: this.peerId,
                peerStore: this.peerStore,
                registrar: this.registrar,
                datastore: this.datastore,
                ...this._config.dht
              })
            }
            if (this._modules.pubsub) {
              let i = this._modules.pubsub;
              this.pubsub = Nat(i, this, this._config.pubsub)
            }
            this.peerRouting = new _at(this), this.contentRouting = new Eat(this), m6.mount(this), this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this)
          }
          emit(e, ...t) {
            return e === "error" && !this._events.error ? (Vs.error(t), !1) : super.emit(e, ...t)
          }
          async start() {
            Vs("libp2p is starting");
            try {
              await this._onStarting(), await this._onDidStart(), Vs("libp2p has started")
            } catch (e) {
              throw this.emit("error", e), Vs.error("An error occurred starting libp2p", e), await this.stop(), e
            }
          }
          async stop() {
            Vs("libp2p is stopping");
            try {
              this._isStarted = !1, this.relay && this.relay.stop(), this.peerRouting.stop();
              for (let e of this._discovery.values()) e.removeListener("peer", this._onDiscoveryPeer);
              await Promise.all(Array.from(this._discovery.values(), e => e.stop())), this._discovery = new Map, await this.peerStore.stop(), await this.connectionManager.stop(), await Promise.all([this.pubsub && this.pubsub.stop(), this._dht && this._dht.stop(), this.metrics && this.metrics.stop()]), await this.natManager.stop(), await this.transportManager.close(), m6.unmount(this), this.dialer.destroy()
            } catch (e) {
              e && (Vs.error(e), this.emit("error", e))
            }
            Vs("libp2p has stopped")
          }
          async loadKeychain() {
            if (!!this.keychain) try {
              await this.keychain.findKeyByName("self")
            } catch (e) {
              await this.keychain.importPeer("self", this.peerId)
            }
          }
          isStarted() {
            return this._isStarted
          }
          get connections() {
            return this.connectionManager.connections
          }
          dial(e, t) {
            return this._dial(e, t)
          }
          async dialProtocol(e, t, i) {
            if (!t || !t.length) throw YR(new Error("no protocols were provided to open a stream"), b6.ERR_INVALID_PROTOCOLS_FOR_STREAM);
            return (await this._dial(e, i)).newStream(t)
          }
          async _dial(e, t) {
            let {
              id: i,
              multiaddrs: n
            } = JR(e);
            if (i.equals(this.peerId)) throw YR(new Error("Cannot dial self"), b6.ERR_DIALED_SELF);
            let s = this.connectionManager.get(i);
            return s ? n && this.peerStore.addressBook.add(i, n) : s = await this.dialer.connectToPeer(e, t), s
          }
          get multiaddrs() {
            let e = this.addressManager.getAnnounceAddrs().map(n => n.toString());
            e.length || (e = this.transportManager.getAddrs().map(n => n.toString())), e = e.concat(this.addressManager.getObservedAddrs().map(n => n.toString()));
            let t = this._options.addresses.announceFilter,
              i = new Set(e);
            return t(Array.from(i).map(n => new wat(n)))
          }
          async hangUp(e) {
            let {
              id: t
            } = JR(e), i = this.connectionManager.connections.get(t.toB58String());
            !i || await Promise.all(i.map(n => n.close()))
          }
          ping(e) {
            let {
              id: t,
              multiaddrs: i
            } = JR(e);
            return i ? m6(this, i[0]) : m6(this, t)
          }
          handle(e, t) {
            e = Array.isArray(e) ? e : [e], e.forEach(i => {
              this.upgrader.protocols.set(i, t)
            }), this.peerStore.protoBook.add(this.peerId, e)
          }
          unhandle(e) {
            e = Array.isArray(e) ? e : [e], e.forEach(t => {
              this.upgrader.protocols.delete(t)
            }), this.peerStore.protoBook.remove(this.peerId, e)
          }
          async _onStarting() {
            let e = this.addressManager.getListenAddrs();
            await this.transportManager.listen(e), this.natManager.start(), await this.peerStore.start(), this._config.pubsub.enabled && this.pubsub && this.pubsub.start(), this._config.dht.enabled && (this._dht && this._dht.start(), this._dht.on("peer", this._onDiscoveryPeer)), this.metrics && this.metrics.start()
          }
          async _onDidStart() {
            this._isStarted = !0, this.peerStore.on("peer", e => {
              this.emit("peer:discovery", e), this._maybeConnect(e)
            });
            for (let e of this.peerStore.peers.values()) this.emit("peer:discovery", e.id);
            this.connectionManager.start(), await this._setupPeerDiscovery(), this.relay && this.relay.start(), this.peerRouting.start()
          }
          _onDiscoveryPeer(e) {
            if (e.id.toB58String() === this.peerId.toB58String()) {
              Vs.error(new Error(b6.ERR_DISCOVERED_SELF));
              return
            }
            e.multiaddrs && this.peerStore.addressBook.add(e.id, e.multiaddrs), e.protocols && this.peerStore.protoBook.set(e.id, e.protocols)
          }
          async _maybeConnect(e) {
            if (this._config.peerDiscovery.autoDial === !0 && !this.connectionManager.get(e) && (this._options.connectionManager.minConnections || 0) > this.connectionManager.size) {
              Vs("connecting to discovered peer %s", e.toB58String());
              try {
                await this.dialer.connectToPeer(e)
              } catch (i) {
                Vs.error(`could not connect to discovered peer ${e.toB58String()} with ${i}`)
              }
            }
          }
          async _setupPeerDiscovery() {
            let e = t => {
              let i = {
                enabled: !0
              };
              if (t.tag && this._config.peerDiscovery && this._config.peerDiscovery[t.tag] && (i = {
                ...i,
                ...this._config.peerDiscovery[t.tag]
              }), i.enabled && !this._discovery.has(t.tag)) {
                let n;
                typeof t == "function" ? n = new t(Object.assign({}, i, {
                  peerId: this.peerId,
                  libp2p: this
                })) : n = t, n.on("peer", this._onDiscoveryPeer), this._discovery.set(t.tag, n)
              }
            };
            for (let t of this._modules.peerDiscovery || []) e(t);
            for (let t of this.transportManager.getTransports()) t.discovery && e(t.discovery);
            await Promise.all(Array.from(this._discovery.values(), t => t.start()))
          }
        };
      wye.exports = qb
    });
    var Iye = y(() => {
      l()
    });
    var Rye = y(($At, Tye) => {
      l();
      Tye.exports = typeof WebSocket == "undefined" ? Iye() : WebSocket
    });
    var Pye = y(v6 => {
      l();
      "use strict";
      Object.defineProperty(v6, "__esModule", {
        value: !0
      });
      var kye = class {
        constructor() {
          this.pullQueue = [], this.pushQueue = [], this.eventHandlers = {}, this.isPaused = !1, this.isStopped = !1
        }
        push(e) {
          if (this.isStopped) return;
          let t = {
            value: e,
            done: !1
          };
          if (this.pullQueue.length) {
            let i = this.pullQueue.shift();
            i && i.resolve(t)
          } else this.pushQueue.push(Promise.resolve(t)), this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused && (this.isPaused = !0, this.eventHandlers.highWater ? this.eventHandlers.highWater() : console && console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))
        }
        stop() {
          if (!this.isStopped) {
            this.isStopped = !0, this.remove();
            for (let e of this.pullQueue) e.resolve({
              value: void 0,
              done: !0
            });
            this.pullQueue.length = 0
          }
        }
        fail(e) {
          if (!this.isStopped)
            if (this.isStopped = !0, this.remove(), this.pullQueue.length) {
              for (let t of this.pullQueue) t.reject(e);
              this.pullQueue.length = 0
            } else {
              let t = Promise.reject(e);
              t.catch(() => { }), this.pushQueue.push(t)
            }
        }
        remove() {
          Promise.resolve().then(() => {
            this.removeCallback && this.removeCallback()
          })
        } [Symbol.asyncIterator]() {
          return {
            next: e => {
              let t = this.pushQueue.shift();
              return t ? (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused && (this.isPaused = !1, this.eventHandlers.lowWater && this.eventHandlers.lowWater()), t) : this.isStopped ? Promise.resolve({
                value: void 0,
                done: !0
              }) : new Promise((i, n) => {
                this.pullQueue.push({
                  resolve: i,
                  reject: n
                })
              })
            },
            return: () => (this.isStopped = !0, this.pushQueue.length = 0, this.remove(), Promise.resolve({
              value: void 0,
              done: !0
            }))
          }
        }
      },
        XR = class {
          constructor(e, {
            highWaterMark: t = 100,
            lowWaterMark: i = 1
          } = {}) {
            let n = new kye;
            n.highWaterMark = t, n.lowWaterMark = i, n.removeCallback = e({
              push: s => n.push(s),
              stop: () => n.stop(),
              fail: s => n.fail(s),
              on: (s, o) => {
                n.eventHandlers[s] = o
              }
            }) || (() => { }), this[Symbol.asyncIterator] = () => n[Symbol.asyncIterator](), Object.freeze(this)
          }
        };
      v6.EventIterator = XR;
      v6.default = XR
    });
    var Cye = y(Mb => {
      l();
      "use strict";
      Object.defineProperty(Mb, "__esModule", {
        value: !0
      });
      var ZR = Pye();
      Mb.EventIterator = ZR.EventIterator;

      function Fat(r, e, t) {
        return new ZR.EventIterator(({
          push: i
        }) => (this.addEventListener(r, i, e), () => this.removeEventListener(r, i, e)), t)
      }
      Mb.subscribe = Fat;
      Mb.default = ZR.EventIterator
    });
    var Nye = y((JAt, Oye) => {
      l();
      var {
        Buffer: Uat
      } = Wt(), {
        EventIterator: Kat
      } = Cye();

      function zat(r) {
        return r instanceof ArrayBuffer || r != null && r.constructor != null && r.constructor.name === "ArrayBuffer" && typeof r.byteLength == "number"
      }
      Oye.exports = r => {
        let e = r.removeEventListener || r.removeListener,
          t = async function* () {
            let s = new Kat(({
              push: o,
              stop: a,
              fail: c
            }) => (r.addEventListener("message", o), r.addEventListener("error", c), r.addEventListener("close", a), () => {
              e.call(r, "message", o), e.call(r, "error", c), e.call(r, "close", a)
            }), {
              highWaterMark: Infinity
            });
            for await (let {
              data: o
            } of s) yield zat(o) ? Uat.from(o) : o
          }(), i = r.readyState === 1, n;
        return r.addEventListener("open", () => {
          i = !0, n = null
        }), r.addEventListener("close", () => {
          i = !1, n = null
        }), r.addEventListener("error", s => {
          i || (n = s)
        }), t.connected = () => new Promise((s, o) => {
          if (i) return s();
          if (n) return o(n);
          let a = f => {
            e.call(r, "open", c), e.call(r, "error", u), f()
          },
            c = () => a(s),
            u = f => a(() => o(f));
          r.addEventListener("open", c), r.addEventListener("error", u)
        }), t
      }
    });
    var Mye = y((XAt, qye) => {
      l();
      qye.exports = async r => {
        if (r.readyState >= 2) throw new Error("socket closed");
        if (r.readyState !== 1) return new Promise((e, t) => {
          let i = r && (r.removeEventListener || r.removeListener);

          function n() {
            typeof i == "function" && (i.call(r, "open", s), i.call(r, "error", o))
          }

          function s() {
            n(), e()
          }

          function o(a) {
            n(), t(a)
          }
          r.addEventListener("open", s), r.addEventListener("error", o)
        })
      }
    });
    var Dye = y((ZAt, Bye) => {
      l();
      var jat = Mye();
      Bye.exports = (r, e) => (e = e || {}, e.closeOnEnd = e.closeOnEnd !== !1, async t => {
        for await (let i of t) {
          try {
            await jat(r)
          } catch (n) {
            if (n.message === "socket closed") break;
            throw n
          }
          r.send(i)
        }
        if (e.closeOnEnd && r.readyState <= 1) return new Promise((i, n) => {
          r.addEventListener("close", s => {
            if (s.wasClean || s.code === 1006) i();
            else {
              let o = Object.assign(new Error("ws error"), {
                event: s
              });
              n(o)
            }
          }), setTimeout(() => r.close())
        })
      })
    });
    var Fye = y((QAt, Lye) => {
      l();
      var Vat = Nye(),
        Hat = Dye();
      Lye.exports = (r, e) => {
        e = e || {}, e.binaryType ? r.binaryType = e.binaryType : e.binary && (r.binaryType = "arraybuffer");
        let t = {
          sink: Hat(r, e),
          source: Vat(r, e),
          connected: () => t.source.connected()
        };
        return t
      }
    });
    var Kye = y((eIt, Uye) => {
      l();
      var {
        relative: Gat
      } = Qh(), $at = {
        http: "ws",
        https: "wss"
      }, Wat = "ws";
      Uye.exports = (r, e) => Gat(r, e, $at, Wat)
    });
    var zye = y((tIt, w6) => {
      l();
      "use strict";
      var Yat = Rye(),
        Jat = Fye(),
        Xat = Kye();
      w6.exports = function (r, e = {}) {
        let t = typeof window == "undefined" ? {} : window.location,
          i = Xat(r, t),
          n = new Yat(i, e.websocket),
          s = Jat(n, e);
        return s.remoteAddress = i, s.close = () => new Promise((o, a) => {
          n.addEventListener("close", o), n.close()
        }), s.destroy = () => {
          n.terminate ? n.terminate() : n.close()
        }, s.socket = n, s
      };
      w6.exports.connect = w6.exports
    });
    var Vye = y((rIt, jye) => {
      l();
      "use strict";
      var Zat = km(),
        _6 = typeof window == "object" && typeof document == "object" && document.nodeType === 9,
        Bb = Zat(),
        Qat = _6 && !Bb,
        ect = Bb && !_6,
        tct = Bb && _6,
        rct = typeof process != "undefined" && typeof process.release != "undefined" && process.release.name === "node" && !Bb,
        ict = typeof importScripts == "function" && typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope,
        nct = typeof process != "undefined" && typeof process.env != "undefined" && process.env.NODE_ENV === "test";
      jye.exports = {
        isTest: nct,
        isElectron: Bb,
        isElectronMain: ect,
        isElectronRenderer: tct,
        isNode: rct,
        isBrowser: Qat,
        isWebWorker: ict,
        isEnvWithDom: _6
      }
    });
    var Gye = y((iIt, Hye) => {
      l();
      "use strict";
      Hye.exports = function () {
        throw new Error("WebSocket Servers can not be created in the browser!")
      }
    });
    var QR = y(Ih => {
      l();
      "use strict";
      Ih.CODE_P2P = 421;
      Ih.CODE_CIRCUIT = 290;
      Ih.CODE_TCP = 6;
      Ih.CODE_WS = 477;
      Ih.CODE_WSS = 478;
      Ih.CLOSE_TIMEOUT = 2e3
    });
    var e9 = y(Up => {
      l();
      "use strict";
      Object.defineProperty(Up, "__esModule", {
        value: !0
      });
      Up.isCorrect = Up.isInSubnet = void 0;

      function sct(r) {
        return this.subnetMask < r.subnetMask ? !1 : this.mask(r.subnetMask) === r.mask()
      }
      Up.isInSubnet = sct;

      function oct(r) {
        return function () {
          return this.addressMinusSuffix !== this.correctForm() ? !1 : this.subnetMask === r && !this.parsedSubnet ? !0 : this.parsedSubnet === String(this.subnetMask)
        }
      }
      Up.isCorrect = oct
    });
    var t9 = y(bc => {
      l();
      "use strict";
      Object.defineProperty(bc, "__esModule", {
        value: !0
      });
      bc.RE_SUBNET_STRING = bc.RE_ADDRESS = bc.GROUPS = bc.BITS = void 0;
      bc.BITS = 32;
      bc.GROUPS = 4;
      bc.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
      bc.RE_SUBNET_STRING = /\/\d{1,2}$/
    });
    var r9 = y(Kp => {
      l();
      "use strict";
      var act = Kp && Kp.__extends || function () {
        var r = function (e, t) {
          return r = Object.setPrototypeOf || {
            __proto__: []
          }
            instanceof Array && function (i, n) {
              i.__proto__ = n
            } || function (i, n) {
              for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (i[s] = n[s])
            }, r(e, t)
        };
        return function (e, t) {
          r(e, t);

          function i() {
            this.constructor = e
          }
          e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i)
        }
      }();
      Object.defineProperty(Kp, "__esModule", {
        value: !0
      });
      Kp.AddressError = void 0;
      var cct = function (r) {
        act(e, r);

        function e(t, i) {
          var n = r.call(this, t) || this;
          return n.name = "AddressError", i !== null && (n.parseMessage = i), n
        }
        return e
      }(Error);
      Kp.AddressError = cct
    });
    var i9 = y((E6, $ye) => {
      l();
      (function () {
        var r, e = 244837814094590,
          t = (e & 16777215) == 15715070;

        function i(C, N, W) {
          C != null && (typeof C == "number" ? this.fromNumber(C, N, W) : N == null && typeof C != "string" ? this.fromString(C, 256) : this.fromString(C, N))
        }

        function n() {
          return new i(null)
        }

        function s(C, N, W, fe, ke, Ce) {
          for (; --Ce >= 0;) {
            var Ye = N * this[C++] + W[fe] + ke;
            ke = Math.floor(Ye / 67108864), W[fe++] = Ye & 67108863
          }
          return ke
        }

        function o(C, N, W, fe, ke, Ce) {
          for (var Ye = N & 32767, rt = N >> 15; --Ce >= 0;) {
            var Nr = this[C] & 32767,
              Fi = this[C++] >> 15,
              $s = rt * Nr + Fi * Ye;
            Nr = Ye * Nr + (($s & 32767) << 15) + W[fe] + (ke & 1073741823), ke = (Nr >>> 30) + ($s >>> 15) + rt * Fi + (ke >>> 30), W[fe++] = Nr & 1073741823
          }
          return ke
        }

        function a(C, N, W, fe, ke, Ce) {
          for (var Ye = N & 16383, rt = N >> 14; --Ce >= 0;) {
            var Nr = this[C] & 16383,
              Fi = this[C++] >> 14,
              $s = rt * Nr + Fi * Ye;
            Nr = Ye * Nr + (($s & 16383) << 14) + W[fe] + ke, ke = (Nr >> 28) + ($s >> 14) + rt * Fi, W[fe++] = Nr & 268435455
          }
          return ke
        }
        var c = typeof navigator != "undefined";
        c && t && navigator.appName == "Microsoft Internet Explorer" ? (i.prototype.am = o, r = 30) : c && t && navigator.appName != "Netscape" ? (i.prototype.am = s, r = 26) : (i.prototype.am = a, r = 28), i.prototype.DB = r, i.prototype.DM = (1 << r) - 1, i.prototype.DV = 1 << r;
        var u = 52;
        i.prototype.FV = Math.pow(2, u), i.prototype.F1 = u - r, i.prototype.F2 = 2 * r - u;
        var f = "0123456789abcdefghijklmnopqrstuvwxyz",
          h = new Array,
          d, p;
        for (d = "0".charCodeAt(0), p = 0; p <= 9; ++p) h[d++] = p;
        for (d = "a".charCodeAt(0), p = 10; p < 36; ++p) h[d++] = p;
        for (d = "A".charCodeAt(0), p = 10; p < 36; ++p) h[d++] = p;

        function g(C) {
          return f.charAt(C)
        }

        function m(C, N) {
          var W = h[C.charCodeAt(N)];
          return W ?? -1
        }

        function E(C) {
          for (var N = this.t - 1; N >= 0; --N) C[N] = this[N];
          C.t = this.t, C.s = this.s
        }

        function w(C) {
          this.t = 1, this.s = C < 0 ? -1 : 0, C > 0 ? this[0] = C : C < -1 ? this[0] = C + this.DV : this.t = 0
        }

        function O(C) {
          var N = n();
          return N.fromInt(C), N
        }

        function q(C, N) {
          var W;
          if (N == 16) W = 4;
          else if (N == 8) W = 3;
          else if (N == 256) W = 8;
          else if (N == 2) W = 1;
          else if (N == 32) W = 5;
          else if (N == 4) W = 2;
          else {
            this.fromRadix(C, N);
            return
          }
          this.t = 0, this.s = 0;
          for (var fe = C.length, ke = !1, Ce = 0; --fe >= 0;) {
            var Ye = W == 8 ? C[fe] & 255 : m(C, fe);
            if (Ye < 0) {
              C.charAt(fe) == "-" && (ke = !0);
              continue
            }
            ke = !1, Ce == 0 ? this[this.t++] = Ye : Ce + W > this.DB ? (this[this.t - 1] |= (Ye & (1 << this.DB - Ce) - 1) << Ce, this[this.t++] = Ye >> this.DB - Ce) : this[this.t - 1] |= Ye << Ce, Ce += W, Ce >= this.DB && (Ce -= this.DB)
          }
          W == 8 && (C[0] & 128) != 0 && (this.s = -1, Ce > 0 && (this[this.t - 1] |= (1 << this.DB - Ce) - 1 << Ce)), this.clamp(), ke && i.ZERO.subTo(this, this)
        }

        function J() {
          for (var C = this.s & this.DM; this.t > 0 && this[this.t - 1] == C;) --this.t
        }

        function Z(C) {
          if (this.s < 0) return "-" + this.negate().toString(C);
          var N;
          if (C == 16) N = 4;
          else if (C == 8) N = 3;
          else if (C == 2) N = 1;
          else if (C == 32) N = 5;
          else if (C == 4) N = 2;
          else return this.toRadix(C);
          var W = (1 << N) - 1,
            fe, ke = !1,
            Ce = "",
            Ye = this.t,
            rt = this.DB - Ye * this.DB % N;
          if (Ye-- > 0)
            for (rt < this.DB && (fe = this[Ye] >> rt) > 0 && (ke = !0, Ce = g(fe)); Ye >= 0;) rt < N ? (fe = (this[Ye] & (1 << rt) - 1) << N - rt, fe |= this[--Ye] >> (rt += this.DB - N)) : (fe = this[Ye] >> (rt -= N) & W, rt <= 0 && (rt += this.DB, --Ye)), fe > 0 && (ke = !0), ke && (Ce += g(fe));
          return ke ? Ce : "0"
        }

        function H() {
          var C = n();
          return i.ZERO.subTo(this, C), C
        }

        function te() {
          return this.s < 0 ? this.negate() : this
        }

        function ae(C) {
          var N = this.s - C.s;
          if (N != 0) return N;
          var W = this.t;
          if (N = W - C.t, N != 0) return this.s < 0 ? -N : N;
          for (; --W >= 0;)
            if ((N = this[W] - C[W]) != 0) return N;
          return 0
        }

        function oe(C) {
          var N = 1,
            W;
          return (W = C >>> 16) != 0 && (C = W, N += 16), (W = C >> 8) != 0 && (C = W, N += 8), (W = C >> 4) != 0 && (C = W, N += 4), (W = C >> 2) != 0 && (C = W, N += 2), (W = C >> 1) != 0 && (C = W, N += 1), N
        }

        function U() {
          return this.t <= 0 ? 0 : this.DB * (this.t - 1) + oe(this[this.t - 1] ^ this.s & this.DM)
        }

        function b(C, N) {
          var W;
          for (W = this.t - 1; W >= 0; --W) N[W + C] = this[W];
          for (W = C - 1; W >= 0; --W) N[W] = 0;
          N.t = this.t + C, N.s = this.s
        }

        function _(C, N) {
          for (var W = C; W < this.t; ++W) N[W - C] = this[W];
          N.t = Math.max(this.t - C, 0), N.s = this.s
        }

        function R(C, N) {
          var W = C % this.DB,
            fe = this.DB - W,
            ke = (1 << fe) - 1,
            Ce = Math.floor(C / this.DB),
            Ye = this.s << W & this.DM,
            rt;
          for (rt = this.t - 1; rt >= 0; --rt) N[rt + Ce + 1] = this[rt] >> fe | Ye, Ye = (this[rt] & ke) << W;
          for (rt = Ce - 1; rt >= 0; --rt) N[rt] = 0;
          N[Ce] = Ye, N.t = this.t + Ce + 1, N.s = this.s, N.clamp()
        }

        function D(C, N) {
          N.s = this.s;
          var W = Math.floor(C / this.DB);
          if (W >= this.t) {
            N.t = 0;
            return
          }
          var fe = C % this.DB,
            ke = this.DB - fe,
            Ce = (1 << fe) - 1;
          N[0] = this[W] >> fe;
          for (var Ye = W + 1; Ye < this.t; ++Ye) N[Ye - W - 1] |= (this[Ye] & Ce) << ke, N[Ye - W] = this[Ye] >> fe;
          fe > 0 && (N[this.t - W - 1] |= (this.s & Ce) << ke), N.t = this.t - W, N.clamp()
        }

        function K(C, N) {
          for (var W = 0, fe = 0, ke = Math.min(C.t, this.t); W < ke;) fe += this[W] - C[W], N[W++] = fe & this.DM, fe >>= this.DB;
          if (C.t < this.t) {
            for (fe -= C.s; W < this.t;) fe += this[W], N[W++] = fe & this.DM, fe >>= this.DB;
            fe += this.s
          } else {
            for (fe += this.s; W < C.t;) fe -= C[W], N[W++] = fe & this.DM, fe >>= this.DB;
            fe -= C.s
          }
          N.s = fe < 0 ? -1 : 0, fe < -1 ? N[W++] = this.DV + fe : fe > 0 && (N[W++] = fe), N.t = W, N.clamp()
        }

        function ee(C, N) {
          var W = this.abs(),
            fe = C.abs(),
            ke = W.t;
          for (N.t = ke + fe.t; --ke >= 0;) N[ke] = 0;
          for (ke = 0; ke < fe.t; ++ke) N[ke + W.t] = W.am(0, fe[ke], N, ke, 0, W.t);
          N.s = 0, N.clamp(), this.s != C.s && i.ZERO.subTo(N, N)
        }

        function re(C) {
          for (var N = this.abs(), W = C.t = 2 * N.t; --W >= 0;) C[W] = 0;
          for (W = 0; W < N.t - 1; ++W) {
            var fe = N.am(W, N[W], C, 2 * W, 0, 1);
            (C[W + N.t] += N.am(W + 1, 2 * N[W], C, 2 * W + 1, fe, N.t - W - 1)) >= N.DV && (C[W + N.t] -= N.DV, C[W + N.t + 1] = 1)
          }
          C.t > 0 && (C[C.t - 1] += N.am(W, N[W], C, 2 * W, 0, 1)), C.s = 0, C.clamp()
        }

        function V(C, N, W) {
          var fe = C.abs();
          if (!(fe.t <= 0)) {
            var ke = this.abs();
            if (ke.t < fe.t) {
              N != null && N.fromInt(0), W != null && this.copyTo(W);
              return
            }
            W == null && (W = n());
            var Ce = n(),
              Ye = this.s,
              rt = C.s,
              Nr = this.DB - oe(fe[fe.t - 1]);
            Nr > 0 ? (fe.lShiftTo(Nr, Ce), ke.lShiftTo(Nr, W)) : (fe.copyTo(Ce), ke.copyTo(W));
            var Fi = Ce.t,
              $s = Ce[Fi - 1];
            if ($s != 0) {
              var As = $s * (1 << this.F1) + (Fi > 1 ? Ce[Fi - 2] >> this.F2 : 0),
                Pc = this.FV / As,
                Em = (1 << this.F1) / As,
                Mo = 1 << this.F2,
                Bo = W.t,
                Sm = Bo - Fi,
                Cu = N ?? n();
              for (Ce.dlShiftTo(Sm, Cu), W.compareTo(Cu) >= 0 && (W[W.t++] = 1, W.subTo(Cu, W)), i.ONE.dlShiftTo(Fi, Cu), Cu.subTo(Ce, Ce); Ce.t < Fi;) Ce[Ce.t++] = 0;
              for (; --Sm >= 0;) {
                var z4 = W[--Bo] == $s ? this.DM : Math.floor(W[Bo] * Pc + (W[Bo - 1] + Mo) * Em);
                if ((W[Bo] += Ce.am(0, z4, W, Sm, 0, Fi)) < z4)
                  for (Ce.dlShiftTo(Sm, Cu), W.subTo(Cu, W); W[Bo] < --z4;) W.subTo(Cu, W)
              }
              N != null && (W.drShiftTo(Fi, N), Ye != rt && i.ZERO.subTo(N, N)), W.t = Fi, W.clamp(), Nr > 0 && W.rShiftTo(Nr, W), Ye < 0 && i.ZERO.subTo(W, W)
            }
          }
        }

        function v(C) {
          var N = n();
          return this.abs().divRemTo(C, null, N), this.s < 0 && N.compareTo(i.ZERO) > 0 && C.subTo(N, N), N
        }

        function Y(C) {
          this.m = C
        }

        function Se(C) {
          return C.s < 0 || C.compareTo(this.m) >= 0 ? C.mod(this.m) : C
        }

        function Q(C) {
          return C
        }

        function ve(C) {
          C.divRemTo(this.m, null, C)
        }

        function x(C, N, W) {
          C.multiplyTo(N, W), this.reduce(W)
        }

        function I(C, N) {
          C.squareTo(N), this.reduce(N)
        }
        Y.prototype.convert = Se, Y.prototype.revert = Q, Y.prototype.reduce = ve, Y.prototype.mulTo = x, Y.prototype.sqrTo = I;

        function le() {
          if (this.t < 1) return 0;
          var C = this[0];
          if ((C & 1) == 0) return 0;
          var N = C & 3;
          return N = N * (2 - (C & 15) * N) & 15, N = N * (2 - (C & 255) * N) & 255, N = N * (2 - ((C & 65535) * N & 65535)) & 65535, N = N * (2 - C * N % this.DV) % this.DV, N > 0 ? this.DV - N : -N
        }

        function he(C) {
          this.m = C, this.mp = C.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << C.DB - 15) - 1, this.mt2 = 2 * C.t
        }

        function S(C) {
          var N = n();
          return C.abs().dlShiftTo(this.m.t, N), N.divRemTo(this.m, null, N), C.s < 0 && N.compareTo(i.ZERO) > 0 && this.m.subTo(N, N), N
        }

        function T(C) {
          var N = n();
          return C.copyTo(N), this.reduce(N), N
        }

        function j(C) {
          for (; C.t <= this.mt2;) C[C.t++] = 0;
          for (var N = 0; N < this.m.t; ++N) {
            var W = C[N] & 32767,
              fe = W * this.mpl + ((W * this.mph + (C[N] >> 15) * this.mpl & this.um) << 15) & C.DM;
            for (W = N + this.m.t, C[W] += this.m.am(0, fe, C, N, 0, this.m.t); C[W] >= C.DV;) C[W] -= C.DV, C[++W]++
          }
          C.clamp(), C.drShiftTo(this.m.t, C), C.compareTo(this.m) >= 0 && C.subTo(this.m, C)
        }

        function G(C, N) {
          C.squareTo(N), this.reduce(N)
        }

        function k(C, N, W) {
          C.multiplyTo(N, W), this.reduce(W)
        }
        he.prototype.convert = S, he.prototype.revert = T, he.prototype.reduce = j, he.prototype.mulTo = k, he.prototype.sqrTo = G;

        function F() {
          return (this.t > 0 ? this[0] & 1 : this.s) == 0
        }

        function B(C, N) {
          if (C > 4294967295 || C < 1) return i.ONE;
          var W = n(),
            fe = n(),
            ke = N.convert(this),
            Ce = oe(C) - 1;
          for (ke.copyTo(W); --Ce >= 0;)
            if (N.sqrTo(W, fe), (C & 1 << Ce) > 0) N.mulTo(fe, ke, W);
            else {
              var Ye = W;
              W = fe, fe = Ye
            } return N.revert(W)
        }

        function L(C, N) {
          var W;
          return C < 256 || N.isEven() ? W = new Y(N) : W = new he(N), this.exp(C, W)
        }
        i.prototype.copyTo = E, i.prototype.fromInt = w, i.prototype.fromString = q, i.prototype.clamp = J, i.prototype.dlShiftTo = b, i.prototype.drShiftTo = _, i.prototype.lShiftTo = R, i.prototype.rShiftTo = D, i.prototype.subTo = K, i.prototype.multiplyTo = ee, i.prototype.squareTo = re, i.prototype.divRemTo = V, i.prototype.invDigit = le, i.prototype.isEven = F, i.prototype.exp = B, i.prototype.toString = Z, i.prototype.negate = H, i.prototype.abs = te, i.prototype.compareTo = ae, i.prototype.bitLength = U, i.prototype.mod = v, i.prototype.modPowInt = L, i.ZERO = O(0), i.ONE = O(1);

        function $() {
          var C = n();
          return this.copyTo(C), C
        }

        function ie() {
          if (this.s < 0) {
            if (this.t == 1) return this[0] - this.DV;
            if (this.t == 0) return -1
          } else {
            if (this.t == 1) return this[0];
            if (this.t == 0) return 0
          }
          return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0]
        }

        function ne() {
          return this.t == 0 ? this.s : this[0] << 24 >> 24
        }

        function pe() {
          return this.t == 0 ? this.s : this[0] << 16 >> 16
        }

        function be(C) {
          return Math.floor(Math.LN2 * this.DB / Math.log(C))
        }

        function de() {
          return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1
        }

        function Ne(C) {
          if (C == null && (C = 10), this.signum() == 0 || C < 2 || C > 36) return "0";
          var N = this.chunkSize(C),
            W = Math.pow(C, N),
            fe = O(W),
            ke = n(),
            Ce = n(),
            Ye = "";
          for (this.divRemTo(fe, ke, Ce); ke.signum() > 0;) Ye = (W + Ce.intValue()).toString(C).substr(1) + Ye, ke.divRemTo(fe, ke, Ce);
          return Ce.intValue().toString(C) + Ye
        }

        function Re(C, N) {
          this.fromInt(0), N == null && (N = 10);
          for (var W = this.chunkSize(N), fe = Math.pow(N, W), ke = !1, Ce = 0, Ye = 0, rt = 0; rt < C.length; ++rt) {
            var Nr = m(C, rt);
            if (Nr < 0) {
              C.charAt(rt) == "-" && this.signum() == 0 && (ke = !0);
              continue
            }
            Ye = N * Ye + Nr, ++Ce >= W && (this.dMultiply(fe), this.dAddOffset(Ye, 0), Ce = 0, Ye = 0)
          }
          Ce > 0 && (this.dMultiply(Math.pow(N, Ce)), this.dAddOffset(Ye, 0)), ke && i.ZERO.subTo(this, this)
        }

        function $e(C, N, W) {
          if (typeof N == "number")
            if (C < 2) this.fromInt(1);
            else
              for (this.fromNumber(C, W), this.testBit(C - 1) || this.bitwiseTo(i.ONE.shiftLeft(C - 1), A, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(N);) this.dAddOffset(2, 0), this.bitLength() > C && this.subTo(i.ONE.shiftLeft(C - 1), this);
          else {
            var fe = new Array,
              ke = C & 7;
            fe.length = (C >> 3) + 1, N.nextBytes(fe), ke > 0 ? fe[0] &= (1 << ke) - 1 : fe[0] = 0, this.fromString(fe, 256)
          }
        }

        function Ke() {
          var C = this.t,
            N = new Array;
          N[0] = this.s;
          var W = this.DB - C * this.DB % 8,
            fe, ke = 0;
          if (C-- > 0)
            for (W < this.DB && (fe = this[C] >> W) != (this.s & this.DM) >> W && (N[ke++] = fe | this.s << this.DB - W); C >= 0;) W < 8 ? (fe = (this[C] & (1 << W) - 1) << 8 - W, fe |= this[--C] >> (W += this.DB - 8)) : (fe = this[C] >> (W -= 8) & 255, W <= 0 && (W += this.DB, --C)), (fe & 128) != 0 && (fe |= -256), ke == 0 && (this.s & 128) != (fe & 128) && ++ke, (ke > 0 || fe != this.s) && (N[ke++] = fe);
          return N
        }

        function Me(C) {
          return this.compareTo(C) == 0
        }

        function Ie(C) {
          return this.compareTo(C) < 0 ? this : C
        }

        function tt(C) {
          return this.compareTo(C) > 0 ? this : C
        }

        function nt(C, N, W) {
          var fe, ke, Ce = Math.min(C.t, this.t);
          for (fe = 0; fe < Ce; ++fe) W[fe] = N(this[fe], C[fe]);
          if (C.t < this.t) {
            for (ke = C.s & this.DM, fe = Ce; fe < this.t; ++fe) W[fe] = N(this[fe], ke);
            W.t = this.t
          } else {
            for (ke = this.s & this.DM, fe = Ce; fe < C.t; ++fe) W[fe] = N(ke, C[fe]);
            W.t = C.t
          }
          W.s = N(this.s, C.s), W.clamp()
        }

        function Ge(C, N) {
          return C & N
        }

        function se(C) {
          var N = n();
          return this.bitwiseTo(C, Ge, N), N
        }

        function A(C, N) {
          return C | N
        }

        function X(C) {
          var N = n();
          return this.bitwiseTo(C, A, N), N
        }

        function Kt(C, N) {
          return C ^ N
        }

        function st(C) {
          var N = n();
          return this.bitwiseTo(C, Kt, N), N
        }

        function Nt(C, N) {
          return C & ~N
        }

        function on(C) {
          var N = n();
          return this.bitwiseTo(C, Nt, N), N
        }

        function qt() {
          for (var C = n(), N = 0; N < this.t; ++N) C[N] = this.DM & ~this[N];
          return C.t = this.t, C.s = ~this.s, C
        }

        function De(C) {
          var N = n();
          return C < 0 ? this.rShiftTo(-C, N) : this.lShiftTo(C, N), N
        }

        function an(C) {
          var N = n();
          return C < 0 ? this.lShiftTo(-C, N) : this.rShiftTo(C, N), N
        }

        function Mt(C) {
          if (C == 0) return -1;
          var N = 0;
          return (C & 65535) == 0 && (C >>= 16, N += 16), (C & 255) == 0 && (C >>= 8, N += 8), (C & 15) == 0 && (C >>= 4, N += 4), (C & 3) == 0 && (C >>= 2, N += 2), (C & 1) == 0 && ++N, N
        }

        function Bt() {
          for (var C = 0; C < this.t; ++C)
            if (this[C] != 0) return C * this.DB + Mt(this[C]);
          return this.s < 0 ? this.t * this.DB : -1
        }

        function cn(C) {
          for (var N = 0; C != 0;) C &= C - 1, ++N;
          return N
        }

        function Dt() {
          for (var C = 0, N = this.s & this.DM, W = 0; W < this.t; ++W) C += cn(this[W] ^ N);
          return C
        }

        function yt(C) {
          var N = Math.floor(C / this.DB);
          return N >= this.t ? this.s != 0 : (this[N] & 1 << C % this.DB) != 0
        }

        function Bn(C, N) {
          var W = i.ONE.shiftLeft(C);
          return this.bitwiseTo(W, N, W), W
        }

        function Ht(C) {
          return this.changeBit(C, A)
        }

        function Gt(C) {
          return this.changeBit(C, Nt)
        }

        function Dn(C) {
          return this.changeBit(C, Kt)
        }

        function et(C, N) {
          for (var W = 0, fe = 0, ke = Math.min(C.t, this.t); W < ke;) fe += this[W] + C[W], N[W++] = fe & this.DM, fe >>= this.DB;
          if (C.t < this.t) {
            for (fe += C.s; W < this.t;) fe += this[W], N[W++] = fe & this.DM, fe >>= this.DB;
            fe += this.s
          } else {
            for (fe += this.s; W < C.t;) fe += C[W], N[W++] = fe & this.DM, fe >>= this.DB;
            fe += C.s
          }
          N.s = fe < 0 ? -1 : 0, fe > 0 ? N[W++] = fe : fe < -1 && (N[W++] = this.DV + fe), N.t = W, N.clamp()
        }

        function $t(C) {
          var N = n();
          return this.addTo(C, N), N
        }

        function Ln(C) {
          var N = n();
          return this.subTo(C, N), N
        }

        function dr(C) {
          var N = n();
          return this.multiplyTo(C, N), N
        }

        function nr() {
          var C = n();
          return this.squareTo(C), C
        }

        function Ss(C) {
          var N = n();
          return this.divRemTo(C, N, null), N
        }

        function sr(C) {
          var N = n();
          return this.divRemTo(C, null, N), N
        }

        function or(C) {
          var N = n(),
            W = n();
          return this.divRemTo(C, N, W), new Array(N, W)
        }

        function ut(C) {
          this[this.t] = this.am(0, C - 1, this, 0, 0, this.t), ++this.t, this.clamp()
        }

        function ar(C, N) {
          if (C != 0) {
            for (; this.t <= N;) this[this.t++] = 0;
            for (this[N] += C; this[N] >= this.DV;) this[N] -= this.DV, ++N >= this.t && (this[this.t++] = 0), ++this[N]
          }
        }

        function Lt() { }

        function Fn(C) {
          return C
        }

        function ns(C, N, W) {
          C.multiplyTo(N, W)
        }

        function ss(C, N) {
          C.squareTo(N)
        }
        Lt.prototype.convert = Fn, Lt.prototype.revert = Fn, Lt.prototype.mulTo = ns, Lt.prototype.sqrTo = ss;

        function os(C) {
          return this.exp(C, new Lt)
        }

        function as(C, N, W) {
          var fe = Math.min(this.t + C.t, N);
          for (W.s = 0, W.t = fe; fe > 0;) W[--fe] = 0;
          var ke;
          for (ke = W.t - this.t; fe < ke; ++fe) W[fe + this.t] = this.am(0, C[fe], W, fe, 0, this.t);
          for (ke = Math.min(C.t, N); fe < ke; ++fe) this.am(0, C[fe], W, fe, 0, N - fe);
          W.clamp()
        }

        function cs(C, N, W) {
          --N;
          var fe = W.t = this.t + C.t - N;
          for (W.s = 0; --fe >= 0;) W[fe] = 0;
          for (fe = Math.max(N - this.t, 0); fe < C.t; ++fe) W[this.t + fe - N] = this.am(N - fe, C[fe], W, 0, 0, this.t + fe - N);
          W.clamp(), W.drShiftTo(1, W)
        }

        function Ze(C) {
          this.r2 = n(), this.q3 = n(), i.ONE.dlShiftTo(2 * C.t, this.r2), this.mu = this.r2.divide(C), this.m = C
        }

        function us(C) {
          if (C.s < 0 || C.t > 2 * this.m.t) return C.mod(this.m);
          if (C.compareTo(this.m) < 0) return C;
          var N = n();
          return C.copyTo(N), this.reduce(N), N
        }

        function kc(C) {
          return C
        }

        function P(C) {
          for (C.drShiftTo(this.m.t - 1, this.r2), C.t > this.m.t + 1 && (C.t = this.m.t + 1, C.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); C.compareTo(this.r2) < 0;) C.dAddOffset(1, this.m.t + 1);
          for (C.subTo(this.r2, C); C.compareTo(this.m) >= 0;) C.subTo(this.m, C)
        }

        function Ve(C, N) {
          C.squareTo(N), this.reduce(N)
        }

        function We(C, N, W) {
          C.multiplyTo(N, W), this.reduce(W)
        }
        Ze.prototype.convert = us, Ze.prototype.revert = kc, Ze.prototype.reduce = P, Ze.prototype.mulTo = We, Ze.prototype.sqrTo = Ve;

        function Fe(C, N) {
          var W = C.bitLength(),
            fe, ke = O(1),
            Ce;
          if (W <= 0) return ke;
          W < 18 ? fe = 1 : W < 48 ? fe = 3 : W < 144 ? fe = 4 : W < 768 ? fe = 5 : fe = 6, W < 8 ? Ce = new Y(N) : N.isEven() ? Ce = new Ze(N) : Ce = new he(N);
          var Ye = new Array,
            rt = 3,
            Nr = fe - 1,
            Fi = (1 << fe) - 1;
          if (Ye[1] = Ce.convert(this), fe > 1) {
            var $s = n();
            for (Ce.sqrTo(Ye[1], $s); rt <= Fi;) Ye[rt] = n(), Ce.mulTo($s, Ye[rt - 2], Ye[rt]), rt += 2
          }
          var As = C.t - 1,
            Pc, Em = !0,
            Mo = n(),
            Bo;
          for (W = oe(C[As]) - 1; As >= 0;) {
            for (W >= Nr ? Pc = C[As] >> W - Nr & Fi : (Pc = (C[As] & (1 << W + 1) - 1) << Nr - W, As > 0 && (Pc |= C[As - 1] >> this.DB + W - Nr)), rt = fe;
              (Pc & 1) == 0;) Pc >>= 1, --rt;
            if ((W -= rt) < 0 && (W += this.DB, --As), Em) Ye[Pc].copyTo(ke), Em = !1;
            else {
              for (; rt > 1;) Ce.sqrTo(ke, Mo), Ce.sqrTo(Mo, ke), rt -= 2;
              rt > 0 ? Ce.sqrTo(ke, Mo) : (Bo = ke, ke = Mo, Mo = Bo), Ce.mulTo(Mo, Ye[Pc], ke)
            }
            for (; As >= 0 && (C[As] & 1 << W) == 0;) Ce.sqrTo(ke, Mo), Bo = ke, ke = Mo, Mo = Bo, --W < 0 && (W = this.DB - 1, --As)
          }
          return Ce.revert(ke)
        }

        function Un(C) {
          var N = this.s < 0 ? this.negate() : this.clone(),
            W = C.s < 0 ? C.negate() : C.clone();
          if (N.compareTo(W) < 0) {
            var fe = N;
            N = W, W = fe
          }
          var ke = N.getLowestSetBit(),
            Ce = W.getLowestSetBit();
          if (Ce < 0) return N;
          for (ke < Ce && (Ce = ke), Ce > 0 && (N.rShiftTo(Ce, N), W.rShiftTo(Ce, W)); N.signum() > 0;)(ke = N.getLowestSetBit()) > 0 && N.rShiftTo(ke, N), (ke = W.getLowestSetBit()) > 0 && W.rShiftTo(ke, W), N.compareTo(W) >= 0 ? (N.subTo(W, N), N.rShiftTo(1, N)) : (W.subTo(N, W), W.rShiftTo(1, W));
          return Ce > 0 && W.lShiftTo(Ce, W), W
        }

        function un(C) {
          if (C <= 0) return 0;
          var N = this.DV % C,
            W = this.s < 0 ? C - 1 : 0;
          if (this.t > 0)
            if (N == 0) W = this[0] % C;
            else
              for (var fe = this.t - 1; fe >= 0; --fe) W = (N * W + this[fe]) % C;
          return W
        }

        function Yf(C) {
          var N = C.isEven();
          if (this.isEven() && N || C.signum() == 0) return i.ZERO;
          for (var W = C.clone(), fe = this.clone(), ke = O(1), Ce = O(0), Ye = O(0), rt = O(1); W.signum() != 0;) {
            for (; W.isEven();) W.rShiftTo(1, W), N ? ((!ke.isEven() || !Ce.isEven()) && (ke.addTo(this, ke), Ce.subTo(C, Ce)), ke.rShiftTo(1, ke)) : Ce.isEven() || Ce.subTo(C, Ce), Ce.rShiftTo(1, Ce);
            for (; fe.isEven();) fe.rShiftTo(1, fe), N ? ((!Ye.isEven() || !rt.isEven()) && (Ye.addTo(this, Ye), rt.subTo(C, rt)), Ye.rShiftTo(1, Ye)) : rt.isEven() || rt.subTo(C, rt), rt.rShiftTo(1, rt);
            W.compareTo(fe) >= 0 ? (W.subTo(fe, W), N && ke.subTo(Ye, ke), Ce.subTo(rt, Ce)) : (fe.subTo(W, fe), N && Ye.subTo(ke, Ye), rt.subTo(Ce, rt))
          }
          if (fe.compareTo(i.ONE) != 0) return i.ZERO;
          if (rt.compareTo(C) >= 0) return rt.subtract(C);
          if (rt.signum() < 0) rt.addTo(C, rt);
          else return rt;
          return rt.signum() < 0 ? rt.add(C) : rt
        }
        var Si = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],
          E1 = (1 << 26) / Si[Si.length - 1];

        function S1(C) {
          var N, W = this.abs();
          if (W.t == 1 && W[0] <= Si[Si.length - 1]) {
            for (N = 0; N < Si.length; ++N)
              if (W[0] == Si[N]) return !0;
            return !1
          }
          if (W.isEven()) return !1;
          for (N = 1; N < Si.length;) {
            for (var fe = Si[N], ke = N + 1; ke < Si.length && fe < E1;) fe *= Si[ke++];
            for (fe = W.modInt(fe); N < ke;)
              if (fe % Si[N++] == 0) return !1
          }
          return W.millerRabin(C)
        }

        function u4e(C) {
          var N = this.subtract(i.ONE),
            W = N.getLowestSetBit();
          if (W <= 0) return !1;
          var fe = N.shiftRight(W);
          C = C + 1 >> 1, C > Si.length && (C = Si.length);
          for (var ke = n(), Ce = 0; Ce < C; ++Ce) {
            ke.fromInt(Si[Math.floor(Math.random() * Si.length)]);
            var Ye = ke.modPow(fe, this);
            if (Ye.compareTo(i.ONE) != 0 && Ye.compareTo(N) != 0) {
              for (var rt = 1; rt++ < W && Ye.compareTo(N) != 0;)
                if (Ye = Ye.modPowInt(2, this), Ye.compareTo(i.ONE) == 0) return !1;
              if (Ye.compareTo(N) != 0) return !1
            }
          }
          return !0
        }
        i.prototype.chunkSize = be, i.prototype.toRadix = Ne, i.prototype.fromRadix = Re, i.prototype.fromNumber = $e, i.prototype.bitwiseTo = nt, i.prototype.changeBit = Bn, i.prototype.addTo = et, i.prototype.dMultiply = ut, i.prototype.dAddOffset = ar, i.prototype.multiplyLowerTo = as, i.prototype.multiplyUpperTo = cs, i.prototype.modInt = un, i.prototype.millerRabin = u4e, i.prototype.clone = $, i.prototype.intValue = ie, i.prototype.byteValue = ne, i.prototype.shortValue = pe, i.prototype.signum = de, i.prototype.toByteArray = Ke, i.prototype.equals = Me, i.prototype.min = Ie, i.prototype.max = tt, i.prototype.and = se, i.prototype.or = X, i.prototype.xor = st, i.prototype.andNot = on, i.prototype.not = qt, i.prototype.shiftLeft = De, i.prototype.shiftRight = an, i.prototype.getLowestSetBit = Bt, i.prototype.bitCount = Dt, i.prototype.testBit = yt, i.prototype.setBit = Ht, i.prototype.clearBit = Gt, i.prototype.flipBit = Dn, i.prototype.add = $t, i.prototype.subtract = Ln, i.prototype.multiply = dr, i.prototype.divide = Ss, i.prototype.remainder = sr, i.prototype.divideAndRemainder = or, i.prototype.modPow = Fe, i.prototype.modInverse = Yf, i.prototype.pow = os, i.prototype.gcd = Un, i.prototype.isProbablePrime = S1, i.prototype.square = nr, i.prototype.Barrett = Ze;
        var _m, xs, Li;

        function f4e(C) {
          xs[Li++] ^= C & 255, xs[Li++] ^= C >> 8 & 255, xs[Li++] ^= C >> 16 & 255, xs[Li++] ^= C >> 24 & 255, Li >= K4 && (Li -= K4)
        }

        function gP() {
          f4e(new Date().getTime())
        }
        if (xs == null) {
          xs = new Array, Li = 0;
          var qo;
          if (typeof window != "undefined" && window.crypto) {
            if (window.crypto.getRandomValues) {
              var bP = new Uint8Array(32);
              for (window.crypto.getRandomValues(bP), qo = 0; qo < 32; ++qo) xs[Li++] = bP[qo]
            } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
              var mP = window.crypto.random(32);
              for (qo = 0; qo < mP.length; ++qo) xs[Li++] = mP.charCodeAt(qo) & 255
            }
          }
          for (; Li < K4;) qo = Math.floor(65536 * Math.random()), xs[Li++] = qo >>> 8, xs[Li++] = qo & 255;
          Li = 0, gP()
        }

        function l4e() {
          if (_m == null) {
            for (gP(), _m = y4e(), _m.init(xs), Li = 0; Li < xs.length; ++Li) xs[Li] = 0;
            Li = 0
          }
          return _m.next()
        }

        function h4e(C) {
          var N;
          for (N = 0; N < C.length; ++N) C[N] = l4e()
        }

        function F4() { }
        F4.prototype.nextBytes = h4e;

        function U4() {
          this.i = 0, this.j = 0, this.S = new Array
        }

        function d4e(C) {
          var N, W, fe;
          for (N = 0; N < 256; ++N) this.S[N] = N;
          for (W = 0, N = 0; N < 256; ++N) W = W + this.S[N] + C[N % C.length] & 255, fe = this.S[N], this.S[N] = this.S[W], this.S[W] = fe;
          this.i = 0, this.j = 0
        }

        function p4e() {
          var C;
          return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, C = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = C, this.S[C + this.S[this.i] & 255]
        }
        U4.prototype.init = d4e, U4.prototype.next = p4e;

        function y4e() {
          return new U4
        }
        var K4 = 256;
        typeof E6 != "undefined" ? E6 = $ye.exports = {
          default: i,
          BigInteger: i,
          SecureRandom: F4
        } : this.jsbn = {
          BigInteger: i,
          SecureRandom: F4
        }
      }).call(E6)
    });
    var Db = y(S6 => {
      l();
      (function () {
        "use strict";
        var r = {
          not_string: /[^s]/,
          not_bool: /[^t]/,
          not_type: /[^T]/,
          not_primitive: /[^v]/,
          number: /[diefg]/,
          numeric_arg: /[bcdiefguxX]/,
          json: /[j]/,
          not_json: /[^j]/,
          text: /^[^\x25]+/,
          modulo: /^\x25{2}/,
          placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
          key: /^([a-z_][a-z_\d]*)/i,
          key_access: /^\.([a-z_][a-z_\d]*)/i,
          index_access: /^\[(\d+)\]/,
          sign: /^[+-]/
        };

        function e(o) {
          return i(s(o), arguments)
        }

        function t(o, a) {
          return e.apply(null, [o].concat(a || []))
        }

        function i(o, a) {
          var c = 1,
            u = o.length,
            f, h = "",
            d, p, g, m, E, w, O, q;
          for (d = 0; d < u; d++)
            if (typeof o[d] == "string") h += o[d];
            else if (typeof o[d] == "object") {
              if (g = o[d], g.keys)
                for (f = a[c], p = 0; p < g.keys.length; p++) {
                  if (f == null) throw new Error(e('[sprintf] Cannot access property "%s" of undefined value "%s"', g.keys[p], g.keys[p - 1]));
                  f = f[g.keys[p]]
                } else g.param_no ? f = a[g.param_no] : f = a[c++];
              if (r.not_type.test(g.type) && r.not_primitive.test(g.type) && f instanceof Function && (f = f()), r.numeric_arg.test(g.type) && typeof f != "number" && isNaN(f)) throw new TypeError(e("[sprintf] expecting number but found %T", f));
              switch (r.number.test(g.type) && (O = f >= 0), g.type) {
                case "b":
                  f = parseInt(f, 10).toString(2);
                  break;
                case "c":
                  f = String.fromCharCode(parseInt(f, 10));
                  break;
                case "d":
                case "i":
                  f = parseInt(f, 10);
                  break;
                case "j":
                  f = JSON.stringify(f, null, g.width ? parseInt(g.width) : 0);
                  break;
                case "e":
                  f = g.precision ? parseFloat(f).toExponential(g.precision) : parseFloat(f).toExponential();
                  break;
                case "f":
                  f = g.precision ? parseFloat(f).toFixed(g.precision) : parseFloat(f);
                  break;
                case "g":
                  f = g.precision ? String(Number(f.toPrecision(g.precision))) : parseFloat(f);
                  break;
                case "o":
                  f = (parseInt(f, 10) >>> 0).toString(8);
                  break;
                case "s":
                  f = String(f), f = g.precision ? f.substring(0, g.precision) : f;
                  break;
                case "t":
                  f = String(!!f), f = g.precision ? f.substring(0, g.precision) : f;
                  break;
                case "T":
                  f = Object.prototype.toString.call(f).slice(8, -1).toLowerCase(), f = g.precision ? f.substring(0, g.precision) : f;
                  break;
                case "u":
                  f = parseInt(f, 10) >>> 0;
                  break;
                case "v":
                  f = f.valueOf(), f = g.precision ? f.substring(0, g.precision) : f;
                  break;
                case "x":
                  f = (parseInt(f, 10) >>> 0).toString(16);
                  break;
                case "X":
                  f = (parseInt(f, 10) >>> 0).toString(16).toUpperCase();
                  break
              }
              r.json.test(g.type) ? h += f : (r.number.test(g.type) && (!O || g.sign) ? (q = O ? "+" : "-", f = f.toString().replace(r.sign, "")) : q = "", E = g.pad_char ? g.pad_char === "0" ? "0" : g.pad_char.charAt(1) : " ", w = g.width - (q + f).length, m = g.width && w > 0 ? E.repeat(w) : "", h += g.align ? q + f + m : E === "0" ? q + m + f : m + q + f)
            }
          return h
        }
        var n = Object.create(null);

        function s(o) {
          if (n[o]) return n[o];
          for (var a = o, c, u = [], f = 0; a;) {
            if ((c = r.text.exec(a)) !== null) u.push(c[0]);
            else if ((c = r.modulo.exec(a)) !== null) u.push("%");
            else if ((c = r.placeholder.exec(a)) !== null) {
              if (c[2]) {
                f |= 1;
                var h = [],
                  d = c[2],
                  p = [];
                if ((p = r.key.exec(d)) !== null)
                  for (h.push(p[1]);
                    (d = d.substring(p[0].length)) !== "";)
                    if ((p = r.key_access.exec(d)) !== null) h.push(p[1]);
                    else if ((p = r.index_access.exec(d)) !== null) h.push(p[1]);
                    else throw new SyntaxError("[sprintf] failed to parse named argument key");
                else throw new SyntaxError("[sprintf] failed to parse named argument key");
                c[2] = h
              } else f |= 2;
              if (f === 3) throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
              u.push({
                placeholder: c[0],
                param_no: c[1],
                keys: c[2],
                sign: c[3],
                pad_char: c[4],
                align: c[5],
                width: c[6],
                precision: c[7],
                type: c[8]
              })
            } else throw new SyntaxError("[sprintf] unexpected placeholder");
            a = a.substring(c[0].length)
          }
          return n[o] = u
        }
        typeof S6 != "undefined" && (S6.sprintf = e, S6.vsprintf = t), typeof window != "undefined" && (window.sprintf = e, window.vsprintf = t, typeof define == "function" && define.amd && define(function () {
          return {
            sprintf: e,
            vsprintf: t
          }
        }))
      })()
    });
    var n9 = y(mc => {
      l();
      "use strict";
      var uct = mc && mc.__createBinding || (Object.create ? function (r, e, t, i) {
        i === void 0 && (i = t), Object.defineProperty(r, i, {
          enumerable: !0,
          get: function () {
            return e[t]
          }
        })
      } : function (r, e, t, i) {
        i === void 0 && (i = t), r[i] = e[t]
      }),
        fct = mc && mc.__setModuleDefault || (Object.create ? function (r, e) {
          Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
          })
        } : function (r, e) {
          r.default = e
        }),
        Wye = mc && mc.__importStar || function (r) {
          if (r && r.__esModule) return r;
          var e = {};
          if (r != null)
            for (var t in r) t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && uct(e, r, t);
          return fct(e, r), e
        };
      Object.defineProperty(mc, "__esModule", {
        value: !0
      });
      mc.Address4 = void 0;
      var Yye = Wye(e9()),
        va = Wye(t9()),
        Jye = r9(),
        Lb = i9(),
        Fb = Db(),
        lct = function () {
          function r(e) {
            this.groups = va.GROUPS, this.parsedAddress = [], this.parsedSubnet = "", this.subnet = "/32", this.subnetMask = 32, this.v4 = !0, this.isCorrect = Yye.isCorrect(va.BITS), this.isInSubnet = Yye.isInSubnet, this.address = e;
            var t = va.RE_SUBNET_STRING.exec(e);
            if (t) {
              if (this.parsedSubnet = t[0].replace("/", ""), this.subnetMask = parseInt(this.parsedSubnet, 10), this.subnet = "/" + this.subnetMask, this.subnetMask < 0 || this.subnetMask > va.BITS) throw new Jye.AddressError("Invalid subnet mask.");
              e = e.replace(va.RE_SUBNET_STRING, "")
            }
            this.addressMinusSuffix = e, this.parsedAddress = this.parse(e)
          }
          return r.isValid = function (e) {
            try {
              return new r(e), !0
            } catch (t) {
              return !1
            }
          }, r.prototype.parse = function (e) {
            var t = e.split(".");
            if (!e.match(va.RE_ADDRESS)) throw new Jye.AddressError("Invalid IPv4 address.");
            return t
          }, r.prototype.correctForm = function () {
            return this.parsedAddress.map(function (e) {
              return parseInt(e, 10)
            }).join(".")
          }, r.fromHex = function (e) {
            var t = e.replace(/:/g, "").padStart(8, "0"),
              i = [],
              n;
            for (n = 0; n < 8; n += 2) {
              var s = t.slice(n, n + 2);
              i.push(parseInt(s, 16))
            }
            return new r(i.join("."))
          }, r.fromInteger = function (e) {
            return r.fromHex(e.toString(16))
          }, r.prototype.toHex = function () {
            return this.parsedAddress.map(function (e) {
              return Fb.sprintf("%02x", parseInt(e, 10))
            }).join(":")
          }, r.prototype.toArray = function () {
            return this.parsedAddress.map(function (e) {
              return parseInt(e, 10)
            })
          }, r.prototype.toGroup6 = function () {
            var e = [],
              t;
            for (t = 0; t < va.GROUPS; t += 2) {
              var i = Fb.sprintf("%02x%02x", parseInt(this.parsedAddress[t], 10), parseInt(this.parsedAddress[t + 1], 10));
              e.push(Fb.sprintf("%x", parseInt(i, 16)))
            }
            return e.join(":")
          }, r.prototype.bigInteger = function () {
            return new Lb.BigInteger(this.parsedAddress.map(function (e) {
              return Fb.sprintf("%02x", parseInt(e, 10))
            }).join(""), 16)
          }, r.prototype._startAddress = function () {
            return new Lb.BigInteger(this.mask() + "0".repeat(va.BITS - this.subnetMask), 2)
          }, r.prototype.startAddress = function () {
            return r.fromBigInteger(this._startAddress())
          }, r.prototype.startAddressExclusive = function () {
            var e = new Lb.BigInteger("1");
            return r.fromBigInteger(this._startAddress().add(e))
          }, r.prototype._endAddress = function () {
            return new Lb.BigInteger(this.mask() + "1".repeat(va.BITS - this.subnetMask), 2)
          }, r.prototype.endAddress = function () {
            return r.fromBigInteger(this._endAddress())
          }, r.prototype.endAddressExclusive = function () {
            var e = new Lb.BigInteger("1");
            return r.fromBigInteger(this._endAddress().subtract(e))
          }, r.fromBigInteger = function (e) {
            return r.fromInteger(parseInt(e.toString(), 10))
          }, r.prototype.mask = function (e) {
            return e === void 0 && (e = this.subnetMask), this.getBitsBase2(0, e)
          }, r.prototype.getBitsBase2 = function (e, t) {
            return this.binaryZeroPad().slice(e, t)
          }, r.prototype.isMulticast = function () {
            return this.isInSubnet(new r("224.0.0.0/4"))
          }, r.prototype.binaryZeroPad = function () {
            return this.bigInteger().toString(2).padStart(va.BITS, "0")
          }, r.prototype.groupForV6 = function () {
            var e = this.parsedAddress;
            return this.address.replace(va.RE_ADDRESS, Fb.sprintf('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', e.slice(0, 2).join("."), e.slice(2, 4).join(".")))
          }, r
        }();
      mc.Address4 = lct
    });
    var s9 = y(oi => {
      l();
      "use strict";
      Object.defineProperty(oi, "__esModule", {
        value: !0
      });
      oi.RE_URL_WITH_PORT = oi.RE_URL = oi.RE_ZONE_STRING = oi.RE_SUBNET_STRING = oi.RE_BAD_ADDRESS = oi.RE_BAD_CHARACTERS = oi.TYPES = oi.SCOPES = oi.GROUPS = oi.BITS = void 0;
      oi.BITS = 128;
      oi.GROUPS = 8;
      oi.SCOPES = {
        0: "Reserved",
        1: "Interface local",
        2: "Link local",
        4: "Admin local",
        5: "Site local",
        8: "Organization local",
        14: "Global",
        15: "Reserved"
      };
      oi.TYPES = {
        "ff01::1/128": "Multicast (All nodes on this interface)",
        "ff01::2/128": "Multicast (All routers on this interface)",
        "ff02::1/128": "Multicast (All nodes on this link)",
        "ff02::2/128": "Multicast (All routers on this link)",
        "ff05::2/128": "Multicast (All routers in this site)",
        "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
        "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
        "ff02::9/128": "Multicast (RIP routers)",
        "ff02::a/128": "Multicast (EIGRP routers)",
        "ff02::d/128": "Multicast (PIM routers)",
        "ff02::16/128": "Multicast (MLDv2 reports)",
        "ff01::fb/128": "Multicast (mDNSv6)",
        "ff02::fb/128": "Multicast (mDNSv6)",
        "ff05::fb/128": "Multicast (mDNSv6)",
        "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
        "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
        "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
        "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
        "::/128": "Unspecified",
        "::1/128": "Loopback",
        "ff00::/8": "Multicast",
        "fe80::/10": "Link-local unicast"
      };
      oi.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
      oi.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
      oi.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
      oi.RE_ZONE_STRING = /%.*$/;
      oi.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
      oi.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/)
    });
    var o9 = y(vc => {
      l();
      "use strict";
      Object.defineProperty(vc, "__esModule", {
        value: !0
      });
      vc.simpleGroup = vc.spanLeadingZeroes = vc.spanAll = vc.spanAllZeroes = void 0;
      var Xye = Db();

      function Zye(r) {
        return r.replace(/(0+)/g, '<span class="zero">$1</span>')
      }
      vc.spanAllZeroes = Zye;

      function hct(r, e) {
        e === void 0 && (e = 0);
        var t = r.split("");
        return t.map(function (i, n) {
          return Xye.sprintf('<span class="digit value-%s position-%d">%s</span>', i, n + e, Zye(i))
        }).join("")
      }
      vc.spanAll = hct;

      function Qye(r) {
        return r.replace(/^(0+)/, '<span class="zero">$1</span>')
      }

      function dct(r) {
        var e = r.split(":");
        return e.map(function (t) {
          return Qye(t)
        }).join(":")
      }
      vc.spanLeadingZeroes = dct;

      function pct(r, e) {
        e === void 0 && (e = 0);
        var t = r.split(":");
        return t.map(function (i, n) {
          return /group-v4/.test(i) ? i : Xye.sprintf('<span class="hover-group group-%d">%s</span>', n + e, Qye(i))
        })
      }
      vc.simpleGroup = pct
    });
    var ege = y(nn => {
      l();
      "use strict";
      var yct = nn && nn.__createBinding || (Object.create ? function (r, e, t, i) {
        i === void 0 && (i = t), Object.defineProperty(r, i, {
          enumerable: !0,
          get: function () {
            return e[t]
          }
        })
      } : function (r, e, t, i) {
        i === void 0 && (i = t), r[i] = e[t]
      }),
        gct = nn && nn.__setModuleDefault || (Object.create ? function (r, e) {
          Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
          })
        } : function (r, e) {
          r.default = e
        }),
        bct = nn && nn.__importStar || function (r) {
          if (r && r.__esModule) return r;
          var e = {};
          if (r != null)
            for (var t in r) t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && yct(e, r, t);
          return gct(e, r), e
        };
      Object.defineProperty(nn, "__esModule", {
        value: !0
      });
      nn.possibleElisions = nn.simpleRegularExpression = nn.ADDRESS_BOUNDARY = nn.padGroup = nn.groupPossibilities = void 0;
      var mct = bct(s9()),
        zp = Db();

      function x6(r) {
        return zp.sprintf("(%s)", r.join("|"))
      }
      nn.groupPossibilities = x6;

      function A6(r) {
        return r.length < 4 ? zp.sprintf("0{0,%d}%s", 4 - r.length, r) : r
      }
      nn.padGroup = A6;
      nn.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";

      function vct(r) {
        var e = [];
        r.forEach(function (i, n) {
          var s = parseInt(i, 16);
          s === 0 && e.push(n)
        });
        var t = e.map(function (i) {
          return r.map(function (n, s) {
            if (s === i) {
              var o = s === 0 || s === mct.GROUPS - 1 ? ":" : "";
              return x6([A6(n), o])
            }
            return A6(n)
          }).join(":")
        });
        return t.push(r.map(A6).join(":")), x6(t)
      }
      nn.simpleRegularExpression = vct;

      function wct(r, e, t) {
        var i = e ? "" : ":",
          n = t ? "" : ":",
          s = [];
        !e && !t && s.push("::"), e && t && s.push(""), (t && !e || !t && e) && s.push(":"), s.push(zp.sprintf("%s(:0{1,4}){1,%d}", i, r - 1)), s.push(zp.sprintf("(0{1,4}:){1,%d}%s", r - 1, n)), s.push(zp.sprintf("(0{1,4}:){%d}0{1,4}", r - 1));
        for (var o = 1; o < r - 1; o++)
          for (var a = 1; a < r - o; a++) s.push(zp.sprintf("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", a, r - a - o - 1));
        return x6(s)
      }
      nn.possibleElisions = wct
    });
    var nge = y(Ro => {
      l();
      "use strict";
      var _ct = Ro && Ro.__createBinding || (Object.create ? function (r, e, t, i) {
        i === void 0 && (i = t), Object.defineProperty(r, i, {
          enumerable: !0,
          get: function () {
            return e[t]
          }
        })
      } : function (r, e, t, i) {
        i === void 0 && (i = t), r[i] = e[t]
      }),
        Ect = Ro && Ro.__setModuleDefault || (Object.create ? function (r, e) {
          Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
          })
        } : function (r, e) {
          r.default = e
        }),
        I6 = Ro && Ro.__importStar || function (r) {
          if (r && r.__esModule) return r;
          var e = {};
          if (r != null)
            for (var t in r) t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && _ct(e, r, t);
          return Ect(e, r), e
        },
        Sct = Ro && Ro.__spreadArrays || function () {
          for (var r = 0, e = 0, t = arguments.length; e < t; e++) r += arguments[e].length;
          for (var i = Array(r), n = 0, e = 0; e < t; e++)
            for (var s = arguments[e], o = 0, a = s.length; o < a; o++, n++) i[n] = s[o];
          return i
        };
      Object.defineProperty(Ro, "__esModule", {
        value: !0
      });
      Ro.Address6 = void 0;
      var tge = I6(e9()),
        a9 = I6(t9()),
        Cr = I6(s9()),
        c9 = I6(o9()),
        Th = n9(),
        Rh = ege(),
        vu = r9(),
        Zn = i9(),
        Qn = Db();

      function T6(r) {
        if (!r) throw new Error("Assertion failed.")
      }

      function xct(r) {
        for (var e = /(\d+)(\d{3})/; e.test(r);) r = r.replace(e, "$1,$2");
        return r
      }

      function Act(r) {
        return r = r.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2'), r = r.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2'), r
      }

      function Ict(r, e) {
        var t = [],
          i = [],
          n;
        for (n = 0; n < r.length; n++) n < e[0] ? t.push(r[n]) : n > e[1] && i.push(r[n]);
        return t.concat(["compact"]).concat(i)
      }

      function rge(r) {
        return Qn.sprintf("%04x", parseInt(r, 16))
      }

      function ige(r) {
        return r & 255
      }
      var Tct = function () {
        function r(e, t) {
          this.addressMinusSuffix = "", this.parsedSubnet = "", this.subnet = "/128", this.subnetMask = 128, this.v4 = !1, this.zone = "", this.isInSubnet = tge.isInSubnet, this.isCorrect = tge.isCorrect(Cr.BITS), t === void 0 ? this.groups = Cr.GROUPS : this.groups = t, this.address = e;
          var i = Cr.RE_SUBNET_STRING.exec(e);
          if (i) {
            if (this.parsedSubnet = i[0].replace("/", ""), this.subnetMask = parseInt(this.parsedSubnet, 10), this.subnet = "/" + this.subnetMask, Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > Cr.BITS) throw new vu.AddressError("Invalid subnet mask.");
            e = e.replace(Cr.RE_SUBNET_STRING, "")
          } else if (/\//.test(e)) throw new vu.AddressError("Invalid subnet mask.");
          var n = Cr.RE_ZONE_STRING.exec(e);
          n && (this.zone = n[0], e = e.replace(Cr.RE_ZONE_STRING, "")), this.addressMinusSuffix = e, this.parsedAddress = this.parse(this.addressMinusSuffix)
        }
        return r.isValid = function (e) {
          try {
            return new r(e), !0
          } catch (t) {
            return !1
          }
        }, r.fromBigInteger = function (e) {
          var t = e.toString(16).padStart(32, "0"),
            i = [],
            n;
          for (n = 0; n < Cr.GROUPS; n++) i.push(t.slice(n * 4, (n + 1) * 4));
          return new r(i.join(":"))
        }, r.fromURL = function (e) {
          var t, i = null,
            n;
          if (e.indexOf("[") !== -1 && e.indexOf("]:") !== -1) {
            if (n = Cr.RE_URL_WITH_PORT.exec(e), n === null) return {
              error: "failed to parse address with port",
              address: null,
              port: null
            };
            t = n[1], i = n[2]
          } else if (e.indexOf("/") !== -1) {
            if (e = e.replace(/^[a-z0-9]+:\/\//, ""), n = Cr.RE_URL.exec(e), n === null) return {
              error: "failed to parse address from URL",
              address: null,
              port: null
            };
            t = n[1]
          } else t = e;
          return i ? (i = parseInt(i, 10), (i < 0 || i > 65536) && (i = null)) : i = null, {
            address: new r(t),
            port: i
          }
        }, r.fromAddress4 = function (e) {
          var t = new Th.Address4(e),
            i = Cr.BITS - (a9.BITS - t.subnetMask);
          return new r("::ffff:" + t.correctForm() + "/" + i)
        }, r.fromArpa = function (e) {
          var t = e.replace(/(\.ip6\.arpa)?\.$/, ""),
            i = 7;
          if (t.length !== 63) throw new vu.AddressError("Invalid 'ip6.arpa' form.");
          for (var n = t.split(".").reverse(), s = i; s > 0; s--) {
            var o = s * 4;
            n.splice(o, 0, ":")
          }
          return t = n.join(""), new r(t)
        }, r.prototype.microsoftTranscription = function () {
          return Qn.sprintf("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"))
        }, r.prototype.mask = function (e) {
          return e === void 0 && (e = this.subnetMask), this.getBitsBase2(0, e)
        }, r.prototype.possibleSubnets = function (e) {
          e === void 0 && (e = 128);
          var t = Cr.BITS - this.subnetMask,
            i = Math.abs(e - Cr.BITS),
            n = t - i;
          return n < 0 ? "0" : xct(new Zn.BigInteger("2", 10).pow(n).toString(10))
        }, r.prototype._startAddress = function () {
          return new Zn.BigInteger(this.mask() + "0".repeat(Cr.BITS - this.subnetMask), 2)
        }, r.prototype.startAddress = function () {
          return r.fromBigInteger(this._startAddress())
        }, r.prototype.startAddressExclusive = function () {
          var e = new Zn.BigInteger("1");
          return r.fromBigInteger(this._startAddress().add(e))
        }, r.prototype._endAddress = function () {
          return new Zn.BigInteger(this.mask() + "1".repeat(Cr.BITS - this.subnetMask), 2)
        }, r.prototype.endAddress = function () {
          return r.fromBigInteger(this._endAddress())
        }, r.prototype.endAddressExclusive = function () {
          var e = new Zn.BigInteger("1");
          return r.fromBigInteger(this._endAddress().subtract(e))
        }, r.prototype.getScope = function () {
          var e = Cr.SCOPES[this.getBits(12, 16).intValue()];
          return this.getType() === "Global unicast" && e !== "Link local" && (e = "Global"), e || "Unknown"
        }, r.prototype.getType = function () {
          for (var e = 0, t = Object.keys(Cr.TYPES); e < t.length; e++) {
            var i = t[e];
            if (this.isInSubnet(new r(i))) return Cr.TYPES[i]
          }
          return "Global unicast"
        }, r.prototype.getBits = function (e, t) {
          return new Zn.BigInteger(this.getBitsBase2(e, t), 2)
        }, r.prototype.getBitsBase2 = function (e, t) {
          return this.binaryZeroPad().slice(e, t)
        }, r.prototype.getBitsBase16 = function (e, t) {
          var i = t - e;
          if (i % 4 != 0) throw new Error("Length of bits to retrieve must be divisible by four");
          return this.getBits(e, t).toString(16).padStart(i / 4, "0")
        }, r.prototype.getBitsPastSubnet = function () {
          return this.getBitsBase2(this.subnetMask, Cr.BITS)
        }, r.prototype.reverseForm = function (e) {
          e || (e = {});
          var t = Math.floor(this.subnetMask / 4),
            i = this.canonicalForm().replace(/:/g, "").split("").slice(0, t).reverse().join(".");
          return t > 0 ? e.omitSuffix ? i : Qn.sprintf("%s.ip6.arpa.", i) : e.omitSuffix ? "" : "ip6.arpa."
        }, r.prototype.correctForm = function () {
          var e, t = [],
            i = 0,
            n = [];
          for (e = 0; e < this.parsedAddress.length; e++) {
            var s = parseInt(this.parsedAddress[e], 16);
            s === 0 && i++, s !== 0 && i > 0 && (i > 1 && n.push([e - i, e - 1]), i = 0)
          }
          i > 1 && n.push([this.parsedAddress.length - i, this.parsedAddress.length - 1]);
          var o = n.map(function (u) {
            return u[1] - u[0] + 1
          });
          if (n.length > 0) {
            var a = o.indexOf(Math.max.apply(Math, o));
            t = Ict(this.parsedAddress, n[a])
          } else t = this.parsedAddress;
          for (e = 0; e < t.length; e++) t[e] !== "compact" && (t[e] = parseInt(t[e], 16).toString(16));
          var c = t.join(":");
          return c = c.replace(/^compact$/, "::"), c = c.replace(/^compact|compact$/, ":"), c = c.replace(/compact/, ""), c
        }, r.prototype.binaryZeroPad = function () {
          return this.bigInteger().toString(2).padStart(Cr.BITS, "0")
        }, r.prototype.parse4in6 = function (e) {
          var t = e.split(":"),
            i = t.slice(-1)[0],
            n = i.match(a9.RE_ADDRESS);
          if (n) {
            this.parsedAddress4 = n[0], this.address4 = new Th.Address4(this.parsedAddress4);
            for (var s = 0; s < this.address4.groups; s++)
              if (/^0[0-9]+/.test(this.address4.parsedAddress[s])) throw new vu.AddressError("IPv4 addresses can't have leading zeroes.", e.replace(a9.RE_ADDRESS, this.address4.parsedAddress.map(Act).join(".")));
            this.v4 = !0, t[t.length - 1] = this.address4.toGroup6(), e = t.join(":")
          }
          return e
        }, r.prototype.parse = function (e) {
          e = this.parse4in6(e);
          var t = e.match(Cr.RE_BAD_CHARACTERS);
          if (t) throw new vu.AddressError(Qn.sprintf("Bad character%s detected in address: %s", t.length > 1 ? "s" : "", t.join("")), e.replace(Cr.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
          var i = e.match(Cr.RE_BAD_ADDRESS);
          if (i) throw new vu.AddressError(Qn.sprintf("Address failed regex: %s", i.join("")), e.replace(Cr.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
          var n = [],
            s = e.split("::");
          if (s.length === 2) {
            var o = s[0].split(":"),
              a = s[1].split(":");
            o.length === 1 && o[0] === "" && (o = []), a.length === 1 && a[0] === "" && (a = []);
            var c = this.groups - (o.length + a.length);
            if (!c) throw new vu.AddressError("Error parsing groups");
            this.elidedGroups = c, this.elisionBegin = o.length, this.elisionEnd = o.length + this.elidedGroups, n = n.concat(o);
            for (var u = 0; u < c; u++) n.push("0");
            n = n.concat(a)
          } else if (s.length === 1) n = e.split(":"), this.elidedGroups = 0;
          else throw new vu.AddressError("Too many :: groups found");
          if (n = n.map(function (f) {
            return Qn.sprintf("%x", parseInt(f, 16))
          }), n.length !== this.groups) throw new vu.AddressError("Incorrect number of groups found");
          return n
        }, r.prototype.canonicalForm = function () {
          return this.parsedAddress.map(rge).join(":")
        }, r.prototype.decimal = function () {
          return this.parsedAddress.map(function (e) {
            return Qn.sprintf("%05d", parseInt(e, 16))
          }).join(":")
        }, r.prototype.bigInteger = function () {
          return new Zn.BigInteger(this.parsedAddress.map(rge).join(""), 16)
        }, r.prototype.to4 = function () {
          var e = this.binaryZeroPad().split("");
          return Th.Address4.fromHex(new Zn.BigInteger(e.slice(96, 128).join(""), 2).toString(16))
        }, r.prototype.to4in6 = function () {
          var e = this.to4(),
            t = new r(this.parsedAddress.slice(0, 6).join(":"), 6),
            i = t.correctForm(),
            n = "";
          return /:$/.test(i) || (n = ":"), i + n + e.address
        }, r.prototype.inspectTeredo = function () {
          var e = this.getBitsBase16(0, 32),
            t = this.getBits(80, 96).xor(new Zn.BigInteger("ffff", 16)).toString(),
            i = Th.Address4.fromHex(this.getBitsBase16(32, 64)),
            n = Th.Address4.fromHex(this.getBits(96, 128).xor(new Zn.BigInteger("ffffffff", 16)).toString(16)),
            s = this.getBits(64, 80),
            o = this.getBitsBase2(64, 80),
            a = s.testBit(15),
            c = s.testBit(14),
            u = s.testBit(8),
            f = s.testBit(9),
            h = new Zn.BigInteger(o.slice(2, 6) + o.slice(8, 16), 2).toString(10);
          return {
            prefix: Qn.sprintf("%s:%s", e.slice(0, 4), e.slice(4, 8)),
            server4: i.address,
            client4: n.address,
            flags: o,
            coneNat: a,
            microsoft: {
              reserved: c,
              universalLocal: f,
              groupIndividual: u,
              nonce: h
            },
            udpPort: t
          }
        }, r.prototype.inspect6to4 = function () {
          var e = this.getBitsBase16(0, 16),
            t = Th.Address4.fromHex(this.getBitsBase16(16, 48));
          return {
            prefix: Qn.sprintf("%s", e.slice(0, 4)),
            gateway: t.address
          }
        }, r.prototype.to6to4 = function () {
          if (!this.is4()) return null;
          var e = ["2002", this.getBitsBase16(96, 112), this.getBitsBase16(112, 128), "", "/16"].join(":");
          return new r(e)
        }, r.prototype.toByteArray = function () {
          var e = this.bigInteger().toByteArray();
          return e.length === 17 && e[0] === 0 ? e.slice(1) : e
        }, r.prototype.toUnsignedByteArray = function () {
          return this.toByteArray().map(ige)
        }, r.fromByteArray = function (e) {
          return this.fromUnsignedByteArray(e.map(ige))
        }, r.fromUnsignedByteArray = function (e) {
          for (var t = new Zn.BigInteger("256", 10), i = new Zn.BigInteger("0", 10), n = new Zn.BigInteger("1", 10), s = e.length - 1; s >= 0; s--) i = i.add(n.multiply(new Zn.BigInteger(e[s].toString(10), 10))), n = n.multiply(t);
          return r.fromBigInteger(i)
        }, r.prototype.isCanonical = function () {
          return this.addressMinusSuffix === this.canonicalForm()
        }, r.prototype.isLinkLocal = function () {
          return this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000"
        }, r.prototype.isMulticast = function () {
          return this.getType() === "Multicast"
        }, r.prototype.is4 = function () {
          return this.v4
        }, r.prototype.isTeredo = function () {
          return this.isInSubnet(new r("2001::/32"))
        }, r.prototype.is6to4 = function () {
          return this.isInSubnet(new r("2002::/16"))
        }, r.prototype.isLoopback = function () {
          return this.getType() === "Loopback"
        }, r.prototype.href = function (e) {
          return e === void 0 ? e = "" : e = Qn.sprintf(":%s", e), Qn.sprintf("http://[%s]%s/", this.correctForm(), e)
        }, r.prototype.link = function (e) {
          e || (e = {}), e.className === void 0 && (e.className = ""), e.prefix === void 0 && (e.prefix = "/#address="), e.v4 === void 0 && (e.v4 = !1);
          var t = this.correctForm;
          return e.v4 && (t = this.to4in6), e.className ? Qn.sprintf('<a href="%1$s%2$s" class="%3$s">%2$s</a>', e.prefix, t.call(this), e.className) : Qn.sprintf('<a href="%1$s%2$s">%2$s</a>', e.prefix, t.call(this))
        }, r.prototype.group = function () {
          if (this.elidedGroups === 0) return c9.simpleGroup(this.address).join(":");
          T6(typeof this.elidedGroups == "number"), T6(typeof this.elisionBegin == "number");
          var e = [],
            t = this.address.split("::"),
            i = t[0],
            n = t[1];
          i.length ? e.push.apply(e, c9.simpleGroup(i)) : e.push("");
          for (var s = ["hover-group"], o = this.elisionBegin; o < this.elisionBegin + this.elidedGroups; o++) s.push(Qn.sprintf("group-%d", o));
          return e.push(Qn.sprintf('<span class="%s"></span>', s.join(" "))), n.length ? e.push.apply(e, c9.simpleGroup(n, this.elisionEnd)) : e.push(""), this.is4() && (T6(this.address4 instanceof Th.Address4), e.pop(), e.push(this.address4.groupForV6())), e.join(":")
        }, r.prototype.regularExpressionString = function (e) {
          e === void 0 && (e = !1);
          var t = [],
            i = new r(this.correctForm());
          if (i.elidedGroups === 0) t.push(Rh.simpleRegularExpression(i.parsedAddress));
          else if (i.elidedGroups === Cr.GROUPS) t.push(Rh.possibleElisions(Cr.GROUPS));
          else {
            var n = i.address.split("::");
            n[0].length && t.push(Rh.simpleRegularExpression(n[0].split(":"))), T6(typeof i.elidedGroups == "number"), t.push(Rh.possibleElisions(i.elidedGroups, n[0].length !== 0, n[1].length !== 0)), n[1].length && t.push(Rh.simpleRegularExpression(n[1].split(":"))), t = [t.join(":")]
          }
          return e || (t = Sct(["(?=^|", Rh.ADDRESS_BOUNDARY, "|[^\\w\\:])("], t, [")(?=[^\\w\\:]|", Rh.ADDRESS_BOUNDARY, "|$)"])), t.join("")
        }, r.prototype.regularExpression = function (e) {
          return e === void 0 && (e = !1), new RegExp(this.regularExpressionString(e), "i")
        }, r
      }();
      Ro.Address6 = Tct
    });
    var sge = y(_s => {
      l();
      "use strict";
      var Rct = _s && _s.__createBinding || (Object.create ? function (r, e, t, i) {
        i === void 0 && (i = t), Object.defineProperty(r, i, {
          enumerable: !0,
          get: function () {
            return e[t]
          }
        })
      } : function (r, e, t, i) {
        i === void 0 && (i = t), r[i] = e[t]
      }),
        kct = _s && _s.__setModuleDefault || (Object.create ? function (r, e) {
          Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
          })
        } : function (r, e) {
          r.default = e
        }),
        Pct = _s && _s.__importStar || function (r) {
          if (r && r.__esModule) return r;
          var e = {};
          if (r != null)
            for (var t in r) t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && Rct(e, r, t);
          return kct(e, r), e
        };
      Object.defineProperty(_s, "__esModule", {
        value: !0
      });
      _s.v6 = _s.Address6 = _s.Address4 = void 0;
      var Cct = n9();
      Object.defineProperty(_s, "Address4", {
        enumerable: !0,
        get: function () {
          return Cct.Address4
        }
      });
      var Oct = nge();
      Object.defineProperty(_s, "Address6", {
        enumerable: !0,
        get: function () {
          return Oct.Address6
        }
      });
      var Nct = Pct(o9());
      _s.v6 = {
        helpers: Nct
      }
    });
    var h9 = y((yIt, u9) => {
      l();
      "use strict";
      var oge = Oe(),
        qct = Object.assign(oge("libp2p:ip-port-to-multiaddr"), {
          error: oge("libp2p:ip-port-to-multiaddr:err")
        }),
        {
          Multiaddr: f9
        } = pr(),
        l9 = xe(),
        {
          Address4: Mct,
          Address6: Bct
        } = sge(),
        R6 = {
          ERR_INVALID_IP_PARAMETER: "ERR_INVALID_IP_PARAMETER",
          ERR_INVALID_PORT_PARAMETER: "ERR_INVALID_PORT_PARAMETER",
          ERR_INVALID_IP: "ERR_INVALID_IP"
        };

      function Dct(r, e) {
        if (typeof r != "string") throw l9(new Error(`invalid ip provided: ${r}`), R6.ERR_INVALID_IP_PARAMETER);
        if (typeof e == "string" && (e = parseInt(e)), isNaN(e)) throw l9(new Error(`invalid port provided: ${e}`), R6.ERR_INVALID_PORT_PARAMETER);
        try {
          return new Mct(r), new f9(`/ip4/${r}/tcp/${e}`)
        } catch { }
        try {
          let t = new Bct(r);
          return t.is4() ? new f9(`/ip4/${t.to4().correctForm()}/tcp/${e}`) : new f9(`/ip6/${r}/tcp/${e}`)
        } catch (t) {
          let i = `invalid ip:port for creating a multiaddr: ${r}:${e}`;
          throw qct.error(i), l9(new Error(i), R6.ERR_INVALID_IP)
        }
      }
      u9.exports = Dct;
      u9.exports.Errors = R6
    });
    var jp = y((gIt, k6) => {
      l();
      "use strict";
      var d9 = class extends Error {
        constructor(e) {
          super(e);
          this.name = "TimeoutError"
        }
      },
        age = (r, e, t, i) => {
          let n, s = new Promise((o, a) => {
            if (typeof e != "number" || e < 0) throw new TypeError("Expected `milliseconds` to be a positive number");
            if (e === Infinity) {
              o(r);
              return
            }
            i = {
              customTimers: {
                setTimeout,
                clearTimeout
              },
              ...i
            }, n = i.customTimers.setTimeout.call(void 0, () => {
              if (typeof t == "function") {
                try {
                  o(t())
                } catch (f) {
                  a(f)
                }
                return
              }
              let c = typeof t == "string" ? t : `Promise timed out after ${e} milliseconds`,
                u = t instanceof Error ? t : new d9(c);
              typeof r.cancel == "function" && r.cancel(), a(u)
            }, e), (async () => {
              try {
                o(await r)
              } catch (c) {
                a(c)
              } finally {
                i.customTimers.clearTimeout.call(void 0, n)
              }
            })()
          });
          return s.clear = () => {
            clearTimeout(n), n = void 0
          }, s
        };
      k6.exports = age;
      k6.exports.default = age;
      k6.exports.TimeoutError = d9
    });
    var hge = y((bIt, cge) => {
      l();
      "use strict";
      var uge = au(),
        {
          CLOSE_TIMEOUT: Lct
        } = QR(),
        fge = h9(),
        Fct = jp(),
        lge = Oe(),
        p9 = lge("libp2p:websockets:socket");
      p9.error = lge("libp2p:websockets:socket:error");
      cge.exports = (r, e = {}) => {
        let t = {
          async sink(i) {
            e.signal && (i = uge(i, e.signal));
            try {
              await r.sink(async function* () {
                for await (let n of i) yield n instanceof Uint8Array ? n : n.slice()
              }())
            } catch (n) {
              n.type !== "aborted" && p9.error(n)
            }
          },
          source: e.signal ? uge(r.source, e.signal) : r.source,
          conn: r,
          localAddr: e.localAddr || (r.localAddress && r.localPort ? fge(r.localAddress, r.localPort) : void 0),
          remoteAddr: e.remoteAddr || fge(r.remoteAddress, r.remotePort),
          timeline: {
            open: Date.now()
          },
          async close() {
            let i = Date.now();
            try {
              await Fct(r.close(), Lct)
            } catch (n) {
              let {
                host: s,
                port: o
              } = t.remoteAddr.toOptions();
              p9("timeout closing stream to %s:%s after %dms, destroying it manually", s, o, Date.now() - i), r.destroy()
            } finally {
              t.timeline.close = Date.now()
            }
          }
        };
        return r.socket.once && r.socket.once("close", () => {
          t.timeline.close || (t.timeline.close = Date.now())
        }), t
      }
    });
    var yge = y((mIt, dge) => {
      l();
      "use strict";
      var Kf = El(),
        {
          CODE_CIRCUIT: y9,
          CODE_P2P: g9,
          CODE_TCP: b9,
          CODE_WS: Uct,
          CODE_WSS: pge
        } = QR();
      dge.exports = {
        all: r => r.filter(e => {
          if (e.protoCodes().includes(y9)) return !1;
          let t = e.decapsulateCode(g9);
          return Kf.WebSockets.matches(t) || Kf.WebSocketsSecure.matches(t)
        }),
        dnsWss: r => r.filter(e => {
          if (e.protoCodes().includes(y9)) return !1;
          let t = e.decapsulateCode(g9);
          return Kf.WebSocketsSecure.matches(t) && Kf.DNS.matches(t.decapsulateCode(b9).decapsulateCode(pge))
        }),
        dnsWsOrWss: r => r.filter(e => {
          if (e.protoCodes().includes(y9)) return !1;
          let t = e.decapsulateCode(g9);
          return Kf.WebSockets.matches(t) ? Kf.DNS.matches(t.decapsulateCode(b9).decapsulateCode(Uct)) : Kf.WebSocketsSecure.matches(t) && Kf.DNS.matches(t.decapsulateCode(b9).decapsulateCode(pge))
        })
      }
    });
    var Ege = y((vIt, gge) => {
      l();
      "use strict";
      var Kct = zye(),
        zct = z2(),
        jct = iA(),
        {
          AbortError: bge
        } = au(),
        Vct = wb(),
        mge = Oe(),
        zf = mge("libp2p:websockets");
      zf.error = mge("libp2p:websockets:error");
      var vge = Vye(),
        Hct = Gye(),
        Gct = hge(),
        wge = yge(),
        _ge = class {
          constructor({
            upgrader: e,
            filter: t
          }) {
            if (!e) throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");
            this._upgrader = e, this._filter = t
          }
          async dial(e, t = {}) {
            zf("dialing %s", e);
            let i = await this._connect(e, t),
              n = Gct(i, {
                remoteAddr: e,
                signal: t.signal
              });
            zf("new outbound connection %s", n.remoteAddr);
            let s = await this._upgrader.upgradeOutbound(n);
            return zf("outbound connection %s upgraded", n.remoteAddr), s
          }
          async _connect(e, t = {}) {
            if (t.signal && t.signal.aborted) throw new bge;
            let i = e.toOptions();
            zf("dialing %s:%s", i.host, i.port);
            let n = Vct(),
              s = u => {
                let f = `connection error: ${u.message}`;
                zf.error(f), n.reject(u)
              },
              o = Kct(jct(e), Object.assign({
                binary: !0
              }, t));
            if (o.socket.on ? o.socket.on("error", s) : o.socket.onerror = s, !t.signal) return await Promise.race([o.connected(), n.promise]), zf("connected %s", e), o;
            let a, c = new Promise((u, f) => {
              if (a = () => {
                f(new bge), setTimeout(() => {
                  o.close()
                })
              }, t.signal.aborted) return a();
              t.signal.addEventListener("abort", a)
            });
            try {
              await Promise.race([c, n.promise, o.connected()])
            } finally {
              t.signal.removeEventListener("abort", a)
            }
            return zf("connected %s", e), o
          }
          createListener(e = {}, t) {
            return typeof e == "function" && (t = e, e = {}), Hct({
              handler: t,
              upgrader: this._upgrader
            }, e)
          }
          filter(e) {
            return e = Array.isArray(e) ? e : [e], this._filter ? this._filter(e) : vge.isBrowser || vge.isWebWorker ? wge.dnsWss(e) : wge.all(e)
          }
        };
      gge.exports = zct(_ge, {
        className: "WebSockets",
        symbolName: "@libp2p/js-libp2p-websockets/websockets"
      })
    });
    var xge = y((wIt, Sge) => {
      l();
      Sge.exports = function () {
        if (typeof globalThis == "undefined") return null;
        var e = {
          RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
          RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
          RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
        };
        return e.RTCPeerConnection ? e : null
      }
    });
    var Tge = y((m9, Age) => {
      l();
      var P6 = Wt(),
        wc = P6.Buffer;

      function Ige(r, e) {
        for (var t in r) e[t] = r[t]
      }
      wc.from && wc.alloc && wc.allocUnsafe && wc.allocUnsafeSlow ? Age.exports = P6 : (Ige(P6, m9), m9.Buffer = kh);

      function kh(r, e, t) {
        return wc(r, e, t)
      }
      kh.prototype = Object.create(wc.prototype);
      Ige(wc, kh);
      kh.from = function (r, e, t) {
        if (typeof r == "number") throw new TypeError("Argument must not be a number");
        return wc(r, e, t)
      };
      kh.alloc = function (r, e, t) {
        if (typeof r != "number") throw new TypeError("Argument must be a number");
        var i = wc(r);
        return e !== void 0 ? typeof t == "string" ? i.fill(e, t) : i.fill(e) : i.fill(0), i
      };
      kh.allocUnsafe = function (r) {
        if (typeof r != "number") throw new TypeError("Argument must be a number");
        return wc(r)
      };
      kh.allocUnsafeSlow = function (r) {
        if (typeof r != "number") throw new TypeError("Argument must be a number");
        return P6.SlowBuffer(r)
      }
    });
    var _9 = y((_It, v9) => {
      l();
      "use strict";
      var w9 = 65536,
        $ct = 4294967295;

      function Wct() {
        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)
      }
      var Yct = Tge().Buffer,
        C6 = globalThis.crypto || globalThis.msCrypto;
      C6 && C6.getRandomValues ? v9.exports = Jct : v9.exports = Wct;

      function Jct(r, e) {
        if (r > $ct) throw new RangeError("requested too many random bytes");
        var t = Yct.allocUnsafe(r);
        if (r > 0)
          if (r > w9)
            for (var i = 0; i < r; i += w9) C6.getRandomValues(t.slice(i, i + w9));
          else C6.getRandomValues(t);
        return typeof e == "function" ? process.nextTick(function () {
          e(null, t)
        }) : t
      }
    });
    var Pge = y((EIt, Rge) => {
      l();
      "use strict";

      function kge(r, e) {
        for (let t in e) Object.defineProperty(r, t, {
          value: e[t],
          enumerable: !0,
          configurable: !0
        });
        return r
      }

      function Xct(r, e, t) {
        if (!r || typeof r == "string") throw new TypeError("Please pass an Error to err-code");
        t || (t = {}), typeof e == "object" && (t = e, e = void 0), e != null && (t.code = e);
        try {
          return kge(r, t)
        } catch (i) {
          t.message = r.message, t.stack = r.stack;
          let n = function () { };
          return n.prototype = Object.create(Object.getPrototypeOf(r)), kge(new n, t)
        }
      }
      Rge.exports = Xct
    });
    var x9 = y((SIt, Cge) => {
      l();
      var Zct = Oe()("simple-peer"),
        Oge = xge(),
        Nge = _9(),
        Qct = iT(),
        E9 = b3(),
        Or = Pge(),
        S9 = 64 * 1024,
        eut = 5 * 1e3,
        tut = 5 * 1e3;

      function qge(r) {
        return r.replace(/a=ice-options:trickle\s\n/g, "")
      }

      function rut(r) {
        console.warn(r)
      }
      var jf = class extends Qct.Duplex {
        constructor(e) {
          if (e = Object.assign({
            allowHalfOpen: !1
          }, e), super(e), this._id = Nge(4).toString("hex").slice(0, 7), this._debug("new peer %o", e), this.channelName = e.initiator ? e.channelName || Nge(20).toString("hex") : null, this.initiator = e.initiator || !1, this.channelConfig = e.channelConfig || jf.channelConfig, this.negotiated = this.channelConfig.negotiated, this.config = Object.assign({}, jf.config, e.config), this.offerOptions = e.offerOptions || {}, this.answerOptions = e.answerOptions || {}, this.sdpTransform = e.sdpTransform || (t => t), this.streams = e.streams || (e.stream ? [e.stream] : []), this.trickle = e.trickle !== void 0 ? e.trickle : !0, this.allowHalfTrickle = e.allowHalfTrickle !== void 0 ? e.allowHalfTrickle : !1, this.iceCompleteTimeout = e.iceCompleteTimeout || eut, this._connected = !1, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = e.wrtc && typeof e.wrtc == "object" ? e.wrtc : Oge(), !this._wrtc) throw typeof window == "undefined" ? Or(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT") : Or(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
          this._pcReady = !1, this._channelReady = !1, this._iceComplete = !1, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = this.negotiated ? !1 : !this.initiator, this._batchedNegotiation = !1, this._queuedNegotiation = !1, this._sendersAwaitingStable = [], this._senderMap = new Map, this._firstStable = !0, this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
          try {
            this._pc = new this._wrtc.RTCPeerConnection(this.config)
          } catch (t) {
            E9(() => this.destroy(Or(t, "ERR_PC_CONSTRUCTOR")));
            return
          }
          this._isReactNativeWebrtc = typeof this._pc._peerConnectionId == "number", this._pc.oniceconnectionstatechange = () => {
            this._onIceStateChange()
          }, this._pc.onicegatheringstatechange = () => {
            this._onIceStateChange()
          }, this._pc.onconnectionstatechange = () => {
            this._onConnectionStateChange()
          }, this._pc.onsignalingstatechange = () => {
            this._onSignalingStateChange()
          }, this._pc.onicecandidate = t => {
            this._onIceCandidate(t)
          }, this.initiator || this.negotiated ? this._setupData({
            channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
          }) : this._pc.ondatachannel = t => {
            this._setupData(t)
          }, this.streams && this.streams.forEach(t => {
            this.addStream(t)
          }), this._pc.ontrack = t => {
            this._onTrack(t)
          }, this.initiator && this._needsNegotiation(), this._onFinishBound = () => {
            this._onFinish()
          }, this.once("finish", this._onFinishBound)
        }
        get bufferSize() {
          return this._channel && this._channel.bufferedAmount || 0
        }
        get connected() {
          return this._connected && this._channel.readyState === "open"
        }
        address() {
          return {
            port: this.localPort,
            family: this.localFamily,
            address: this.localAddress
          }
        }
        signal(e) {
          if (this.destroyed) throw Or(new Error("cannot signal after peer is destroyed"), "ERR_SIGNALING");
          if (typeof e == "string") try {
            e = JSON.parse(e)
          } catch (t) {
            e = {}
          }
          this._debug("signal()"), e.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), e.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(e.transceiverRequest.kind, e.transceiverRequest.init)), e.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e.candidate) : this._pendingCandidates.push(e.candidate)), e.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e)).then(() => {
            this.destroyed || (this._pendingCandidates.forEach(t => {
              this._addIceCandidate(t)
            }), this._pendingCandidates = [], this._pc.remoteDescription.type === "offer" && this._createAnswer())
          }).catch(t => {
            this.destroy(Or(t, "ERR_SET_REMOTE_DESCRIPTION"))
          }), !e.sdp && !e.candidate && !e.renegotiate && !e.transceiverRequest && this.destroy(Or(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"))
        }
        _addIceCandidate(e) {
          var t = new this._wrtc.RTCIceCandidate(e);
          this._pc.addIceCandidate(t).catch(i => {
            !t.address || t.address.endsWith(".local") ? rut("Ignoring unsupported ICE candidate.") : this.destroy(Or(i, "ERR_ADD_ICE_CANDIDATE"))
          })
        }
        send(e) {
          this._channel.send(e)
        }
        addTransceiver(e, t) {
          if (this._debug("addTransceiver()"), this.initiator) try {
            this._pc.addTransceiver(e, t), this._needsNegotiation()
          } catch (i) {
            this.destroy(Or(i, "ERR_ADD_TRANSCEIVER"))
          } else this.emit("signal", {
            transceiverRequest: {
              kind: e,
              init: t
            }
          })
        }
        addStream(e) {
          this._debug("addStream()"), e.getTracks().forEach(t => {
            this.addTrack(t, e)
          })
        }
        addTrack(e, t) {
          this._debug("addTrack()");
          var i = this._senderMap.get(e) || new Map,
            n = i.get(t);
          if (!n) n = this._pc.addTrack(e, t), i.set(t, n), this._senderMap.set(e, i), this._needsNegotiation();
          else throw n.removed ? Or(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED") : Or(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED")
        }
        replaceTrack(e, t, i) {
          this._debug("replaceTrack()");
          var n = this._senderMap.get(e),
            s = n ? n.get(i) : null;
          if (!s) throw Or(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
          t && this._senderMap.set(t, n), s.replaceTrack != null ? s.replaceTrack(t) : this.destroy(Or(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"))
        }
        removeTrack(e, t) {
          this._debug("removeSender()");
          var i = this._senderMap.get(e),
            n = i ? i.get(t) : null;
          if (!n) throw Or(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
          try {
            n.removed = !0, this._pc.removeTrack(n)
          } catch (s) {
            s.name === "NS_ERROR_UNEXPECTED" ? this._sendersAwaitingStable.push(n) : this.destroy(Or(s, "ERR_REMOVE_TRACK"))
          }
          this._needsNegotiation()
        }
        removeStream(e) {
          this._debug("removeSenders()"), e.getTracks().forEach(t => {
            this.removeTrack(t, e)
          })
        }
        _needsNegotiation() {
          this._debug("_needsNegotiation"), !this._batchedNegotiation && (this._batchedNegotiation = !0, E9(() => {
            this._batchedNegotiation = !1, this._debug("starting batched negotiation"), this.negotiate()
          }))
        }
        negotiate() {
          this.initiator ? this._isNegotiating ? (this._queuedNegotiation = !0, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => {
            this._createOffer()
          }, 0)) : this._isNegotiating ? (this._queuedNegotiation = !0, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", {
            renegotiate: !0
          })), this._isNegotiating = !0
        }
        _destroy(e, t) {
          if (this._debug("destroy (error: %s)", e && (e.message || e)), this.readable = this.writable = !1, this._readableState.ended || this.push(null), this._writableState.finished || this.end(), this._connected = !1, this._pcReady = !1, this._channelReady = !1, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
            try {
              this._channel.close()
            } catch (i) { }
            this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null
          }
          if (this._pc) {
            try {
              this._pc.close()
            } catch (i) { }
            this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null
          }
          this._pc = null, this._channel = null, t(e)
        }
        _setupData(e) {
          if (!e.channel) return this.destroy(Or(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
          this._channel = e.channel, this._channel.binaryType = "arraybuffer", typeof this._channel.bufferedAmountLowThreshold == "number" && (this._channel.bufferedAmountLowThreshold = S9), this.channelName = this._channel.label, this._channel.onmessage = i => {
            this._onChannelMessage(i)
          }, this._channel.onbufferedamountlow = () => {
            this._onChannelBufferedAmountLow()
          }, this._channel.onopen = () => {
            this._onChannelOpen()
          }, this._channel.onclose = () => {
            this._onChannelClose()
          }, this._channel.onerror = i => {
            this.destroy(Or(i, "ERR_DATA_CHANNEL"))
          };
          var t = !1;
          this._closingInterval = setInterval(() => {
            this._channel && this._channel.readyState === "closing" ? (t && this._onChannelClose(), t = !0) : t = !1
          }, tut)
        }
        _read() { }
        _write(e, t, i) {
          if (this.destroyed) return i(Or(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
          if (this._connected) {
            try {
              this.send(e)
            } catch (n) {
              return this.destroy(Or(n, "ERR_DATA_CHANNEL"))
            }
            this._channel.bufferedAmount > S9 ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = i) : i(null)
          } else this._debug("write before connect"), this._chunk = e, this._cb = i
        }
        _onFinish() {
          if (this.destroyed) return;
          let e = () => {
            setTimeout(() => this.destroy(), 1e3)
          };
          this._connected ? e() : this.once("connect", e)
        }
        _startIceCompleteTimeout() {
          this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => {
            this._iceComplete || (this._iceComplete = !0, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"))
          }, this.iceCompleteTimeout))
        }
        _createOffer() {
          this.destroyed || this._pc.createOffer(this.offerOptions).then(e => {
            if (this.destroyed) return;
            !this.trickle && !this.allowHalfTrickle && (e.sdp = qge(e.sdp)), e.sdp = this.sdpTransform(e.sdp);
            let t = () => {
              if (!this.destroyed) {
                var s = this._pc.localDescription || e;
                this._debug("signal"), this.emit("signal", {
                  type: s.type,
                  sdp: s.sdp
                })
              }
            },
              i = () => {
                this._debug("createOffer success"), !this.destroyed && (this.trickle || this._iceComplete ? t() : this.once("_iceComplete", t))
              },
              n = s => {
                this.destroy(Or(s, "ERR_SET_LOCAL_DESCRIPTION"))
              };
            this._pc.setLocalDescription(e).then(i).catch(n)
          }).catch(e => {
            this.destroy(Or(e, "ERR_CREATE_OFFER"))
          })
        }
        _requestMissingTransceivers() {
          this._pc.getTransceivers && this._pc.getTransceivers().forEach(e => {
            !e.mid && e.sender.track && !e.requested && (e.requested = !0, this.addTransceiver(e.sender.track.kind))
          })
        }
        _createAnswer() {
          this.destroyed || this._pc.createAnswer(this.answerOptions).then(e => {
            if (this.destroyed) return;
            !this.trickle && !this.allowHalfTrickle && (e.sdp = qge(e.sdp)), e.sdp = this.sdpTransform(e.sdp);
            let t = () => {
              if (!this.destroyed) {
                var s = this._pc.localDescription || e;
                this._debug("signal"), this.emit("signal", {
                  type: s.type,
                  sdp: s.sdp
                }), this.initiator || this._requestMissingTransceivers()
              }
            },
              i = () => {
                this.destroyed || (this.trickle || this._iceComplete ? t() : this.once("_iceComplete", t))
              },
              n = s => {
                this.destroy(Or(s, "ERR_SET_LOCAL_DESCRIPTION"))
              };
            this._pc.setLocalDescription(e).then(i).catch(n)
          }).catch(e => {
            this.destroy(Or(e, "ERR_CREATE_ANSWER"))
          })
        }
        _onConnectionStateChange() {
          this.destroyed || this._pc.connectionState === "failed" && this.destroy(Or(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"))
        }
        _onIceStateChange() {
          if (!this.destroyed) {
            var e = this._pc.iceConnectionState,
              t = this._pc.iceGatheringState;
            this._debug("iceStateChange (connection: %s) (gathering: %s)", e, t), this.emit("iceStateChange", e, t), (e === "connected" || e === "completed") && (this._pcReady = !0, this._maybeReady()), e === "failed" && this.destroy(Or(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), e === "closed" && this.destroy(Or(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"))
          }
        }
        getStats(e) {
          let t = i => (Object.prototype.toString.call(i.values) === "[object Array]" && i.values.forEach(n => {
            Object.assign(i, n)
          }), i);
          this._pc.getStats.length === 0 || this._isReactNativeWebrtc ? this._pc.getStats().then(i => {
            var n = [];
            i.forEach(s => {
              n.push(t(s))
            }), e(null, n)
          }, i => e(i)) : this._pc.getStats.length > 0 ? this._pc.getStats(i => {
            if (!this.destroyed) {
              var n = [];
              i.result().forEach(s => {
                var o = {};
                s.names().forEach(a => {
                  o[a] = s.stat(a)
                }), o.id = s.id, o.type = s.type, o.timestamp = s.timestamp, n.push(t(o))
              }), e(null, n)
            }
          }, i => e(i)) : e(null, [])
        }
        _maybeReady() {
          if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady) return;
          this._connecting = !0;
          let e = () => {
            this.destroyed || this.getStats((t, i) => {
              if (this.destroyed) return;
              t && (i = []);
              var n = {},
                s = {},
                o = {},
                a = !1;
              i.forEach(f => {
                (f.type === "remotecandidate" || f.type === "remote-candidate") && (n[f.id] = f), (f.type === "localcandidate" || f.type === "local-candidate") && (s[f.id] = f), (f.type === "candidatepair" || f.type === "candidate-pair") && (o[f.id] = f)
              });
              let c = f => {
                a = !0;
                var h = s[f.localCandidateId];
                h && (h.ip || h.address) ? (this.localAddress = h.ip || h.address, this.localPort = Number(h.port)) : h && h.ipAddress ? (this.localAddress = h.ipAddress, this.localPort = Number(h.portNumber)) : typeof f.googLocalAddress == "string" && (h = f.googLocalAddress.split(":"), this.localAddress = h[0], this.localPort = Number(h[1])), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
                var d = n[f.remoteCandidateId];
                d && (d.ip || d.address) ? (this.remoteAddress = d.ip || d.address, this.remotePort = Number(d.port)) : d && d.ipAddress ? (this.remoteAddress = d.ipAddress, this.remotePort = Number(d.portNumber)) : typeof f.googRemoteAddress == "string" && (d = f.googRemoteAddress.split(":"), this.remoteAddress = d[0], this.remotePort = Number(d[1])), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort)
              };
              if (i.forEach(f => {
                f.type === "transport" && f.selectedCandidatePairId && c(o[f.selectedCandidatePairId]), (f.type === "googCandidatePair" && f.googActiveConnection === "true" || (f.type === "candidatepair" || f.type === "candidate-pair") && f.selected) && c(f)
              }), !a && (!Object.keys(o).length || Object.keys(s).length)) {
                setTimeout(e, 100);
                return
              } else this._connecting = !1, this._connected = !0;
              if (this._chunk) {
                try {
                  this.send(this._chunk)
                } catch (f) {
                  return this.destroy(Or(f, "ERR_DATA_CHANNEL"))
                }
                this._chunk = null, this._debug('sent chunk from "write before connect"');
                var u = this._cb;
                this._cb = null, u(null)
              }
              typeof this._channel.bufferedAmountLowThreshold != "number" && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect")
            })
          };
          e()
        }
        _onInterval() {
          !this._cb || !this._channel || this._channel.bufferedAmount > S9 || this._onChannelBufferedAmountLow()
        }
        _onSignalingStateChange() {
          this.destroyed || (this._pc.signalingState === "stable" && !this._firstStable && (this._isNegotiating = !1, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach(e => {
            this._pc.removeTrack(e), this._queuedNegotiation = !0
          }), this._sendersAwaitingStable = [], this._queuedNegotiation && (this._debug("flushing negotiation queue"), this._queuedNegotiation = !1, this._needsNegotiation()), this._debug("negotiate"), this.emit("negotiate")), this._firstStable = !1, this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState))
        }
        _onIceCandidate(e) {
          this.destroyed || (e.candidate && this.trickle ? this.emit("signal", {
            candidate: {
              candidate: e.candidate.candidate,
              sdpMLineIndex: e.candidate.sdpMLineIndex,
              sdpMid: e.candidate.sdpMid
            }
          }) : !e.candidate && !this._iceComplete && (this._iceComplete = !0, this.emit("_iceComplete")), e.candidate && this._startIceCompleteTimeout())
        }
        _onChannelMessage(e) {
          if (!this.destroyed) {
            var t = e.data;
            t instanceof ArrayBuffer && (t = new Uint8Array(t)), this.push(t)
          }
        }
        _onChannelBufferedAmountLow() {
          if (!(this.destroyed || !this._cb)) {
            this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
            var e = this._cb;
            this._cb = null, e(null)
          }
        }
        _onChannelOpen() {
          this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = !0, this._maybeReady())
        }
        _onChannelClose() {
          this.destroyed || (this._debug("on channel close"), this.destroy())
        }
        _onTrack(e) {
          this.destroyed || e.streams.forEach(t => {
            this._debug("on track"), this.emit("track", e.track, t), this._remoteTracks.push({
              track: e.track,
              stream: t
            }), !this._remoteStreams.some(i => i.id === t.id) && (this._remoteStreams.push(t), E9(() => {
              this.emit("stream", t)
            }))
          })
        }
        _debug() {
          var e = [].slice.call(arguments);
          e[0] = "[" + this._id + "] " + e[0], Zct.apply(null, e)
        }
      };
      jf.WEBRTC_SUPPORT = !!Oge();
      jf.config = {
        iceServers: [{
          urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"]
        }],
        sdpSemantics: "unified-plan"
      };
      jf.channelConfig = {};
      Cge.exports = jf
    });
    var Bge = y((xIt, Mge) => {
      l();
      "use strict";
      Mge.exports = {
        supportsFileReader: typeof self != "undefined" && "FileReader" in self,
        supportsWebRTC: "RTCPeerConnection" in globalThis && typeof navigator != "undefined" && typeof navigator.mediaDevices != "undefined" && "getUserMedia" in navigator.mediaDevices,
        supportsWebRTCDataChannels: "RTCPeerConnection" in globalThis
      }
    });
    var N6 = y(O6 => {
      l();
      "use strict";
      O6.CODE_P2P = 421;
      O6.CODE_CIRCUIT = 290;
      O6.CLOSE_TIMEOUT = 2e3
    });
    var A9 = y((IIt, Dge) => {
      l();
      var iut = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
        nut = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
      Dge.exports = function (e) {
        var t = e,
          i = e.indexOf("["),
          n = e.indexOf("]");
        i != -1 && n != -1 && (e = e.substring(0, i) + e.substring(i, n).replace(/:/g, ";") + e.substring(n, e.length));
        for (var s = iut.exec(e || ""), o = {}, a = 14; a--;) o[nut[a]] = s[a] || "";
        return i != -1 && n != -1 && (o.source = t, o.host = o.host.substring(1, o.host.length - 1).replace(/;/g, ":"), o.authority = o.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), o.ipv6uri = !0), o.pathNames = sut(o, o.path), o.queryKey = out(o, o.query), o
      };

      function sut(r, e) {
        var t = /\/{2,9}/g,
          i = e.replace(t, "/").split("/");
        return (e.substr(0, 1) == "/" || e.length === 0) && i.splice(0, 1), e.substr(e.length - 1, 1) == "/" && i.splice(i.length - 1, 1), i
      }

      function out(r, e) {
        var t = {};
        return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (i, n, s) {
          n && (t[n] = s)
        }), t
      }
    });
    var Fge = y(q6 => {
      l();
      "use strict";
      Object.defineProperty(q6, "__esModule", {
        value: !0
      });
      q6.url = void 0;
      var aut = A9(),
        Lge = Oe()("socket.io-client:url");

      function cut(r, e = "", t) {
        let i = r;
        t = t || typeof location != "undefined" && location, r == null && (r = t.protocol + "//" + t.host), typeof r == "string" && (r.charAt(0) === "/" && (r.charAt(1) === "/" ? r = t.protocol + r : r = t.host + r), /^(https?|wss?):\/\//.test(r) || (Lge("protocol-less url %s", r), typeof t != "undefined" ? r = t.protocol + "//" + r : r = "https://" + r), Lge("parse %s", r), i = aut(r)), i.port || (/^(http|ws)$/.test(i.protocol) ? i.port = "80" : /^(http|ws)s$/.test(i.protocol) && (i.port = "443")), i.path = i.path || "/";
        let s = i.host.indexOf(":") !== -1 ? "[" + i.host + "]" : i.host;
        return i.id = i.protocol + "://" + s + ":" + i.port + e, i.href = i.protocol + "://" + s + (t && t.port === i.port ? "" : ":" + i.port), i
      }
      q6.url = cut
    });
    var Uge = y((RIt, I9) => {
      l();
      try {
        I9.exports = typeof XMLHttpRequest != "undefined" && "withCredentials" in new XMLHttpRequest
      } catch (r) {
        I9.exports = !1
      }
    });
    var Ub = y((kIt, Kge) => {
      l();
      Kge.exports = (() => typeof self != "undefined" ? self : typeof window != "undefined" ? window : Function("return this")())()
    });
    var T9 = y((PIt, zge) => {
      l();
      var uut = Uge(),
        fut = Ub();
      zge.exports = function (r) {
        let e = r.xdomain,
          t = r.xscheme,
          i = r.enablesXDR;
        try {
          if (typeof XMLHttpRequest != "undefined" && (!e || uut)) return new XMLHttpRequest
        } catch (n) { }
        try {
          if (typeof XDomainRequest != "undefined" && !t && i) return new XDomainRequest
        } catch (n) { }
        if (!e) try {
          return new fut[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")
        } catch (n) { }
      }
    });
    var R9 = y((CIt, jge) => {
      l();
      var _c = Object.create(null);
      _c.open = "0";
      _c.close = "1";
      _c.ping = "2";
      _c.pong = "3";
      _c.message = "4";
      _c.upgrade = "5";
      _c.noop = "6";
      var Vge = Object.create(null);
      Object.keys(_c).forEach(r => {
        Vge[_c[r]] = r
      });
      var lut = {
        type: "error",
        data: "parser error"
      };
      jge.exports = {
        PACKET_TYPES: _c,
        PACKET_TYPES_REVERSE: Vge,
        ERROR_PACKET: lut
      }
    });
    var $ge = y((OIt, Hge) => {
      l();
      var {
        PACKET_TYPES: hut
      } = R9(), dut = typeof Blob == "function" || typeof Blob != "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", put = typeof ArrayBuffer == "function", yut = r => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(r) : r && r.buffer instanceof ArrayBuffer, gut = ({
        type: r,
        data: e
      }, t, i) => dut && e instanceof Blob ? t ? i(e) : Gge(e, i) : put && (e instanceof ArrayBuffer || yut(e)) ? t ? i(e instanceof ArrayBuffer ? e : e.buffer) : Gge(new Blob([e]), i) : i(hut[r] + (e || "")), Gge = (r, e) => {
        let t = new FileReader;
        return t.onload = function () {
          let i = t.result.split(",")[1];
          e("b" + i)
        }, t.readAsDataURL(r)
      };
      Hge.exports = gut
    });
    var Wge = y(k9 => {
      l();
      (function (r) {
        "use strict";
        k9.encode = function (e) {
          var t = new Uint8Array(e),
            i, n = t.length,
            s = "";
          for (i = 0; i < n; i += 3) s += r[t[i] >> 2], s += r[(t[i] & 3) << 4 | t[i + 1] >> 4], s += r[(t[i + 1] & 15) << 2 | t[i + 2] >> 6], s += r[t[i + 2] & 63];
          return n % 3 == 2 ? s = s.substring(0, s.length - 1) + "=" : n % 3 == 1 && (s = s.substring(0, s.length - 2) + "=="), s
        }, k9.decode = function (e) {
          var t = e.length * .75,
            i = e.length,
            n, s = 0,
            o, a, c, u;
          e[e.length - 1] === "=" && (t--, e[e.length - 2] === "=" && t--);
          var f = new ArrayBuffer(t),
            h = new Uint8Array(f);
          for (n = 0; n < i; n += 4) o = r.indexOf(e[n]), a = r.indexOf(e[n + 1]), c = r.indexOf(e[n + 2]), u = r.indexOf(e[n + 3]), h[s++] = o << 2 | a >> 4, h[s++] = (a & 15) << 4 | c >> 2, h[s++] = (c & 3) << 6 | u & 63;
          return f
        }
      })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")
    });
    var Xge = y((qIt, Yge) => {
      l();
      var {
        PACKET_TYPES_REVERSE: P9,
        ERROR_PACKET: but
      } = R9(), mut = typeof ArrayBuffer == "function", C9;
      mut && (C9 = Wge());
      var wut = (r, e) => {
        if (typeof r != "string") return {
          type: "message",
          data: Jge(r, e)
        };
        let t = r.charAt(0);
        return t === "b" ? {
          type: "message",
          data: vut(r.substring(1), e)
        } : P9[t] ? r.length > 1 ? {
          type: P9[t],
          data: r.substring(1)
        } : {
          type: P9[t]
        } : but
      },
        vut = (r, e) => {
          if (C9) {
            let t = C9.decode(r);
            return Jge(t, e)
          } else return {
            base64: !0,
            data: r
          }
        },
        Jge = (r, e) => {
          switch (e) {
            case "blob":
              return r instanceof ArrayBuffer ? new Blob([r]) : r;
            case "arraybuffer":
            default:
              return r
          }
        };
      Yge.exports = wut
    });
    var Vp = y((MIt, Zge) => {
      l();
      var Qge = $ge(),
        ebe = Xge(),
        tbe = String.fromCharCode(30),
        _ut = (r, e) => {
          let t = r.length,
            i = new Array(t),
            n = 0;
          r.forEach((s, o) => {
            Qge(s, !1, a => {
              i[o] = a, ++n === t && e(i.join(tbe))
            })
          })
        },
        Eut = (r, e) => {
          let t = r.split(tbe),
            i = [];
          for (let n = 0; n < t.length; n++) {
            let s = ebe(t[n], e);
            if (i.push(s), s.type === "error") break
          }
          return i
        };
      Zge.exports = {
        protocol: 4,
        encodePacket: Qge,
        encodePayload: _ut,
        decodePacket: ebe,
        decodePayload: Eut
      }
    });
    var Ph = y((BIt, O9) => {
      l();
      typeof O9 != "undefined" && (O9.exports = Hs);

      function Hs(r) {
        if (r) return Sut(r)
      }

      function Sut(r) {
        for (var e in Hs.prototype) r[e] = Hs.prototype[e];
        return r
      }
      Hs.prototype.on = Hs.prototype.addEventListener = function (r, e) {
        return this._callbacks = this._callbacks || {}, (this._callbacks["$" + r] = this._callbacks["$" + r] || []).push(e), this
      };
      Hs.prototype.once = function (r, e) {
        function t() {
          this.off(r, t), e.apply(this, arguments)
        }
        return t.fn = e, this.on(r, t), this
      };
      Hs.prototype.off = Hs.prototype.removeListener = Hs.prototype.removeAllListeners = Hs.prototype.removeEventListener = function (r, e) {
        if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this;
        var t = this._callbacks["$" + r];
        if (!t) return this;
        if (arguments.length == 1) return delete this._callbacks["$" + r], this;
        for (var i, n = 0; n < t.length; n++)
          if (i = t[n], i === e || i.fn === e) {
            t.splice(n, 1);
            break
          } return t.length === 0 && delete this._callbacks["$" + r], this
      };
      Hs.prototype.emit = function (r) {
        this._callbacks = this._callbacks || {};
        for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + r], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
        if (t) {
          t = t.slice(0);
          for (var i = 0, n = t.length; i < n; ++i) t[i].apply(this, e)
        }
        return this
      };
      Hs.prototype.listeners = function (r) {
        return this._callbacks = this._callbacks || {}, this._callbacks["$" + r] || []
      };
      Hs.prototype.hasListeners = function (r) {
        return !!this.listeners(r).length
      }
    });
    var M6 = y((DIt, rbe) => {
      l();
      var xut = Vp(),
        Aut = Ph(),
        Iut = Oe()("engine.io-client:transport"),
        ibe = class extends Aut {
          constructor(e) {
            super();
            this.opts = e, this.query = e.query, this.readyState = "", this.socket = e.socket
          }
          onError(e, t) {
            let i = new Error(e);
            return i.type = "TransportError", i.description = t, this.emit("error", i), this
          }
          open() {
            return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening", this.doOpen()), this
          }
          close() {
            return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this
          }
          send(e) {
            this.readyState === "open" ? this.write(e) : Iut("transport is not open, discarding packets")
          }
          onOpen() {
            this.readyState = "open", this.writable = !0, this.emit("open")
          }
          onData(e) {
            let t = xut.decodePacket(e, this.socket.binaryType);
            this.onPacket(t)
          }
          onPacket(e) {
            this.emit("packet", e)
          }
          onClose() {
            this.readyState = "closed", this.emit("close")
          }
        };
      rbe.exports = ibe
    });
    var B6 = y(N9 => {
      l();
      N9.encode = function (r) {
        var e = "";
        for (var t in r) r.hasOwnProperty(t) && (e.length && (e += "&"), e += encodeURIComponent(t) + "=" + encodeURIComponent(r[t]));
        return e
      };
      N9.decode = function (r) {
        for (var e = {}, t = r.split("&"), i = 0, n = t.length; i < n; i++) {
          var s = t[i].split("=");
          e[decodeURIComponent(s[0])] = decodeURIComponent(s[1])
        }
        return e
      }
    });
    var B9 = y((FIt, nbe) => {
      l();
      "use strict";
      var sbe = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),
        D6 = 64,
        obe = {},
        abe = 0,
        Vf = 0,
        cbe;

      function q9(r) {
        var e = "";
        do e = sbe[r % D6] + e, r = Math.floor(r / D6); while (r > 0);
        return e
      }

      function Tut(r) {
        var e = 0;
        for (Vf = 0; Vf < r.length; Vf++) e = e * D6 + obe[r.charAt(Vf)];
        return e
      }

      function M9() {
        var r = q9(+new Date);
        return r !== cbe ? (abe = 0, cbe = r) : r + "." + q9(abe++)
      }
      for (; Vf < D6; Vf++) obe[sbe[Vf]] = Vf;
      M9.encode = q9;
      M9.decode = Tut;
      nbe.exports = M9
    });
    var D9 = y((UIt, ube) => {
      l();
      var Rut = M6(),
        kut = B6(),
        fbe = Vp(),
        Put = B9(),
        wa = Oe()("engine.io-client:polling"),
        lbe = class extends Rut {
          get name() {
            return "polling"
          }
          doOpen() {
            this.poll()
          }
          pause(e) {
            let t = this;
            this.readyState = "pausing";

            function i() {
              wa("paused"), t.readyState = "paused", e()
            }
            if (this.polling || !this.writable) {
              let n = 0;
              this.polling && (wa("we are currently polling - waiting to pause"), n++, this.once("pollComplete", function () {
                wa("pre-pause polling complete"), --n || i()
              })), this.writable || (wa("we are currently writing - waiting to pause"), n++, this.once("drain", function () {
                wa("pre-pause writing complete"), --n || i()
              }))
            } else i()
          }
          poll() {
            wa("polling"), this.polling = !0, this.doPoll(), this.emit("poll")
          }
          onData(e) {
            let t = this;
            wa("polling got data %s", e);
            let i = function (n, s, o) {
              if (t.readyState === "opening" && n.type === "open" && t.onOpen(), n.type === "close") return t.onClose(), !1;
              t.onPacket(n)
            };
            fbe.decodePayload(e, this.socket.binaryType).forEach(i), this.readyState !== "closed" && (this.polling = !1, this.emit("pollComplete"), this.readyState === "open" ? this.poll() : wa('ignoring poll - transport state "%s"', this.readyState))
          }
          doClose() {
            let e = this;

            function t() {
              wa("writing close packet"), e.write([{
                type: "close"
              }])
            }
            this.readyState === "open" ? (wa("transport open - closing"), t()) : (wa("transport not open - deferring close"), this.once("open", t))
          }
          write(e) {
            this.writable = !1, fbe.encodePayload(e, t => {
              this.doWrite(t, () => {
                this.writable = !0, this.emit("drain")
              })
            })
          }
          uri() {
            let e = this.query || {},
              t = this.opts.secure ? "https" : "http",
              i = "";
            this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = Put()), !this.supportsBinary && !e.sid && (e.b64 = 1), e = kut.encode(e), this.opts.port && (t === "https" && Number(this.opts.port) !== 443 || t === "http" && Number(this.opts.port) !== 80) && (i = ":" + this.opts.port), e.length && (e = "?" + e);
            let n = this.opts.hostname.indexOf(":") !== -1;
            return t + "://" + (n ? "[" + this.opts.hostname + "]" : this.opts.hostname) + i + this.opts.path + e
          }
        };
      ube.exports = lbe
    });
    var L9 = y((KIt, hbe) => {
      l();
      hbe.exports.pick = (r, ...e) => e.reduce((t, i) => (r.hasOwnProperty(i) && (t[i] = r[i]), t), {})
    });
    var bbe = y((zIt, F9) => {
      l();
      var dbe = T9(),
        Cut = D9(),
        Out = Ph(),
        {
          pick: Nut
        } = L9(),
        qut = Ub(),
        U9 = Oe()("engine.io-client:polling-xhr");

      function pbe() { }
      var Mut = function () {
        return new dbe({
          xdomain: !1
        }).responseType != null
      }(),
        ybe = class extends Cut {
          constructor(e) {
            super(e);
            if (typeof location != "undefined") {
              let i = location.protocol === "https:",
                n = location.port;
              n || (n = i ? 443 : 80), this.xd = typeof location != "undefined" && e.hostname !== location.hostname || n !== e.port, this.xs = e.secure !== i
            }
            let t = e && e.forceBase64;
            this.supportsBinary = Mut && !t
          }
          request(e = {}) {
            return Object.assign(e, {
              xd: this.xd,
              xs: this.xs
            }, this.opts), new ko(this.uri(), e)
          }
          doWrite(e, t) {
            let i = this.request({
              method: "POST",
              data: e
            }),
              n = this;
            i.on("success", t), i.on("error", function (s) {
              n.onError("xhr post error", s)
            })
          }
          doPoll() {
            U9("xhr poll");
            let e = this.request(),
              t = this;
            e.on("data", function (i) {
              t.onData(i)
            }), e.on("error", function (i) {
              t.onError("xhr poll error", i)
            }), this.pollXhr = e
          }
        },
        ko = class extends Out {
          constructor(e, t) {
            super();
            this.opts = t, this.method = t.method || "GET", this.uri = e, this.async = t.async !== !1, this.data = t.data !== void 0 ? t.data : null, this.create()
          }
          create() {
            let e = Nut(this.opts, "agent", "enablesXDR", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized");
            e.xdomain = !!this.opts.xd, e.xscheme = !!this.opts.xs;
            let t = this.xhr = new dbe(e),
              i = this;
            try {
              U9("xhr open %s: %s", this.method, this.uri), t.open(this.method, this.uri, this.async);
              try {
                if (this.opts.extraHeaders) {
                  t.setDisableHeaderCheck && t.setDisableHeaderCheck(!0);
                  for (let n in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(n) && t.setRequestHeader(n, this.opts.extraHeaders[n])
                }
              } catch (n) { }
              if (this.method === "POST") try {
                t.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
              } catch (n) { }
              try {
                t.setRequestHeader("Accept", "*/*")
              } catch (n) { }
              "withCredentials" in t && (t.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (t.timeout = this.opts.requestTimeout), this.hasXDR() ? (t.onload = function () {
                i.onLoad()
              }, t.onerror = function () {
                i.onError(t.responseText)
              }) : t.onreadystatechange = function () {
                t.readyState === 4 && (t.status === 200 || t.status === 1223 ? i.onLoad() : setTimeout(function () {
                  i.onError(typeof t.status == "number" ? t.status : 0)
                }, 0))
              }, U9("xhr data %s", this.data), t.send(this.data)
            } catch (n) {
              setTimeout(function () {
                i.onError(n)
              }, 0);
              return
            }
            typeof document != "undefined" && (this.index = ko.requestsCount++, ko.requests[this.index] = this)
          }
          onSuccess() {
            this.emit("success"), this.cleanup()
          }
          onData(e) {
            this.emit("data", e), this.onSuccess()
          }
          onError(e) {
            this.emit("error", e), this.cleanup(!0)
          }
          cleanup(e) {
            if (!(typeof this.xhr == "undefined" || this.xhr === null)) {
              if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = pbe : this.xhr.onreadystatechange = pbe, e) try {
                this.xhr.abort()
              } catch (t) { }
              typeof document != "undefined" && delete ko.requests[this.index], this.xhr = null
            }
          }
          onLoad() {
            let e = this.xhr.responseText;
            e !== null && this.onData(e)
          }
          hasXDR() {
            return typeof XDomainRequest != "undefined" && !this.xs && this.enablesXDR
          }
          abort() {
            this.cleanup()
          }
        };
      ko.requestsCount = 0;
      ko.requests = {};
      if (typeof document != "undefined") {
        if (typeof attachEvent == "function") attachEvent("onunload", gbe);
        else if (typeof addEventListener == "function") {
          let r = "onpagehide" in qut ? "pagehide" : "unload";
          addEventListener(r, gbe, !1)
        }
      }

      function gbe() {
        for (let r in ko.requests) ko.requests.hasOwnProperty(r) && ko.requests[r].abort()
      }
      F9.exports = ybe;
      F9.exports.Request = ko
    });
    var _be = y((jIt, mbe) => {
      l();
      var But = D9(),
        vbe = Ub(),
        Dut = /\n/g,
        Lut = /\\n/g,
        L6, wbe = class extends But {
          constructor(e) {
            super(e);
            this.query = this.query || {}, L6 || (L6 = vbe.___eio = vbe.___eio || []), this.index = L6.length;
            let t = this;
            L6.push(function (i) {
              t.onData(i)
            }), this.query.j = this.index
          }
          get supportsBinary() {
            return !1
          }
          doClose() {
            this.script && (this.script.onerror = () => { }, this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), super.doClose()
          }
          doPoll() {
            let e = this,
              t = document.createElement("script");
            this.script && (this.script.parentNode.removeChild(this.script), this.script = null), t.async = !0, t.src = this.uri(), t.onerror = function (s) {
              e.onError("jsonp poll error", s)
            };
            let i = document.getElementsByTagName("script")[0];
            i ? i.parentNode.insertBefore(t, i) : (document.head || document.body).appendChild(t), this.script = t, typeof navigator != "undefined" && /gecko/i.test(navigator.userAgent) && setTimeout(function () {
              let s = document.createElement("iframe");
              document.body.appendChild(s), document.body.removeChild(s)
            }, 100)
          }
          doWrite(e, t) {
            let i = this,
              n;
            if (!this.form) {
              let a = document.createElement("form"),
                c = document.createElement("textarea"),
                u = this.iframeId = "eio_iframe_" + this.index;
              a.className = "socketio", a.style.position = "absolute", a.style.top = "-1000px", a.style.left = "-1000px", a.target = u, a.method = "POST", a.setAttribute("accept-charset", "utf-8"), c.name = "d", a.appendChild(c), document.body.appendChild(a), this.form = a, this.area = c
            }
            this.form.action = this.uri();

            function s() {
              o(), t()
            }

            function o() {
              if (i.iframe) try {
                i.form.removeChild(i.iframe)
              } catch (a) {
                i.onError("jsonp polling iframe removal error", a)
              }
              try {
                let a = '<iframe src="javascript:0" name="' + i.iframeId + '">';
                n = document.createElement(a)
              } catch (a) {
                n = document.createElement("iframe"), n.name = i.iframeId, n.src = "javascript:0"
              }
              n.id = i.iframeId, i.form.appendChild(n), i.iframe = n
            }
            o(), e = e.replace(Lut, `\\
`), this.area.value = e.replace(Dut, "\\n");
            try {
              this.form.submit()
            } catch (a) { }
            this.iframe.attachEvent ? this.iframe.onreadystatechange = function () {
              i.iframe.readyState === "complete" && s()
            } : this.iframe.onload = s
          }
        };
      mbe.exports = wbe
    });
    var xbe = y((VIt, Ebe) => {
      l();
      var Sbe = Ub();
      Ebe.exports = {
        WebSocket: Sbe.WebSocket || Sbe.MozWebSocket,
        usingBrowserWebSocket: !0,
        defaultBinaryType: "arraybuffer"
      }
    });
    var Rbe = y((HIt, Abe) => {
      l();
      var Ibe = M6(),
        Fut = Vp(),
        Uut = B6(),
        Kut = B9(),
        {
          pick: zut
        } = L9(),
        {
          WebSocket: Kb,
          usingBrowserWebSocket: K9,
          defaultBinaryType: jut
        } = xbe(),
        Vut = Oe()("engine.io-client:websocket"),
        Tbe = typeof navigator != "undefined" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative",
        F6 = class extends Ibe {
          constructor(e) {
            super(e);
            this.supportsBinary = !e.forceBase64
          }
          get name() {
            return "websocket"
          }
          doOpen() {
            if (!this.check()) return;
            let e = this.uri(),
              t = this.opts.protocols,
              i = Tbe ? {} : zut(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
            this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
            try {
              this.ws = K9 && !Tbe ? t ? new Kb(e, t) : new Kb(e) : new Kb(e, t, i)
            } catch (n) {
              return this.emit("error", n)
            }
            this.ws.binaryType = this.socket.binaryType || jut, this.addEventListeners()
          }
          addEventListeners() {
            let e = this;
            this.ws.onopen = function () {
              e.onOpen()
            }, this.ws.onclose = function () {
              e.onClose()
            }, this.ws.onmessage = function (t) {
              e.onData(t.data)
            }, this.ws.onerror = function (t) {
              e.onError("websocket error", t)
            }
          }
          write(e) {
            let t = this;
            this.writable = !1;
            let i = e.length,
              n = 0,
              s = i;
            for (; n < s; n++)(function (a) {
              Fut.encodePacket(a, t.supportsBinary, function (c) {
                let u = {};
                K9 || (a.options && (u.compress = a.options.compress), t.opts.perMessageDeflate && (typeof c == "string" ? Buffer.byteLength(c) : c.length) < t.opts.perMessageDeflate.threshold && (u.compress = !1));
                try {
                  K9 ? t.ws.send(c) : t.ws.send(c, u)
                } catch (f) {
                  Vut("websocket closed before onclose event")
                } --i || o()
              })
            })(e[n]);

            function o() {
              t.emit("flush"), setTimeout(function () {
                t.writable = !0, t.emit("drain")
              }, 0)
            }
          }
          onClose() {
            Ibe.prototype.onClose.call(this)
          }
          doClose() {
            typeof this.ws != "undefined" && (this.ws.close(), this.ws = null)
          }
          uri() {
            let e = this.query || {},
              t = this.opts.secure ? "wss" : "ws",
              i = "";
            this.opts.port && (t === "wss" && Number(this.opts.port) !== 443 || t === "ws" && Number(this.opts.port) !== 80) && (i = ":" + this.opts.port), this.opts.timestampRequests && (e[this.opts.timestampParam] = Kut()), this.supportsBinary || (e.b64 = 1), e = Uut.encode(e), e.length && (e = "?" + e);
            let n = this.opts.hostname.indexOf(":") !== -1;
            return t + "://" + (n ? "[" + this.opts.hostname + "]" : this.opts.hostname) + i + this.opts.path + e
          }
          check() {
            return !!Kb && !("__initialize" in Kb && this.name === F6.prototype.name)
          }
        };
      Abe.exports = F6
    });
    var j9 = y(z9 => {
      l();
      var Hut = T9(),
        Gut = bbe(),
        $ut = _be(),
        Wut = Rbe();
      z9.polling = Yut;
      z9.websocket = Wut;

      function Yut(r) {
        let e, t = !1,
          i = !1,
          n = r.jsonp !== !1;
        if (typeof location != "undefined") {
          let s = location.protocol === "https:",
            o = location.port;
          o || (o = s ? 443 : 80), t = r.hostname !== location.hostname || o !== r.port, i = r.secure !== s
        }
        if (r.xdomain = t, r.xscheme = i, e = new Hut(r), "open" in e && !r.forceJSONP) return new Gut(r);
        if (!n) throw new Error("JSONP disabled");
        return new $ut(r)
      }
    });
    var Obe = y(($It, kbe) => {
      l();
      var Jut = j9(),
        Xut = Ph(),
        hi = Oe()("engine.io-client:socket"),
        Pbe = Vp(),
        Cbe = A9(),
        Zut = B6(),
        Ec = class extends Xut {
          constructor(e, t = {}) {
            super();
            e && typeof e == "object" && (t = e, e = null), e ? (e = Cbe(e), t.hostname = e.host, t.secure = e.protocol === "https" || e.protocol === "wss", t.port = e.port, e.query && (t.query = e.query)) : t.host && (t.hostname = Cbe(t.host).host), this.secure = t.secure != null ? t.secure : typeof location != "undefined" && location.protocol === "https:", t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || (typeof location != "undefined" ? location.hostname : "localhost"), this.port = t.port || (typeof location != "undefined" && location.port ? location.port : this.secure ? 443 : 80), this.transports = t.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
              path: "/engine.io",
              agent: !1,
              withCredentials: !1,
              upgrade: !0,
              jsonp: !0,
              timestampParam: "t",
              rememberUpgrade: !1,
              rejectUnauthorized: !0,
              perMessageDeflate: {
                threshold: 1024
              },
              transportOptions: {}
            }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", typeof this.opts.query == "string" && (this.opts.query = Zut.decode(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && addEventListener("beforeunload", () => {
              this.transport && (this.transport.removeAllListeners(), this.transport.close())
            }, !1), this.open()
          }
          createTransport(e) {
            hi('creating transport "%s"', e);
            let t = Qut(this.opts.query);
            t.EIO = Pbe.protocol, t.transport = e, this.id && (t.sid = this.id);
            let i = Object.assign({}, this.opts.transportOptions[e], this.opts, {
              query: t,
              socket: this,
              hostname: this.hostname,
              secure: this.secure,
              port: this.port
            });
            return hi("options: %j", i), new Jut[e](i)
          }
          open() {
            let e;
            if (this.opts.rememberUpgrade && Ec.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) e = "websocket";
            else if (this.transports.length === 0) {
              let t = this;
              setTimeout(function () {
                t.emit("error", "No transports available")
              }, 0);
              return
            } else e = this.transports[0];
            this.readyState = "opening";
            try {
              e = this.createTransport(e)
            } catch (t) {
              hi("error while creating transport: %s", t), this.transports.shift(), this.open();
              return
            }
            e.open(), this.setTransport(e)
          }
          setTransport(e) {
            hi("setting transport %s", e.name);
            let t = this;
            this.transport && (hi("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = e, e.on("drain", function () {
              t.onDrain()
            }).on("packet", function (i) {
              t.onPacket(i)
            }).on("error", function (i) {
              t.onError(i)
            }).on("close", function () {
              t.onClose("transport close")
            })
          }
          probe(e) {
            hi('probing transport "%s"', e);
            let t = this.createTransport(e, {
              probe: 1
            }),
              i = !1,
              n = this;
            Ec.priorWebsocketSuccess = !1;

            function s() {
              if (n.onlyBinaryUpgrades) {
                let d = !this.supportsBinary && n.transport.supportsBinary;
                i = i || d
              }
              i || (hi('probe transport "%s" opened', e), t.send([{
                type: "ping",
                data: "probe"
              }]), t.once("packet", function (d) {
                if (!i)
                  if (d.type === "pong" && d.data === "probe") {
                    if (hi('probe transport "%s" pong', e), n.upgrading = !0, n.emit("upgrading", t), !t) return;
                    Ec.priorWebsocketSuccess = t.name === "websocket", hi('pausing current transport "%s"', n.transport.name), n.transport.pause(function () {
                      i || n.readyState !== "closed" && (hi("changing transport and sending upgrade packet"), h(), n.setTransport(t), t.send([{
                        type: "upgrade"
                      }]), n.emit("upgrade", t), t = null, n.upgrading = !1, n.flush())
                    })
                  } else {
                    hi('probe transport "%s" failed', e);
                    let p = new Error("probe error");
                    p.transport = t.name, n.emit("upgradeError", p)
                  }
              }))
            }

            function o() {
              i || (i = !0, h(), t.close(), t = null)
            }

            function a(d) {
              let p = new Error("probe error: " + d);
              p.transport = t.name, o(), hi('probe transport "%s" failed because of error: %s', e, d), n.emit("upgradeError", p)
            }

            function c() {
              a("transport closed")
            }

            function u() {
              a("socket closed")
            }

            function f(d) {
              t && d.name !== t.name && (hi('"%s" works - aborting "%s"', d.name, t.name), o())
            }

            function h() {
              t.removeListener("open", s), t.removeListener("error", a), t.removeListener("close", c), n.removeListener("close", u), n.removeListener("upgrading", f)
            }
            t.once("open", s), t.once("error", a), t.once("close", c), this.once("close", u), this.once("upgrading", f), t.open()
          }
          onOpen() {
            if (hi("socket open"), this.readyState = "open", Ec.priorWebsocketSuccess = this.transport.name === "websocket", this.emit("open"), this.flush(), this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
              hi("starting upgrade probes");
              let e = 0,
                t = this.upgrades.length;
              for (; e < t; e++) this.probe(this.upgrades[e])
            }
          }
          onPacket(e) {
            if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") switch (hi('socket receive: type "%s", data "%s"', e.type, e.data), this.emit("packet", e), this.emit("heartbeat"), e.type) {
              case "open":
                this.onHandshake(JSON.parse(e.data));
                break;
              case "ping":
                this.resetPingTimeout(), this.sendPacket("pong"), this.emit("pong");
                break;
              case "error":
                let t = new Error("server error");
                t.code = e.data, this.onError(t);
                break;
              case "message":
                this.emit("data", e.data), this.emit("message", e.data);
                break
            } else hi('packet received with socket readyState "%s"', this.readyState)
          }
          onHandshake(e) {
            this.emit("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout()
          }
          resetPingTimeout() {
            clearTimeout(this.pingTimeoutTimer), this.pingTimeoutTimer = setTimeout(() => {
              this.onClose("ping timeout")
            }, this.pingInterval + this.pingTimeout)
          }
          onDrain() {
            this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emit("drain") : this.flush()
          }
          flush() {
            this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length && (hi("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"))
          }
          write(e, t, i) {
            return this.sendPacket("message", e, t, i), this
          }
          send(e, t, i) {
            return this.sendPacket("message", e, t, i), this
          }
          sendPacket(e, t, i, n) {
            if (typeof t == "function" && (n = t, t = void 0), typeof i == "function" && (n = i, i = null), this.readyState === "closing" || this.readyState === "closed") return;
            i = i || {}, i.compress = i.compress !== !1;
            let s = {
              type: e,
              data: t,
              options: i
            };
            this.emit("packetCreate", s), this.writeBuffer.push(s), n && this.once("flush", n), this.flush()
          }
          close() {
            let e = this;
            (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", function () {
              this.upgrading ? n() : t()
            }) : this.upgrading ? n() : t());

            function t() {
              e.onClose("forced close"), hi("socket closing - telling transport to close"), e.transport.close()
            }

            function i() {
              e.removeListener("upgrade", i), e.removeListener("upgradeError", i), t()
            }

            function n() {
              e.once("upgrade", i), e.once("upgradeError", i)
            }
            return this
          }
          onError(e) {
            hi("socket error %j", e), Ec.priorWebsocketSuccess = !1, this.emit("error", e), this.onClose("transport error", e)
          }
          onClose(e, t) {
            if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
              hi('socket close with reason: "%s"', e);
              let i = this;
              clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", e, t), i.writeBuffer = [], i.prevBufferLen = 0
            }
          }
          filterUpgrades(e) {
            let t = [],
              i = 0,
              n = e.length;
            for (; i < n; i++) ~this.transports.indexOf(e[i]) && t.push(e[i]);
            return t
          }
        };
      Ec.priorWebsocketSuccess = !1;
      Ec.protocol = Pbe.protocol;

      function Qut(r) {
        let e = {};
        for (let t in r) r.hasOwnProperty(t) && (e[t] = r[t]);
        return e
      }
      kbe.exports = Ec
    });
    var Nbe = y((WIt, Ch) => {
      l();
      var V9 = Obe();
      Ch.exports = (r, e) => new V9(r, e);
      Ch.exports.Socket = V9;
      Ch.exports.protocol = V9.protocol;
      Ch.exports.Transport = M6();
      Ch.exports.transports = j9();
      Ch.exports.parser = Vp()
    });
    var H9 = y(Hp => {
      l();
      "use strict";
      Object.defineProperty(Hp, "__esModule", {
        value: !0
      });
      Hp.hasBinary = Hp.isBinary = void 0;
      var eft = typeof ArrayBuffer == "function",
        tft = r => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(r) : r.buffer instanceof ArrayBuffer,
        qbe = Object.prototype.toString,
        rft = typeof Blob == "function" || typeof Blob != "undefined" && qbe.call(Blob) === "[object BlobConstructor]",
        ift = typeof File == "function" || typeof File != "undefined" && qbe.call(File) === "[object FileConstructor]";

      function Mbe(r) {
        return eft && (r instanceof ArrayBuffer || tft(r)) || rft && r instanceof Blob || ift && r instanceof File
      }
      Hp.isBinary = Mbe;

      function U6(r, e) {
        if (!r || typeof r != "object") return !1;
        if (Array.isArray(r)) {
          for (let t = 0, i = r.length; t < i; t++)
            if (U6(r[t])) return !0;
          return !1
        }
        if (Mbe(r)) return !0;
        if (r.toJSON && typeof r.toJSON == "function" && arguments.length === 1) return U6(r.toJSON(), !0);
        for (let t in r)
          if (Object.prototype.hasOwnProperty.call(r, t) && U6(r[t])) return !0;
        return !1
      }
      Hp.hasBinary = U6
    });
    var Bbe = y(Gp => {
      l();
      "use strict";
      Object.defineProperty(Gp, "__esModule", {
        value: !0
      });
      Gp.reconstructPacket = Gp.deconstructPacket = void 0;
      var nft = H9();

      function sft(r) {
        let e = [],
          t = r.data,
          i = r;
        return i.data = G9(t, e), i.attachments = e.length, {
          packet: i,
          buffers: e
        }
      }
      Gp.deconstructPacket = sft;

      function G9(r, e) {
        if (!r) return r;
        if (nft.isBinary(r)) {
          let t = {
            _placeholder: !0,
            num: e.length
          };
          return e.push(r), t
        } else if (Array.isArray(r)) {
          let t = new Array(r.length);
          for (let i = 0; i < r.length; i++) t[i] = G9(r[i], e);
          return t
        } else if (typeof r == "object" && !(r instanceof Date)) {
          let t = {};
          for (let i in r) r.hasOwnProperty(i) && (t[i] = G9(r[i], e));
          return t
        }
        return r
      }

      function oft(r, e) {
        return r.data = $9(r.data, e), r.attachments = void 0, r
      }
      Gp.reconstructPacket = oft;

      function $9(r, e) {
        if (!r) return r;
        if (r && r._placeholder) return e[r.num];
        if (Array.isArray(r))
          for (let t = 0; t < r.length; t++) r[t] = $9(r[t], e);
        else if (typeof r == "object")
          for (let t in r) r.hasOwnProperty(t) && (r[t] = $9(r[t], e));
        return r
      }
    });
    var z6 = y(_a => {
      l();
      "use strict";
      Object.defineProperty(_a, "__esModule", {
        value: !0
      });
      _a.Decoder = _a.Encoder = _a.PacketType = _a.protocol = void 0;
      var aft = Ph(),
        Dbe = Bbe(),
        Lbe = H9(),
        W9 = Oe()("socket.io-parser");
      _a.protocol = 5;
      var _i;
      (function (r) {
        r[r.CONNECT = 0] = "CONNECT", r[r.DISCONNECT = 1] = "DISCONNECT", r[r.EVENT = 2] = "EVENT", r[r.ACK = 3] = "ACK", r[r.CONNECT_ERROR = 4] = "CONNECT_ERROR", r[r.BINARY_EVENT = 5] = "BINARY_EVENT", r[r.BINARY_ACK = 6] = "BINARY_ACK"
      })(_i = _a.PacketType || (_a.PacketType = {}));
      var Fbe = class {
        encode(e) {
          return W9("encoding packet %j", e), (e.type === _i.EVENT || e.type === _i.ACK) && Lbe.hasBinary(e) ? (e.type = e.type === _i.EVENT ? _i.BINARY_EVENT : _i.BINARY_ACK, this.encodeAsBinary(e)) : [this.encodeAsString(e)]
        }
        encodeAsString(e) {
          let t = "" + e.type;
          return (e.type === _i.BINARY_EVENT || e.type === _i.BINARY_ACK) && (t += e.attachments + "-"), e.nsp && e.nsp !== "/" && (t += e.nsp + ","), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data)), W9("encoded %j as %s", e, t), t
        }
        encodeAsBinary(e) {
          let t = Dbe.deconstructPacket(e),
            i = this.encodeAsString(t.packet),
            n = t.buffers;
          return n.unshift(i), n
        }
      };
      _a.Encoder = Fbe;
      var K6 = class extends aft {
        constructor() {
          super()
        }
        add(e) {
          let t;
          if (typeof e == "string") t = this.decodeString(e), t.type === _i.BINARY_EVENT || t.type === _i.BINARY_ACK ? (this.reconstructor = new Ube(t), t.attachments === 0 && super.emit("decoded", t)) : super.emit("decoded", t);
          else if (Lbe.isBinary(e) || e.base64)
            if (this.reconstructor) t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emit("decoded", t));
            else throw new Error("got binary data when not reconstructing a packet");
          else throw new Error("Unknown type: " + e)
        }
        decodeString(e) {
          let t = 0,
            i = {
              type: Number(e.charAt(0))
            };
          if (_i[i.type] === void 0) throw new Error("unknown packet type " + i.type);
          if (i.type === _i.BINARY_EVENT || i.type === _i.BINARY_ACK) {
            let s = t + 1;
            for (; e.charAt(++t) !== "-" && t != e.length;);
            let o = e.substring(s, t);
            if (o != Number(o) || e.charAt(t) !== "-") throw new Error("Illegal attachments");
            i.attachments = Number(o)
          }
          if (e.charAt(t + 1) === "/") {
            let s = t + 1;
            for (; ++t && !(e.charAt(t) === "," || t === e.length););
            i.nsp = e.substring(s, t)
          } else i.nsp = "/";
          let n = e.charAt(t + 1);
          if (n !== "" && Number(n) == n) {
            let s = t + 1;
            for (; ++t;) {
              let o = e.charAt(t);
              if (o == null || Number(o) != o) {
                --t;
                break
              }
              if (t === e.length) break
            }
            i.id = Number(e.substring(s, t + 1))
          }
          if (e.charAt(++t)) {
            let s = cft(e.substr(t));
            if (K6.isPayloadValid(i.type, s)) i.data = s;
            else throw new Error("invalid payload")
          }
          return W9("decoded %s as %j", e, i), i
        }
        static isPayloadValid(e, t) {
          switch (e) {
            case _i.CONNECT:
              return typeof t == "object";
            case _i.DISCONNECT:
              return t === void 0;
            case _i.CONNECT_ERROR:
              return typeof t == "string" || typeof t == "object";
            case _i.EVENT:
            case _i.BINARY_EVENT:
              return Array.isArray(t) && t.length > 0;
            case _i.ACK:
            case _i.BINARY_ACK:
              return Array.isArray(t)
          }
        }
        destroy() {
          this.reconstructor && this.reconstructor.finishedReconstruction()
        }
      };
      _a.Decoder = K6;

      function cft(r) {
        try {
          return JSON.parse(r)
        } catch (e) {
          return !1
        }
      }
      var Ube = class {
        constructor(e) {
          this.packet = e, this.buffers = [], this.reconPack = e
        }
        takeBinaryData(e) {
          if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
            let t = Dbe.reconstructPacket(this.reconPack, this.buffers);
            return this.finishedReconstruction(), t
          }
          return null
        }
        finishedReconstruction() {
          this.reconPack = null, this.buffers = []
        }
      }
    });
    var Y9 = y(j6 => {
      l();
      "use strict";
      Object.defineProperty(j6, "__esModule", {
        value: !0
      });
      j6.on = void 0;

      function uft(r, e, t) {
        return r.on(e, t),
          function () {
            r.off(e, t)
          }
      }
      j6.on = uft
    });
    var J9 = y(V6 => {
      l();
      "use strict";
      Object.defineProperty(V6, "__esModule", {
        value: !0
      });
      V6.Socket = void 0;
      var Po = z6(),
        fft = Ph(),
        H6 = Y9(),
        Co = Oe()("socket.io-client:socket"),
        lft = Object.freeze({
          connect: 1,
          connect_error: 1,
          disconnect: 1,
          disconnecting: 1,
          newListener: 1,
          removeListener: 1
        }),
        Kbe = class extends fft {
          constructor(e, t, i) {
            super();
            this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, this.flags = {}, i && i.auth && (this.auth = i.auth), this.io._autoConnect && this.open()
          }
          subEvents() {
            if (this.subs) return;
            let e = this.io;
            this.subs = [H6.on(e, "open", this.onopen.bind(this)), H6.on(e, "packet", this.onpacket.bind(this)), H6.on(e, "error", this.onerror.bind(this)), H6.on(e, "close", this.onclose.bind(this))]
          }
          get active() {
            return !!this.subs
          }
          connect() {
            return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this)
          }
          open() {
            return this.connect()
          }
          send(...e) {
            return e.unshift("message"), this.emit.apply(this, e), this
          }
          emit(e, ...t) {
            if (lft.hasOwnProperty(e)) throw new Error('"' + e + '" is a reserved event name');
            t.unshift(e);
            let i = {
              type: Po.PacketType.EVENT,
              data: t
            };
            i.options = {}, i.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] == "function" && (Co("emitting packet with ack id %d", this.ids), this.acks[this.ids] = t.pop(), i.id = this.ids++);
            let n = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
            return this.flags.volatile && (!n || !this.connected) ? Co("discard packet as the transport is not currently writable") : this.connected ? this.packet(i) : this.sendBuffer.push(i), this.flags = {}, this
          }
          packet(e) {
            e.nsp = this.nsp, this.io._packet(e)
          }
          onopen() {
            Co("transport is open - connecting"), typeof this.auth == "function" ? this.auth(e => {
              this.packet({
                type: Po.PacketType.CONNECT,
                data: e
              })
            }) : this.packet({
              type: Po.PacketType.CONNECT,
              data: this.auth
            })
          }
          onerror(e) {
            this.connected || super.emit("connect_error", e)
          }
          onclose(e) {
            Co("close (%s)", e), this.connected = !1, this.disconnected = !0, delete this.id, super.emit("disconnect", e)
          }
          onpacket(e) {
            if (e.nsp === this.nsp) switch (e.type) {
              case Po.PacketType.CONNECT:
                if (e.data && e.data.sid) {
                  let n = e.data.sid;
                  this.onconnect(n)
                } else super.emit("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                break;
              case Po.PacketType.EVENT:
                this.onevent(e);
                break;
              case Po.PacketType.BINARY_EVENT:
                this.onevent(e);
                break;
              case Po.PacketType.ACK:
                this.onack(e);
                break;
              case Po.PacketType.BINARY_ACK:
                this.onack(e);
                break;
              case Po.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
              case Po.PacketType.CONNECT_ERROR:
                let i = new Error(e.data.message);
                i.data = e.data.data, super.emit("connect_error", i);
                break
            }
          }
          onevent(e) {
            let t = e.data || [];
            Co("emitting event %j", t), e.id != null && (Co("attaching ack callback to event"), t.push(this.ack(e.id))), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t))
          }
          emitEvent(e) {
            if (this._anyListeners && this._anyListeners.length) {
              let t = this._anyListeners.slice();
              for (let i of t) i.apply(this, e)
            }
            super.emit.apply(this, e)
          }
          ack(e) {
            let t = this,
              i = !1;
            return function (...n) {
              i || (i = !0, Co("sending ack %j", n), t.packet({
                type: Po.PacketType.ACK,
                id: e,
                data: n
              }))
            }
          }
          onack(e) {
            let t = this.acks[e.id];
            typeof t == "function" ? (Co("calling ack %s with %j", e.id, e.data), t.apply(this, e.data), delete this.acks[e.id]) : Co("bad ack %s", e.id)
          }
          onconnect(e) {
            Co("socket connected with id %s", e), this.id = e, this.connected = !0, this.disconnected = !1, super.emit("connect"), this.emitBuffered()
          }
          emitBuffered() {
            this.receiveBuffer.forEach(e => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach(e => this.packet(e)), this.sendBuffer = []
          }
          ondisconnect() {
            Co("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect")
          }
          destroy() {
            this.subs && (this.subs.forEach(e => e()), this.subs = void 0), this.io._destroy(this)
          }
          disconnect() {
            return this.connected && (Co("performing disconnect (%s)", this.nsp), this.packet({
              type: Po.PacketType.DISCONNECT
            })), this.destroy(), this.connected && this.onclose("io client disconnect"), this
          }
          close() {
            return this.disconnect()
          }
          compress(e) {
            return this.flags.compress = e, this
          }
          get volatile() {
            return this.flags.volatile = !0, this
          }
          onAny(e) {
            return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this
          }
          prependAny(e) {
            return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this
          }
          offAny(e) {
            if (!this._anyListeners) return this;
            if (e) {
              let t = this._anyListeners;
              for (let i = 0; i < t.length; i++)
                if (e === t[i]) return t.splice(i, 1), this
            } else this._anyListeners = [];
            return this
          }
          listenersAny() {
            return this._anyListeners || []
          }
        };
      V6.Socket = Kbe
    });
    var jbe = y((eTt, zbe) => {
      l();
      zbe.exports = $p;

      function $p(r) {
        r = r || {}, this.ms = r.min || 100, this.max = r.max || 1e4, this.factor = r.factor || 2, this.jitter = r.jitter > 0 && r.jitter <= 1 ? r.jitter : 0, this.attempts = 0
      }
      $p.prototype.duration = function () {
        var r = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
          var e = Math.random(),
            t = Math.floor(e * this.jitter * r);
          r = (Math.floor(e * 10) & 1) == 0 ? r - t : r + t
        }
        return Math.min(r, this.max) | 0
      };
      $p.prototype.reset = function () {
        this.attempts = 0
      };
      $p.prototype.setMin = function (r) {
        this.ms = r
      };
      $p.prototype.setMax = function (r) {
        this.max = r
      };
      $p.prototype.setJitter = function (r) {
        this.jitter = r
      }
    });
    var X9 = y(G6 => {
      l();
      "use strict";
      Object.defineProperty(G6, "__esModule", {
        value: !0
      });
      G6.Manager = void 0;
      var hft = Nbe(),
        dft = J9(),
        pft = Ph(),
        yft = z6(),
        Oh = Y9(),
        gft = jbe(),
        mn = Oe()("socket.io-client:manager"),
        Vbe = class extends pft {
          constructor(e, t) {
            super();
            this.nsps = {}, this.subs = [], e && typeof e == "object" && (t = e, e = void 0), t = t || {}, t.path = t.path || "/socket.io", this.opts = t, this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || Infinity), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor(t.randomizationFactor || .5), this.backoff = new gft({
              min: this.reconnectionDelay(),
              max: this.reconnectionDelayMax(),
              jitter: this.randomizationFactor()
            }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e;
            let i = t.parser || yft;
            this.encoder = new i.Encoder, this.decoder = new i.Decoder, this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open()
          }
          reconnection(e) {
            return arguments.length ? (this._reconnection = !!e, this) : this._reconnection
          }
          reconnectionAttempts(e) {
            return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this)
          }
          reconnectionDelay(e) {
            var t;
            return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this)
          }
          randomizationFactor(e) {
            var t;
            return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this)
          }
          reconnectionDelayMax(e) {
            var t;
            return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this)
          }
          timeout(e) {
            return arguments.length ? (this._timeout = e, this) : this._timeout
          }
          maybeReconnectOnOpen() {
            !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect()
          }
          open(e) {
            if (mn("readyState %s", this._readyState), ~this._readyState.indexOf("open")) return this;
            mn("opening %s", this.uri), this.engine = hft(this.uri, this.opts);
            let t = this.engine,
              i = this;
            this._readyState = "opening", this.skipReconnect = !1;
            let n = Oh.on(t, "open", function () {
              i.onopen(), e && e()
            }),
              s = Oh.on(t, "error", o => {
                mn("error"), i.cleanup(), i._readyState = "closed", super.emit("error", o), e ? e(o) : i.maybeReconnectOnOpen()
              });
            if (this._timeout !== !1) {
              let o = this._timeout;
              mn("connect attempt will timeout after %d", o), o === 0 && n();
              let a = setTimeout(() => {
                mn("connect attempt timed out after %d", o), n(), t.close(), t.emit("error", new Error("timeout"))
              }, o);
              this.subs.push(function () {
                clearTimeout(a)
              })
            }
            return this.subs.push(n), this.subs.push(s), this
          }
          connect(e) {
            return this.open(e)
          }
          onopen() {
            mn("open"), this.cleanup(), this._readyState = "open", super.emit("open");
            let e = this.engine;
            this.subs.push(Oh.on(e, "ping", this.onping.bind(this)), Oh.on(e, "data", this.ondata.bind(this)), Oh.on(e, "error", this.onerror.bind(this)), Oh.on(e, "close", this.onclose.bind(this)), Oh.on(this.decoder, "decoded", this.ondecoded.bind(this)))
          }
          onping() {
            super.emit("ping")
          }
          ondata(e) {
            this.decoder.add(e)
          }
          ondecoded(e) {
            super.emit("packet", e)
          }
          onerror(e) {
            mn("error", e), super.emit("error", e)
          }
          socket(e, t) {
            let i = this.nsps[e];
            return i || (i = new dft.Socket(this, e, t), this.nsps[e] = i), i
          }
          _destroy(e) {
            let t = Object.keys(this.nsps);
            for (let i of t)
              if (this.nsps[i].active) {
                mn("socket %s is still active, skipping close", i);
                return
              } this._close()
          }
          _packet(e) {
            mn("writing packet %j", e);
            let t = this.encoder.encode(e);
            for (let i = 0; i < t.length; i++) this.engine.write(t[i], e.options)
          }
          cleanup() {
            mn("cleanup"), this.subs.forEach(e => e()), this.subs.length = 0, this.decoder.destroy()
          }
          _close() {
            mn("disconnect"), this.skipReconnect = !0, this._reconnecting = !1, this._readyState === "opening" && this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.engine && this.engine.close()
          }
          disconnect() {
            return this._close()
          }
          onclose(e) {
            mn("onclose"), this.cleanup(), this.backoff.reset(), this._readyState = "closed", super.emit("close", e), this._reconnection && !this.skipReconnect && this.reconnect()
          }
          reconnect() {
            if (this._reconnecting || this.skipReconnect) return this;
            let e = this;
            if (this.backoff.attempts >= this._reconnectionAttempts) mn("reconnect failed"), this.backoff.reset(), super.emit("reconnect_failed"), this._reconnecting = !1;
            else {
              let t = this.backoff.duration();
              mn("will wait %dms before reconnect attempt", t), this._reconnecting = !0;
              let i = setTimeout(() => {
                e.skipReconnect || (mn("attempting reconnect"), super.emit("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open(n => {
                  n ? (mn("reconnect attempt error"), e._reconnecting = !1, e.reconnect(), super.emit("reconnect_error", n)) : (mn("reconnect success"), e.onreconnect())
                }))
              }, t);
              this.subs.push(function () {
                clearTimeout(i)
              })
            }
          }
          onreconnect() {
            let e = this.backoff.attempts;
            this._reconnecting = !1, this.backoff.reset(), super.emit("reconnect", e)
          }
        };
      G6.Manager = Vbe
    });
    var Wbe = y((Gs, Hbe) => {
      l();
      "use strict";
      Object.defineProperty(Gs, "__esModule", {
        value: !0
      });
      Gs.Socket = Gs.io = Gs.Manager = Gs.protocol = void 0;
      var bft = Fge(),
        Gbe = X9(),
        mft = J9();
      Object.defineProperty(Gs, "Socket", {
        enumerable: !0,
        get: function () {
          return mft.Socket
        }
      });
      var $be = Oe()("socket.io-client");
      Hbe.exports = Gs = Z9;
      var zb = Gs.managers = {};

      function Z9(r, e) {
        typeof r == "object" && (e = r, r = void 0), e = e || {};
        let t = bft.url(r, e.path),
          i = t.source,
          n = t.id,
          s = t.path,
          o = zb[n] && s in zb[n].nsps,
          a = e.forceNew || e["force new connection"] || e.multiplex === !1 || o,
          c;
        return a ? ($be("ignoring socket cache for %s", i), c = new Gbe.Manager(i, e)) : (zb[n] || ($be("new io instance for %s", i), zb[n] = new Gbe.Manager(i, e)), c = zb[n]), t.query && !e.query && (e.query = t.queryKey), c.socket(t.path, e)
      }
      Gs.io = Z9;
      var vft = z6();
      Object.defineProperty(Gs, "protocol", {
        enumerable: !0,
        get: function () {
          return vft.protocol
        }
      });
      Gs.connect = Z9;
      var wft = X9();
      Object.defineProperty(Gs, "Manager", {
        enumerable: !0,
        get: function () {
          return wft.Manager
        }
      })
    });
    var $6 = y((rTt, Ybe) => {
      l();
      Ybe.exports = r => {
        if (r[Symbol.asyncIterator]) return r;
        if (r.getReader) return async function* () {
          let e = r.getReader();
          try {
            for (; ;) {
              let {
                done: t,
                value: i
              } = await e.read();
              if (t) return;
              yield i
            }
          } finally {
            e.releaseLock()
          }
        }();
        throw new Error("unknown stream")
      }
    });
    var Q9 = y((iTt, Jbe) => {
      l();
      var _ft = __();
      Jbe.exports = r => async e => {
        e = _ft(e);
        let t = w => {
          typeof w.return == "function" && w.return()
        },
          i = null,
          n = null,
          s = w => {
            i = w, n && n(w), t(e)
          },
          o = null,
          a = !1,
          c = () => {
            a = !0, o && o()
          },
          u = null,
          f = !1,
          h = () => {
            f = !0, u && u()
          },
          d = null,
          p = () => {
            d && d()
          },
          g = () => new Promise((w, O) => {
            o = d = w, n = O, r.once("drain", p)
          }),
          m = () => (t(e), new Promise((w, O) => {
            if (a || f || i) return w();
            u = o = w, n = O
          })),
          E = () => {
            r.removeListener("error", s), r.removeListener("close", c), r.removeListener("finish", h), r.removeListener("drain", p)
          };
        r.once("error", s), r.once("close", c), r.once("finish", h);
        try {
          for await (let w of e) {
            if (!r.writable || r.destroyed || i) break;
            r.write(w) === !1 && await g()
          }
        } catch (w) {
          i || r.destroy(), i = w
        }
        try {
          if (r.writable && r.end(), await m(), i) throw i
        } finally {
          E()
        }
      }
    });
    var ek = y((nTt, Xbe) => {
      l();
      var Eft = Q9(),
        Sft = $6();
      Xbe.exports = r => ({
        sink: Eft(r),
        source: Sft(r)
      })
    });
    var Qbe = y((sTt, Zbe) => {
      l();
      var xft = ek();
      Zbe.exports = r => async function* (e) {
        let t = xft(r);
        t.sink(e).catch(i => { }), yield* t.source
      }
    });
    var eme = y((oTt, Wp) => {
      l();
      Wp.exports = $6();
      Wp.exports.source = $6();
      Wp.exports.sink = Q9();
      Wp.exports.transform = Qbe();
      Wp.exports.duplex = ek()
    });
    var tk = y((aTt, tme) => {
      l();
      "use strict";
      var rme = au(),
        Aft = eme(),
        {
          CLOSE_TIMEOUT: Ift
        } = N6(),
        ime = h9(),
        nme = Oe(),
        W6 = nme("libp2p:webrtc-star:socket");
      W6.error = nme("libp2p:webrtc-star:socket:error");
      var sme = (r, e) => {
        if (!(!r || !e)) try {
          return ime(r, e)
        } catch (t) {
          return W6.error(t), ime("0.0.0.0", e)
        }
      };
      tme.exports = (r, e = {}) => {
        let {
          sink: t,
          source: i
        } = Aft.duplex(r), n = e.remoteAddr || sme(r.remoteAddress, r.remotePort), s = sme(r.localAddress, r.localPort), o = {
          async sink(a) {
            e.signal && (a = rme(a, e.signal));
            try {
              await t(async function* () {
                for await (let c of a) yield c instanceof Uint8Array ? c : c.slice()
              }())
            } catch (c) {
              c.type !== "aborted" && W6.error(c)
            }
          },
          source: e.signal ? rme(i, e.signal) : i,
          conn: r,
          localAddr: s,
          remoteAddr: n,
          timeline: {
            open: Date.now()
          },
          close() {
            if (!r.destroyed) return new Promise((a, c) => {
              let u = Date.now(),
                f = setTimeout(() => {
                  if (o.remoteAddr) {
                    let {
                      host: h,
                      port: d
                    } = o.remoteAddr.toOptions();
                    W6("timeout closing socket to %s:%s after %dms, destroying it manually", h, d, Date.now() - u)
                  }
                  r.destroyed || r.destroy()
                }, Ift);
              r.once("close", () => {
                a()
              }), r.end(h => {
                if (clearTimeout(f), o.timeline.close = Date.now(), h) return c(h)
              })
            })
          }
        };
        return r.once("close", () => {
          o.timeline.close || (o.timeline.close = Date.now())
        }), o
      }
    });
    var rk = y((cTt, ome) => {
      l();
      "use strict";
      var {
        Multiaddr: ame
      } = pr();

      function Tft(r) {
        let e = r.toString().split("/"),
          t = r.protos()[1].name,
          i = r.protos()[2].name,
          n = r.stringTuples()[1][1];
        if (t !== "tcp" || i !== "ws" && i !== "wss") throw new Error("invalid multiaddr: " + r.toString());
        if (!ame.isName(r)) return "http://" + e[2] + ":" + e[4];
        if (i === "ws") return "http://" + e[2] + (n === "80" ? "" : ":" + n);
        if (i === "wss") return "https://" + e[2] + (n === "443" ? "" : ":" + n)
      }

      function Rft(r) {
        let e = "/libp2p-webrtc-star";
        if (r.indexOf(e) !== -1) {
          r = r.substring(e.length, r.length);
          let t = new ame(r),
            i = t.stringTuples().filter(n => n[0] === 421)[0];
          t = t.decapsulate("p2p"), t = t.encapsulate("/p2p-webrtc-star"), t = t.encapsulate(`/p2p/${i[1]}`), r = t.toString()
        }
        return r
      }
      ome.exports = {
        cleanUrlSIO: Tft,
        cleanMultiaddr: Rft
      }
    });
    var lme = y((uTt, cme) => {
      l();
      "use strict";
      var kft = Br(),
        ume = Oe(),
        Nh = ume("libp2p:webrtc-star:listener");
      Nh.error = ume("libp2p:webrtc-star:listener:error");
      var Pft = xe(),
        Cft = Wbe(),
        Oft = x9(),
        Nft = wb(),
        qft = tk(),
        {
          cleanUrlSIO: Mft
        } = rk(),
        {
          CODE_P2P: fme
        } = N6(),
        Bft = {
          transports: ["websocket"],
          "force new connection": !0,
          path: "/socket.io-next/"
        };
      cme.exports = ({
        handler: r,
        upgrader: e
      }, t, i = {}) => {
        let n = new kft,
          s, o;
        return n.__connections = [], n.__spChannels = new Map, n.__pendingIntents = new Map, n.listen = a => {
          if (s) throw Pft(new Error("listener already in use"), "ERR_ALREADY_LISTENING");
          let c = Nft();
          s = a;
          let u;
          !a.protoCodes().includes(fme) && e.localPeer ? u = a.encapsulate(`/p2p/${e.localPeer.toB58String()}`) : u = a, n.on("error", () => c.reject()), o = Mft(a), Nh("Dialing to Signalling Server on: " + o), n.io = Cft.connect(o, Bft);
          let f = h => {
            if (h.answer || h.err || !h.intentId) return;
            let d = h.intentId,
              p = n.__pendingIntents.get(d);
            p || (p = [], n.__pendingIntents.set(d, p));
            let g = n.__spChannels.get(d);
            if (g) {
              g.signal(h.signal);
              return
            } else if (h.signal.type !== "offer") {
              p.push(h);
              return
            }
            let m = {
              trickle: !1,
              ...i
            };
            t.wrtc && (m.wrtc = t.wrtc), g = new Oft(m);
            let E = w => {
              Nh.error("incoming connectioned errored", w)
            };
            g.on("error", E), g.once("close", (...w) => {
              g.removeListener("error", E)
            }), g.on("signal", w => {
              h.signal = w, h.answer = !0, n.io.emit("ss-handshake", h)
            }), g.signal(h.signal);
            for (let w of p) g.signal(w.signal);
            n.__pendingIntents.set(d, []), g.once("connect", async () => {
              let w = qft(g);
              Nh("new inbound connection %s", w.remoteAddr);
              let O;
              try {
                O = await e.upgradeInbound(w)
              } catch (q) {
                return Nh.error("inbound connection failed to upgrade", q), w.close()
              }
              if (!O.remoteAddr) try {
                O.remoteAddr = a.decapsulateCode(fme).encapsulate(`/p2p/${O.remotePeer.toB58String()}`)
              } catch (q) {
                Nh.error("could not determine remote address", q)
              }
              Nh("inbound connection %s upgraded", w.remoteAddr), Dft(n, w, d), n.emit("connection", O), r(O)
            }), n.__spChannels.set(d, g)
          };
          return n.io.once("connect_error", h => c.reject(h)), n.io.once("error", h => {
            n.emit("error", h), n.emit("close")
          }), n.io.on("ws-handshake", f), n.io.on("ws-peer", t._peerDiscovered), n.io.on("connect", () => {
            n.io.emit("ss-join", u.toString())
          }), n.io.once("connect", () => {
            n.emit("listening"), c.resolve()
          }), t.sigReferences.set(o, {
            listener: n,
            signallingAddr: u
          }), c.promise
        }, n.close = async () => {
          let a = t.sigReferences.get(o);
          a && a.listener.io && (a.listener.io.emit("ss-leave"), a.listener.io.close()), await Promise.all(n.__connections.map(c => c.close())), n.emit("close"), n.removeAllListeners(), s = void 0, t.sigReferences.delete(o)
        }, n.getAddrs = () => [s], n
      };

      function Dft(r, e, t) {
        r.__connections.push(e);
        let i = () => {
          r.__connections = r.__connections.filter(n => n !== e), r.__spChannels.delete(t), r.__pendingIntents.delete(t)
        };
        e.conn.once("close", i)
      }
    });
    var gme = y((fTt, hme) => {
      l();
      "use strict";
      var dme = Oe(),
        wu = dme("libp2p:webrtc-star");
      wu.error = dme("libp2p:webrtc-star:error");
      var {
        EventEmitter: Lft
      } = Br(), Y6 = xe(), Fft = z2(), {
        AbortError: pme
      } = au(), Uft = x9(), {
        supportsWebRTCDataChannels: Kft
      } = Bge(), {
        Multiaddr: zft
      } = pr(), jft = El(), Vft = Et(), {
        CODE_CIRCUIT: Hft
      } = N6(), Gft = lme(), $ft = tk(), {
        cleanMultiaddr: Wft,
        cleanUrlSIO: Yft
      } = rk();

      function Jft() { }
      var yme = class {
        constructor(e = {}) {
          if (!e.upgrader) throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");
          this._upgrader = e.upgrader, this.sioOptions = {
            transports: ["websocket"],
            "force new connection": !0
          }, e.wrtc && (this.wrtc = e.wrtc), this.sigReferences = new Map, this.discovery = new Lft, this.discovery.tag = "webRTCStar", this.discovery._isStarted = !1, this.discovery.start = () => {
            this.discovery._isStarted = !0
          }, this.discovery.stop = () => {
            this.discovery._isStarted = !1
          }, this._peerDiscovered = this._peerDiscovered.bind(this)
        }
        async dial(e, t = {}) {
          let i = await this._connect(e, t),
            n = $ft(i, {
              remoteAddr: e,
              signal: t.signal
            });
          wu("new outbound connection %s", n.remoteAddr);
          let s = await this._upgrader.upgradeOutbound(n);
          return wu("outbound connection %s upgraded", n.remoteAddr), s
        }
        _connect(e, t = {}) {
          if (t.signal && t.signal.aborted) throw new pme;
          let i = {
            initiator: !0,
            trickle: !1,
            ...t.spOptions || {}
          };
          this.wrtc && (i.wrtc = this.wrtc);
          let n = e.toOptions(),
            s = (~~(Math.random() * 1e9)).toString(36) + Date.now();
          return new Promise((o, a) => {
            let c = this.sigReferences.get(Yft(e));
            if (!c || !c.listener) return a(Y6(new Error("unknown signal server to use"), "ERR_UNKNOWN_SIGNAL_SERVER"));
            let u = c.listener.io,
              f = Date.now(),
              h;
            wu("dialing %s:%s", n.host, n.port);
            let d = new Uft(i),
              p = O => {
                if (!h) {
                  let q = `connection error ${n.host}:${n.port}: ${O.message}`;
                  wu.error(q), w(O)
                }
              },
              g = () => {
                wu("connnection timeout %s:%s", n.host, n.port);
                let O = Y6(new Error(`connection timeout after ${Date.now() - f}ms`), "ERR_CONNECT_TIMEOUT");
                d.emit("error", O)
              },
              m = () => {
                h = !0, wu("connection opened %s:%s", n.host, n.port), w(null)
              },
              E = () => {
                wu.error("connection aborted %s:%s", n.host, n.port), d.destroy(), w(new pme)
              },
              w = O => {
                d.removeListener("timeout", g), d.removeListener("connect", m), t.signal && t.signal.removeEventListener("abort", E), O ? a(O) : o(d)
              };
            d.on("error", p), d.once("timeout", g), d.once("connect", m), d.on("close", () => {
              d.removeListener("error", p)
            }), t.signal && t.signal.addEventListener("abort", E), d.on("signal", O => {
              u.emit("ss-handshake", {
                intentId: s,
                srcMultiaddr: c.signallingAddr.toString(),
                dstMultiaddr: e.toString(),
                signal: O
              })
            }), u.on("ws-handshake", O => {
              O.intentId === s && O.err && a(Y6(O.err instanceof Error ? O.err : new Error(O.err), "ERR_SIGNALLING_FAILED")), !(O.intentId !== s || !O.answer || d.destroyed) && d.signal(O.signal)
            })
          })
        }
        createListener(e = {}, t) {
          if (!Kft && !this.wrtc) throw Y6(new Error("no WebRTC support"), "ERR_NO_WEBRTC_SUPPORT");
          return typeof e == "function" && (t = e, e = {}), t = t || Jft, Gft({
            handler: t,
            upgrader: this._upgrader
          }, this, e)
        }
        filter(e) {
          return e = Array.isArray(e) ? e : [e], e.filter(t => t.protoCodes().includes(Hft) ? !1 : jft.WebRTCStar.matches(t))
        }
        _peerDiscovered(e) {
          if (!this.discovery._isStarted) return;
          wu("Peer Discovered:", e), e = Wft(e);
          let t = new zft(e),
            i = Vft.createFromB58String(t.getPeerId());
          this.discovery.emit("peer", {
            id: i,
            multiaddrs: [t]
          })
        }
      };
      hme.exports = Fft(yme, {
        className: "WebRTCStar",
        symbolName: "@libp2p/js-libp2p-webrtc-star/webrtcstar"
      })
    });
    var _me = y((lTt, bme) => {
      l();
      "use strict";
      var J6 = Yo(),
        mme = go(),
        ik = 10 * 1024,
        vme = class {
          constructor() {
            this._pool = new Uint8Array(ik), this._poolOffset = 0
          }
          write(e) {
            let t = this._pool,
              i = this._poolOffset;
            J6.encode(e.id << 3 | e.type, t, i), i += J6.encode.bytes, J6.encode(e.data ? e.data.length : 0, t, i), i += J6.encode.bytes;
            let n = t.subarray(this._poolOffset, i);
            return ik - i < 100 ? (this._pool = new Uint8Array(ik), this._poolOffset = 0) : this._poolOffset = i, e.data ? [n, e.data] : n
          }
        },
        wme = new vme;
      bme.exports = r => async function* () {
        for await (let t of r) Array.isArray(t) ? yield new mme(t.map(i => wme.write(i))) : yield new mme(wme.write(t))
      }()
    });
    var xme = y((hTt, Eme) => {
      l();
      "use strict";
      var X6 = Yo(),
        Xft = go();
      Eme.exports = r => async function* () {
        let t = new Sme;
        for await (let i of r) {
          let n = t.write(i);
          n.length && (yield n)
        }
      }();
      var Sme = class {
        constructor() {
          this._buffer = new Xft, this._bufferProxy = new Proxy({}, {
            get: (e, t) => t[0] === "l" ? this._buffer[t] : this._buffer.get(parseInt(t))
          }), this._headerInfo = null
        }
        write(e) {
          if (!e || !e.length) return [];
          this._buffer.append(e);
          let t = [];
          for (; ;) {
            if (!this._headerInfo) try {
              this._headerInfo = this._decodeHeader(this._bufferProxy)
            } catch (c) {
              break
            }
            let {
              id: i,
              type: n,
              length: s,
              offset: o
            } = this._headerInfo;
            if (this._buffer.length - o < s) break;
            t.push({
              id: i,
              type: n,
              data: this._buffer.shallowSlice(o, o + s)
            }), this._buffer.consume(o + s), this._headerInfo = null
          }
          return t
        }
        _decodeHeader(e) {
          let t = X6.decode(e),
            i = X6.decode.bytes,
            n = X6.decode(e, i);
          return i += X6.decode.bytes, {
            id: t >> 3,
            type: t & 7,
            offset: i,
            length: n
          }
        }
      }
    });
    var Ame = y(nk => {
      l();
      "use strict";
      nk.encode = _me();
      nk.decode = xme()
    });
    var ok = y((pTt, sk) => {
      l();
      "use strict";
      var Ime = 1 << 20;
      sk.exports = r => {
        r = r || Ime;
        let e = t => {
          if (t.data && t.data.length > r) throw Object.assign(new Error("message size too large!"), {
            code: "ERR_MSG_TOO_BIG"
          })
        };
        return t => async function* () {
          for await (let n of t) Array.isArray(n) ? n.forEach(e) : e(n), yield n
        }()
      };
      sk.exports.MAX_MSG_SIZE = Ime
    });
    var ak = y(jb => {
      l();
      "use strict";
      var _u = Object.freeze({
        NEW_STREAM: 0,
        MESSAGE_RECEIVER: 1,
        MESSAGE_INITIATOR: 2,
        CLOSE_RECEIVER: 3,
        CLOSE_INITIATOR: 4,
        RESET_RECEIVER: 5,
        RESET_INITIATOR: 6
      });
      jb.MessageTypes = _u;
      jb.InitiatorMessageTypes = Object.freeze({
        NEW_STREAM: _u.NEW_STREAM,
        MESSAGE: _u.MESSAGE_INITIATOR,
        CLOSE: _u.CLOSE_INITIATOR,
        RESET: _u.RESET_INITIATOR
      });
      jb.ReceiverMessageTypes = Object.freeze({
        MESSAGE: _u.MESSAGE_RECEIVER,
        CLOSE: _u.CLOSE_RECEIVER,
        RESET: _u.RESET_RECEIVER
      });
      jb.MessageTypeNames = Object.freeze(Object.entries(_u).reduce((r, e) => (r[e[1]] = e[0], r), {}))
    });
    var Pme = y((gTt, Tme) => {
      l();
      "use strict";
      var Zft = au(),
        Rme = Zf(),
        Vb = Oe()("libp2p:mplex:stream"),
        Qft = eu(),
        kme = go(),
        elt = xe(),
        {
          MAX_MSG_SIZE: tlt
        } = ok(),
        {
          InitiatorMessageTypes: rlt,
          ReceiverMessageTypes: ilt
        } = ak(),
        ck = "ERR_MPLEX_STREAM_RESET",
        nlt = "ERR_MPLEX_STREAM_ABORT";
      Tme.exports = ({
        id: r,
        name: e,
        send: t,
        onEnd: i = () => { },
        type: n = "initiator",
        maxMsgSize: s = tlt
      }) => {
        let o = new Rme,
          a = new Rme,
          c = n === "initiator" ? rlt : ilt,
          u = n === "initiator" ? `i${r}` : `r${r}`;
        e = String(e ?? r);
        let f = !1,
          h = !1,
          d, p = E => {
            f || (f = !0, Vb("%s stream %s source end", n, e, E), E && !d && (d = E), h && (m.timeline.close = Date.now(), i(d)))
          },
          g = E => {
            h || (h = !0, Vb("%s stream %s sink end", n, e, E), E && !d && (d = E), f && (m.timeline.close = Date.now(), i(d)))
          },
          m = {
            close: () => m.source.end(),
            abort: E => {
              Vb("%s stream %s abort", n, e, E), m.source.end(E), o.abort(), g(E)
            },
            reset: () => {
              let E = elt(new Error("stream reset"), ck);
              a.abort(), m.source.end(E), g(E)
            },
            sink: async E => {
              E = Zft(E, [{
                signal: o.signal,
                options: {
                  abortMessage: "stream aborted",
                  abortCode: nlt
                }
              }, {
                signal: a.signal,
                options: {
                  abortMessage: "stream reset",
                  abortCode: ck
                }
              }]), n === "initiator" && t({
                id: r,
                type: c.NEW_STREAM,
                data: e
              });
              try {
                for await (let w of E) for (; w.length;) {
                  if (w.length <= s) {
                    t({
                      id: r,
                      type: c.MESSAGE,
                      data: w
                    });
                    break
                  }
                  w = kme.isBufferList(w) ? w : new kme(w), t({
                    id: r,
                    type: c.MESSAGE,
                    data: w.shallowSlice(0, s)
                  }), w.consume(s)
                }
              } catch (w) {
                return w.code === ck ? Vb("%s stream %s reset", n, e) : (Vb("%s stream %s error", n, e, w), t({
                  id: r,
                  type: c.RESET
                })), m.source.end(w), g(w)
              }
              t({
                id: r,
                type: c.CLOSE
              }), g()
            },
            source: Qft(p),
            timeline: {
              open: Date.now(),
              close: null
            },
            id: u
          };
        return m
      }
    });
    var qme = y((bTt, Cme) => {
      l();
      "use strict";
      var slt = vi(),
        olt = eu(),
        Eu = Oe()("libp2p:mplex"),
        alt = au(),
        Ome = Ame(),
        clt = ok(),
        {
          MessageTypes: qh,
          MessageTypeNames: Nme
        } = ak(),
        ult = Pme(),
        uk = class {
          constructor(e) {
            e = e || {}, e = typeof e == "function" ? {
              onStream: e
            } : e, this._streamId = 0, this._streams = {
              initiators: new Map,
              receivers: new Map
            }, this._options = e, this.sink = this._createSink(), this.source = this._createSource(), this.onStream = e.onStream, this.onStreamEnd = e.onStreamEnd
          }
          get streams() {
            let e = [];
            return this._streams.initiators.forEach(t => {
              e.push(t)
            }), this._streams.receivers.forEach(t => {
              e.push(t)
            }), e
          }
          newStream(e) {
            let t = this._streamId++;
            e = e == null ? t.toString() : String(e);
            let i = this._streams.initiators;
            return this._newStream({
              id: t,
              name: e,
              type: "initiator",
              registry: i
            })
          }
          _newReceiverStream({
            id: e,
            name: t
          }) {
            let i = this._streams.receivers;
            return this._newStream({
              id: e,
              name: t,
              type: "receiver",
              registry: i
            })
          }
          _newStream({
            id: e,
            name: t,
            type: i,
            registry: n
          }) {
            if (n.has(e)) throw new Error(`${i} stream ${e} already exists!`);
            Eu("new %s stream %s %s", i, e, t);
            let a = ult({
              id: e,
              name: t,
              send: c => (Eu.enabled && Eu("%s stream %s %s send", i, e, t, {
                ...c,
                type: Nme[c.type],
                data: c.data && c.data.slice()
              }), this.source.push(c)),
              type: i,
              onEnd: () => {
                Eu("%s stream %s %s ended", i, e, t), n.delete(e), this.onStreamEnd && this.onStreamEnd(a)
              },
              maxMsgSize: this._options.maxMsgSize
            });
            return n.set(e, a), a
          }
          _createSink() {
            return async e => {
              this._options.signal && (e = alt(e, this._options.signal));
              try {
                await slt(e, Ome.decode, clt(this._options.maxMsgSize), async t => {
                  for await (let i of t) for (let n of i) this._handleIncoming(n)
                })
              } catch (t) {
                return Eu("error in sink", t), this.source.end(t)
              }
              this.source.end()
            }
          }
          _createSource() {
            let t = olt({
              onEnd: i => {
                let {
                  initiators: n,
                  receivers: s
                } = this._streams;
                for (let o of n.values()) o.abort(i);
                for (let o of s.values()) o.abort(i)
              },
              writev: !0
            });
            return Object.assign(Ome.encode(t), {
              push: t.push,
              end: t.end,
              return: t.return
            })
          }
          _handleIncoming({
            id: e,
            type: t,
            data: i
          }) {
            if (Eu.enabled && Eu("incoming message", {
              id: e,
              type: Nme[t],
              data: i.slice()
            }), t === qh.NEW_STREAM && this.onStream) {
              let o = this._newReceiverStream({
                id: e,
                name: i.toString()
              });
              return this.onStream(o)
            }
            let s = (t & 1 ? this._streams.initiators : this._streams.receivers).get(e);
            if (!s) return Eu("missing stream %s", e);
            switch (t) {
              case qh.MESSAGE_INITIATOR:
              case qh.MESSAGE_RECEIVER:
                s.source.push(i);
                break;
              case qh.CLOSE_INITIATOR:
              case qh.CLOSE_RECEIVER:
                s.close();
                break;
              case qh.RESET_INITIATOR:
              case qh.RESET_RECEIVER:
                s.reset();
                break;
              default:
                Eu("unknown message type %s", t)
            }
          }
        };
      uk.multicodec = "/mplex/6.7.0";
      Cme.exports = uk
    });
    var Bme = y((mTt, Mme) => {
      l();
      "use strict";
      Mme.exports = qme()
    });
    var Su = y((vTt, Dme) => {
      l();
      "use strict";

      function Lme(r, e) {
        if (!r) {
          let t = new Error(e || "Assertion failed");
          throw Error.captureStackTrace && Error.captureStackTrace(t, Lme), t
        }
      }
      Dme.exports = Lme
    });
    var fk = y(Fme => {
      l();
      "use strict";
      Fme.custom = "inspect"
    });
    var c2e = y((_Tt, Ume) => {
      l();
      "use strict";
      var {
        custom: Kme
      } = fk(), zme = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], flt = [0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], llt = [0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176], lk = {
        p192: null,
        p224: null,
        p521: null,
        k256: null,
        p251: null,
        p25519: null,
        p448: null
      }, Xr = {
        NONE: 0,
        QUO: 1,
        REM: 2,
        BOTH: 3,
        EUCLID: 4,
        ALL: 7
      }, Hb = 4, Yp = 1 << Hb - 1, Mh = typeof BigInt == "function", ye = class {
        constructor(e, t, i) {
          this.words = [0], this.length = 1, this.negative = 0, this.red = null, this.from(e, t, i)
        }
        _iadd(e, t) {
          let i = 0,
            n = 0;
          for (e.length < t.length && ([e, t] = [t, e]), e !== this && this._alloc(e.length); n < t.length; n++) {
            let s = (e.words[n] | 0) + (t.words[n] | 0) + i;
            this.words[n] = s & 67108863, i = s >>> 26
          }
          for (; i !== 0 && n < e.length; n++) {
            let s = (e.words[n] | 0) + i;
            this.words[n] = s & 67108863, i = s >>> 26
          }
          if (this.length = e.length, i !== 0) this._alloc(this.length + 1), this.words[this.length++] = i;
          else if (e !== this)
            for (; n < e.length; n++) this.words[n] = e.words[n];
          return this
        }
        _iaddn(e) {
          if (this.words[0] += e, this.words[0] < 67108864) return this;
          let t = 0;
          for (this._alloc(this.length + 1), this.words[this.length] = 0; t < this.length && this.words[t] >= 67108864; t++) this.words[t] -= 67108864, this.words[t + 1] += 1;
          return this.length = Math.max(this.length, t + 1), this
        }
        iadd(e) {
          if (me(ye.isBN(e), "num", "bignum"), this.negative === e.negative) this._iadd(this, e);
          else {
            let t = this.ucmp(e);
            if (t === 0) return this.words[0] = 0, this.length = 1, this.negative = 0, this;
            t < 0 ? (this._isub(e, this), this.negative ^= 1) : this._isub(this, e)
          }
          return this
        }
        iaddn(e) {
          me(vr(e), "num", "smi");
          let t = e < 0 | 0;
          return t && (e = -e), this.negative === t ? this._iaddn(e) : this.length === 1 && this.words[0] < e ? (this.words[0] = e - this.words[0], this.negative ^= 1) : this._isubn(e), this
        }
        add(e) {
          return me(ye.isBN(e), "num", "bignum"), e.length > this.length ? e.clone().iadd(this) : this.clone().iadd(e)
        }
        addn(e) {
          return this.clone().iaddn(e)
        }
        _isub(e, t) {
          let i = 0,
            n = 0;
          for (Zr(e.length >= t.length), e !== this && this._alloc(e.length); n < t.length; n++) {
            let s = (e.words[n] | 0) - (t.words[n] | 0) + i;
            i = s >> 26, this.words[n] = s & 67108863
          }
          for (; i !== 0 && n < e.length; n++) {
            let s = (e.words[n] | 0) + i;
            i = s >> 26, this.words[n] = s & 67108863
          }
          if (Zr(i === 0), e !== this)
            for (; n < e.length; n++) this.words[n] = e.words[n];
          return this.length = Math.max(this.length, n), this._strip()
        }
        _isubn(e) {
          if (this.words[0] -= e, this.words[0] >= 0) return this._normalize();
          Zr(this.length !== 1), this._alloc(this.length + 1);
          for (let t = 0; t < this.length && this.words[t] < 0; t++) this.words[t] += 67108864, this.words[t + 1] -= 1;
          return this.words[this.length] = 0, this._strip()
        }
        isub(e) {
          if (me(ye.isBN(e), "num", "bignum"), this.negative !== e.negative) this._iadd(this, e);
          else {
            let t = this.ucmp(e);
            if (t === 0) return this.words[0] = 0, this.length = 1, this.negative = 0, this;
            t < 0 ? (this._isub(e, this), this.negative ^= 1) : this._isub(this, e)
          }
          return this
        }
        isubn(e) {
          me(vr(e), "num", "smi");
          let t = e < 0 | 0;
          return t && (e = -e), this.negative !== t ? this._iaddn(e) : this.length === 1 && this.words[0] < e ? (this.words[0] = e - this.words[0], this.negative ^= 1) : this._isubn(e), this
        }
        sub(e) {
          return this.clone().isub(e)
        }
        subn(e) {
          return this.clone().isubn(e)
        }
        _mul(e, t) {
          if (me(ye.isBN(e), "num", "bignum"), me(ye.isBN(t), "out", "bignum"), this.length === 10 && e.length === 10) return s2e(this, e, t);
          let i = this.length + e.length;
          return i < 63 ? i2e(this, e, t) : i < 1024 ? n2e(this, e, t) : dlt(this, e, t)
        }
        imul(e) {
          return this.mul(e)._move(this)
        }
        imuln(e) {
          me(vr(e), "num", "smi");
          let t = e < 0 | 0;
          t && (e = -e);
          let i = 0;
          for (let n = 0; n < this.length; n++) {
            let s = this.words[n] * e,
              o = (s & 67108863) + (i & 67108863);
            i >>= 26, i += s / 67108864 | 0, i += o >>> 26, this.words[n] = o & 67108863
          }
          return this.negative ^= t, i !== 0 ? (this._alloc(this.length + 1), this.words[this.length++] = i) : this._strip(), this
        }
        mul(e) {
          me(ye.isBN(e), "num", "bignum");
          let t = this.length + e.length,
            i = new ye;
          i.words = new Array(t);
          for (let n = 0; n < t; n++) i.words[n] = 0;
          return this._mul(e, i)
        }
        muln(e) {
          return this.clone().imuln(e)
        }
        mulShift(e, t) {
          me(ye.isBN(e), "num", "bignum"), me(t >>> 0 === t, "bits", "uint32");
          let i = this.mul(e),
            n = i.utestn(t - 1);
          return i.iushrn(t), this.negative ^ e.negative ? i.isubn(n) : i.iaddn(n)
        }
        _div(e, t) {
          me(ye.isBN(e), "num", "bignum"), Zr((t & Xr.ALL) === t), Zr(t !== Xr.NONE);
          let i = this,
            n = e;
          if (Z6(!n.isZero()), i.isZero()) return [new ye(0), new ye(0)];
          let s = i.negative,
            o = n.negative;
          i.negative = 0, n.negative = 0;
          let a = null,
            c = null;
          return i.ucmp(n) < 0 ? (t & Xr.QUO && (a = new ye(0)), t & Xr.REM && (c = i.clone())) : n.length === 1 ? (t & Xr.QUO && (a = i.quon(n.words[0])), t & Xr.REM && (c = i.remn(n.words[0]))) : [a, c] = i._wordDiv(n, t), i.negative = s, n.negative = o, t & Xr.QUO && (a.negative = i.negative ^ n.negative, a._normalize()), t & Xr.REM && (c.negative = i.negative, c._normalize()), t & Xr.EUCLID && (t & Xr.QUO && (Zr((t & Xr.REM) != 0), c.negative !== 0 && (n.negative !== 0 ? a.iaddn(1) : a.isubn(1))), t & Xr.REM && c.negative !== 0 && (n.negative !== 0 ? c.isub(n) : c.iadd(n))), [a, c]
        }
        _wordDiv(e, t) {
          let i = this.clone(),
            n = e,
            s = null,
            o, a = n.words[n.length - 1] | 0,
            c = 26 - Jp(a);
          c !== 0 ? (n = n.clone(), i.iushln(c), n.iushln(c), o = n.words[n.length - 1] | 0) : o = a;
          let u = i.length - n.length;
          if (Zr(u >= 0), t & Xr.QUO) {
            s = new ye(0), s.length = u + 1, s.words = new Array(s.length);
            for (let h = 0; h < s.length; h++) s.words[h] = 0
          }
          let f = i.clone();
          f._ishlnsubmul(n, 1, u), f.negative === 0 && (s && (s.words[u] = 1), i = f);
          for (let h = u - 1; h >= 0; h--) {
            let d = i.words[n.length + h],
              p = i.words[n.length + h - 1],
              g = (d * 67108864 + p) / o | 0,
              m = Math.min(g, 67108863);
            for (i._ishlnsubmul(n, m, h); i.negative !== 0;) m -= 1, i.negative = 0, i._ishlnsubmul(n, 1, h), i.ineg();
            s && (s.words[h] = m)
          }
          return s && s._strip(), t & Xr.REM && c !== 0 && i.iushrn(c), [s, i]
        }
        _ishlnsubmul(e, t, i) {
          let n = 0,
            s = 0;
          for (this._expand(e.length + i); s < e.length; s++) {
            let o = (this.words[s + i] | 0) + n,
              a = e.words[s] * t,
              c = o - (a & 67108863);
            n = (c >> 26) - (a / 67108864 | 0), this.words[s + i] = c & 67108863
          }
          for (; s < this.length - i; s++) {
            let o = (this.words[s + i] | 0) + n;
            n = o >> 26, this.words[s + i] = o & 67108863
          }
          if (n === 0) return this._strip();
          Zr(n === -1), n = 0;
          for (let o = 0; o < this.length; o++) {
            let a = -(this.words[o] | 0) + n;
            n = a >> 26, this.words[o] = a & 67108863
          }
          return this.negative = 1, this._strip()
        }
        quorem(e) {
          return this._div(e, Xr.BOTH)
        }
        iquo(e) {
          return this.quo(e)._move(this)
        }
        iquon(e) {
          me(vr(e), "num", "smi"), Z6(e !== 0);
          let t = e < 0 | 0;
          t && (e = -e);
          let i = 0;
          for (let n = this.length - 1; n >= 0; n--) {
            let s = (this.words[n] | 0) + i * 67108864;
            this.words[n] = s / e | 0, i = s % e
          }
          return this.negative ^= t, this._strip()
        }
        quo(e) {
          return this._div(e, Xr.QUO)[0]
        }
        quon(e) {
          return this.clone().iquon(e)
        }
        irem(e) {
          return this.rem(e)._move(this)
        }
        iremn(e) {
          let t = this.remrn(e);
          return t < 0 && (t = -t), this.words[0] = t, this.length = 1, this._normalize()
        }
        rem(e) {
          return this._div(e, Xr.REM)[1]
        }
        remn(e) {
          return this.clone().iremn(e)
        }
        remrn(e) {
          me(vr(e), "num", "smi"), Z6(e !== 0), e < 0 && (e = -e);
          let t = (1 << 26) % e,
            i = 0;
          for (let n = this.length - 1; n >= 0; n--) i = (t * i + (this.words[n] | 0)) % e;
          return this.negative !== 0 ? -i | 0 : i
        }
        divmod(e) {
          return this._div(e, Xr.BOTH | Xr.EUCLID)
        }
        idiv(e) {
          return this.div(e)._move(this)
        }
        idivn(e) {
          if (this.negative === 0) return this.iquon(e);
          let t = this.remrn(e);
          return this.iquon(e), t < 0 && (e < 0 ? this.iaddn(1) : this.isubn(1)), this
        }
        div(e) {
          return this._div(e, Xr.BOTH | Xr.EUCLID)[0]
        }
        divn(e) {
          return this.clone().idivn(e)
        }
        imod(e) {
          return this.ucmp(e) < 0 ? (this.negative !== 0 && (this._isub(e, this), this.negative = 0), this) : this.mod(e)._move(this)
        }
        imodn(e) {
          return this.words[0] = this.modrn(e), this.length = 1, this.negative = 0, this
        }
        mod(e) {
          return this._div(e, Xr.REM | Xr.EUCLID)[1]
        }
        modn(e) {
          return this.clone().imodn(e)
        }
        modrn(e) {
          me(vr(e), "num", "smi");
          let t = this.remrn(e);
          return t < 0 && (e < 0 ? t -= e : t += e), t
        }
        divRound(e) {
          let [t, i] = this.quorem(e);
          if (i.isZero()) return t;
          let n = e.words[0] & 1;
          e.iushrn(1);
          let s = i.ucmp(e);
          return e.iushln(1), e.words[0] |= n, s < 0 || e.isOdd() && s === 0 ? t : this.negative ^ e.negative ? t.isubn(1) : t.iaddn(1)
        }
        ipow(e) {
          return this.pow(e)._move(this)
        }
        ipown(e) {
          return this.pown(e)._move(this)
        }
        pow(e) {
          me(ye.isBN(e), "num", "bignum");
          let t = Jp(e.words[e.length - 1]),
            i = new ye(1);
          for (let n = e.length - 1; n >= 0; n--) {
            let s = e.words[n];
            for (let o = t - 1; o >= 0; o--) i = i.sqr(), s >> o & 1 && (i = i.mul(this));
            t = 26
          }
          return i
        }
        pown(e) {
          if (me(vr(e), "num", "smi"), e < 0 && (e = -e), e === 0) return new ye(1);
          if (e === 1) return this.clone();
          let t = Jp(e),
            i = this;
          for (let n = t - 2; n >= 0; n--) i = i.sqr(), e >> n & 1 && (i = i.mul(this));
          return i
        }
        isqr() {
          return this.imul(this)
        }
        sqr() {
          return this.mul(this)
        }
        _rootrem(e, t) {
          if (me(e >>> 0 === e, "num", "uint32"), e === 0) throw new RangeError("Zeroth root.");
          if (~e & this.negative) throw new RangeError("Negative with even root.");
          if (this.ucmpn(1) <= 0) return [this.clone(), new ye(0)];
          let i = new ye(0),
            n = ye.shift(1, this.bitLength() / e + 1 | 0),
            s, o;
          if (this.negative !== 0 && n.ineg(), e === 2)
            do i = n, n = this.quo(i), n.iadd(i), n.iushrn(1); while (n.ucmp(i) < 0);
          else
            do i = n, n = i.pown(e - 1), n = this.quo(n), s = i.muln(e - 1), n.iadd(s), n = n.quon(e); while (n.ucmp(i) < 0);
          return t && (n = i.pown(e), o = this.sub(n)), [i, o]
        }
        rootrem(e) {
          return this._rootrem(e, 1)
        }
        iroot(e) {
          return this.root(e)._move(this)
        }
        root(e) {
          return this._rootrem(e, 0)[0]
        }
        isPower(e) {
          if (me(e >>> 0 === e, "num", "uint32"), e === 0 || ~e & this.negative) return !1;
          let [, t] = this.rootrem(e);
          return t.sign() === 0
        }
        sqrtrem() {
          return this.rootrem(2)
        }
        isqrt() {
          return this.sqrt()._move(this)
        }
        sqrt() {
          return this.root(2)
        }
        isSquare() {
          return this.isPower(2)
        }
        iand(e) {
          me(ye.isBN(e), "num", "bignum");
          let t = this,
            i = e;
          if (t === i) return t;
          if ((t.negative | i.negative) == 0) return t.iuand(i);
          if ((t.negative & i.negative) == 1) return t.iaddn(1), i.iaddn(1), t.iuor(i), t.isubn(1), i.isubn(1), t;
          t.negative !== 0 && ([t, i] = [i.clone(), t]);
          let n = t.bitLength();
          return i.iaddn(1), i.inotn(n), t.iuand(i), i.inotn(n), i.isubn(1), t._move(this)
        }
        iandn(e) {
          return me(vr(e), "num", "smi"), (this.negative | e < 0) != 0 ? this.iand(new ye(e)) : (this.words[0] &= e, this.length = 1, this)
        }
        and(e) {
          return this.clone().iand(e)
        }
        andn(e) {
          return this.clone().iandn(e)
        }
        andrn(e) {
          if (me(vr(e), "num", "smi"), (this.negative | e < 0) != 0) {
            let t = this.iand(new ye(e));
            if (t.length > 1) throw new RangeError("Number exceeds 26 bits.");
            return t.negative !== 0 ? -t.words[0] : t.words[0]
          }
          return this.words[0] & e
        }
        iuand(e) {
          me(ye.isBN(e), "num", "bignum"), this.length = Math.min(this.length, e.length);
          for (let t = 0; t < this.length; t++) this.words[t] &= e.words[t];
          return this._strip()
        }
        iuandn(e) {
          return me(vr(e), "num", "smi"), this.words[0] &= Math.abs(e), this.length = 1, this._normalize()
        }
        uand(e) {
          return this.clone().iuand(e)
        }
        uandn(e) {
          return this.clone().iuandn(e)
        }
        uandrn(e) {
          me(vr(e), "num", "smi");
          let t = this.words[0] & Math.abs(e);
          return this.negative !== 0 ? -t | 0 : t
        }
        ior(e) {
          me(ye.isBN(e), "num", "bignum");
          let t = this,
            i = e;
          return t === i ? t : (t.negative | i.negative) == 0 ? t.iuor(i) : (t.negative & i.negative) == 1 ? (t.iaddn(1), i.iaddn(1), t.iuand(i), t.isubn(1), i.isubn(1), t) : (i = i.clone(), t.negative !== 0 && ([t, i] = [i, t]), i.iaddn(1), t.inotn(i.bitLength()), i.iuand(t), i.isubn(1), i._move(this))
        }
        iorn(e) {
          return me(vr(e), "num", "smi"), (this.negative | e < 0) != 0 ? this.ior(new ye(e)) : (this.words[0] |= e, this)
        }
        or(e) {
          return this.clone().ior(e)
        }
        orn(e) {
          return this.clone().iorn(e)
        }
        iuor(e) {
          me(ye.isBN(e), "num", "bignum"), this._expand(e.length);
          for (let t = 0; t < e.length; t++) this.words[t] |= e.words[t];
          return this
        }
        iuorn(e) {
          return me(vr(e), "num", "smi"), this.words[0] |= Math.abs(e), this
        }
        uor(e) {
          return this.clone().iuor(e)
        }
        uorn(e) {
          return this.clone().iuorn(e)
        }
        ixor(e) {
          me(ye.isBN(e), "num", "bignum");
          let t = this,
            i = e;
          return t === i ? (t.words[0] = 0, t.length = 1, t.negative = 0, t) : (t.negative | i.negative) == 0 ? t.iuxor(i) : (t.negative & i.negative) == 1 ? (t.iaddn(1), i.iaddn(1), t.iuxor(i), t.ineg(), i.isubn(1), t) : (t.negative !== 0 && ([t, i] = [i.clone(), t]), i.iaddn(1), t.iuxor(i), t.iaddn(1), t.ineg(), i.isubn(1), t._move(this))
        }
        ixorn(e) {
          return me(vr(e), "num", "smi"), (this.negative | e < 0) != 0 ? this.ixor(new ye(e)) : (this.words[0] ^= e, this)
        }
        xor(e) {
          return this.clone().ixor(e)
        }
        xorn(e) {
          return this.clone().ixorn(e)
        }
        iuxor(e) {
          me(ye.isBN(e), "num", "bignum");
          let t = this,
            i = e;
          t.length < i.length && ([t, i] = [i, t]);
          let n = 0;
          for (; n < i.length; n++) this.words[n] = t.words[n] ^ i.words[n];
          if (t !== this)
            for (this._alloc(t.length); n < t.length; n++) this.words[n] = t.words[n];
          return this.length = t.length, this._strip()
        }
        iuxorn(e) {
          return me(vr(e), "num", "smi"), this.words[0] ^= Math.abs(e), this._normalize()
        }
        uxor(e) {
          return this.clone().iuxor(e)
        }
        uxorn(e) {
          return this.clone().iuxorn(e)
        }
        inot() {
          return this.negative !== 0 ? this.ineg().isubn(1) : this.iaddn(1).ineg(), this
        }
        not() {
          return this.clone().inot()
        }
        inotn(e) {
          me(e >>> 0 === e, "width", "uint32");
          let t = e % 26,
            i = Math.ceil(e / 26),
            n = 0;
          for (this._expand(i), t > 0 && (i -= 1); n < i; n++) this.words[n] ^= 67108863;
          return t > 0 && (this.words[n] ^= (1 << t) - 1), this._strip()
        }
        notn(e) {
          return this.clone().inotn(e)
        }
        ishl(e) {
          return me(ye.isBN(e), "bits", "bignum"), me(e.bitLength() <= 32, "bits", "uint32"), this.ishln(e.toNumber())
        }
        ishln(e) {
          return this.iushln(e)
        }
        shl(e) {
          return this.clone().ishl(e)
        }
        shln(e) {
          return this.clone().ishln(e)
        }
        iushl(e) {
          return me(ye.isBN(e), "bits", "bignum"), me(e.bitLength() <= 32, "bits", "uint32"), this.iushln(e.toNumber())
        }
        iushln(e) {
          me(e >>> 0 === e, "bits", "uint32");
          let t = e % 26,
            i = (e - t) / 26,
            n = (1 << t) - 1 << 26 - t;
          if (t !== 0) {
            let s = 0;
            for (let o = 0; o < this.length; o++) {
              let a = this.words[o] & n,
                c = (this.words[o] | 0) - a << t;
              this.words[o] = c | s, s = a >>> 26 - t
            }
            s !== 0 && (this._alloc(this.length + 1), this.words[this.length++] = s)
          }
          if (i !== 0) {
            this._alloc(this.length + i);
            for (let s = this.length - 1; s >= 0; s--) this.words[s + i] = this.words[s];
            for (let s = 0; s < i; s++) this.words[s] = 0;
            this.length += i
          }
          return this._strip()
        }
        ushl(e) {
          return this.clone().iushl(e)
        }
        ushln(e) {
          return this.clone().iushln(e)
        }
        _split(e, t) {
          let i = e % 26,
            n = Math.min((e - i) / 26, this.length),
            s = (1 << i) - 1;
          if (t) {
            t._alloc(n);
            for (let a = 0; a < n; a++) t.words[a] = this.words[a];
            t.length = n
          }
          if (n !== 0)
            if (this.length > n) {
              this.length -= n;
              for (let a = 0; a < this.length; a++) this.words[a] = this.words[a + n]
            } else this.words[0] = 0, this.length = 1;
          let o = 0;
          if (i !== 0)
            for (let a = this.length - 1; a >= 0; a--) {
              let c = this.words[a] | 0;
              this.words[a] = o << 26 - i | c >>> i, o = c & s
            }
          return t && (o !== 0 ? (t._alloc(t.length + 1), t.words[t.length++] = o) : (t.length === 0 && (t.words[t.length++] = 0), t._strip())), this._strip()
        }
        ishr(e) {
          return me(ye.isBN(e), "bits", "bignum"), me(e.bitLength() <= 32, "bits", "uint32"), this.ishrn(e.toNumber())
        }
        ishrn(e) {
          return me(e >>> 0 === e, "bits", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.iushrn(e), this.isubn(1), this) : this.iushrn(e)
        }
        shr(e) {
          return this.clone().ishr(e)
        }
        shrn(e) {
          return this.clone().ishrn(e)
        }
        iushr(e) {
          return me(ye.isBN(e), "bits", "bignum"), me(e.bitLength() <= 32, "bits", "uint32"), this.iushrn(e.toNumber())
        }
        iushrn(e) {
          return me(e >>> 0 === e, "bits", "uint32"), this._split(e, null)
        }
        ushr(e) {
          return this.clone().iushr(e)
        }
        ushrn(e) {
          return this.clone().iushrn(e)
        }
        setn(e, t) {
          return me(e >>> 0 === e, "bit", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.usetn(e, !t), this.isubn(1), this) : this.usetn(e, t)
        }
        usetn(e, t) {
          me(e >>> 0 === e, "bit", "uint32");
          let i = e % 26,
            n = (e - i) / 26;
          return this._expand(n + 1), t ? this.words[n] |= 1 << i : this.words[n] &= ~(1 << i), this._strip()
        }
        testn(e) {
          me(e >>> 0 === e, "bit", "uint32");
          let t = e % 26,
            i = (e - t) / 26;
          if (this.length <= i) return this.negative;
          let n = this.words[i],
            s = n >> t & 1;
          if (this.negative !== 0) {
            if (t > 0 && n & (1 << t) - 1) return s ^ 1;
            let o = i;
            for (; o--;)
              if (this.words[o] > 0) return s ^ 1
          }
          return s
        }
        utestn(e) {
          me(e >>> 0 === e, "bit", "uint32");
          let t = e % 26,
            i = (e - t) / 26;
          return this.length <= i ? 0 : this.words[i] >> t & 1
        }
        imaskn(e) {
          return me(e >>> 0 === e, "bits", "uint32"), this.negative !== 0 && (this.iaddn(1), this.inotn(e + 1), this.ineg()), this.iumaskn(e)
        }
        maskn(e) {
          return this.clone().imaskn(e)
        }
        iumaskn(e) {
          me(e >>> 0 === e, "bits", "uint32");
          let t = e % 26,
            i = (e - t) / 26;
          return this.length <= i ? this : (t !== 0 && (i += 1), this.length = Math.min(i, this.length), t !== 0 && (this.words[this.length - 1] &= (1 << t) - 1), this.length === 0 && (this.words[this.length++] = 0), this._strip())
        }
        umaskn(e) {
          return this.clone().iumaskn(e)
        }
        andln(e) {
          return this.words[0] & e
        }
        bit(e) {
          return this.utestn(e)
        }
        bits(e, t) {
          me(e >>> 0 === e, "pos", "uint32"), me(t >>> 0 === t, "width", "uint32"), me(t <= 26, "width", "width");
          let i = e % 26,
            n = (e - i) / 26;
          if (n >= this.length) return 0;
          let s = this.words[n] >> i & (1 << t) - 1;
          if (i + t > 26 && n + 1 < this.length) {
            let o = i + t - 26;
            s |= (this.words[n + 1] & (1 << o) - 1) << 26 - i
          }
          return s
        }
        ineg() {
          return this.isZero() || (this.negative ^= 1), this
        }
        neg() {
          return this.clone().ineg()
        }
        iabs() {
          return this.negative = 0, this
        }
        abs() {
          return this.clone().iabs()
        }
        cmp(e) {
          if (me(ye.isBN(e), "num", "bignum"), this.negative !== e.negative) return e.negative - this.negative;
          let t = this.ucmp(e);
          return this.negative !== 0 ? -t | 0 : t
        }
        cmpn(e) {
          me(vr(e), "num", "smi");
          let t = e < 0 | 0;
          if (this.negative !== t) return t - this.negative;
          let i = this.ucmpn(e);
          return this.negative !== 0 ? -i | 0 : i
        }
        eq(e) {
          return this.cmp(e) === 0
        }
        eqn(e) {
          return this.cmpn(e) === 0
        }
        gt(e) {
          return this.cmp(e) > 0
        }
        gtn(e) {
          return this.cmpn(e) > 0
        }
        gte(e) {
          return this.cmp(e) >= 0
        }
        gten(e) {
          return this.cmpn(e) >= 0
        }
        lt(e) {
          return this.cmp(e) < 0
        }
        ltn(e) {
          return this.cmpn(e) < 0
        }
        lte(e) {
          return this.cmp(e) <= 0
        }
        lten(e) {
          return this.cmpn(e) <= 0
        }
        sign() {
          return this.negative !== 0 ? -1 : this.length === 1 && this.words[0] === 0 ? 0 : 1
        }
        isZero() {
          return this.length === 1 && this.words[0] === 0
        }
        isNeg() {
          return this.negative !== 0
        }
        isPos() {
          return this.negative === 0
        }
        isOdd() {
          return (this.words[0] & 1) == 1
        }
        isEven() {
          return (this.words[0] & 1) == 0
        }
        ucmp(e) {
          if (me(ye.isBN(e), "num", "bignum"), this.length < e.length) return -1;
          if (this.length > e.length) return 1;
          for (let t = this.length - 1; t >= 0; t--) {
            let i = this.words[t] | 0,
              n = e.words[t] | 0;
            if (i !== n) return (i > n) - (i < n)
          }
          return 0
        }
        ucmpn(e) {
          if (me(vr(e), "num", "smi"), this.length > 1) return 1;
          let t = this.words[0] | 0;
          return e < 0 && (e = -e), (t > e) - (t < e)
        }
        legendre(e) {
          let t = Mh ? ye.red(e) : ye.mont(e);
          return this.toRed(t).redLegendre()
        }
        jacobi(e) {
          if (me(ye.isBN(e), "num", "bignum"), e.isZero() || e.isEven()) throw new Error("jacobi: `num` must be odd.");
          let t = this._cloneNormal(),
            i = e.clone(),
            n = 1;
          for (i.isNeg() && (t.isNeg() && (n = -1), i.ineg()), (t.isNeg() || t.ucmp(i) >= 0) && t.imod(i); !t.isZero();) {
            if (t._makeOdd() & 1) {
              let a = i.andln(7);
              (a === 3 || a === 5) && (n = -n)
            }
            t.ucmp(i) < 0 && ([t, i] = [i, t], t.andln(3) === 3 && i.andln(3) === 3 && (n = -n)), t._isub(t, i).iushrn(1);
            let o = i.andln(7);
            (o === 3 || o === 5) && (n = -n)
          }
          return i.cmpn(1) !== 0 ? 0 : n
        }
        kronecker(e) {
          me(ye.isBN(e), "num", "bignum");
          let t = [0, 1, 0, -1, 0, -1, 0, 1],
            i = this._cloneNormal(),
            n = e.clone(),
            s = 1;
          if (n.isZero()) return i.ucmpn(1) === 0 ? s : 0;
          if (!i.isOdd() && !n.isOdd()) return 0;
          for (n._makeOdd() & 1 && (s = t[i.andln(7)]), n.isNeg() && (i.isNeg() && (s = -s), n.ineg()); !i.isZero();) i._makeOdd() & 1 && (s *= t[n.andln(7)]), (i.words[0] ^ i.negative * 67108863) & n.words[0] & 2 && (s = -s), n.imod(i), [i, n] = [n, i], n.negative = 0;
          return n.cmpn(1) !== 0 ? 0 : s
        }
        igcd(e) {
          return this.gcd(e)._move(this)
        }
        gcd(e) {
          if (me(ye.isBN(e), "num", "bignum"), this.isZero()) return e.abs();
          if (e.isZero()) return this.abs();
          let t = this.clone(),
            i = e.clone();
          t.negative = 0, i.negative = 0;
          let n = t._factor2(i);
          for (n !== 0 && (t.iushrn(n), i.iushrn(n)); ;) {
            t._makeOdd(), i._makeOdd();
            let s = t.ucmp(i);
            if (s < 0) [t, i] = [i, t];
            else if (s === 0 || i.ucmpn(1) === 0) break;
            t._isub(t, i)
          }
          return i.iushln(n)
        }
        ilcm(e) {
          return this.lcm(e)._move(this)
        }
        lcm(e) {
          return me(ye.isBN(e), "num", "bignum"), this.isZero() || e.isZero() ? new ye(0) : this.quo(this.gcd(e)).mul(e).iabs()
        }
        egcd(e) {
          if (me(ye.isBN(e), "num", "bignum"), this.isZero()) return [new ye(0), new ye(e.sign()), e.abs()];
          if (e.isZero()) return [new ye(this.sign()), new ye(0), this.abs()];
          let t = this.clone(),
            i = e.clone();
          t.negative = 0, i.negative = 0;
          let n = new ye(1),
            s = new ye(0),
            o = new ye(0),
            a = new ye(1),
            c = t._factor2(i);
          c > 0 && (t.iushrn(c), i.iushrn(c));
          let u = t.clone(),
            f = i.clone();
          for (; !t.isZero();) {
            let h = t._makeOdd(),
              d = i._makeOdd();
            for (; h--;)(n.isOdd() || s.isOdd()) && (n.iadd(f), s.isub(u)), n.iushrn(1), s.iushrn(1);
            for (; d--;)(o.isOdd() || a.isOdd()) && (o.iadd(f), a.isub(u)), o.iushrn(1), a.iushrn(1);
            t.cmp(i) >= 0 ? (t.isub(i), n.isub(o), s.isub(a)) : (i.isub(t), o.isub(n), a.isub(s))
          }
          return this.negative !== 0 && o.ineg(), e.negative !== 0 && a.ineg(), [o, a, i.iushln(c)]
        }
        iinvert(e) {
          return this.invert(e)._move(this)
        }
        invert(e) {
          if (me(ye.isBN(e), "num", "bignum"), Sc(e.sign() > 0, "invert"), e.isOdd()) return this._invertp(e);
          if (e.cmpn(1) === 0) throw new RangeError("Not invertible.");
          let [t, , i] = this.egcd(e);
          if (i.cmpn(1) !== 0) throw new RangeError("Not invertible.");
          return t.imod(e)
        }
        ifermat(e) {
          return this.fermat(e)._move(this)
        }
        fermat(e) {
          let t = Mh ? ye.red(e) : ye.mont(e);
          return this.toRed(t).redFermat().fromRed()
        }
        ipowm(e, t, i) {
          return this.powm(e, t, i)._move(this)
        }
        powm(e, t, i) {
          let n = !Mh && i ? ye.mont(t) : ye.red(t);
          return this.toRed(n).redPow(e).fromRed()
        }
        ipowmn(e, t, i) {
          return this.powmn(e, t, i)._move(this)
        }
        powmn(e, t, i) {
          let n = i ? ye.mont(t) : ye.red(t);
          return this.toRed(n).redPown(e).fromRed()
        }
        isqrtm(e) {
          return this.sqrtm(e)._move(this)
        }
        sqrtm(e) {
          me(ye.isBN(e), "p", "bignum");
          let t;
          return e.andln(3) === 3 || e.andln(7) === 5 ? t = ye.red(e) : t = ye.mont(e), this.toRed(t).redSqrt().fromRed()
        }
        isqrtpq(e, t) {
          return this.sqrtpq(e, t)._move(this)
        }
        sqrtpq(e, t) {
          let i = this.sqrtm(e),
            n = this.sqrtm(t),
            [s, o] = e.egcd(t),
            a = n.mul(s).mul(e),
            c = i.mul(o).mul(t),
            u = e.mul(t);
          return a.iadd(c).imod(u)
        }
        isPrime(e, t, i) {
          return me(t >>> 0 === t, "reps", "uint32"), !(!this.isPrimeMR(e, t + 1, !0) || !this.isPrimeLucas(i))
        }
        isPrimeMR(e, t, i = !1) {
          me(t >>> 0 === t, "reps", "uint32"), me(t > 0, "reps", "integer"), me(typeof i == "boolean", "force2", "boolean");
          let n = this;
          if (n.cmpn(7) < 0) return n.cmpn(2) === 0 || n.cmpn(3) === 0 || n.cmpn(5) === 0;
          if (n.isEven()) return !1;
          let s = n.subn(1),
            o = s.subn(2),
            a = s.zeroBits(),
            c = s.ushrn(a),
            u = ye.red(n),
            f = s.toRed(u),
            h = new ye(1).toRed(u);
          e: for (let d = 0; d < t; d++) {
            let p;
            d === t - 1 && i ? p = new ye(2) : (p = ye.random(e, 0, o), p.iaddn(2));
            let g = p.toRed(u).redPow(c);
            if (!(g.cmp(h) === 0 || g.cmp(f) === 0)) {
              for (let m = 1; m < a; m++) {
                if (g = g.redSqr(), g.cmp(f) === 0) continue e;
                if (g.cmp(h) === 0) return !1
              }
              return !1
            }
          }
          return !0
        }
        isPrimeLucas(e = 0) {
          me(e >>> 0 === e, "limit", "uint32");
          let t = this;
          if (t.cmpn(1) <= 0) return !1;
          if (t.isEven()) return t.cmpn(2) === 0;
          let i = 3;
          for (; ;) {
            if (i > 1e4) throw new Error(`Cannot find (D/n) = -1 for ${t.toString(10)}.`);
            if (e !== 0 && i > e) return !1;
            let u = new ye(i * i - 4).jacobi(t);
            if (u === -1) break;
            if (u === 0) return t.cmpn(i + 2) === 0;
            if (i === 40 && t.isSquare()) return !1;
            i += 1
          }
          let n = t.addn(1),
            s = n._makeOdd(),
            o = new ye(2),
            a = new ye(i);
          for (let c = n.bitLength(); c >= 0; c--) n.utestn(c) ? (o = o.mul(a).isubn(i).imod(t), a = a.sqr().isubn(2).imod(t)) : (a = a.mul(o).isubn(i).imod(t), o = o.sqr().isubn(2).imod(t));
          if (o.cmpn(2) === 0 || o.cmp(t.subn(2)) === 0) {
            let c = o.muln(i).imod(t),
              u = a.ushln(1).imod(t);
            if (c.cmp(u) === 0) return !0
          }
          for (let c = 0; c < s - 1; c++) {
            if (o.isZero()) return !0;
            if (o.cmpn(2) === 0) return !1;
            o = o.sqr().isubn(2).imod(t)
          }
          return !1
        }
        toTwos(e) {
          return this.negative !== 0 ? this.abs().inotn(e).iaddn(1) : this.clone()
        }
        fromTwos(e) {
          return me(e >>> 0 === e, "width", "uint32"), Sc(e > 0, "width"), this.testn(e - 1) ? this.notn(e).iaddn(1).ineg() : this.clone()
        }
        toRed(e) {
          if (me(e instanceof Bh, "ctx", "reduction context"), this.red) throw new Error("Already in reduction context.");
          return e.convertTo(this)
        }
        fromRed() {
          return dt(this.red, "fromRed"), this.red.convertFrom(this)
        }
        forceRed(e) {
          if (me(e instanceof Bh, "ctx", "reduction context"), this.red) {
            if (!e.m.eq(this.red.m) || e.mont !== this.red.mont) throw new Error("Already in reduction context.")
          } else Sc(this.negative === 0, "red"), Sc(this.ucmp(e.m) < 0, "red");
          return this.clone()._forceRed(e)
        }
        redIAdd(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redIAdd"), this.red.iadd(this, e)
        }
        redAdd(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redAdd"), this.red.add(this, e)
        }
        redIAddn(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redIAddn"), this.red.iaddn(this, e)
        }
        redAddn(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redAddn"), this.red.addn(this, e)
        }
        redISub(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redISub"), this.red.isub(this, e)
        }
        redSub(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redSub"), this.red.sub(this, e)
        }
        redISubn(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redISubn"), this.red.isubn(this, e)
        }
        redSubn(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redSubn"), this.red.subn(this, e)
        }
        redIMul(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redIMul"), this.red.imul(this, e)
        }
        redMul(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redMul"), this.red.mul(this, e)
        }
        redIMuln(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redIMuln"), this.red.imuln(this, e)
        }
        redMuln(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redMuln"), this.red.muln(this, e)
        }
        redIDiv(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redIDiv"), this.red.idiv(this, e)
        }
        redDiv(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redDiv"), this.red.div(this, e)
        }
        redIDivn(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redIDivn"), this.red.idivn(this, e)
        }
        redDivn(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redDivn"), this.red.divn(this, e)
        }
        redIPow(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redIPow"), Dh(!e.red, "redIPow"), this.red.ipow(this, e)
        }
        redPow(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redPow"), Dh(!e.red, "redPow"), this.red.pow(this, e)
        }
        redIPown(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redIPown"), this.red.ipown(this, e)
        }
        redPown(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redPown"), this.red.pown(this, e)
        }
        redISqr() {
          return dt(this.red, "redISqr"), this.red.isqr(this)
        }
        redSqr() {
          return dt(this.red, "redSqr"), this.red.sqr(this)
        }
        redISqrt() {
          return dt(this.red, "redISqrt"), this.red.isqrt(this)
        }
        redSqrt() {
          return dt(this.red, "redSqrt"), this.red.sqrt(this)
        }
        redIDivSqrt(e) {
          return dt(this.red, "redIDivSqrt"), this.red.idivsqrt(this, e)
        }
        redDivSqrt(e) {
          return dt(this.red, "redDivSqrt"), this.red.divsqrt(this, e)
        }
        redIsSquare() {
          return dt(this.red, "redIsSquare"), this.red.isSquare(this)
        }
        redIShl(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redIShl"), Dh(!e.red, "redIShl"), this.red.ishl(this, e)
        }
        redShl(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redShl"), Dh(!e.red, "redShl"), this.red.shl(this, e)
        }
        redIShln(e) {
          return me(e >>> 0 === e, "num", "uint32"), dt(this.red, "redIShln"), this.red.ishln(this, e)
        }
        redShln(e) {
          return me(e >>> 0 === e, "num", "uint32"), dt(this.red, "redShln"), this.red.shln(this, e)
        }
        redINeg() {
          return dt(this.red, "redINeg"), this.red.ineg(this)
        }
        redNeg() {
          return dt(this.red, "redNeg"), this.red.neg(this)
        }
        redEq(e) {
          return me(ye.isBN(e), "num", "bignum"), dt(this.red, "redEq"), this.red.eq(this, e)
        }
        redEqn(e) {
          return me(vr(e), "num", "smi"), dt(this.red, "redEqn"), this.red.eqn(this, e)
        }
        redIsHigh() {
          return dt(this.red, "redIsHigh"), this.red.isHigh(this)
        }
        redIsLow() {
          return dt(this.red, "redIsLow"), this.red.isLow(this)
        }
        redIsOdd() {
          return dt(this.red, "redIsOdd"), this.red.isOdd(this)
        }
        redIsEven() {
          return dt(this.red, "redIsEven"), this.red.isEven(this)
        }
        redLegendre() {
          return dt(this.red, "redLegendre"), this.red.legendre(this)
        }
        redJacobi() {
          return dt(this.red, "redJacobi"), this.red.jacobi(this)
        }
        redKronecker() {
          return dt(this.red, "redKronecker"), this.red.kronecker(this)
        }
        redIInvert() {
          return dt(this.red, "redIInvert"), this.red.iinvert(this)
        }
        redInvert() {
          return dt(this.red, "redInvert"), this.red.invert(this)
        }
        redIFermat() {
          return dt(this.red, "redIFermat"), this.red.ifermat(this)
        }
        redFermat() {
          return dt(this.red, "redFermat"), this.red.fermat(this)
        }
        _move(e) {
          return e.words = this.words, e.length = this.length, e.negative = this.negative, e.red = this.red, e
        }
        _alloc(e) {
          for (; this.words.length < e;) this.words.push(0);
          return this
        }
        _expand(e) {
          for (this._alloc(e); this.length < e;) this.words[this.length++] = 0;
          return this
        }
        _strip() {
          for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length -= 1;
          return this._normalize()
        }
        _normalize() {
          return Zr(this.length > 0), this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        }
        _check() {
          return Zr(this.length > 0), Zr(this.length <= this.words.length), this.length === 1 ? (this.words[0] === 0 && Zr(this.negative === 0), this) : (Zr(this.words[this.length - 1] !== 0), this)
        }
        _invertp(e) {
          if (me(ye.isBN(e), "p", "bignum"), Sc(e.sign() > 0, "invert"), Zr(e.isOdd()), e.cmpn(1) === 0) throw new RangeError("Not invertible.");
          let t = this.clone(),
            i = e.clone(),
            n = new ye(1),
            s = new ye(0);
          for ((t.isNeg() || t.ucmp(i) >= 0) && t.imod(i); !t.isZero();) {
            let o = t._makeOdd(),
              a = i._makeOdd();
            for (; o--;) n.isOdd() && n._iadd(n, e), n.iushrn(1);
            for (; a--;) s.isOdd() && s._iadd(s, e), s.iushrn(1);
            t.ucmp(i) >= 0 ? (t._isub(t, i), n.ucmp(s) < 0 ? (n._isub(s, n), n._isub(e, n)) : n._isub(n, s)) : (i._isub(i, t), s.ucmp(n) < 0 ? (s._isub(n, s), s._isub(e, s)) : s._isub(s, n))
          }
          if (i.cmpn(1) !== 0) throw new RangeError("Not invertible.");
          return Zr(s.negative === 0), Zr(s.ucmp(e) < 0), s
        }
        _makeOdd() {
          let e = this.zeroBits();
          return e > 0 && this.iushrn(e), e
        }
        _factor2(e) {
          if ((this.words[0] | e.words[0]) & 1) return 0;
          let t = Math.min(this.length, e.length),
            i = 0;
          for (let n = 0; n < t; n++) {
            let s = e2e(this.words[n] | e.words[n]);
            if (i += s, s !== 26) break
          }
          return i
        }
        _cloneNormal() {
          return this.red ? this.fromRed() : this.clone()
        }
        _forceRed(e) {
          return this.red = e, this
        }
        clone() {
          let e = new ye;
          e.words = new Array(this.length);
          for (let t = 0; t < this.length; t++) e.words[t] = this.words[t];
          return e.length = this.length, e.negative = this.negative, e.red = this.red, e
        }
        inject(e) {
          me(ye.isBN(e), "num", "bignum"), this._alloc(e.length);
          for (let t = 0; t < e.length; t++) this.words[t] = e.words[t];
          return this.length = e.length, this.negative = e.negative, this.red = e.red, this
        }
        set(e, t) {
          return this.fromNumber(e, t)
        }
        swap(e) {
          me(ye.isBN(e), "num", "bignum");
          let t = this,
            i = e;
          return [t.words, i.words] = [i.words, t.words], [t.length, i.length] = [i.length, t.length], [t.negative, i.negative] = [i.negative, t.negative], [t.red, i.red] = [i.red, t.red], t
        }
        reverse() {
          let e = this.negative;
          return this.fromBuffer(this.toBuffer("be"), "le"), this.negative = e, this
        }
        byteLength() {
          return Math.ceil(this.bitLength() / 8)
        }
        bitLength() {
          let e = this.words[this.length - 1],
            t = Jp(e);
          return (this.length - 1) * 26 + t
        }
        zeroBits() {
          if (this.isZero() || this.isOdd()) return 0;
          let e = 0;
          for (let t = 0; t < this.length; t++) {
            let i = e2e(this.words[t]);
            if (e += i, i !== 26) break
          }
          return e
        }
        isSafe() {
          return this.length <= 2 || this.length === 3 && this.words[2] === 1
        }
        word(e) {
          return me(e >>> 0 === e, "pos", "uint32"), e >= this.length ? 0 : this.words[e]
        } [Kme]() {
          let e = "BN";
          return this.red && (e = "BN-R"), `<${e}: ${this.toString(10)}>`
        }
        toNumber() {
          let e = this.words[0];
          if (this.length === 2) e += this.words[1] * 67108864;
          else if (this.length === 3 && this.words[2] === 1) e += 4503599627370496 + this.words[1] * 67108864;
          else if (this.length > 2) throw new RangeError("Number can only safely store up to 53 bits.");
          return this.negative !== 0 ? -e : e
        }
        toDouble() {
          let e = 0;
          for (let t = this.length - 1; t >= 0; t--) e = e * 67108864 + this.words[t];
          return this.negative !== 0 ? -e : e
        }
        valueOf() {
          return this.toDouble()
        }
        toBigInt() {
          if (!Mh) throw new Error("BigInt is not supported!");
          let e = BigInt(52),
            t = BigInt(26),
            i = this.length - 1,
            n = BigInt(0);
          for (; i >= 1; i -= 2) {
            let s = this.words[i] * 67108864,
              o = this.words[i - 1];
            n = n << e | BigInt(s + o)
          }
          return i >= 0 && (n = n << t | BigInt(this.words[0])), this.negative !== 0 ? -n : n
        }
        toBool() {
          return !this.isZero()
        }
        toString(e, t) {
          if (e = Qme(e), t == null && (t = 0), t === 0 && (t = 1), me(e >>> 0 === e, "base", "uint32"), me(t >>> 0 === t, "padding", "uint32"), e < 2 || e > 36) throw new RangeError("Base ranges between 2 and 36.");
          if (this._check(), e === 16) {
            let a = "",
              c = 0,
              u = 0;
            for (let f = 0; f < this.length; f++) {
              let h = this.words[f],
                d = ((h << c | u) & 16777215).toString(16);
              u = h >>> 24 - c & 16777215, u !== 0 || f !== this.length - 1 ? a = zme[6 - d.length] + d + a : a = d + a, c += 2, c >= 26 && (c -= 26, f -= 1)
            }
            for (u !== 0 && (a = u.toString(16) + a); a.length % t != 0;) a = "0" + a;
            return this.negative !== 0 && (a = "-" + a), a
          }
          let i = flt[e - 1],
            n = llt[e - 1],
            s = this.clone(),
            o = "";
          for (s.negative = 0; !s.isZero();) {
            let a = s.remrn(n).toString(e);
            s.iquon(n), s.isZero() ? o = a + o : o = zme[i - a.length] + a + o
          }
          for (this.isZero() && (o = "0"); o.length % t != 0;) o = "0" + o;
          return this.negative !== 0 && (o = "-" + o), o
        }
        toJSON() {
          return this.toString(16, 2)
        }
        toArray(e, t) {
          return this.toArrayLike(Array, e, t)
        }
        toBuffer(e, t) {
          return this.toArrayLike(Buffer, e, t)
        }
        toArrayLike(e, t, i) {
          t == null && (t = "be"), i == null && (i = 0), me(typeof e == "function", "ArrayType", "function"), me(t === "be" || t === "le", "endian", "endianness"), me(i >>> 0 === i, "length", "uint32"), this._check();
          let n = this.byteLength(),
            s = i || Math.max(1, n);
          if (n > s) throw new RangeError("Byte array longer than desired length.");
          let o = hlt(e, s);
          if (t === "be") {
            let a = o.length - 1,
              c = 0;
            for (let u = 0; u < this.length; u++) {
              let f = (u & 3) << 1,
                h = this.words[u] << f | c;
              o[a--] = h & 255, a >= 0 && (o[a--] = h >>> 8 & 255), a >= 0 && (o[a--] = h >>> 16 & 255), f === 6 ? (a >= 0 && (o[a--] = h >>> 24 & 255), c = 0) : c = h >>> 24
            }
            if (a >= 0) {
              for (o[a--] = c; a >= 0;) o[a--] = 0;
              c = 0
            }
            Zr(c === 0)
          } else {
            let a = 0,
              c = 0;
            for (let u = 0; u < this.length; u++) {
              let f = (u & 3) << 1,
                h = this.words[u] << f | c;
              o[a++] = h & 255, a < o.length && (o[a++] = h >>> 8 & 255), a < o.length && (o[a++] = h >>> 16 & 255), f === 6 ? (a < o.length && (o[a++] = h >>> 24 & 255), c = 0) : c = h >>> 24
            }
            if (a < o.length) {
              for (o[a++] = c; a < o.length;) o[a++] = 0;
              c = 0
            }
            Zr(c === 0)
          }
          return o
        }
        encode(e, t) {
          return this.toBuffer(e, t)
        } of(e, t) {
          return this.fromNumber(e, t)
        }
        fromNumber(e, t) {
          t == null && (t = "be"), me(Zme(e), "num", "integer"), me(t === "be" || t === "le", "endian", "endianness");
          let i = e < 0 | 0;
          return i && (e = -e), e < 67108864 ? (this.words[0] = e & 67108863, this.length = 1) : e < 4503599627370496 ? (this.words = [e & 67108863, e / 67108864 & 67108863], this.length = 2) : (this.words = [e & 67108863, e / 67108864 & 67108863, 1], this.length = 3), this.negative = i, t === "le" && this.reverse(), this
        }
        fromDouble(e, t) {
          t == null && (t = "be"), me(typeof e == "number", "num", "double"), me(t === "be" || t === "le", "endian", "endianness"), isFinite(e) || (e = 0);
          let i = e <= -1 | 0;
          for (e < 0 && (e = -e), e = Math.floor(e), this.words = []; e > 0;) {
            let n = e % 67108864,
              s = (e - n) / 67108864;
            this.words.push(n), e = s
          }
          return this.words.length === 0 && this.words.push(0), this.length = this.words.length, this.negative = i, t === "le" && this.reverse(), this
        }
        fromBigInt(e, t) {
          if (t == null && (t = "be"), me(typeof e == "bigint", "num", "bigint"), me(t === "be" || t === "le", "endian", "endianness"), !Mh) throw new Error("BigInt is not supported!");
          let i = e < BigInt(0) | 0;
          return this._fromHex(e.toString(16), i), this.negative = i, t === "le" && this.reverse(), this
        }
        fromBool(e) {
          return me(typeof e == "boolean", "value", "boolean"), this.words[0] = e | 0, this.length = 1, this.negative = 0, this
        }
        fromString(e, t, i) {
          if ((t === "le" || t === "be") && ([t, i] = [i, t]), t = Qme(t), i == null && (i = "be"), me(typeof e == "string", "string", "string"), me(t >>> 0 === t, "base", "uint32"), me(i === "be" || i === "le", "endian", "endianness"), t < 2 || t > 36) throw new Error("Base ranges between 2 and 36.");
          e = e.replace(/\s+/g, "");
          let n = 0;
          return e.length > 0 && e.charCodeAt(0) === 45 && (n = 1), t === 16 ? this._fromHex(e, n) : this._fromBase(e, t, n), this.negative = n, this._normalize(), i === "le" && this.reverse(), this
        }
        _fromHex(e, t) {
          this.length = Math.max(2, Math.ceil((e.length - t) / 6)), this.words = new Array(this.length);
          for (let o = 0; o < this.length; o++) this.words[o] = 0;
          let i = 0,
            n = e.length - 6,
            s = 0;
          for (; n >= t; n -= 6) {
            let o = t2e(e, n, n + 6);
            this.words[s] |= o << i & 67108863, this.words[s + 1] |= o >>> 26 - i & 4194303, i += 24, i >= 26 && (i -= 26, s += 1)
          }
          if (n + 6 !== t) {
            let o = t2e(e, t, n + 6);
            this.words[s] |= o << i & 67108863, this.words[s + 1] |= o >>> 26 - i & 4194303
          }
          return this._strip()
        }
        _fromBase(e, t, i) {
          this.words[0] = 0, this.length = 1, this.negative = 0;
          let n = 0,
            s = 1;
          for (; s <= 67108863; s *= t) n += 1;
          n -= 1, s = s / t | 0;
          let o = e.length - i,
            a = o % n,
            c = Math.min(o, o - a) + i,
            u = i;
          for (; u < c; u += n) {
            let f = r2e(e, u, u + n, t);
            this.imuln(s), this._iaddn(f)
          }
          if (a !== 0) {
            let f = Math.pow(t, a),
              h = r2e(e, u, e.length, t);
            this.imuln(f), this._iaddn(h)
          }
          return this
        }
        fromJSON(e) {
          if (ye.isBN(e)) return e.red ? e.fromRed() : e.clone();
          if (Array.isArray(e)) {
            for (let t of e) me(typeof t == "string", "chunk", "string");
            e = e.join("")
          }
          return this.fromString(e, 16)
        }
        fromBN(e) {
          return this.inject(e)
        }
        fromArray(e, t) {
          return me(Array.isArray(e), "data", "array"), this.fromArrayLike(e, t)
        }
        fromBuffer(e, t) {
          return me(Buffer.isBuffer(e), "data", "buffer"), this.fromArrayLike(e, t)
        }
        fromArrayLike(e, t) {
          if (t == null && (t = "be"), me(e && e.length >>> 0 === e.length, "data", "array-like"), me(t === "be" || t === "le", "endian", "endianness"), e.length === 0) return this.words[0] = 0, this.length = 1, this.negative = 0, this;
          this.length = Math.max(2, Math.ceil(e.length / 3)), this.words = new Array(this.length), this.negative = 0;
          for (let a = 0; a < this.length; a++) this.words[a] = 0;
          let i = e.length % 3,
            n = 0,
            s = 0,
            o = 0;
          if (t === "be") {
            for (let a = e.length - 1; a >= 2; a -= 3) {
              let c = e[a] | e[a - 1] << 8 | e[a - 2] << 16;
              this.words[s] |= c << n & 67108863, this.words[s + 1] = c >>> 26 - n & 67108863, n += 24, n >= 26 && (n -= 26, s += 1)
            }
            switch (i) {
              case 2:
                o = e[1] | e[0] << 8;
                break;
              case 1:
                o = e[0];
                break
            }
          } else {
            let a = e.length - i;
            for (let c = 0; c < a; c += 3) {
              let u = e[c] | e[c + 1] << 8 | e[c + 2] << 16;
              this.words[s] |= u << n & 67108863, this.words[s + 1] = u >>> 26 - n & 67108863, n += 24, n >= 26 && (n -= 26, s += 1)
            }
            switch (i) {
              case 2:
                o = e[a] | e[a + 1] << 8;
                break;
              case 1:
                o = e[a];
                break
            }
          }
          return i > 0 && (this.words[s] |= o << n & 67108863, this.words[s + 1] = o >>> 26 - n & 67108863), this._strip()
        }
        decode(e, t) {
          return this.fromBuffer(e, t)
        }
        from(e, t, i) {
          if (e == null) return this;
          if ((t === "le" || t === "be") && ([t, i] = [i, t]), typeof e == "number") return this.fromNumber(e, i);
          if (typeof e == "bigint") return this.fromBigInt(e, i);
          if (typeof e == "string") return this.fromString(e, t, i);
          if (typeof e == "object") {
            if (ye.isBN(e)) return this.fromBN(e, i);
            if (e.length >>> 0 === e.length) return this.fromArrayLike(e, i)
          }
          if (typeof e == "boolean") return this.fromBool(e);
          throw new TypeError("Non-numeric object passed to BN.")
        }
        static min(...e) {
          let t = null;
          for (let i of e) me(ye.isBN(i), "num", "bignum"), (!t || i.cmp(t) < 0) && (t = i);
          return t || new ye(0)
        }
        static max(...e) {
          let t = null;
          for (let i of e) me(ye.isBN(i), "num", "bignum"), (!t || i.cmp(t) > 0) && (t = i);
          return t || new ye(0)
        }
        static cmp(e, t) {
          return me(ye.isBN(e), "a", "bignum"), e.cmp(t)
        }
        static ucmp(e, t) {
          return me(ye.isBN(e), "a", "bignum"), e.ucmp(t)
        }
        static red(e) {
          return new Bh(e)
        }
        static barrett(e) {
          return new Jme(e)
        }
        static mont(e) {
          return new Xme(e)
        }
        static _prime(e) {
          if (lk[e]) return lk[e];
          let t;
          if (e === "p192") t = new jme;
          else if (e === "p224") t = new Vme;
          else if (e === "p521") t = new Hme;
          else if (e === "k256") t = new Gme;
          else if (e === "p251") t = new $me;
          else if (e === "p25519") t = new Wme;
          else if (e === "p448") t = new Yme;
          else throw new Error(`Unknown prime: "${e}".`);
          return lk[e] = t, t
        }
        static prime(e) {
          return ye._prime(e).p.clone()
        }
        static pow(e, t) {
          return e === 2 ? ye.shift(1, t) : new ye().fromNumber(e).pown(t)
        }
        static shift(e, t) {
          return e === 1 ? new ye(0).usetn(t, 1) : new ye().fromNumber(e).ishln(t)
        }
        static mask(e) {
          return ye.shift(1, e).isubn(1)
        }
        static randomBits(e, t) {
          if (me(e != null, "rng", "rng"), me(t >>> 0 === t, "bits", "uint32"), typeof e == "object") {
            me(typeof e.randomBytes == "function", "rng", "rng");
            let n = t + 7 >>> 3,
              s = n * 8,
              o = e.randomBytes(n);
            if (me(Buffer.isBuffer(o), "bytes", "buffer"), o.length !== n) throw new RangeError("Invalid number of bytes returned from RNG.");
            let a = ye.fromBuffer(o);
            return s > t && a.iushrn(s - t), a
          }
          me(typeof e == "function", "rng", "rng");
          let i = e(t);
          if (me(ye.isBN(i), "num", "bignum"), Sc(i.negative === 0, "RNG"), Dh(!i.red, "RNG"), i.bitLength() > t) throw new RangeError("Invalid number of bits returned from RNG.");
          return i
        }
        static random(e, t, i) {
          if (t = ye.cast(t, 16), i = ye.cast(i, 16), t.cmp(i) > 0) throw new RangeError("Minimum cannot be greater than maximum.");
          let n = i.sub(t).iabs(),
            s = n.bitLength();
          if (s === 0) return t.clone();
          for (; ;) {
            let o = ye.randomBits(e, s);
            if (!(o.cmp(n) >= 0)) return o.iadd(t), o
          }
        }
        static of(e, t) {
          return new ye().of(e, t)
        }
        static fromNumber(e, t) {
          return new ye().fromNumber(e, t)
        }
        static fromDouble(e, t) {
          return new ye().fromDouble(e, t)
        }
        static fromBigInt(e, t) {
          return new ye().fromBigInt(e, t)
        }
        static fromBool(e) {
          return new ye().fromBool(e)
        }
        static fromString(e, t, i) {
          return new ye().fromString(e, t, i)
        }
        static fromJSON(e) {
          return new ye().fromJSON(e)
        }
        static fromBN(e) {
          return new ye().fromBN(e)
        }
        static fromArray(e, t) {
          return new ye().fromArray(e, t)
        }
        static fromBuffer(e, t) {
          return new ye().fromBuffer(e, t)
        }
        static fromArrayLike(e, t) {
          return new ye().fromArrayLike(e, t)
        }
        static decode(e, t) {
          return new ye().decode(e, t)
        }
        static from(e, t, i) {
          return new ye().from(e, t, i)
        }
        static cast(e, t, i) {
          return ye.isBN(e) ? e : new ye(e, t, i)
        }
        static isBN(e) {
          return e instanceof ye
        }
      };
      ye.BN = ye;
      ye.wordSize = 26;
      ye.native = 0;
      var Q6 = class {
        constructor(e, t) {
          this.name = e, this.p = new ye(t, 16), this.n = this.p.bitLength(), this.k = ye.shift(1, this.n).isub(this.p), this.lo = this.p.clone(), this.one = this.p.clone()
        }
        ireduce(e) {
          let t = e.negative !== 0,
            i = e.bitLength();
          for (Zr(i <= this.n * 2), e.negative = 0; i > this.n;) this.split(e, this.lo), this.imulK(e), e._iadd(e, this.lo), i = e.bitLength();
          let n = i < this.n ? -1 : e.ucmp(this.p);
          return n === 0 ? (e.words[0] = 0, e.length = 1) : n > 0 && e._isub(e, this.p), t && !e.isZero() && e._isub(this.p, e), e
        }
        split(e, t) {
          e._split(this.n, t)
        }
        imulK(e) {
          return e.imul(this.k)
        }
        pm2(e) {
          throw new Error("Not implemented.")
        }
        fermat(e) {
          return this.pm2(e)
        }
      },
        Xp = class extends Q6 {
          constructor(e, t) {
            super(e, t)
          }
          pm3d4(e) {
            throw new Error("Not implemented.")
          }
          pp1d4(e) {
            throw new Error("Not implemented.")
          }
          sqrt(e) {
            let {
              red: t
            } = e, i = this.pp1d4(e);
            if (!t.sqr(i).eq(e)) throw new Bi(i);
            return i
          }
          divsqrt(e, t) {
            let {
              red: i
            } = e, n = i.sqr(e), s = i.mul(n, e), o = i.mul(s, n), a = i.mul(i.sqr(t), t), c = this.pm3d4(i.mul(o, a)), u = i.mul(i.mul(s, t), c);
            if (i.mul(t, i.sqr(u)).eq(e)) return u;
            throw new Bi(u)
          }
        },
        o2e = class extends Q6 {
          constructor(e, t, i) {
            super(e, t);
            this.sm1 = new ye(i, 16)
          }
          pm5d8(e) {
            throw new Error("Not implemented.")
          }
          pp3d8(e) {
            throw new Error("Not implemented.")
          }
          sqrt(e) {
            let {
              red: t
            } = e, i = this.sm1._forceRed(t), n = this.pp3d8(e);
            if (t.sqr(n).eq(e)) return n;
            let s = t.mul(n, i);
            if (t.sqr(s).eq(e)) return s;
            throw new Bi(n)
          }
          divsqrt(e, t) {
            let {
              red: i
            } = e, n = this.sm1._forceRed(i), s = i.mul(i.sqr(t), t), o = i.mul(i.sqr(s), t), a = this.pm5d8(i.mul(e, o)), c = i.mul(i.mul(e, s), a), u = i.mul(t, i.sqr(c));
            if (u.eq(e)) return c;
            let f = i.ineg(u);
            if (f.eq(e)) return i.mul(c, n);
            throw f.eq(i.mul(e, n)) ? new Bi(i.mul(c, n)) : new Bi(c)
          }
        },
        a2e = class extends Q6 {
          constructor(e, t, i) {
            super(e, t);
            this.g = new ye(i, 16), this.z = this.p.subn(1).zeroBits()
          }
          powS(e) {
            throw new Error("Not implemented.")
          }
          powE(e) {
            throw new Error("Not implemented.")
          }
          sqrt(e) {
            let {
              red: t
            } = e;
            switch (t.jacobi(e)) {
              case -1:
                throw new Bi(e);
              case 0:
                return e.clone();
              case 1:
                break
            }
            let i = this.g._forceRed(t),
              n = this.powE(e),
              s = this.powS(e),
              o = this.z;
            for (; ;) {
              let a = s,
                c = 0;
              for (; a.cmpn(1) !== 0 && c < o;) a = t.sqr(a), c += 1;
              if (c === 0) break;
              Zr(c < o), a = t.sqrn(i, o - c - 1), i = t.sqr(a), n = t.mul(n, a), s = t.mul(s, i), o = c
            }
            return n
          }
          divsqrt(e, t) {
            let {
              red: i
            } = e;
            if (t.isZero()) throw new Bi(t);
            return this.sqrt(i.div(e, t))
          }
        },
        jme = class extends Xp {
          constructor() {
            super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff")
          }
          imulK(e) {
            let t = this.one.inject(e);
            return e.iushln(64)._iadd(e, t)
          }
          core(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = t.sqrnmul(i, 1, e), s = t.sqrnmul(n, 3, n), o = t.sqrnmul(s, 6, s), a = t.sqrnmul(o, 12, o), c = t.sqrnmul(a, 6, s), u = t.sqrnmul(c, 1, e), f = t.sqrnmul(u, 31, u), h = t.sqrnmul(f, 62, f), d = t.sqrnmul(h, 3, n), p = t.sqrn(d, 1);
            return t.sqrnmul(p, 62, f)
          }
          pm3d4(e) {
            return this.core(e)
          }
          pm2(e) {
            let {
              red: t
            } = e, i = this.core(e), n = t.sqrn(i, 1);
            return t.sqrnmul(n, 1, e)
          }
          pp1d4(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = t.sqrnmul(i, 2, i), s = t.sqrnmul(n, 4, n), o = t.sqrnmul(s, 8, s), a = t.sqrnmul(o, 16, o), c = t.sqrnmul(a, 32, a), u = t.sqrnmul(c, 64, c);
            return t.sqrn(u, 62)
          }
        },
        Vme = class extends a2e {
          constructor() {
            super("p224", "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001", "6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74")
          }
          imulK(e) {
            let t = this.one.inject(e);
            return e.iushln(96)._isub(e, t)
          }
          powS(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = t.sqrnmul(i, 2, i), s = t.sqrnmul(n, 4, n), o = t.sqrnmul(s, 8, s), a = t.sqrnmul(o, 16, o), c = t.sqrnmul(a, 32, a);
            return t.sqrnmul(c, 64, c)
          }
          powE(e) {
            let {
              red: t
            } = e;
            return t.sqrn(e, 127)
          }
          pm2(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = t.sqrnmul(i, 1, e), s = t.sqrnmul(n, 3, n), o = t.sqrnmul(s, 6, s), a = t.sqrnmul(o, 12, o), c = t.sqrnmul(a, 24, a), u = t.sqrnmul(c, 48, c), f = t.sqrnmul(u, 24, a), h = t.sqrnmul(f, 6, s), d = t.sqrnmul(h, 1, e), p = t.sqrn(d, 1);
            return t.sqrnmul(p, 96, u)
          }
        },
        Hme = class extends Xp {
          constructor() {
            super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff")
          }
          imulK(e) {
            return e
          }
          core(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = t.sqrnmul(i, 1, e), s = t.sqrnmul(n, 3, n), o = t.sqrnmul(s, 1, e), a = t.sqrnmul(o, 1, e), c = t.sqrnmul(a, 8, a), u = t.sqrnmul(c, 16, c), f = t.sqrnmul(u, 32, u), h = t.sqrnmul(f, 64, f), d = t.sqrnmul(h, 128, h), p = t.sqrnmul(d, 256, d);
            return t.sqrnmul(p, 7, o)
          }
          pm3d4(e) {
            return this.core(e)
          }
          pm2(e) {
            let {
              red: t
            } = e, i = this.core(e), n = t.sqrn(i, 1);
            return t.sqrnmul(n, 1, e)
          }
          pp1d4(e) {
            let {
              red: t
            } = e;
            return t.sqrn(e, 519)
          }
        },
        Gme = class extends Xp {
          constructor() {
            super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f")
          }
          split(e, t) {
            let i = 4194303,
              n = Math.min(e.length, 9);
            t._alloc(n + 1);
            for (let a = 0; a < n; a++) t.words[a] = e.words[a];
            if (t.length = n, e.length <= 9) {
              t._strip(), e.words[0] = 0, e.length = 1;
              return
            }
            let s = e.words[9],
              o = 10;
            for (t.words[t.length++] = s & i, t._strip(); o < e.length; o++) {
              let a = e.words[o] | 0;
              e.words[o - 10] = (a & i) << 4 | s >>> 22, s = a
            }
            s >>>= 22, e.words[o - 10] = s, s === 0 && e.length > 10 ? e.length -= 10 : e.length -= 9, e._strip()
          }
          imulK(e) {
            e._expand(e.length + 2);
            let t = 0;
            for (let i = 0; i < e.length; i++) {
              let n = e.words[i];
              t += n * 977, e.words[i] = t & 67108863, t = n * 64 + Math.floor(t / 67108864)
            }
            return e.words[e.length - 1] === 0 && (e.length -= 1, e.words[e.length - 1] === 0 && (e.length -= 1)), e
          }
          core(e, t) {
            let {
              red: i
            } = e, n = i.sqrnmul(t, 1, e), s = i.sqrnmul(n, 3, n), o = i.sqrnmul(s, 3, n), a = i.sqrnmul(o, 2, t), c = i.sqrnmul(a, 11, a), u = i.sqrnmul(c, 22, c), f = i.sqrnmul(u, 44, u), h = i.sqrnmul(f, 88, f), d = i.sqrnmul(h, 44, u), p = i.sqrnmul(d, 3, n), g = i.sqrn(p, 1), m = i.sqrnmul(g, 22, c);
            return i.sqrn(m, 4)
          }
          pm3d4(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = this.core(e, i), s = t.sqrnmul(n, 1, e), o = t.sqrn(s, 1);
            return t.sqrnmul(o, 2, i)
          }
          pm2(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = this.core(e, i), s = t.sqrnmul(n, 1, e), o = t.sqrn(s, 1), a = t.sqrnmul(o, 2, i), c = t.sqrn(a, 1);
            return t.sqrnmul(c, 1, e)
          }
          pp1d4(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = this.core(e, i), s = t.sqrnmul(n, 2, i);
            return t.sqrn(s, 2)
          }
        },
        $me = class extends Xp {
          constructor() {
            super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7")
          }
          imulK(e) {
            if (e.isZero()) return e;
            let t = 0;
            for (let i = 0; i < e.length; i++) {
              let n = e.words[i] * 9 + t;
              t = n >>> 26, e.words[i] = n & 67108863
            }
            return t !== 0 && (e._alloc(e.length + 1), e.words[e.length++] = t), e
          }
          core(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = t.sqrnmul(i, 1, e), s = t.sqrnmul(n, 3, n), o = t.sqrnmul(s, 6, s), a = t.sqrnmul(o, 12, o), c = t.sqrnmul(a, 24, a), u = t.sqrnmul(c, 48, c), f = t.sqrnmul(u, 96, u), h = t.sqrnmul(f, 48, c), d = t.sqrnmul(h, 6, s);
            return t.sqrnmul(d, 1, e)
          }
          pm3d4(e) {
            let {
              red: t
            } = e, i = this.core(e), n = t.sqrn(i, 1);
            return t.sqrnmul(n, 1, e)
          }
          pm2(e) {
            let {
              red: t
            } = e, i = this.core(e), n = t.sqrn(i, 1), s = t.sqrnmul(n, 1, e), o = t.sqrn(s, 1);
            return t.sqrnmul(o, 1, e)
          }
          pp1d4(e) {
            let {
              red: t
            } = e, i = this.core(e), n = t.sqrnmul(i, 1, e);
            return t.sqrn(n, 1)
          }
        },
        Wme = class extends o2e {
          constructor() {
            super("p25519", "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed", "2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0")
          }
          imulK(e) {
            let t = 0;
            for (let i = 0; i < e.length; i++) {
              let n = e.words[i] * 19 + t;
              t = n >>> 26, e.words[i] = n & 67108863
            }
            return t !== 0 && (e._alloc(e.length + 1), e.words[e.length++] = t), e
          }
          core(e, t) {
            let {
              red: i
            } = e, n = i.sqrnmul(t, 2, t), s = i.sqrnmul(n, 1, e), o = i.sqrnmul(s, 5, s), a = i.sqrnmul(o, 10, o), c = i.sqrnmul(a, 20, a), u = i.sqrnmul(c, 10, o), f = i.sqrnmul(u, 50, u), h = i.sqrnmul(f, 100, f);
            return i.sqrnmul(h, 50, u)
          }
          pm5d8(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = this.core(e, i), s = t.sqrn(n, 1);
            return t.sqrnmul(s, 1, e)
          }
          pm2(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = this.core(e, i), s = t.sqrn(n, 1), o = t.sqrnmul(s, 1, e), a = t.sqrn(o, 1);
            return t.sqrnmul(a, 2, i)
          }
          pp3d8(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = this.core(e, i), s = t.sqrnmul(n, 1, e);
            return t.sqrn(s, 1)
          }
        },
        Yme = class extends Xp {
          constructor() {
            super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff")
          }
          imulK(e) {
            let t = this.one.inject(e);
            return e.iushln(224)._iadd(e, t)
          }
          core(e, t) {
            let {
              red: i
            } = e, n = i.sqrnmul(t, 1, e), s = i.sqrnmul(n, 3, n), o = i.sqrnmul(s, 3, n), a = i.sqrnmul(o, 2, t), c = i.sqrnmul(a, 11, a), u = i.sqrnmul(c, 22, c), f = i.sqrnmul(u, 44, u), h = i.sqrnmul(f, 88, f), d = i.sqrnmul(h, 44, u);
            return i.sqrnmul(d, 2, t)
          }
          pm3d4(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = this.core(e, i), s = t.sqrnmul(n, 1, e), o = t.sqrn(s, 1);
            return t.sqrnmul(o, 222, n)
          }
          pm2(e) {
            let {
              red: t
            } = e, i = this.pm3d4(e), n = t.sqrn(i, 1);
            return t.sqrnmul(n, 1, e)
          }
          pp1d4(e) {
            let {
              red: t
            } = e, i = t.sqrnmul(e, 1, e), n = this.core(e, i), s = t.sqrnmul(n, 2, i);
            return t.sqrn(s, 222)
          }
        },
        Bh = class {
          constructor(e) {
            let t = null;
            typeof e == "string" && (t = ye._prime(e), e = t.p), me(ye.isBN(e), "m", "bignum"), Dh(!e.red, "reduction"), Sc(e.sign() > 0, "reduction"), this.m = e, this.prime = t, this.mb = null, this.sm1 = null
          }
          _verify1(e) {
            Sc(e.negative === 0, "red"), dt(e.red != null, "red")
          }
          _verify2(e, t) {
            Sc((e.negative | t.negative) == 0, "red"), dt(e.red != null && e.red === t.red, "red")
          }
          get mont() {
            return !1
          }
          precompute() {
            if (this.sm1 === null && this.m.andln(7) === 5)
              if (this.prime) this.sm1 = this.prime.sm1.clone()._forceRed(this);
              else {
                let e = new ye(2).toRed(this),
                  t = this.m.subn(1).iushrn(2);
                this.sm1 = this.pow(e, t)
              } return this
          }
          convertTo(e) {
            let t = e.mod(this.m);
            return t.red = this, t
          }
          convertFrom(e) {
            let t = e.clone();
            return t.red = null, t
          }
          intTo(e) {
            return e
          }
          intFrom(e) {
            return e
          }
          imod(e) {
            return this.prime ? this.prime.ireduce(e)._forceRed(this) : e.imod(this.m)._forceRed(this)
          }
          iadd(e, t) {
            return this._verify2(e, t), e._iadd(e, t), e.ucmp(this.m) >= 0 && e._isub(e, this.m), e
          }
          add(e, t) {
            return e.length < t.length ? this.iadd(t.clone(), e) : this.iadd(e.clone(), t)
          }
          iaddn(e, t) {
            return this._verify1(e), t < 0 ? this.isubn(e, -t) : (this.m.length === 1 && (t %= this.m.words[0]), e._iaddn(t), e.ucmp(this.m) >= 0 && e._isub(e, this.m), e)
          }
          addn(e, t) {
            return this.iaddn(e.clone(), t)
          }
          isub(e, t) {
            this._verify2(e, t);
            let i = e.ucmp(t);
            return i === 0 ? (e.words[0] = 0, e.length = 1, e) : (i < 0 ? (e._isub(t, e), e._isub(this.m, e)) : e._isub(e, t), e)
          }
          sub(e, t) {
            return this.isub(e.clone(), t)
          }
          isubn(e, t) {
            return this._verify1(e), t < 0 ? this.iaddn(e, -t) : (this.m.length === 1 && (t %= this.m.words[0]), e.length === 1 && e.words[0] < t ? (e.words[0] = t - e.words[0], e._isub(this.m, e)) : e._isubn(t), e)
          }
          subn(e, t) {
            return this.isubn(e.clone(), t)
          }
          imul(e, t) {
            return this._verify2(e, t), this.imod(e.imul(t))
          }
          mul(e, t) {
            return this._verify2(e, t), this.imod(e.mul(t))
          }
          imuln(e, t) {
            if (this._verify1(e), e.isZero()) return e;
            if (t === 0) return e.words[0] = 0, e.length = 1, e;
            let i = t < 0;
            if (i && (t = -t), this.m.length === 1 && (t %= this.m.words[0]), e.imuln(t), t <= 16)
              for (; e.ucmp(this.m) >= 0;) e._isub(e, this.m);
            else this.imod(e);
            return i && this.ineg(e), e
          }
          muln(e, t) {
            return this.imuln(e.clone(), t)
          }
          idiv(e, t) {
            return this.div(e, t)._move(e)
          }
          div(e, t) {
            return this.mul(e, this.invert(t))
          }
          idivn(e, t) {
            return this.divn(e, t)._move(e)
          }
          divn(e, t) {
            return this.div(e, this.convertTo(new ye(t)))
          }
          ipow(e, t) {
            return this.pow(e, t)._move(e)
          }
          pow(e, t) {
            return this._verify1(e), t.isNeg() && (e = this.invert(e)), t.length === 1 ? this.pown(e, t.words[0]) : Mh && !this.prime ? this.powInt(e, t) : this.powNum(e, t)
          }
          powNum(e, t) {
            let i = new ye(1).toRed(this),
              n = new Array(Yp),
              s = this.sqr(e);
            n[0] = e;
            for (let c = 1; c < Yp; c++) n[c] = this.mul(n[c - 1], s);
            let o = t.bitLength(),
              a = i;
            for (; o >= Hb;) {
              let c = Hb,
                u = t.bits(o - c, c);
              if (u < Yp) {
                a = this.sqr(a), o -= 1;
                continue
              }
              for (;
                (u & 1) == 0;) c -= 1, u >>= 1;
              a === i ? a = n[u >> 1].clone() : (a = this.sqrn(a, c), a = this.mul(a, n[u >> 1])), o -= c
            }
            if (o > 0) {
              let c = t.bits(0, o);
              for (; o--;) a = this.sqr(a), c >> o & 1 && (a = this.mul(a, e))
            }
            return a
          }
          powInt(e, t) {
            this.mb === null && (this.mb = this.m.toBigInt());
            let i = this.intFrom(e.toBigInt()),
              n = plt(i, t, this.mb),
              s = this.intTo(n);
            return ye.fromBigInt(s)._forceRed(this)
          }
          sqrn(e, t) {
            for (; t--;) e = this.sqr(e);
            return e
          }
          sqrnmul(e, t, i) {
            return this.mul(this.sqrn(e, t), i)
          }
          ipown(e, t) {
            return this.pown(e, t)._move(e)
          }
          pown(e, t) {
            if (this._verify1(e), t < 0 && (e = this.invert(e), t = -t), t === 0) return new ye(1).toRed(this);
            if (t === 1) return e.clone();
            let i = Jp(t),
              n = e;
            for (let s = i - 2; s >= 0; s--) n = this.sqr(n), t >> s & 1 && (n = this.mul(n, e));
            return n
          }
          isqr(e) {
            return this.imul(e, e)
          }
          sqr(e) {
            return this.mul(e, e)
          }
          isqrt(e) {
            return this.sqrt(e)._move(e)
          }
          sqrt(e) {
            return this._verify1(e), this.prime ? this.prime.sqrt(e) : this.m.andln(3) === 3 ? this.sqrt3mod4(e) : this.m.andln(7) === 5 ? this.sm1 != null ? this.sqrt5mod8sm1(e) : this.sqrt5mod8(e) : this.sqrt0(e)
          }
          sqrt3mod4(e) {
            let t = this.m.addn(1).iushrn(2),
              i = this.pow(e, t);
            if (!this.sqr(i).eq(e)) throw new Bi(i);
            return i
          }
          sqrt5mod8(e) {
            let t = new ye(1).toRed(this),
              i = this.m.ushrn(3),
              n = this.add(e, e),
              s = this.pow(n, i),
              o = this.mul(n, this.sqr(s)),
              a = this.mul(this.mul(s, e), this.isub(o, t));
            if (!this.sqr(a).eq(e)) throw new Bi(a);
            return a
          }
          sqrt5mod8sm1(e) {
            let t = this.m.addn(3).iushrn(3),
              i = this.pow(e, t);
            if (this.sqr(i).eq(e)) return i;
            let n = this.mul(i, this.sm1);
            if (this.sqr(n).eq(e)) return n;
            throw new Bi(i)
          }
          sqrt0(e) {
            if (this.m.cmpn(1) === 0 || !this.m.isOdd()) throw new Error("Invalid prime.");
            switch (this.jacobi(e)) {
              case -1:
                throw new Bi(e);
              case 0:
                return e.clone();
              case 1:
                break
            }
            let t = new ye(1).toRed(this),
              i = this.m.subn(1),
              n = i._makeOdd(),
              s = new ye(2).toRed(this);
            for (; this.jacobi(s) !== -1;) this.iadd(s, t);
            let o = this.pow(s, i),
              a = this.pow(e, i),
              c = this.pow(e, i.iaddn(1).iushrn(1)),
              u = n;
            for (; ;) {
              let f = a,
                h = 0;
              for (; !f.eq(t) && h < u;) f = this.sqr(f), h += 1;
              if (h === 0) break;
              Zr(h < u), f = this.sqrn(o, u - h - 1), o = this.sqr(f), c = this.mul(c, f), a = this.mul(a, o), u = h
            }
            return c
          }
          idivsqrt(e, t) {
            return this.divsqrt(e, t)._move(e)
          }
          divsqrt(e, t) {
            if (this._verify2(e, t), e.isZero() && t.isZero()) throw new Bi(t);
            if (this.prime) return this.prime.divsqrt(e, t);
            if (this.m.andln(3) === 3) return this.divsqrt3mod4(e, t);
            if (this.sm1 != null && this.m.andln(7) === 5) return this.divsqrt5mod8(e, t);
            if (t.isZero()) throw new Bi(t);
            return this.sqrt(this.div(e, t))
          }
          divsqrt3mod4(e, t) {
            let i = this.m.subn(3).iushrn(2),
              n = this.sqr(e),
              s = this.mul(n, e),
              o = this.mul(s, n),
              a = this.mul(this.sqr(t), t),
              c = this.pow(this.mul(o, a), i),
              u = this.mul(this.mul(s, t), c);
            if (this.mul(t, this.sqr(u)).eq(e)) return u;
            throw new Bi(u)
          }
          divsqrt5mod8(e, t) {
            let i = this.m.subn(5).iushrn(3),
              n = this.mul(this.sqr(t), t),
              s = this.mul(this.sqr(n), t),
              o = this.pow(this.mul(e, s), i),
              a = this.mul(this.mul(e, n), o),
              c = this.mul(t, this.sqr(a));
            if (c.eq(e)) return a;
            let u = this.ineg(c);
            if (u.eq(e)) return this.mul(a, this.sm1);
            throw u.eq(this.mul(e, this.sm1)) ? new Bi(this.mul(a, this.sm1)) : new Bi(a)
          }
          isSquare(e) {
            return this.m.isOdd() ? this.jacobi(e) >= 0 : this.kronecker(e) >= 0
          }
          ishl(e, t) {
            return this._verify1(e), this.imod(e.iushl(t))
          }
          shl(e, t) {
            return this.ishl(e.clone(), t)
          }
          ishln(e, t) {
            if (this._verify1(e), e.iushln(t), t <= 4)
              for (; e.ucmp(this.m) >= 0;) e._isub(e, this.m);
            else this.imod(e);
            return e
          }
          shln(e, t) {
            return this.ishln(e.clone(), t)
          }
          ineg(e) {
            return this._verify1(e), e.isZero() || e._isub(this.m, e), e
          }
          neg(e) {
            return this.ineg(e.clone())
          }
          eq(e, t) {
            return this._verify2(e, t), e.ucmp(t) === 0
          }
          eqn(e, t) {
            if (this._verify1(e), this.m.length === 1) return t %= this.m.words[0], t < 0 && (t += this.m.words[0]), e.ucmpn(t) === 0;
            if (t < 0) {
              this.m._isubn(-t);
              let i = e.ucmp(this.m);
              return this.m._iaddn(-t), i === 0
            }
            return e.ucmpn(t) === 0
          }
          isHigh(e) {
            return !this.isLow(e)
          }
          isLow(e) {
            return this._verify1(e), e.ucmp(this.m.ushrn(1)) <= 0
          }
          isOdd(e) {
            return this._verify1(e), e.isOdd()
          }
          isEven(e) {
            return this._verify1(e), e.isEven()
          }
          legendre(e) {
            if (this._verify1(e), this.m.isEven()) throw new Error("legendre: `num` must be odd.");
            let t = this.m.subn(1).iushrn(1),
              i = this.pow(e, t);
            if (i.isZero()) return 0;
            let n = new ye(1).toRed(this);
            if (i.eq(n)) return 1;
            if (i.eq(this.ineg(n))) return -1;
            throw new Error("Invalid prime.")
          }
          jacobi(e) {
            return this._verify1(e), e.jacobi(this.m)
          }
          kronecker(e) {
            return this._verify1(e), e.kronecker(this.m)
          }
          iinvert(e) {
            return this.invert(e)._move(e)
          }
          invert(e) {
            return this._verify1(e), e.invert(this.m)._forceRed(this)
          }
          ifermat(e) {
            return this.fermat(e)._move(e)
          }
          fermat(e) {
            if (this._verify1(e), e.isZero() || this.m.cmpn(1) === 0) throw new RangeError("Not invertible.");
            return this.prime ? this.prime.fermat(e) : this.pow(e, this.m.subn(2))
          }
          invertAll(e) {
            me(Array.isArray(e), "elems", "array");
            for (let s of e) me(ye.isBN(s), "elem", "bignum"), this._verify1(s);
            if (this.m.cmpn(1) === 0 || this.m.isEven()) throw new RangeError("Not invertible.");
            let t = e.length,
              i = new Array(t);
            if (t === 0) return i;
            let n = new ye(1).toRed(this);
            for (let s = 0; s < t; s++) {
              if (e[s].isZero()) {
                i[s] = e[s].clone();
                continue
              }
              i[s] = n, n = this.mul(n, e[s])
            }
            n = this.invert(n);
            for (let s = t - 1; s >= 0; s--) e[s].isZero() || (i[s] = this.mul(n, i[s]), n = this.mul(n, e[s]));
            return i
          } [Kme]() {
            return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.m.toString(10)}>`
          }
        },
        Jme = class extends Bh {
          constructor(e) {
            super(e);
            this.prime = null, this.n = this.m.bitLength(), this.n % 26 != 0 && (this.n += 26 - this.n % 26), this.k = this.n * 2, this.w = this.k / 26, this.b = ye.shift(1, this.k).div(this.m)
          }
          convertTo(e) {
            return e.length > this.w ? super.convertTo(e) : this.imod(e.clone())
          }
          _shift(e) {
            let t = 0,
              i = this.w;
            for (; i < e.length;) e.words[t++] = e.words[i++];
            t === 0 && (e.words[t++] = 0), e.length = t
          }
          imod(e) {
            let t = e.negative;
            Zr(e.length <= this.w), e.negative = 0;
            let i = e.mul(this.b);
            return this._shift(i), e._isub(e, i.mul(this.m)), e.ucmp(this.m) >= 0 && e._isub(e, this.m), t && !e.isZero() && e._isub(this.m, e), e.red = this, e
          }
        },
        Xme = class extends Bh {
          constructor(e) {
            super(e);
            this.prime = null, this.n = this.m.length * 26, this.r = ye.shift(1, this.n), this.r2 = ye.shift(1, this.n * 2).imod(this.m), this.ri = this.r.invert(this.m), this.mi = this.r.mul(this.ri).isubn(1).div(this.m), this.rib = null
          }
          get mont() {
            return !0
          }
          convertTo(e) {
            return e.isNeg() || e.ucmp(this.m) >= 0 ? this.imod(e.ushln(this.n)) : this.mul(e, this.r2)
          }
          convertFrom(e) {
            let t = this.mul(e, new ye(1));
            return t.red = null, t
          }
          intTo(e) {
            return (e << BigInt(this.n)) % this.mb
          }
          intFrom(e) {
            return this.rib === null && (this.rib = this.ri.toBigInt()), e * this.rib % this.mb
          }
          iaddn(e, t) {
            return this.iadd(e, this.convertTo(new ye(t)))
          }
          isubn(e, t) {
            return this.isub(e, this.convertTo(new ye(t)))
          }
          imul(e, t) {
            return this.mul(e, t)._move(e)
          }
          mul(e, t) {
            if (e.isZero() || t.isZero()) return new ye(0)._forceRed(this);
            let i = e.mul(t),
              n = i.umaskn(this.n).mul(this.mi).iumaskn(this.n),
              s = i.iadd(n.mul(this.m)).iushrn(this.n);
            return s.ucmp(this.m) >= 0 && s._isub(s, this.m), s._forceRed(this)
          }
          imuln(e, t) {
            if (this._verify1(e), e.isZero()) return e;
            if (t === 0) return e.words[0] = 0, e.length = 1, e;
            let i = t < 0;
            i && (t = -t), this.m.length === 1 && (t %= this.m.words[0]);
            let n = Jp(t);
            if (n > 5) this.imul(e, this.convertTo(new ye(t)));
            else if ((t & t - 1) == 0)
              for (let s = 0; s < n - 1; s++) this.iadd(e, e);
            else {
              let s = e.clone();
              for (let o = n - 2; o >= 0; o--) this.iadd(e, e), t >> o & 1 && this.iadd(e, s)
            }
            return i && this.ineg(e), e
          }
          eqn(e, t) {
            return this._verify1(e), t === 0 ? e.isZero() : e.ucmp(this.convertTo(new ye(t))) === 0
          }
          isLow(e) {
            return this._verify1(e), this.convertFrom(e).ucmp(this.m.ushrn(1)) <= 0
          }
          isOdd(e) {
            return this._verify1(e), this.convertFrom(e).isOdd()
          }
          isEven(e) {
            return this._verify1(e), this.convertFrom(e).isEven()
          }
          invert(e) {
            return this._verify1(e), this.imod(e.invert(this.m).mul(this.r2))
          }
        };

      function Zp(r, e, t) {
        let i = new r(e);
        return r.captureStackTrace && r.captureStackTrace(i, t), i
      }

      function Zr(r, e) {
        if (!r) throw Zp(Error, e || "Assertion failed.", Zr)
      }

      function me(r, e, t) {
        if (!r) {
          let i = `"${e}" must be a(n) ${t}.`;
          throw Zp(TypeError, i, me)
        }
      }

      function Sc(r, e) {
        if (!r) {
          let t = `"${e}" only works with positive numbers.`;
          throw Zp(RangeError, t, Sc)
        }
      }

      function dt(r, e) {
        if (!r) {
          let t = `"${e}" only works with red numbers.`;
          throw Zp(TypeError, t, dt)
        }
      }

      function Dh(r, e) {
        if (!r) {
          let t = `"${e}" only works with normal numbers.`;
          throw Zp(TypeError, t, Dh)
        }
      }

      function Z6(r) {
        if (!r) throw Zp(RangeError, "Cannot divide by zero.", Z6)
      }
      var Bi = class extends Error {
        constructor(e) {
          super();
          this.name = "SquareRootError", this.message = "X is not a square mod P.", this.result = e.fromRed(), Error.captureStackTrace && Error.captureStackTrace(this, Bi)
        }
      };

      function Zme(r) {
        return Number.isSafeInteger(r)
      }

      function vr(r) {
        return Zme(r) && r >= -67108863 && r <= 67108863
      }

      function hlt(r, e) {
        return r.allocUnsafeSlow ? r.allocUnsafeSlow(e) : new r(e)
      }

      function Qme(r) {
        if (r == null) return 10;
        if (typeof r == "number") return r;
        switch (r) {
          case "bin":
            return 2;
          case "oct":
            return 8;
          case "dec":
            return 10;
          case "hex":
            return 16
        }
        return 0
      }

      function Jp(r) {
        if (Math.clz32) return 32 - Math.clz32(r);
        let e = r,
          t = 0;
        return e >= 4096 && (t += 13, e >>>= 13), e >= 64 && (t += 7, e >>>= 7), e >= 8 && (t += 4, e >>>= 4), e >= 2 && (t += 2, e >>>= 2), t + e
      }

      function e2e(r) {
        if (r === 0) return 26;
        let e = r,
          t = 0;
        return (e & 8191) == 0 && (t += 13, e >>>= 13), (e & 127) == 0 && (t += 7, e >>>= 7), (e & 15) == 0 && (t += 4, e >>>= 4), (e & 3) == 0 && (t += 2, e >>>= 2), (e & 1) == 0 && (t += 1), t
      }

      function t2e(r, e, t) {
        let i = Math.min(r.length, t),
          n = 0,
          s = 0;
        for (let o = e; o < i; o++) {
          let a = r.charCodeAt(o) - 48;
          n <<= 4;
          let c;
          a >= 49 && a <= 54 ? c = a - 49 + 10 : a >= 17 && a <= 22 ? c = a - 17 + 10 : c = a, n |= c, s |= c
        }
        if (s & ~15) throw new Error("Invalid string.");
        return n
      }

      function r2e(r, e, t, i) {
        let n = Math.min(r.length, t),
          s = 0;
        for (let o = e; o < n; o++) {
          let a = r.charCodeAt(o) - 48;
          s *= i;
          let c;
          if (a >= 49 ? c = a - 49 + 10 : a >= 17 ? c = a - 17 + 10 : c = a, a < 0 || a > 207 || c >= i) throw new Error("Invalid string.");
          s += c
        }
        return s
      }

      function plt(r, e, t) {
        let i = BigInt(1),
          n = new Array(Yp),
          s = r * r % t;
        n[0] = r;
        for (let c = 1; c < Yp; c++) n[c] = n[c - 1] * s % t;
        let o = e.bitLength(),
          a = i;
        for (; o >= Hb;) {
          let c = Hb,
            u = e.bits(o - c, c);
          if (u < Yp) {
            a = a * a % t, o -= 1;
            continue
          }
          for (;
            (u & 1) == 0;) c -= 1, u >>= 1;
          a === i ? a = n[u >> 1] : (a = ylt(a, c, t), a = a * n[u >> 1] % t), o -= c
        }
        if (o > 0) {
          let c = e.bits(0, o);
          for (; o--;) a = a * a % t, c >> o & 1 && (a = a * r % t)
        }
        return a
      }

      function ylt(r, e, t) {
        for (let i = 0; i < e; i++) r = r * r % t;
        return r
      }

      function i2e(r, e, t) {
        let i = r.length + e.length;
        t.negative = r.negative ^ e.negative, t._alloc(i), t.length = i;
        let n = r.words[0],
          s = e.words[0],
          o = n * s,
          a = o & 67108863,
          c = o / 67108864 | 0,
          u = 1;
        for (t.words[0] = a; u < t.length - 1; u++) {
          let f = c >>> 26,
            h = c & 67108863,
            d = Math.max(0, u - r.length + 1),
            p = Math.min(u, e.length - 1);
          for (let g = d; g <= p; g++) {
            let m = u - g,
              E = r.words[m],
              w = e.words[g],
              O = E * w + h;
            f += O / 67108864 | 0, h = O & 67108863
          }
          t.words[u] = h | 0, c = f | 0
        }
        return c !== 0 ? t.words[u] = c | 0 : t.length -= 1, t._strip()
      }

      function n2e(r, e, t) {
        let i = r.length + e.length;
        t.negative = r.negative ^ e.negative, t._alloc(i), t.length = i;
        let n = 0,
          s = 0,
          o = 0;
        for (; o < t.length - 1; o++) {
          let a = s;
          s = 0;
          let c = n & 67108863,
            u = Math.max(0, o - r.length + 1),
            f = Math.min(o, e.length - 1);
          for (let h = u; h <= f; h++) {
            let d = o - h,
              p = r.words[d],
              g = e.words[h],
              m = p * g,
              E = m & 67108863;
            a = a + (m / 67108864 | 0) | 0, E = E + c | 0, c = E & 67108863, a = a + (E >>> 26) | 0, s += a >>> 26, a &= 67108863
          }
          t.words[o] = c, n = a, a = s
        }
        return n !== 0 ? t.words[o] = n : t.length -= 1, t._strip()
      }

      function dlt(r, e, t) {
        if (!Mh || r.length + e.length > 82595519) return n2e(r, e, t);
        let i = BigInt(0),
          n = BigInt(67108863),
          s = BigInt(26),
          o = r.toBigInt() * e.toBigInt(),
          a = o < i | 0;
        a && (o = -o);
        let c = 0;
        for (; o > i;) t.words[c++] = Number(o & n), o >>= s;
        return c === 0 && (t.words[c++] = 0), t.length = c, t.negative = a, t
      }

      function s2e(r, e, t) {
        let i = r.words,
          n = e.words,
          s = t.words,
          o = i[0] | 0,
          a = o & 8191,
          c = o >>> 13,
          u = i[1] | 0,
          f = u & 8191,
          h = u >>> 13,
          d = i[2] | 0,
          p = d & 8191,
          g = d >>> 13,
          m = i[3] | 0,
          E = m & 8191,
          w = m >>> 13,
          O = i[4] | 0,
          q = O & 8191,
          J = O >>> 13,
          Z = i[5] | 0,
          H = Z & 8191,
          te = Z >>> 13,
          ae = i[6] | 0,
          oe = ae & 8191,
          U = ae >>> 13,
          b = i[7] | 0,
          _ = b & 8191,
          R = b >>> 13,
          D = i[8] | 0,
          K = D & 8191,
          ee = D >>> 13,
          re = i[9] | 0,
          V = re & 8191,
          v = re >>> 13,
          Y = n[0] | 0,
          Se = Y & 8191,
          Q = Y >>> 13,
          ve = n[1] | 0,
          x = ve & 8191,
          I = ve >>> 13,
          le = n[2] | 0,
          he = le & 8191,
          S = le >>> 13,
          T = n[3] | 0,
          j = T & 8191,
          G = T >>> 13,
          k = n[4] | 0,
          F = k & 8191,
          B = k >>> 13,
          L = n[5] | 0,
          $ = L & 8191,
          ie = L >>> 13,
          ne = n[6] | 0,
          pe = ne & 8191,
          be = ne >>> 13,
          de = n[7] | 0,
          Ne = de & 8191,
          Re = de >>> 13,
          $e = n[8] | 0,
          Ke = $e & 8191,
          Me = $e >>> 13,
          Ie = n[9] | 0,
          tt = Ie & 8191,
          nt = Ie >>> 13,
          Ge = 0,
          se, A, X;
        t.negative = r.negative ^ e.negative, t._alloc(20), t.length = 19, se = Math.imul(a, Se), A = Math.imul(a, Q), A = A + Math.imul(c, Se) | 0, X = Math.imul(c, Q);
        let Kt = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, se = Math.imul(f, Se), A = Math.imul(f, Q), A = A + Math.imul(h, Se) | 0, X = Math.imul(h, Q), se = se + Math.imul(a, x) | 0, A = A + Math.imul(a, I) | 0, A = A + Math.imul(c, x) | 0, X = X + Math.imul(c, I) | 0;
        let st = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, se = Math.imul(p, Se), A = Math.imul(p, Q), A = A + Math.imul(g, Se) | 0, X = Math.imul(g, Q), se = se + Math.imul(f, x) | 0, A = A + Math.imul(f, I) | 0, A = A + Math.imul(h, x) | 0, X = X + Math.imul(h, I) | 0, se = se + Math.imul(a, he) | 0, A = A + Math.imul(a, S) | 0, A = A + Math.imul(c, he) | 0, X = X + Math.imul(c, S) | 0;
        let Nt = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, se = Math.imul(E, Se), A = Math.imul(E, Q), A = A + Math.imul(w, Se) | 0, X = Math.imul(w, Q), se = se + Math.imul(p, x) | 0, A = A + Math.imul(p, I) | 0, A = A + Math.imul(g, x) | 0, X = X + Math.imul(g, I) | 0, se = se + Math.imul(f, he) | 0, A = A + Math.imul(f, S) | 0, A = A + Math.imul(h, he) | 0, X = X + Math.imul(h, S) | 0, se = se + Math.imul(a, j) | 0, A = A + Math.imul(a, G) | 0, A = A + Math.imul(c, j) | 0, X = X + Math.imul(c, G) | 0;
        let on = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, se = Math.imul(q, Se), A = Math.imul(q, Q), A = A + Math.imul(J, Se) | 0, X = Math.imul(J, Q), se = se + Math.imul(E, x) | 0, A = A + Math.imul(E, I) | 0, A = A + Math.imul(w, x) | 0, X = X + Math.imul(w, I) | 0, se = se + Math.imul(p, he) | 0, A = A + Math.imul(p, S) | 0, A = A + Math.imul(g, he) | 0, X = X + Math.imul(g, S) | 0, se = se + Math.imul(f, j) | 0, A = A + Math.imul(f, G) | 0, A = A + Math.imul(h, j) | 0, X = X + Math.imul(h, G) | 0, se = se + Math.imul(a, F) | 0, A = A + Math.imul(a, B) | 0, A = A + Math.imul(c, F) | 0, X = X + Math.imul(c, B) | 0;
        let qt = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, se = Math.imul(H, Se), A = Math.imul(H, Q), A = A + Math.imul(te, Se) | 0, X = Math.imul(te, Q), se = se + Math.imul(q, x) | 0, A = A + Math.imul(q, I) | 0, A = A + Math.imul(J, x) | 0, X = X + Math.imul(J, I) | 0, se = se + Math.imul(E, he) | 0, A = A + Math.imul(E, S) | 0, A = A + Math.imul(w, he) | 0, X = X + Math.imul(w, S) | 0, se = se + Math.imul(p, j) | 0, A = A + Math.imul(p, G) | 0, A = A + Math.imul(g, j) | 0, X = X + Math.imul(g, G) | 0, se = se + Math.imul(f, F) | 0, A = A + Math.imul(f, B) | 0, A = A + Math.imul(h, F) | 0, X = X + Math.imul(h, B) | 0, se = se + Math.imul(a, $) | 0, A = A + Math.imul(a, ie) | 0, A = A + Math.imul(c, $) | 0, X = X + Math.imul(c, ie) | 0;
        let De = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, se = Math.imul(oe, Se), A = Math.imul(oe, Q), A = A + Math.imul(U, Se) | 0, X = Math.imul(U, Q), se = se + Math.imul(H, x) | 0, A = A + Math.imul(H, I) | 0, A = A + Math.imul(te, x) | 0, X = X + Math.imul(te, I) | 0, se = se + Math.imul(q, he) | 0, A = A + Math.imul(q, S) | 0, A = A + Math.imul(J, he) | 0, X = X + Math.imul(J, S) | 0, se = se + Math.imul(E, j) | 0, A = A + Math.imul(E, G) | 0, A = A + Math.imul(w, j) | 0, X = X + Math.imul(w, G) | 0, se = se + Math.imul(p, F) | 0, A = A + Math.imul(p, B) | 0, A = A + Math.imul(g, F) | 0, X = X + Math.imul(g, B) | 0, se = se + Math.imul(f, $) | 0, A = A + Math.imul(f, ie) | 0, A = A + Math.imul(h, $) | 0, X = X + Math.imul(h, ie) | 0, se = se + Math.imul(a, pe) | 0, A = A + Math.imul(a, be) | 0, A = A + Math.imul(c, pe) | 0, X = X + Math.imul(c, be) | 0;
        let an = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, se = Math.imul(_, Se), A = Math.imul(_, Q), A = A + Math.imul(R, Se) | 0, X = Math.imul(R, Q), se = se + Math.imul(oe, x) | 0, A = A + Math.imul(oe, I) | 0, A = A + Math.imul(U, x) | 0, X = X + Math.imul(U, I) | 0, se = se + Math.imul(H, he) | 0, A = A + Math.imul(H, S) | 0, A = A + Math.imul(te, he) | 0, X = X + Math.imul(te, S) | 0, se = se + Math.imul(q, j) | 0, A = A + Math.imul(q, G) | 0, A = A + Math.imul(J, j) | 0, X = X + Math.imul(J, G) | 0, se = se + Math.imul(E, F) | 0, A = A + Math.imul(E, B) | 0, A = A + Math.imul(w, F) | 0, X = X + Math.imul(w, B) | 0, se = se + Math.imul(p, $) | 0, A = A + Math.imul(p, ie) | 0, A = A + Math.imul(g, $) | 0, X = X + Math.imul(g, ie) | 0, se = se + Math.imul(f, pe) | 0, A = A + Math.imul(f, be) | 0, A = A + Math.imul(h, pe) | 0, X = X + Math.imul(h, be) | 0, se = se + Math.imul(a, Ne) | 0, A = A + Math.imul(a, Re) | 0, A = A + Math.imul(c, Ne) | 0, X = X + Math.imul(c, Re) | 0;
        let Mt = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, se = Math.imul(K, Se), A = Math.imul(K, Q), A = A + Math.imul(ee, Se) | 0, X = Math.imul(ee, Q), se = se + Math.imul(_, x) | 0, A = A + Math.imul(_, I) | 0, A = A + Math.imul(R, x) | 0, X = X + Math.imul(R, I) | 0, se = se + Math.imul(oe, he) | 0, A = A + Math.imul(oe, S) | 0, A = A + Math.imul(U, he) | 0, X = X + Math.imul(U, S) | 0, se = se + Math.imul(H, j) | 0, A = A + Math.imul(H, G) | 0, A = A + Math.imul(te, j) | 0, X = X + Math.imul(te, G) | 0, se = se + Math.imul(q, F) | 0, A = A + Math.imul(q, B) | 0, A = A + Math.imul(J, F) | 0, X = X + Math.imul(J, B) | 0, se = se + Math.imul(E, $) | 0, A = A + Math.imul(E, ie) | 0, A = A + Math.imul(w, $) | 0, X = X + Math.imul(w, ie) | 0, se = se + Math.imul(p, pe) | 0, A = A + Math.imul(p, be) | 0, A = A + Math.imul(g, pe) | 0, X = X + Math.imul(g, be) | 0, se = se + Math.imul(f, Ne) | 0, A = A + Math.imul(f, Re) | 0, A = A + Math.imul(h, Ne) | 0, X = X + Math.imul(h, Re) | 0, se = se + Math.imul(a, Ke) | 0, A = A + Math.imul(a, Me) | 0, A = A + Math.imul(c, Ke) | 0, X = X + Math.imul(c, Me) | 0;
        let Bt = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, se = Math.imul(V, Se), A = Math.imul(V, Q), A = A + Math.imul(v, Se) | 0, X = Math.imul(v, Q), se = se + Math.imul(K, x) | 0, A = A + Math.imul(K, I) | 0, A = A + Math.imul(ee, x) | 0, X = X + Math.imul(ee, I) | 0, se = se + Math.imul(_, he) | 0, A = A + Math.imul(_, S) | 0, A = A + Math.imul(R, he) | 0, X = X + Math.imul(R, S) | 0, se = se + Math.imul(oe, j) | 0, A = A + Math.imul(oe, G) | 0, A = A + Math.imul(U, j) | 0, X = X + Math.imul(U, G) | 0, se = se + Math.imul(H, F) | 0, A = A + Math.imul(H, B) | 0, A = A + Math.imul(te, F) | 0, X = X + Math.imul(te, B) | 0, se = se + Math.imul(q, $) | 0, A = A + Math.imul(q, ie) | 0, A = A + Math.imul(J, $) | 0, X = X + Math.imul(J, ie) | 0, se = se + Math.imul(E, pe) | 0, A = A + Math.imul(E, be) | 0, A = A + Math.imul(w, pe) | 0, X = X + Math.imul(w, be) | 0, se = se + Math.imul(p, Ne) | 0, A = A + Math.imul(p, Re) | 0, A = A + Math.imul(g, Ne) | 0, X = X + Math.imul(g, Re) | 0, se = se + Math.imul(f, Ke) | 0, A = A + Math.imul(f, Me) | 0, A = A + Math.imul(h, Ke) | 0, X = X + Math.imul(h, Me) | 0, se = se + Math.imul(a, tt) | 0, A = A + Math.imul(a, nt) | 0, A = A + Math.imul(c, tt) | 0, X = X + Math.imul(c, nt) | 0;
        let cn = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, se = Math.imul(V, x), A = Math.imul(V, I), A = A + Math.imul(v, x) | 0, X = Math.imul(v, I), se = se + Math.imul(K, he) | 0, A = A + Math.imul(K, S) | 0, A = A + Math.imul(ee, he) | 0, X = X + Math.imul(ee, S) | 0, se = se + Math.imul(_, j) | 0, A = A + Math.imul(_, G) | 0, A = A + Math.imul(R, j) | 0, X = X + Math.imul(R, G) | 0, se = se + Math.imul(oe, F) | 0, A = A + Math.imul(oe, B) | 0, A = A + Math.imul(U, F) | 0, X = X + Math.imul(U, B) | 0, se = se + Math.imul(H, $) | 0, A = A + Math.imul(H, ie) | 0, A = A + Math.imul(te, $) | 0, X = X + Math.imul(te, ie) | 0, se = se + Math.imul(q, pe) | 0, A = A + Math.imul(q, be) | 0, A = A + Math.imul(J, pe) | 0, X = X + Math.imul(J, be) | 0, se = se + Math.imul(E, Ne) | 0, A = A + Math.imul(E, Re) | 0, A = A + Math.imul(w, Ne) | 0, X = X + Math.imul(w, Re) | 0, se = se + Math.imul(p, Ke) | 0, A = A + Math.imul(p, Me) | 0, A = A + Math.imul(g, Ke) | 0, X = X + Math.imul(g, Me) | 0, se = se + Math.imul(f, tt) | 0, A = A + Math.imul(f, nt) | 0, A = A + Math.imul(h, tt) | 0, X = X + Math.imul(h, nt) | 0;
        let Dt = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, se = Math.imul(V, he), A = Math.imul(V, S), A = A + Math.imul(v, he) | 0, X = Math.imul(v, S), se = se + Math.imul(K, j) | 0, A = A + Math.imul(K, G) | 0, A = A + Math.imul(ee, j) | 0, X = X + Math.imul(ee, G) | 0, se = se + Math.imul(_, F) | 0, A = A + Math.imul(_, B) | 0, A = A + Math.imul(R, F) | 0, X = X + Math.imul(R, B) | 0, se = se + Math.imul(oe, $) | 0, A = A + Math.imul(oe, ie) | 0, A = A + Math.imul(U, $) | 0, X = X + Math.imul(U, ie) | 0, se = se + Math.imul(H, pe) | 0, A = A + Math.imul(H, be) | 0, A = A + Math.imul(te, pe) | 0, X = X + Math.imul(te, be) | 0, se = se + Math.imul(q, Ne) | 0, A = A + Math.imul(q, Re) | 0, A = A + Math.imul(J, Ne) | 0, X = X + Math.imul(J, Re) | 0, se = se + Math.imul(E, Ke) | 0, A = A + Math.imul(E, Me) | 0, A = A + Math.imul(w, Ke) | 0, X = X + Math.imul(w, Me) | 0, se = se + Math.imul(p, tt) | 0, A = A + Math.imul(p, nt) | 0, A = A + Math.imul(g, tt) | 0, X = X + Math.imul(g, nt) | 0;
        let yt = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, se = Math.imul(V, j), A = Math.imul(V, G), A = A + Math.imul(v, j) | 0, X = Math.imul(v, G), se = se + Math.imul(K, F) | 0, A = A + Math.imul(K, B) | 0, A = A + Math.imul(ee, F) | 0, X = X + Math.imul(ee, B) | 0, se = se + Math.imul(_, $) | 0, A = A + Math.imul(_, ie) | 0, A = A + Math.imul(R, $) | 0, X = X + Math.imul(R, ie) | 0, se = se + Math.imul(oe, pe) | 0, A = A + Math.imul(oe, be) | 0, A = A + Math.imul(U, pe) | 0, X = X + Math.imul(U, be) | 0, se = se + Math.imul(H, Ne) | 0, A = A + Math.imul(H, Re) | 0, A = A + Math.imul(te, Ne) | 0, X = X + Math.imul(te, Re) | 0, se = se + Math.imul(q, Ke) | 0, A = A + Math.imul(q, Me) | 0, A = A + Math.imul(J, Ke) | 0, X = X + Math.imul(J, Me) | 0, se = se + Math.imul(E, tt) | 0, A = A + Math.imul(E, nt) | 0, A = A + Math.imul(w, tt) | 0, X = X + Math.imul(w, nt) | 0;
        let Bn = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (Bn >>> 26) | 0, Bn &= 67108863, se = Math.imul(V, F), A = Math.imul(V, B), A = A + Math.imul(v, F) | 0, X = Math.imul(v, B), se = se + Math.imul(K, $) | 0, A = A + Math.imul(K, ie) | 0, A = A + Math.imul(ee, $) | 0, X = X + Math.imul(ee, ie) | 0, se = se + Math.imul(_, pe) | 0, A = A + Math.imul(_, be) | 0, A = A + Math.imul(R, pe) | 0, X = X + Math.imul(R, be) | 0, se = se + Math.imul(oe, Ne) | 0, A = A + Math.imul(oe, Re) | 0, A = A + Math.imul(U, Ne) | 0, X = X + Math.imul(U, Re) | 0, se = se + Math.imul(H, Ke) | 0, A = A + Math.imul(H, Me) | 0, A = A + Math.imul(te, Ke) | 0, X = X + Math.imul(te, Me) | 0, se = se + Math.imul(q, tt) | 0, A = A + Math.imul(q, nt) | 0, A = A + Math.imul(J, tt) | 0, X = X + Math.imul(J, nt) | 0;
        let Ht = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, se = Math.imul(V, $), A = Math.imul(V, ie), A = A + Math.imul(v, $) | 0, X = Math.imul(v, ie), se = se + Math.imul(K, pe) | 0, A = A + Math.imul(K, be) | 0, A = A + Math.imul(ee, pe) | 0, X = X + Math.imul(ee, be) | 0, se = se + Math.imul(_, Ne) | 0, A = A + Math.imul(_, Re) | 0, A = A + Math.imul(R, Ne) | 0, X = X + Math.imul(R, Re) | 0, se = se + Math.imul(oe, Ke) | 0, A = A + Math.imul(oe, Me) | 0, A = A + Math.imul(U, Ke) | 0, X = X + Math.imul(U, Me) | 0, se = se + Math.imul(H, tt) | 0, A = A + Math.imul(H, nt) | 0, A = A + Math.imul(te, tt) | 0, X = X + Math.imul(te, nt) | 0;
        let Gt = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, se = Math.imul(V, pe), A = Math.imul(V, be), A = A + Math.imul(v, pe) | 0, X = Math.imul(v, be), se = se + Math.imul(K, Ne) | 0, A = A + Math.imul(K, Re) | 0, A = A + Math.imul(ee, Ne) | 0, X = X + Math.imul(ee, Re) | 0, se = se + Math.imul(_, Ke) | 0, A = A + Math.imul(_, Me) | 0, A = A + Math.imul(R, Ke) | 0, X = X + Math.imul(R, Me) | 0, se = se + Math.imul(oe, tt) | 0, A = A + Math.imul(oe, nt) | 0, A = A + Math.imul(U, tt) | 0, X = X + Math.imul(U, nt) | 0;
        let Dn = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, se = Math.imul(V, Ne), A = Math.imul(V, Re), A = A + Math.imul(v, Ne) | 0, X = Math.imul(v, Re), se = se + Math.imul(K, Ke) | 0, A = A + Math.imul(K, Me) | 0, A = A + Math.imul(ee, Ke) | 0, X = X + Math.imul(ee, Me) | 0, se = se + Math.imul(_, tt) | 0, A = A + Math.imul(_, nt) | 0, A = A + Math.imul(R, tt) | 0, X = X + Math.imul(R, nt) | 0;
        let et = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, se = Math.imul(V, Ke), A = Math.imul(V, Me), A = A + Math.imul(v, Ke) | 0, X = Math.imul(v, Me), se = se + Math.imul(K, tt) | 0, A = A + Math.imul(K, nt) | 0, A = A + Math.imul(ee, tt) | 0, X = X + Math.imul(ee, nt) | 0;
        let $t = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        Ge = (X + (A >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, se = Math.imul(V, tt), A = Math.imul(V, nt), A = A + Math.imul(v, tt) | 0, X = Math.imul(v, nt);
        let Ln = (Ge + se | 0) + ((A & 8191) << 13) | 0;
        return Ge = (X + (A >>> 13) | 0) + (Ln >>> 26) | 0, Ln &= 67108863, s[0] = Kt, s[1] = st, s[2] = Nt, s[3] = on, s[4] = qt, s[5] = De, s[6] = an, s[7] = Mt, s[8] = Bt, s[9] = cn, s[10] = Dt, s[11] = yt, s[12] = Bn, s[13] = Ht, s[14] = Gt, s[15] = Dn, s[16] = et, s[17] = $t, s[18] = Ln, Ge !== 0 && (s[19] = Ge, t.length += 1), t
      }
      Math.imul || (s2e = i2e);
      ye.Red = Bh;
      Ume.exports = ye
    });
    var hk = y((ETt, u2e) => {
      l();
      "use strict";
      u2e.exports = c2e()
    });
    var P2e = y(Es => {
      l();
      "use strict";
      var {
        custom: Qp
      } = fk(), we = hk(), xc = {
        AFFINE: 0,
        JACOBIAN: 1,
        PROJECTIVE: 2,
        EXTENDED: 3
      }, glt = [-3, -1, -5, -7, 0, 7, 5, 1, 3], f2e = !1, blt = 0, es = class {
        constructor(e, t, i) {
          this.Point = null, this.id = null, this.uid = blt++, this.ossl = null, this.type = "base", this.endian = "be", this.hash = null, this.prefix = null, this.context = !1, this.prime = null, this.p = null, this.red = null, this.fieldSize = 0, this.fieldBits = 0, this.adjustedSize = 0, this.signBit = 0, this.mask = 0, this.n = null, this.h = null, this.q = null, this.z = null, this.g = null, this.nh = null, this.scalarSize = 0, this.scalarBits = 0, this.zero = null, this.one = null, this.two = null, this.three = null, this.four = null, this.i2 = null, this.i3 = null, this.i4 = null, this.i6 = null, this.torsion = null, this.endo = null, this.hi = null, this._init(e, t, i)
        }
        _init(e, t, i) {
          z(typeof e == "function"), z(typeof t == "string"), z(i && typeof i == "object"), z(i.red == null || i.red instanceof we.Red), z(i.p != null, "Must pass a prime."), z(i.id == null || typeof i.id == "string"), z(i.ossl == null || typeof i.ossl == "string"), z(i.endian == null || typeof i.endian == "string"), z(i.hash == null || typeof i.hash == "string"), z(i.prefix == null || typeof i.prefix == "string"), z(i.context == null || typeof i.context == "boolean"), z(i.prime == null || typeof i.prime == "string"), z(i.torsion == null || Array.isArray(i.torsion)), this.Point = e, this.id = i.id || null, this.ossl = i.ossl || null, this.type = t, this.endian = i.endian || (t === "short" ? "be" : "le"), this.hash = i.hash || null, this.prefix = i.prefix ? Buffer.from(i.prefix, "binary") : null, this.context = i.context || !1, this.prime = i.prime || null, this.p = we.fromJSON(i.p), i.red ? this.red = i.red : (this.red = i.prime ? we.red(i.prime) : we.mont(this.p), this.red.precompute()), this.fieldSize = this.p.byteLength(), this.fieldBits = this.p.bitLength(), this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) == 0), this.signBit = this.adjustedSize * 8 - 1, this.mask = 255, (this.fieldBits & 7) != 0 && (this.mask = (1 << (this.fieldBits & 7)) - 1), this.n = we.fromJSON(i.n || "0"), this.h = we.fromJSON(i.h || "1"), this.q = this.n.mul(this.h), this.z = we.fromJSON(i.z || "0").toRed(this.red), this.g = null, this.nh = this.n.ushrn(1), this.scalarSize = this.n.byteLength(), this.scalarBits = this.n.bitLength(), this.zero = new we(0).toRed(this.red), this.one = new we(1).toRed(this.red), this.two = new we(2).toRed(this.red), this.three = new we(3).toRed(this.red), this.four = new we(4).toRed(this.red), this.i2 = this.two.redInvert(), this.i3 = this.three.redInvert(), this.i4 = this.i2.redSqr(), this.i6 = this.i2.redMul(this.i3), this.torsion = new Array(this.h.word(0));
          for (let n = 0; n < this.torsion.length; n++) this.torsion[n] = this.point();
          return this.endo = null, this.hi = null, this._scale = dk(this._scale, this), this.isIsomorphic = dk(this.isIsomorphic, this), this.isIsogenous = dk(this.isIsogenous, this), z(this.p.sign() > 0 && this.p.isOdd()), z(this.n.sign() >= 0), z(this.h.sign() > 0 && this.h.cmpn(255) <= 0), z(this.endian === "be" || this.endian === "le"), this
        }
        _finalize(e) {
          if (z(e && typeof e == "object"), this.g = e.g ? this.pointFromJSON(e.g) : this.point(), e.torsion) {
            z(e.torsion.length === this.torsion.length);
            for (let t = 0; t < this.torsion.length; t++) this.torsion[t] = this.pointFromJSON(e.torsion[t])
          }
          return this
        }
        _findTorsion() {
          z(!this.n.isZero());
          let e = this.h.word(0),
            t = this.one.redNeg(),
            i = [this.point()],
            n = new Set,
            s = e;
          for (; i.length < s;) {
            let o;
            t.redIAdd(this.one);
            try {
              o = this.pointFromX(t.clone())
            } catch (a) {
              continue
            }
            try {
              o = o.mul(this.n)
            } catch (a) {
              s = 2;
              continue
            }
            if (!o.isInfinity()) {
              o.normalize();
              for (let a of [o, o.neg()]) {
                let c = a.key();
                n.has(c) || (i.push(a), n.add(c))
              }
            }
          }
          for (i.sort((o, a) => o.cmp(a)); i.length < e;) i.push(this.point());
          return i
        }
        _fixedMul(e, t) {
          z(e instanceof Dr), z(t instanceof we), z(e.pre && e.pre.windows);
          let {
            width: i,
            points: n
          } = e._getWindows(0, 0), s = 1 << i, a = (t.bitLength() + i - 1) / i >>> 0, c = this.jpoint();
          for (let u = 0; u < a; u++) {
            let f = t.bits(u * i, i);
            c = c.add(n[u * s + f])
          }
          return t.isNeg() && (c = c.neg()), c
        }
        _fixedNafMul(e, t) {
          z(e instanceof Dr), z(t instanceof we), z(e.pre && e.pre.doubles);
          let {
            step: i,
            points: n
          } = e._getDoubles(0, 0), s = mlt(t, 2, t.bitLength() + 1, i), o = ((1 << i + 1) - (i % 2 == 0 ? 2 : 1)) / 3, a = this.jpoint(), c = this.jpoint();
          for (let u = o; u > 0; u--) {
            for (let f = 0; f < s.length; f++) {
              let h = s[f];
              h === u ? c = c.add(n[f]) : h === -u && (c = c.sub(n[f]))
            }
            a = a.add(c)
          }
          return a
        }
        _wnafMul(e, t, i) {
          z(t instanceof Dr), z(i instanceof we);
          let {
            width: n,
            points: s
          } = t._safeNAF(e), o = e4(i, n, i.bitLength() + 1), a = this.jpoint();
          for (let c = o.length - 1; c >= 0; c--) {
            let u = o[c];
            c !== o.length - 1 && (a = a.dbl()), u > 0 ? a = a.add(s[u - 1 >> 1]) : u < 0 && (a = a.sub(s[-u - 1 >> 1]))
          }
          return a
        }
        _wnafMulAdd(e, t, i) {
          z(e >>> 0 === e), z(Array.isArray(t)), z(Array.isArray(i)), z(t.length === i.length);
          let n = t.length,
            s = new Array(n),
            o = new Array(n),
            a = 0;
          for (let d = 0; d < n; d++) {
            let p = t[d],
              g = i[d];
            if (z(p instanceof Dr), z(g instanceof we), d > 0 && p.type !== t[d - 1].type) throw new Error("Cannot mix points.");
            s[d] = null, o[d] = null, a = Math.max(a, g.bitLength() + 1)
          }
          let c = null,
            u = null,
            f = 0;
          for (let d = 0; d < n; d++) {
            let p = t[d],
              g = i[d],
              m = p._getNAF(0);
            if (m) {
              s[f] = m.points, o[f] = e4(g, m.width, a), f += 1;
              continue
            }
            if (!c) {
              c = p, u = g;
              continue
            }
            s[f] = c._getJNAF(p), o[f] = vlt(u, g, a), c = null, u = null, f += 1
          }
          if (c) {
            let d = c._safeNAF(e);
            s[f] = d.points, o[f] = e4(u, d.width, a), f += 1
          }
          let h = this.jpoint();
          for (let d = a - 1; d >= 0; d--) {
            d !== a - 1 && (h = h.dbl());
            for (let p = 0; p < f; p++) {
              let g = o[p][d];
              g > 0 ? h = h.add(s[p][g - 1 >> 1]) : g < 0 && (h = h.sub(s[p][-g - 1 >> 1]))
            }
          }
          return h
        }
        _endoWnafMulAdd(e, t) {
          throw new Error("Not implemented.")
        }
        _scale(e, t) {
          switch (z(e instanceof es), z(e.p.eq(this.p)), e.type) {
            case "short":
              return this._scaleShort(e, t);
            case "mont":
              return this._scaleMont(e, t);
            case "edwards":
              return this._scaleEdwards(e, t);
            default:
              throw new Error("Not implemented.")
          }
        }
        _scaleShort(e, t) {
          throw new Error("Not implemented.")
        }
        _scaleMont(e, t) {
          throw new Error("Not implemented.")
        }
        _scaleEdwards(e, t) {
          throw new Error("Not implemented.")
        }
        isElliptic() {
          throw new Error("Not implemented.")
        }
        jinv() {
          throw new Error("Not implemented.")
        }
        isComplete() {
          return !1
        }
        precompute(e) {
          return z(!this.g.isInfinity(), "Must have base point."), z(!this.n.isZero(), "Must have order."), this.g.precompute(this.n.bitLength(), e), this
        }
        scalar(e, t, i) {
          let n = new we(e, t, i);
          return z(!n.red), this.n.isZero() ? n : n.imod(this.n)
        }
        field(e, t, i) {
          let n = we.cast(e, t, i);
          return n.red ? n.forceRed(this.red) : n.toRed(this.red)
        }
        point(e, t) {
          throw new Error("Not implemented.")
        }
        jpoint(e, t, i) {
          throw new Error("Not implemented.")
        }
        xpoint(e, t) {
          throw new Error("Not implemented.")
        }
        cpoint(e, t, i, n) {
          if (z(e instanceof we), z(t instanceof we), z(i instanceof we), z(n instanceof we), t.isZero() || n.isZero()) return this.point();
          let s = t.redMul(n).redInvert(),
            o = e.redMul(n).redMul(s),
            a = i.redMul(t).redMul(s);
          return this.point(o, a)
        }
        solveX2(e) {
          throw new Error("Not implemented.")
        }
        solveX(e) {
          return this.solveX2(e).redSqrt()
        }
        solveY2(e) {
          throw new Error("Not implemented.")
        }
        solveY(e) {
          return this.solveY2(e).redSqrt()
        }
        validate(e) {
          throw new Error("Not implemented.")
        }
        pointFromX(e, t) {
          throw new Error("Not implemented.")
        }
        pointFromY(e, t) {
          throw new Error("Not implemented.")
        }
        isIsomorphic(e) {
          throw new Error("Not implemented.")
        }
        isIsogenous(e) {
          throw new Error("Not implemented.")
        }
        pointFromShort(e) {
          throw new Error("Not implemented.")
        }
        pointFromMont(e, t) {
          throw new Error("Not implemented.")
        }
        pointFromEdwards(e) {
          throw new Error("Not implemented.")
        }
        pointFromUniform(e) {
          throw new Error("Not implemented.")
        }
        pointToUniform(e) {
          throw new Error("Not implemented.")
        }
        pointFromHash(e, t = !1) {
          if (z(Buffer.isBuffer(e)), z(typeof t == "boolean"), e.length !== this.fieldSize * 2) throw new Error("Invalid hash size.");
          let i = e.slice(0, this.fieldSize),
            n = e.slice(this.fieldSize),
            s = this.decodeUniform(i),
            o = this.decodeUniform(n),
            a = this.pointFromUniform(s),
            c = this.pointFromUniform(o),
            u = a.add(c);
          return t ? u.mulH() : u
        }
        pointToHash(e, t, i) {
          z(e instanceof this.Point), z(t >>> 0 === t);
          let n = t % this.torsion.length,
            s = e.add(this.torsion[n]);
          for (; ;) {
            let o = this.randomField(i),
              a = this.pointFromUniform(o);
            if (a.neg().eq(a)) continue;
            let c = s.sub(a),
              u = l2e(i),
              f;
            try {
              f = this.pointToUniform(c, u & 15)
            } catch (p) {
              if (p.message === "Invalid point.") continue;
              throw p
            }
            let h = this.encodeUniform(o, u >>> 8),
              d = this.encodeUniform(f, u >>> 16);
            return Buffer.concat([h, d])
          }
        }
        randomScalar(e) {
          let t = this.n.isZero() ? this.p : this.n;
          return we.random(e, 1, t)
        }
        randomField(e) {
          return we.random(e, 1, this.p).toRed(this.red)
        }
        randomPoint(e) {
          let t;
          for (; ;) {
            let i = this.randomField(e),
              n = (l2e(e) & 1) != 0;
            try {
              t = this.pointFromX(i, n)
            } catch (s) {
              continue
            }
            return z(t.validate()), t.mulH()
          }
        }
        mulAll(e, t) {
          return this.jmulAll(e, t)
        }
        jmulAll(e, t) {
          return z(Array.isArray(e)), z(e.length === 0 || e[0] instanceof Dr), this.endo && e.length > 0 && e[0].type === xc.AFFINE ? this._endoWnafMulAdd(e, t) : this._wnafMulAdd(5, e, t)
        }
        mulH(e) {
          return z(e instanceof we), this.imulH(e.clone())
        }
        imulH(e) {
          z(e instanceof we), z(!e.red);
          let t = this.h.word(0);
          if ((t & t - 1) == 0) {
            let i = this.h.bitLength();
            return e.iushln(i - 1).imod(this.n)
          }
          return e.imuln(t).imod(this.n)
        }
        normalizeAll(e) {
          z(Array.isArray(e));
          let t = e.length,
            i = new Array(t);
          for (let o = 0; o < t; o++) {
            let a = e[o];
            if (z(a instanceof Dr), z(a.curve === this), a.type === xc.AFFINE) {
              i[o] = this.one;
              continue
            }
            i[o] = a.z
          }
          let n = this.red.invertAll(i),
            s = new Array(t);
          for (let o = 0; o < t; o++) s[o] = e[o].scale(n[o]);
          return s
        }
        affinizeAll(e) {
          return this.normalizeAll(e)
        }
        clamp(e) {
          z(Buffer.isBuffer(e)), z(e.length === this.scalarSize), z(this.scalarSize <= this.fieldSize);
          let t = this.fieldBits & 7 || 8,
            i = 0,
            n = this.scalarSize - 1;
          return this.endian === "be" && ([i, n] = [n, i]), this.scalarSize < this.fieldSize && (t = 8), e[i] &= -this.h.word(0) & 255, e[n] &= (1 << t) - 1, e[n] |= 1 << t - 1, e
        }
        splitHash(e) {
          z(Buffer.isBuffer(e)), z(e.length === this.adjustedSize * 2), z(this.scalarSize <= this.adjustedSize);
          let t = 0;
          this.endian === "be" && (t = this.adjustedSize - this.scalarSize);
          let i = e.slice(t, t + this.scalarSize),
            n = e.slice(this.adjustedSize);
          return this.clamp(i), [i, n]
        }
        encodeField(e) {
          return z(e instanceof we), z(!e.red), e.encode(this.endian, this.fieldSize)
        }
        decodeField(e) {
          if (z(Buffer.isBuffer(e)), e.length !== this.fieldSize) throw new Error("Invalid field element size.");
          return we.decode(e, this.endian)
        }
        encodeAdjusted(e) {
          return z(e instanceof we), z(!e.red), e.encode(this.endian, this.adjustedSize)
        }
        decodeAdjusted(e) {
          if (z(Buffer.isBuffer(e)), e.length !== this.adjustedSize) throw new Error("Invalid field element size.");
          return we.decode(e, this.endian)
        }
        encodeScalar(e) {
          return z(e instanceof we), z(!e.red), e.encode(this.endian, this.scalarSize)
        }
        decodeScalar(e) {
          if (z(Buffer.isBuffer(e)), e.length !== this.scalarSize) throw new Error("Invalid scalar size.");
          return we.decode(e, this.endian)
        }
        encodeClamped(e) {
          return this.clamp(this.encodeScalar(e))
        }
        decodeClamped(e) {
          if (z(Buffer.isBuffer(e)), e.length !== this.scalarSize) throw new Error("Invalid scalar size.");
          let t = this.clamp(Buffer.from(e));
          return we.decode(t, this.endian)
        }
        encodeUniform(e, t) {
          z(e instanceof we), z(t >>> 0 === t);
          let i = this.endian === "le" ? this.fieldSize - 1 : 0,
            n = e.fromRed().encode(this.endian, this.fieldSize);
          return n[i] |= t & ~this.mask & 255, n
        }
        decodeUniform(e) {
          if (z(Buffer.isBuffer(e)), e.length !== this.fieldSize) throw new Error("Invalid field size.");
          let t = we.decode(e, this.endian);
          return t.iumaskn(this.fieldBits), t.toRed(this.red)
        }
        encodePoint(e, t) {
          return z(e instanceof Dr), e.encode(t)
        }
        decodePoint(e) {
          throw new Error("Not implemented.")
        }
        encodeX(e) {
          throw new Error("Not implemented.")
        }
        decodeX(e) {
          throw new Error("Not implemented.")
        }
        decodeEven(e) {
          throw new Error("Not implemented.")
        }
        decodeSquare(e) {
          throw new Error("Not implemented.")
        }
        toShort() {
          throw new Error("Not implemented.")
        }
        toMont(e) {
          throw new Error("Not implemented.")
        }
        toEdwards(e) {
          throw new Error("Not implemented.")
        }
        pointToJSON(e, t) {
          return z(e instanceof Dr), e.toJSON(t)
        }
        pointFromJSON(e) {
          throw new Error("Not implemented.")
        }
        toJSON(e) {
          let t, i, n, s, o;
          return this.type === "edwards" && (t = this.prefix ? this.prefix.toString() : null, i = this.context), this.n.isZero() || (n = this.n.toJSON()), this.z.isZero() || (s = this.z.fromRed(), this.z.redIsHigh() && s.isub(this.p), s = s.toString(16)), this.endo && (o = this.endo.toJSON()), {
            id: this.id,
            ossl: this.ossl,
            type: this.type,
            endian: this.endian,
            hash: this.hash,
            prefix: t,
            context: i,
            prime: this.prime,
            p: this.p.toJSON(),
            a: void 0,
            b: void 0,
            d: void 0,
            n,
            h: this.h.toString(16),
            s: void 0,
            z: s,
            c: void 0,
            g: this.g.toJSON(e),
            endo: o
          }
        }
        static fromJSON(e) {
          return new this(e)
        }
      }, Dr = class {
        constructor(e, t) {
          z(e instanceof es), z(t >>> 0 === t), this.curve = e, this.type = t, this.pre = null
        }
        _init() {
          throw new Error("Not implemented.")
        }
        _safeNAF(e) {
          if (z(e >>> 0 === e), this.pre && this.pre.naf) return this.pre.naf;
          if (e === 0) return null;
          let t = 1 << e - 2,
            i = new Array(t),
            n = this.toJ(),
            s = t === 1 ? null : n.dbl();
          i[0] = n;
          for (let o = 1; o < t; o++) i[o] = i[o - 1].add(s);
          return new r4(e, i)
        }
        _getNAF(e) {
          if (z(e >>> 0 === e), this.pre && this.pre.naf) return this.pre.naf;
          if (e === 0) return null;
          let t = this._safeNAF(e).points,
            i = this.curve.affinizeAll(t);
          return new r4(e, i)
        }
        _getWindows(e, t) {
          if (z(e >>> 0 === e), z(t >>> 0 === t), this.pre && this.pre.windows) return this.pre.windows;
          if (e === 0) return null;
          let i = 1 << e,
            n = (t + e - 1) / e >>> 0,
            s = new Array(n * i),
            o = this.toJ();
          for (let c = 0; c < n; c++) {
            s[c * i] = this.curve.jpoint();
            for (let u = 1; u < i; u++) s[c * i + u] = s[c * i + u - 1].add(o);
            o = o.dblp(e)
          }
          let a = this.curve.affinizeAll(s);
          return new pk(e, t, a)
        }
        _getDoubles(e, t) {
          if (z(e >>> 0 === e), z(t >>> 0 === t), this.pre && this.pre.doubles) return this.pre.doubles;
          if (e === 0) return null;
          let i = Math.ceil(t / e) + 1,
            n = new Array(i),
            s = this.toJ(),
            o = 0;
          n[o++] = s;
          for (let c = 0; c < t; c += e) {
            for (let u = 0; u < e; u++) s = s.dbl();
            n[o++] = s
          }
          z(o === i);
          let a = this.curve.affinizeAll(n);
          return new yk(e, a)
        }
        _getBeta() {
          return null
        }
        _getBlinding(e) {
          if (this.pre && this.pre.blinding) return this.pre.blinding;
          if (!e || this.curve.n.isZero()) return null;
          let t = this.curve.randomScalar(e),
            i = this.mul(t);
          return new gk(t, i)
        }
        _hasWindows(e) {
          if (z(e instanceof we), !this.pre || !this.pre.windows) return !1;
          let {
            width: t,
            bits: i
          } = this.pre.windows, n = (i + t - 1) / t >>> 0;
          return e.bitLength() <= n * t
        }
        _hasDoubles(e) {
          if (z(e instanceof we), !this.pre || !this.pre.doubles) return !1;
          let {
            step: t,
            points: i
          } = this.pre.doubles, n = e.bitLength() + 1;
          return i.length >= Math.ceil(n / t) + 1
        }
        _getJNAF(e) {
          return z(e instanceof Dr), z(e.type === this.type), [this, this.add(e), this.sub(e), e]
        }
        _blind(e, t) {
          if (z(e instanceof we), z(!e.red), this.pre && this.pre.blinding) {
            let {
              blind: n,
              unblind: s
            } = this.pre.blinding, o = e.sub(n);
            return [this, o, s]
          }
          if (!t) return [this, e, null];
          if (this.pre) {
            if (this.curve.n.isZero()) return [this, e, null];
            let o = this.curve.randomScalar(t).mul(this.curve.n).iadd(e);
            return [this, o, null]
          }
          return [this.randomize(t), e, null]
        }
        clone() {
          throw new Error("Not implemented.")
        }
        precompute(e, t) {
          return z(e >>> 0 === e), this.pre || (this.pre = new t4), this.pre.naf || (this.pre.naf = this._getNAF(9)), f2e && !this.pre.windows && (this.pre.windows = this._getWindows(4, e)), this.pre.doubles || (this.pre.doubles = this._getDoubles(4, e + 1)), this.pre.beta || (this.pre.beta = this._getBeta()), this.pre.blinding || (this.pre.blinding = this._getBlinding(t)), this
        }
        validate() {
          return this.curve.validate(this)
        }
        normalize() {
          return this
        }
        scale(e) {
          throw new Error("Not implemented.")
        }
        randomize(e) {
          let t = this.curve.randomField(e);
          return this.scale(t)
        }
        neg() {
          throw new Error("Not implemented.")
        }
        add(e) {
          throw new Error("Not implemented.")
        }
        sub(e) {
          return z(e instanceof Dr), this.add(e.neg())
        }
        dbl() {
          throw new Error("Not implemented.")
        }
        dblp(e) {
          z(e >>> 0 === e);
          let t = this;
          for (let i = 0; i < e; i++) t = t.dbl();
          return t
        }
        diffAddDbl(e, t) {
          throw new Error("Not implemented.")
        }
        getX() {
          throw new Error("Not implemented.")
        }
        getY() {
          throw new Error("Not implemented.")
        }
        eq(e) {
          throw new Error("Not implemented.")
        }
        cmp(e) {
          throw new Error("Not implemented.")
        }
        isInfinity() {
          throw new Error("Not implemented.")
        }
        isOrder2() {
          throw new Error("Not implemented.")
        }
        isOdd() {
          throw new Error("Not implemented.")
        }
        isEven() {
          throw new Error("Not implemented.")
        }
        isSquare() {
          throw new Error("Not implemented.")
        }
        eqX(e) {
          throw new Error("Not implemented.")
        }
        eqR(e) {
          throw new Error("Not implemented.")
        }
        isSmall() {
          return this.isInfinity() ? !1 : this.jmulH().isInfinity()
        }
        hasTorsion() {
          return this.isInfinity() ? !1 : !this.jmul(this.curve.n).isInfinity()
        }
        order() {
          let {
            h: e,
            n: t
          } = this.curve, i = this.toJ(), n = new we(1);
          for (; !i.isInfinity();) {
            if (n.iaddn(1), n.cmp(e) > 0) {
              n = t.clone();
              break
            }
            i = i.add(this)
          }
          return n
        }
        mul(e) {
          return this.jmul(e)
        }
        muln(e) {
          return this.jmuln(e)
        }
        mulBlind(e, t) {
          return this.jmulBlind(e, t)
        }
        mulAdd(e, t, i) {
          return this.jmulAdd(e, t, i)
        }
        mulH() {
          return this.jmulH()
        }
        div(e) {
          return this.jdiv(e)
        }
        divn(e) {
          return this.jdivn(e)
        }
        divH() {
          return this.jdivH()
        }
        jmul(e) {
          return f2e && this._hasWindows(e) ? this.curve._fixedMul(this, e) : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo && this.type === xc.AFFINE ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(5, this, e)
        }
        jmuln(e) {
          return z((e | 0) === e), this.jmul(new we(e))
        }
        jmulBlind(e, t = null) {
          let [i, n, s] = this._blind(e, t), o = i.jmul(n);
          return s ? o.add(s) : o
        }
        jmulAdd(e, t, i) {
          return this.curve.endo && this.type === xc.AFFINE ? this.curve._endoWnafMulAdd([this, t], [e, i]) : this.curve._wnafMulAdd(5, [this, t], [e, i])
        }
        jmulH() {
          let e = this.curve.h.word(0);
          if ((e & e - 1) == 0) {
            let t = this.curve.h.bitLength();
            return this.toJ().dblp(t - 1)
          }
          return this.jmul(this.curve.h)
        }
        jdiv(e) {
          return z(e instanceof we), z(!e.red), this.jmul(e.invert(this.curve.n))
        }
        jdivn(e) {
          return z(!this.curve.n.isZero()), this.curve.h.cmpn(e) === 0 ? this.jdivH() : this.jdiv(new we(e))
        }
        jdivH() {
          return this.curve.n.isZero() ? this.toJ() : this.curve.h.cmpn(1) === 0 ? this.toJ() : (this.curve.hi === null && (this.curve.hi = this.curve.h.invert(this.curve.n)), this.jmul(this.curve.hi))
        }
        toP() {
          return this.normalize()
        }
        toJ() {
          return this
        }
        toX() {
          return this
        }
        key() {
          if (this.isInfinity()) return `${this.curve.uid}:oo`;
          this.normalize();
          let e = this.getX().toString(16),
            t = this.getY().toString(16);
          return `${this.curve.uid}:${e},${t}`
        }
        encode(e) {
          throw new Error("Not implemented.")
        }
        static decode(e, t) {
          throw new Error("Not implemented.")
        }
        encodeX() {
          throw new Error("Not implemented.")
        }
        static decodeX(e, t) {
          throw new Error("Not implemented.")
        }
        static decodeEven(e, t) {
          throw new Error("Not implemented.")
        }
        static decodeSquare(e, t) {
          throw new Error("Not implemented.")
        }
        toJSON(e) {
          throw new Error("Not implemented.")
        }
        static fromJSON(e, t) {
          throw new Error("Not implemented.")
        } [Qp]() {
          return "<Point>"
        }
      }, Ir = class extends es {
        constructor(e) {
          super(Gr, "short", e);
          this.a = we.fromJSON(e.a).toRed(this.red), this.b = we.fromJSON(e.b).toRed(this.red), this.c = we.fromJSON(e.c || "0").toRed(this.red), this.ai = this.a.isZero() ? this.zero : this.a.redInvert(), this.zi = this.z.isZero() ? this.zero : this.z.redInvert(), this.zeroA = this.a.isZero(), this.threeA = this.a.eq(this.three.redNeg()), this.redN = this.n.toRed(this.red), this.pmodn = this.p.clone(), this.highOrder = this.n.cmp(this.p) >= 0, this.smallGap = !1, this._finalize(e)
        }
        _finalize(e) {
          return super._finalize(e), e.endo != null ? this.endo = bk.fromJSON(this, e.endo) : this.endo = this._getEndomorphism(), this.n.isZero() || (this.pmodn = this.p.mod(this.n), this.smallGap = this.p.div(this.n).cmpn(1) <= 0), this
        }
        static _isomorphism(e, t, i, n) {
          if (z(e instanceof we), z(t instanceof we), z(i instanceof we), z(n == null || typeof n == "boolean"), z(!e.isZero() || !t.isZero()), i.isZero()) throw new Error("Invalid coefficient.");
          if (e.isZero()) {
            let h = i,
              d = h.redDiv(t),
              p = p2e(d);
            return z(p.redJacobi() === 1), [e.clone(), h.clone()]
          }
          if (t.isZero()) {
            let h = i,
              p = h.redDiv(e).redSqrt();
            if (p.redJacobi() !== 1 && p.redINeg(), p.redJacobi() !== 1) throw new Error("Invalid `a` coefficient.");
            return [h.clone(), t.clone()]
          }
          let s = i,
            o = s.redDiv(e),
            a = o.redSqrt();
          if (n != null ? a.redIsOdd() !== n && a.redINeg() : a.redJacobi() !== 1 && a.redINeg(), a.redJacobi() !== 1) throw new Error("Invalid `a` coefficient.");
          let c = o.redMul(a),
            u = e.redMul(o),
            f = t.redMul(c);
          return z(u.eq(s)), [u, f]
        }
        _short(e, t) {
          return Ir._isomorphism(this.a, this.b, e, t)
        }
        _mont(e, t) {
          let [i, n] = this._findRS(t), s = n.redInvert(), o = i.redMuln(3).redMul(s);
          return e != null ? $r._isomorphism(o, s, e) : [o, s]
        }
        _edwards(e, t) {
          let [i, n] = this._findRS(t), s = i.redMuln(3), o = n.redMuln(2), a = s.redAdd(o), c = s.redSub(o);
          return e != null ? sn._isomorphism(a, c, e) : [a, c]
        }
        _findRS(e) {
          z(e == null || typeof e == "boolean"), z(this.h.word(0) >= 4), z(!this.n.isZero());
          let t = this.one.redNeg(),
            i;
          for (; ;) {
            t.redIAdd(this.one);
            try {
              i = this.pointFromX(t.clone())
            } catch (a) {
              continue
            }
            if (i = i.mul(this.n), !i.isInfinity() && !!i.y.isZero()) break
          }
          let n = i.x,
            o = n.redSqr().redMuln(3).redIAdd(this.a).redSqrt();
          return e != null && o.redIsOdd() !== e && o.redINeg(), [n, o]
        }
        _scale0(e, t) {
          if (z(this.a.isZero() === e.isZero()), z(this.b.isZero() === t.isZero()), this.a.isZero()) {
            let c = this.b.redDiv(this.field(t)),
              u = p2e(c),
              f = u.redSqrt(),
              h = u.redMul(f);
            return z(h.redSqr().eq(c)), z(!f.isZero()), [u, h]
          }
          if (this.b.isZero()) {
            let c = this.a.redDiv(this.field(e)),
              u = c.redSqrt();
            u.redJacobi() !== 1 && u.redINeg();
            let f = u.redSqrt(),
              h = u.redMul(f);
            return z(h.redMul(f).eq(c)), z(!f.isZero()), [u, h]
          }
          let i = this.a.redDiv(this.field(e)),
            n = this.b.redDiv(this.field(t)),
            s = i.redSqrt();
          i.redMul(s).eq(n) || s.redINeg(), z(i.redMul(s).eq(n));
          let o = s.redSqrt(),
            a = s.redMul(o);
          return z(!o.isZero()), [s, a]
        }
        _scale1(e, t) {
          let i = this.g.x.redDiv(this.field(e)),
            n = this.g.y.redDiv(this.field(t)),
            s = i.redSqrt();
          return i.redMul(s).eq(n) || s.redINeg(), z(i.redMul(s).eq(n)), z(!s.isZero()), [i, n]
        }
        _scaleShort(e) {
          return z(e instanceof Ir), this.g.isInfinity() || e.g.isInfinity() ? this._scale0(e.a, e.b) : this._scale1(e.g.x, e.g.y)
        }
        _scaleMont(e) {
          if (z(e instanceof $r), this.g.isInfinity() || e.g.isInfinity()) {
            let [o, a] = e._short();
            return this._scale0(o, a)
          }
          let {
            x: t,
            y: i
          } = e.g, n = t.redAdd(e.a3).redMul(e.bi), s = i.redMul(e.bi);
          return this._scale1(n, s)
        }
        _scaleEdwards(e) {
          if (z(e instanceof sn), this.g.isInfinity() || e.g.isInfinity()) {
            let [q, J] = e._short();
            return this._scale0(q, J)
          }
          let {
            x: t,
            y: i,
            z: n
          } = e.g, s = e.a.redMuln(5), o = e.d.redMuln(5), a = e.d.redSub(e.a), c = o.redSub(e.a), u = e.d.redSub(s), f = i.redAdd(n), h = i.redSub(n), d = c.redMul(i).redIAdd(u.redMul(n)), p = h.redMuln(12), g = a.redMul(f).redMul(n), m = h.redMul(t).redIMuln(4), E = p.redMul(m).redInvert(), w = d.redMul(m).redMul(E), O = g.redMul(p).redMul(E);
          return this._scale1(w, O)
        }
        _getEndomorphism(e = 0) {
          if (this.n.isZero() || this.g.isInfinity() || !this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1) return null;
          let [t, i] = this._getEndoRoots(this.p), n = [t, i][e & 1].toRed(this.red), [s, o] = this._getEndoRoots(this.n), a = this.point(this.g.x.redMul(n), this.g.y), c;
          this.g.mul(s).eq(a) ? c = s : (z(this.g.mul(o).eq(a)), c = o);
          let u = this._getEndoBasis(c),
            f = this._getEndoPrecomp(u);
          return new bk(n, c, u, f)
        }
        _getEndoRoots(e) {
          let t = e === this.p ? this.red : we.mont(e),
            i = new we(2).toRed(t),
            n = new we(3).toRed(t),
            s = i.redInvert(),
            o = n.redNeg().redSqrt().redMul(s),
            a = o.redNeg(),
            c = o.redSub(s).fromRed(),
            u = a.redSub(s).fromRed();
          return [c, u].sort(we.cmp)
        }
        _getEndoBasis(e) {
          let [t, i, n, s, o, a] = this._egcdSqrt(e), c = n, u = s.neg(), f = t.sqr().iadd(i.sqr()), h = o.sqr().iadd(a.sqr()), d, p;
          return f.cmp(h) <= 0 ? (d = t, p = i.neg()) : (d = o, p = a.neg()), [new Fh(c, u), new Fh(d, p)]
        }
        _egcdSqrt(e) {
          z(e instanceof we), z(!e.red), z(e.sign() > 0), z(this.n.sign() > 0);
          let t = this.n.ushrn(this.n.bitLength() >>> 1),
            i = e,
            n = this.n.clone(),
            s = new we(1),
            o = new we(0),
            a = new we(0),
            c = new we(1),
            u, f, h, d, p = 0,
            g = 0,
            m;
          for (; !i.isZero() && p < 2;) {
            let O = n.quo(i),
              q = n.sub(O.mul(i)),
              J = a.sub(O.mul(s)),
              Z = c.sub(O.mul(o));
            g === 0 && q.cmp(t) < 0 && (u = m, f = s, h = q, d = J, g = 1), m = q, n = i, i = q, a = s, s = J, c = o, o = Z, p += g
          }
          return z(g !== 0, "Could not find r < sqrt(n)."), [u, f, h, d, a, s]
        }
        _getEndoPrecomp(e) {
          z(Array.isArray(e)), z(e.length === 2), z(e[0] instanceof Fh), z(e[1] instanceof Fh);
          let [t, i] = e, n = t.a.mul(i.b).isub(t.b.mul(i.a)), s = n.bitLength(), o = s >= 160;
          z(n.eq(this.n));
          let a = s + Math.ceil(s / 2) + 1,
            c, u;
          for (o && (a -= a & 63); a > s && (c = i.b.ushln(a).divRound(n), u = t.b.ushln(a).divRound(n), !(c.ucmp(n) < 0 && u.ucmp(n) < 0));) o ? a -= 64 : a -= 1;
          if (a <= s) throw new Error("Could not calculate g1 and g2.");
          return [a, c, u]
        }
        _endoSplit(e) {
          z(e instanceof we), z(!e.red), z(!this.n.isZero());
          let [t, i] = this.endo.basis, n = i.b.mul(e).divRound(this.n), s = t.b.neg().mul(e).divRound(this.n), o = n.mul(t.a), a = s.mul(i.a), c = n.ineg().mul(t.b), u = s.mul(i.b), f = e.sub(o).isub(a), h = c.isub(u);
          return [f, h]
        }
        _endoBeta(e) {
          return z(e instanceof Gr), [e, e._getBeta()]
        }
        _endoWnafMulAdd(e, t) {
          z(Array.isArray(e)), z(Array.isArray(t)), z(e.length === t.length), z(this.endo != null);
          let i = e.length,
            n = new Array(i * 2),
            s = new Array(i * 2);
          for (let o = 0; o < i; o++) {
            let [a, c] = this._endoBeta(e[o]), [u, f] = this._endoSplit(t[o]);
            n[o * 2 + 0] = a, s[o * 2 + 0] = u, n[o * 2 + 1] = c, s[o * 2 + 1] = f
          }
          return this._wnafMulAdd(5, n, s)
        }
        _sswu(e) {
          let {
            b: t,
            z: i,
            ai: n,
            zi: s,
            one: o
          } = this, a = i.redSqr(), c = t.redNeg().redMul(n), u = t.redMul(s).redMul(n), f = e.redSqr(), h = f.redSqr(), d = a.redMul(h).redIAdd(i.redMul(f)), p = d.isZero() ? d : d.redInvert(), g = p.isZero() ? u : c.redMul(o.redAdd(p)), m = i.redMul(f).redMul(g), E = this.solveY2(g), w = this.solveY2(m), O = E.redIsSquare() | 0, q = [g, m][O ^ 1], J = [E, w][O ^ 1].redSqrt();
          return J.redIsOdd() !== e.redIsOdd() && J.redINeg(), this.point(q, J)
        }
        _sswui(e, t) {
          let {
            a: i,
            b: n,
            z: s
          } = this, {
            x: o,
            y: a
          } = e, c = t & 3, u = i.redSqr().redMul(o.redSqr()), f = i.redMul(n).redMul(o).redIMuln(2), h = n.redSqr().redMuln(3), d = i.redMul(o).redIAdd(n), p = u.redISub(f).redISub(h).redSqrt(), g = d.redSub(p).redINeg(), m = d.redAdd(p).redINeg(), E = d.redMul(s).redIMuln(2), w = n.redMul(s).redIMuln(2), O = [g, m][c & 1], q = [E, w][c >>> 1], J = O.redDivSqrt(q);
          return J.redIsOdd() !== a.redIsOdd() && J.redINeg(), J
        }
        _svdwf(e) {
          let {
            c: t,
            z: i,
            zi: n,
            i2: s,
            i3: o
          } = this, a = this.solveY2(i), c = o.redMul(n.redSqr()), u = e.redSqr(), f = u.redSqr(), h = u.redAdd(a), d = u.redMul(h), p = d.isZero() ? d : d.redInvert(), g = f.redMul(p).redMul(t), m = h.redSqr().redMul(h), E = t.redSub(i).redMul(s).redISub(g), w = g.redSub(t.redAdd(i).redMul(s)), O = i.redSub(m.redMul(p).redMul(c)), q = this.solveY2(E), J = this.solveY2(w), Z = this.solveY2(O), H = q.redJacobi() | 1, te = J.redJacobi() | 1, ae = wlt((H - 1) * te, 3), oe = [E, w, O][ae], U = [q, J, Z][ae];
          return [oe, U]
        }
        _svdw(e) {
          let [t, i] = this._svdwf(e), n = i.redSqrt();
          return n.redIsOdd() !== e.redIsOdd() && n.redINeg(), this.point(t, n)
        }
        _svdwi(e, t) {
          let {
            b: i,
            c: n,
            z: s,
            zero: o,
            two: a
          } = this, {
            x: c,
            y: u
          } = e, f = t & 3, h = s.redSqr(), d = h.redMul(s), p = h.redSqr(), g = d.redAdd(i), m = g.redMuln(2), E = c.redSqr(), w = c.redMuln(2).redIAdd(s), O = c.redMul(h), q = n.redSub(w), J = n.redAdd(w), Z = E.redMul(h).redIAdd(p).redIMuln(9), H = c.redMul(d).redIMuln(18), te = g.redMul(c.redSub(s)).redIMuln(12), oe = (f >= 2 ? Z.redISub(H).redIAdd(te).redSqrt() : o).redMul(s), U = d.redISub(O).redIMuln(3).redISub(m), b = g.redMul(q), _ = g.redMul(J), R = U.redAdd(oe), D = U.redSub(oe), K = a, ee = [b, _, R, D][f], re = [J, q, K, K][f], V = ee.redDivSqrt(re), [v] = this._svdwf(V);
          if (!v.eq(c)) throw new Error("Invalid point.");
          return V.redIsOdd() !== u.redIsOdd() && V.redINeg(), V
        }
        isElliptic() {
          let {
            a: e,
            b: t
          } = this, n = e.redSqr().redMul(e);
          return !t.redSqr().redMuln(27).redIAdd(n.redMuln(4)).isZero()
        }
        jinv() {
          let {
            a: e,
            b: t
          } = this, n = e.redSqr().redMul(e), s = t.redSqr(), o = n.redMuln(4), a = o.redMuln(1728), c = s.redMuln(27).redIAdd(o);
          if (c.isZero()) throw new Error("Curve is not elliptic.");
          return a.redDiv(c).fromRed()
        }
        point(e, t) {
          return new Gr(this, e, t)
        }
        jpoint(e, t, i) {
          return new Lh(this, e, t, i)
        }
        solveX(e) {
          if (z(e instanceof we), !this.a.isZero()) throw new Error("Not implemented.");
          let i = e.redSqr().redSub(this.b);
          return d2e(i)
        }
        solveY2(e) {
          z(e instanceof we);
          let i = e.redSqr().redMul(e).redIAdd(this.b);
          return this.zeroA || (this.threeA ? i.redIAdd(e.redMuln(-3)) : i.redIAdd(this.a.redMul(e))), i
        }
        validate(e) {
          if (z(e instanceof Gr), e.inf) return !0;
          let {
            x: t,
            y: i
          } = e, n = this.solveY2(t);
          return i.redSqr().eq(n)
        }
        pointFromX(e, t = null) {
          z(e instanceof we), z(t == null || typeof t == "boolean"), e.red || (e = e.toRed(this.red));
          let i = this.solveY(e);
          if (t != null) {
            if (this.h.cmpn(1) > 0 && i.isZero() && t) throw new Error("Invalid point.");
            i.redIsOdd() !== t && i.redINeg()
          }
          return this.point(e, i)
        }
        pointFromY(e, t = 0) {
          z(e instanceof we), z(t >>> 0 === t), e.red || (e = e.toRed(this.red));
          let i = this.solveX(e);
          if (t >= i.length) throw new Error("Invalid X coordinate index.");
          let n = i[t];
          return this.point(n, e)
        }
        isIsomorphic(e) {
          if (z(e instanceof es), !e.p.eq(this.p)) return !1;
          let t, i;
          try {
            [t, i] = this._scale(e)
          } catch (n) {
            return !1
          }
          if (e.type === "short") {
            let n = this.field(e.a).redMul(t.redSqr()),
              s = this.field(e.b).redMul(i.redSqr());
            return this.a.eq(n) && this.b.eq(s)
          }
          if (e.type === "mont") {
            let {
              a3: n,
              bi: s
            } = e, o = this.field(n.redMul(s)).redMul(t);
            return this.solveY2(o).isZero()
          }
          if (e.type === "edwards") {
            let n = this.field(e.ad6).redMul(t);
            return this.solveY2(n).isZero()
          }
          return !1
        }
        isIsogenous(e) {
          return z(e instanceof es), !1
        }
        pointFromShort(e) {
          if (z(e instanceof Gr), this.isIsomorphic(e.curve)) {
            if (e.isInfinity()) return this.point();
            let [t, i] = this._scale(e.curve), n = this.field(e.x), s = this.field(e.y), o = n.redMul(t), a = s.redMul(i);
            return this.point(o, a)
          }
          throw new Error("Not implemented.")
        }
        pointFromMont(e) {
          if (z(e instanceof On), this.isIsomorphic(e.curve)) {
            if (e.isInfinity()) return this.point();
            let {
              a3: t,
              bi: i
            } = e.curve, [n, s] = this._scale(e.curve), o = e.x.redAdd(t).redMul(i), a = e.y.redMul(i);
            return this.point(this.field(o).redMul(n), this.field(a).redMul(s))
          }
          throw new Error("Not implemented.")
        }
        pointFromEdwards(e) {
          if (z(e instanceof Nn), this.isIsomorphic(e.curve)) {
            let {
              a: t,
              d: i,
              ad6: n
            } = e.curve, [s, o] = this._scale(e.curve);
            if (e.isInfinity()) return this.point();
            if (e.x.isZero()) {
              let Z = this.field(n).redMul(s);
              return this.point(Z, this.zero)
            }
            let {
              x: a,
              y: c,
              z: u
            } = e, f = t.redMuln(5), h = i.redMuln(5), d = i.redSub(t), p = h.redSub(t), g = i.redSub(f), m = c.redAdd(u), E = c.redSub(u), w = p.redMul(c).redIAdd(g.redMul(u)), O = E.redMuln(12), q = d.redMul(m).redMul(u), J = E.redMul(a).redIMuln(4);
            return this.cpoint(this.field(w).redMul(s), this.field(O), this.field(q).redMul(o), this.field(J))
          }
          throw new Error("Not implemented.")
        }
        pointFromUniform(e) {
          if (z(e instanceof we), this.z.isZero() || this.b.isZero()) throw new Error("Not implemented.");
          if (!this.a.isZero()) return this._sswu(e);
          if (!this.c.isZero()) return this._svdw(e);
          throw new Error("Not implemented.")
        }
        pointToUniform(e, t) {
          if (z(e instanceof Gr), z(t >>> 0 === t), this.z.isZero() || this.b.isZero()) throw new Error("Not implemented.");
          if (e.isInfinity()) throw new Error("Invalid point.");
          let i = (t >>> 4 & 15) % this.torsion.length,
            n = e.add(this.torsion[i]);
          return h2e(() => {
            if (!this.a.isZero()) return this._sswui(n, t);
            if (!this.c.isZero()) return this._svdwi(n, t);
            throw new Error("Not implemented.")
          })
        }
        mulAll(e, t) {
          return super.mulAll(e, t).toP()
        }
        affinizeAll(e) {
          let t = this.normalizeAll(e);
          for (let i = 0; i < t.length; i++) t[i] = t[i].toP();
          return t
        }
        decodePoint(e) {
          return Gr.decode(this, e)
        }
        encodeX(e) {
          return z(e instanceof Dr), e.encodeX()
        }
        decodeEven(e) {
          return Gr.decodeEven(this, e)
        }
        decodeSquare(e) {
          return Gr.decodeSquare(this, e)
        }
        toShort(e, t, i = null) {
          let [n, s] = this._short(e, t), o = new Ir({
            red: this.red,
            prime: this.prime,
            p: this.p,
            a: n,
            b: s,
            n: this.n,
            h: this.h
          });
          if (i != null) {
            let [, a] = o._scale(this);
            a.redIsOdd() !== i && a.redINeg()
          }
          this.g.isInfinity() || (o.g = o.pointFromShort(this.g));
          for (let a = 0; a < this.h.word(0); a++) o.torsion[a] = o.pointFromShort(this.torsion[a]);
          return o
        }
        toMont(e, t, i = null) {
          let [n, s] = this._mont(e, t), o = new $r({
            red: this.red,
            prime: this.prime,
            p: this.p,
            a: n,
            b: s,
            n: this.n,
            h: this.h
          });
          if (i != null) {
            let [, a] = this._scale(o);
            a.redIsOdd() !== i && a.redINeg()
          }
          this.g.isInfinity() || (o.g = o.pointFromShort(this.g));
          for (let a = 0; a < this.h.word(0); a++) o.torsion[a] = o.pointFromShort(this.torsion[a]);
          return o
        }
        toEdwards(e, t, i = null) {
          let [n, s] = this._edwards(e, t), o = new sn({
            red: this.red,
            prime: this.prime,
            p: this.p,
            a: n,
            d: s,
            n: this.n,
            h: this.h
          });
          if (i != null) {
            let [, a] = this._scale(o);
            a.redIsOdd() !== i && a.redINeg()
          }
          if (this.g.isInfinity() || (o.g = o.pointFromShort(this.g), o.g.normalize()), o.isComplete())
            for (let a = 0; a < this.h.word(0); a++) o.torsion[a] = o.pointFromShort(this.torsion[a]), o.torsion[a].normalize();
          return o
        }
        pointFromJSON(e) {
          return Gr.fromJSON(this, e)
        }
        toJSON(e) {
          let t = super.toJSON(e);
          return t.a = this.a.fromRed().toJSON(), t.b = this.b.fromRed().toJSON(), this.c.isZero() || (t.c = this.c.fromRed().toJSON()), t
        }
      }, Gr = class extends Dr {
        constructor(e, t, i) {
          z(e instanceof Ir), super(e, xc.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, t != null && this._init(t, i)
        }
        _init(e, t) {
          z(e instanceof we), z(t instanceof we), this.x = e, this.y = t, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1
        }
        _getBeta() {
          if (!this.curve.endo) return null;
          if (this.pre && this.pre.beta) return this.pre.beta;
          let e = this.x.redMul(this.curve.endo.beta),
            t = this.curve.point(e, this.y);
          return this.pre && (t.pre = this.pre.map(i => {
            let n = i.x.redMul(this.curve.endo.beta);
            return this.curve.point(n, i.y)
          }), this.pre.beta = t), t
        }
        _getJNAF(e) {
          if (z(e instanceof Gr), this.inf || e.inf) return super._getJNAF(e);
          let t = [this, null, null, e];
          return this.y.eq(e.y) ? (t[1] = this.add(e), t[2] = this.toJ().sub(e)) : this.y.eq(e.y.redNeg()) ? (t[1] = this.toJ().add(e), t[2] = this.sub(e)) : (t[1] = this.toJ().add(e), t[2] = this.toJ().sub(e)), t
        }
        clone() {
          return this.inf ? this.curve.point() : this.curve.point(this.x, this.y)
        }
        scale(e) {
          return this.toJ().scale(e)
        }
        neg() {
          return this.inf ? this : this.curve.point(this.x, this.y.redNeg())
        }
        add(e) {
          if (z(e instanceof Gr), this.inf) return e;
          if (e.inf) return this;
          if (this.x.eq(e.x)) return this.y.eq(e.y) ? this.dbl() : this.curve.point();
          if (this.y.eq(e.y)) {
            let a = this.x.redNeg().redISub(e.x),
              c = this.y.redNeg();
            return this.curve.point(a, c)
          }
          let t = this.x.redSub(e.x),
            n = this.y.redSub(e.y).redDiv(t),
            s = n.redSqr().redISub(this.x).redISub(e.x),
            o = n.redMul(this.x.redSub(s)).redISub(this.y);
          return this.curve.point(s, o)
        }
        dbl() {
          if (this.inf) return this;
          if (this.y.isZero()) return this.curve.point();
          let t = this.x.redSqr().redIMuln(3).redIAdd(this.curve.a),
            i = this.y.redMuln(2),
            n = t.redDiv(i),
            s = n.redSqr().redISub(this.x).redISub(this.x),
            o = n.redMul(this.x.redSub(s)).redISub(this.y);
          return this.curve.point(s, o)
        }
        dblp(e) {
          return this.toJ().dblp(e).toP()
        }
        getX() {
          if (this.inf) throw new Error("Invalid point.");
          return this.x.fromRed()
        }
        getY() {
          if (this.inf) throw new Error("Invalid point.");
          return this.y.fromRed()
        }
        eq(e) {
          return z(e instanceof Gr), this === e ? !0 : this.inf ? e.inf : e.inf ? !1 : this.x.eq(e.x) && this.y.eq(e.y)
        }
        cmp(e) {
          return z(e instanceof Gr), this.inf && !e.inf ? -1 : !this.inf && e.inf ? 1 : this.inf && e.inf ? 0 : this.order().cmp(e.order()) || this.getX().cmp(e.getX()) || this.getY().cmp(e.getY())
        }
        isInfinity() {
          return this.inf
        }
        isOrder2() {
          return this.inf ? !1 : this.y.isZero()
        }
        isOdd() {
          return this.inf ? !1 : this.y.redIsOdd()
        }
        isEven() {
          return this.inf ? !1 : this.y.redIsEven()
        }
        isSquare() {
          return this.inf ? !1 : this.y.redJacobi() !== -1
        }
        eqX(e) {
          return z(e instanceof we), z(!e.red), this.inf ? !1 : this.getX().eq(e)
        }
        eqR(e) {
          return z(e instanceof we), z(!e.red), z(!this.curve.n.isZero()), this.inf ? !1 : this.getX().imod(this.curve.n).eq(e)
        }
        mul(e) {
          return super.mul(e).toP()
        }
        muln(e) {
          return super.muln(e).toP()
        }
        mulBlind(e, t) {
          return super.mulBlind(e, t).toP()
        }
        mulAdd(e, t, i) {
          return super.mulAdd(e, t, i).toP()
        }
        mulH() {
          return super.mulH().toP()
        }
        div(e) {
          return super.div(e).toP()
        }
        divn(e) {
          return super.divn(e).toP()
        }
        divH() {
          return super.divH().toP()
        }
        toP() {
          return this
        }
        toJ() {
          return this.inf ? this.curve.jpoint() : this.curve.jpoint(this.x, this.y, this.curve.one)
        }
        encode(e) {
          e == null && (e = !0), z(typeof e == "boolean");
          let {
            fieldSize: t
          } = this.curve;
          if (this.inf) throw new Error("Invalid point.");
          if (e) {
            let o = Buffer.alloc(1 + t),
              a = this.curve.encodeField(this.getX());
            return o[0] = 2 | this.y.redIsOdd(), a.copy(o, 1), o
          }
          let i = Buffer.alloc(1 + t * 2),
            n = this.curve.encodeField(this.getX()),
            s = this.curve.encodeField(this.getY());
          return i[0] = 4, n.copy(i, 1), s.copy(i, 1 + t), i
        }
        static decode(e, t) {
          z(e instanceof Ir), z(Buffer.isBuffer(t));
          let i = e.fieldSize;
          if (t.length < 1 + i) throw new Error("Not a point.");
          let n = t[0];
          switch (n) {
            case 2:
            case 3: {
              if (t.length !== 1 + i) throw new Error("Invalid point size for compressed.");
              let s = e.decodeField(t.slice(1, 1 + i));
              if (s.cmp(e.p) >= 0) throw new Error("Invalid point.");
              let o = e.pointFromX(s, n === 3);
              return z(!o.isInfinity()), o
            }
            case 4:
            case 6:
            case 7: {
              if (t.length !== 1 + i * 2) throw new Error("Invalid point size for uncompressed.");
              let s = e.decodeField(t.slice(1, 1 + i)),
                o = e.decodeField(t.slice(1 + i, 1 + 2 * i));
              if (s.cmp(e.p) >= 0 || o.cmp(e.p) >= 0) throw new Error("Invalid point.");
              if (n !== 4 && n !== (6 | o.isOdd())) throw new Error("Invalid hybrid encoding.");
              let a = e.point(s, o);
              if (!a.validate()) throw new Error("Invalid point.");
              return z(!a.isInfinity()), a
            }
            default:
              throw new Error("Unknown point format.")
          }
        }
        encodeX() {
          return this.curve.encodeField(this.getX())
        }
        static decodeEven(e, t) {
          z(e instanceof Ir);
          let i = e.decodeField(t);
          if (i.cmp(e.p) >= 0) throw new Error("Invalid point.");
          return e.pointFromX(i, !1)
        }
        static decodeSquare(e, t) {
          z(e instanceof Ir);
          let i = e.decodeField(t);
          if (i.cmp(e.p) >= 0) throw new Error("Invalid point.");
          return e.pointFromX(i)
        }
        toJSON(e) {
          if (this.inf) return [];
          let t = this.getX().toJSON(),
            i = this.getY().toJSON();
          return e === !0 && this.pre ? [t, i, this.pre.toJSON()] : [t, i]
        }
        toPretty() {
          if (this.inf) return [];
          let e = this.curve.fieldSize * 2,
            t = e1(this.getX(), e),
            i = e1(this.getY(), e);
          return [t, i]
        }
        static fromJSON(e, t) {
          if (z(e instanceof Ir), z(Array.isArray(t)), z(t.length === 0 || t.length === 2 || t.length === 3), t.length === 0) return e.point();
          let i = we.fromJSON(t[0]),
            n = we.fromJSON(t[1]),
            s = e.point(i, n);
          return t.length > 2 && t[2] != null && (s.pre = t4.fromJSON(s, t[2])), s
        } [Qp]() {
          return this.inf ? "<ShortPoint: Infinity>" : "<ShortPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">"
        }
      }, Lh = class extends Dr {
        constructor(e, t, i, n) {
          z(e instanceof Ir), super(e, xc.JACOBIAN), this.x = this.curve.one, this.y = this.curve.one, this.z = this.curve.zero, this.zOne = !1, t != null && this._init(t, i, n)
        }
        _init(e, t, i) {
          z(e instanceof we), z(t instanceof we), z(i == null || i instanceof we), this.x = e, this.y = t, this.z = i || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one)
        }
        clone() {
          return this.curve.jpoint(this.x, this.y, this.z)
        }
        validate() {
          let {
            a: e,
            b: t
          } = this.curve;
          if (this.isInfinity()) return !0;
          if (this.zOne) return this.curve.validate(this.toP());
          let i = this.y.redSqr(),
            n = this.x.redSqr().redMul(this.x),
            s = this.z.redSqr(),
            o = s.redSqr(),
            a = o.redMul(s),
            c = n.redIAdd(t.redMul(a));
          return this.curve.zeroA || (this.curve.threeA ? c.redIAdd(o.redIMuln(-3).redMul(this.x)) : c.redIAdd(e.redMul(o).redMul(this.x))), i.eq(c)
        }
        normalize() {
          if (this.zOne) return this;
          if (this.isInfinity()) return this;
          let e = this.z.redInvert(),
            t = e.redSqr();
          return this.x = this.x.redMul(t), this.y = this.y.redMul(t).redMul(e), this.z = this.curve.one, this.zOne = !0, this
        }
        scale(e) {
          if (z(e instanceof we), this.isInfinity()) return this.curve.jpoint();
          let t = e.redSqr(),
            i = this.x.redMul(t),
            n = this.y.redMul(t).redMul(e),
            s = this.z.redMul(e);
          return this.curve.jpoint(i, n, s)
        }
        neg() {
          return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
        }
        add(e) {
          return z(e instanceof Dr), e.type === xc.AFFINE ? this._mixedAdd(e) : this._add(e)
        }
        _add(e) {
          return z(e instanceof Lh), this.isInfinity() ? e : e.isInfinity() ? this : this.zOne ? e._addJA(this) : e.zOne ? this._addJA(e) : this._addJJ(e)
        }
        _mixedAdd(e) {
          return z(e instanceof Gr), this.isInfinity() ? e.toJ() : e.isInfinity() ? this : this._addJA(e)
        }
        _addJJ(e) {
          let t = this.z.redSqr(),
            i = e.z.redSqr(),
            n = this.x.redMul(i),
            s = e.x.redMul(t),
            o = this.y.redMul(e.z).redMul(i),
            a = e.y.redMul(this.z).redMul(t),
            c = s.redISub(n),
            u = a.redISub(o);
          if (c.isZero()) return u.isZero() ? this.dbl() : this.curve.jpoint();
          let f = c.redSqr(),
            h = c.redMul(f),
            d = n.redMul(f),
            p = u.redSqr().redISub(h).redISub(d).redISub(d),
            g = u.redMul(d.redISub(p)).redISub(o.redMul(h)),
            m = this.z.redMul(e.z).redMul(c);
          return this.curve.jpoint(p, g, m)
        }
        _addJA(e) {
          let t = this.z.redSqr(),
            i = e.x.redMul(t),
            n = e.y.redMul(this.z).redMul(t),
            s = i.redISub(this.x),
            o = n.redISub(this.y).redIMuln(2);
          if (s.isZero()) return o.isZero() ? this.dbl() : this.curve.jpoint();
          let a = s.redMuln(2).redSqr(),
            c = s.redMul(a),
            u = this.x.redMul(a),
            f = o.redSqr().redISub(c).redISub(u).redISub(u),
            h = o.redMul(u.redISub(f)).redISub(this.y.redMul(c).redIMuln(2)),
            d = this.z.redMul(s).redIMuln(2);
          return this.curve.jpoint(f, h, d)
        }
        dbl() {
          return this.isInfinity() ? this : this.y.isZero() ? this.curve.jpoint() : this.curve.zeroA ? this._dbl0() : this.curve.threeA ? this._dbl3() : this._dblJ()
        }
        _dblJ() {
          let e = this.x.redSqr(),
            t = this.y.redSqr(),
            i = this.z.redSqr(),
            n = this.x.redMul(t).redIMuln(4),
            s = e.redIMuln(3).redIAdd(this.curve.a.redMul(i.redSqr())),
            o = s.redSqr().redISub(n).redISub(n),
            a = o,
            c = s.redMul(n.redISub(o)).redISub(t.redSqr().redIMuln(8)),
            u = this.y.redMul(this.z).redIMuln(2);
          return this.curve.jpoint(a, c, u)
        }
        _dbl0() {
          let e = this.x.redSqr(),
            t = this.y.redSqr(),
            i = t.redSqr(),
            s = t.redIAdd(this.x).redSqr().redISub(e).redISub(i).redIMuln(2),
            o = e.redIMuln(3),
            c = o.redSqr().redISub(s).redISub(s),
            u = o.redMul(s.redISub(c)).redISub(i.redIMuln(8)),
            f = this.y.redMul(this.z).redIMuln(2);
          return this.curve.jpoint(c, u, f)
        }
        _dbl3() {
          let e = this.z.redSqr(),
            t = this.y.redSqr(),
            i = this.x.redMul(t),
            n = this.x.redSub(e),
            s = this.x.redAdd(e),
            o = n.redMul(s).redIMuln(3),
            a = i.redIMuln(4),
            c = a.redMuln(2),
            u = t.redSqr().redIMuln(8),
            f = o.redSqr().redISub(c),
            h = this.y.redAdd(this.z).redSqr().redISub(t).redISub(e),
            d = o.redMul(a.redISub(f)).redISub(u);
          return this.curve.jpoint(f, d, h)
        }
        getX() {
          if (this.isInfinity()) throw new Error("Invalid point.");
          return this.normalize(), this.x.fromRed()
        }
        getY() {
          if (this.isInfinity()) throw new Error("Invalid point.");
          return this.normalize(), this.y.fromRed()
        }
        eq(e) {
          if (z(e instanceof Lh), this === e) return !0;
          if (this.isInfinity()) return e.isInfinity();
          if (e.isInfinity()) return !1;
          if (this.z.eq(e.z)) return this.x.eq(e.x) && this.y.eq(e.y);
          let t = this.z.redSqr(),
            i = e.z.redSqr(),
            n = this.x.redMul(i),
            s = e.x.redMul(t);
          if (!n.eq(s)) return !1;
          let o = t.redMul(this.z),
            a = i.redMul(e.z),
            c = this.y.redMul(a),
            u = e.y.redMul(o);
          return c.eq(u)
        }
        cmp(e) {
          z(e instanceof Lh);
          let t = this.isInfinity(),
            i = e.isInfinity();
          return t && !i ? -1 : !t && i ? 1 : t && i ? 0 : this.order().cmp(e.order()) || this.getX().cmp(e.getX()) || this.getY().cmp(e.getY())
        }
        isInfinity() {
          return this.z.isZero()
        }
        isOrder2() {
          return this.isInfinity() ? !1 : this.y.isZero()
        }
        isOdd() {
          return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsOdd())
        }
        isEven() {
          return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsEven())
        }
        isSquare() {
          return this.isInfinity() ? !1 : this.y.redMul(this.z).redJacobi() !== -1
        }
        eqX(e) {
          if (z(e instanceof we), z(!e.red), this.isInfinity()) return !1;
          let t = this.z.redSqr(),
            i = e.toRed(this.curve.red).redMul(t);
          return this.x.eq(i)
        }
        eqR(e) {
          if (z(e instanceof we), z(!e.red), !this.curve.smallGap) return this.toP().eqR(e);
          if (this.isInfinity() || e.cmp(this.curve.p) >= 0) return !1;
          let t = this.z.redSqr(),
            i = e.toRed(this.curve.red).redMul(t);
          if (this.x.eq(i)) return !0;
          if (this.curve.highOrder || e.cmp(this.curve.pmodn) >= 0) return !1;
          let n = this.curve.redN.redMul(t);
          return i.redIAdd(n), this.x.eq(i)
        }
        toP() {
          return this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.point(this.x, this.y))
        }
        toJ() {
          return this
        }
        encode(e) {
          return this.toP().encode(e)
        }
        static decode(e, t) {
          return Gr.decode(e, t).toJ()
        }
        encodeX() {
          return this.toP().encodeX()
        }
        static decodeEven(e, t) {
          return Gr.decodeEven(e, t).toJ()
        }
        static decodeSquare(e, t) {
          return Gr.decodeSquare(e, t).toJ()
        }
        toJSON(e) {
          return this.toP().toJSON(e)
        }
        toPretty() {
          return this.toP().toPretty()
        }
        static fromJSON(e, t) {
          return Gr.fromJSON(e, t).toJ()
        } [Qp]() {
          return this.isInfinity() ? "<JPoint: Infinity>" : "<JPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">"
        }
      }, $r = class extends es {
        constructor(e) {
          super(On, "mont", e);
          this.a = we.fromJSON(e.a).toRed(this.red), this.b = we.fromJSON(e.b).toRed(this.red), this.bi = this.b.redInvert(), this.a2 = this.a.redAdd(this.two), this.a24 = this.a2.redMul(this.i4), this.a3 = this.a.redMul(this.i3), this.a0 = this.a.redMul(this.bi), this.b0 = this.bi.redSqr(), this._finalize(e)
        }
        static _isomorphism(e, t, i) {
          z(e instanceof we), z(t instanceof we), z(i instanceof we);
          let n = e.clone(),
            s = i.clone();
          if (t.redDiv(i).redJacobi() !== 1) throw new Error("Invalid `b` coefficient.");
          return [n, s]
        }
        _short(e, t) {
          let {
            a: i,
            b: n,
            three: s
          } = this, o = i.redSqr(), a = o.redMul(i), c = n.redSqr(), u = c.redMul(n), f = s.redSub(o), h = c.redMuln(3), d = a.redMuln(2).redISub(i.redMuln(9)), p = u.redMuln(27), g = f.redDiv(h), m = d.redDiv(p);
          return e != null ? Ir._isomorphism(g, m, e, t) : [g, m]
        }
        _mont(e) {
          return $r._isomorphism(this.a, this.b, e)
        }
        _edwards(e, t = !1) {
          z(typeof t == "boolean");
          let {
            two: i,
            bi: n
          } = this, s = this.a.redAdd(i).redMul(n), o = this.a.redSub(i).redMul(n);
          return t && s.swap(o), e != null ? sn._isomorphism(s, o, e) : [s, o]
        }
        _scaleShort(e) {
          z(e instanceof Ir);
          let [t, i] = e._scale(this);
          return [this.field(t.redInvert()), this.field(i.redInvert())]
        }
        _scaleMont(e) {
          return z(e instanceof $r), this.g.isInfinity() || e.g.isInfinity() ? this.field(e.b).redDivSqrt(this.b) : this.g.y.redDiv(this.field(e.g.y))
        }
        _scaleEdwards(e, t) {
          z(e instanceof sn);
          let i = e._scale(this, t);
          return this.field(i)
        }
        _solveY0(e) {
          z(e instanceof we);
          let t = this.a0,
            i = this.b0,
            n = e.redSqr();
          return n.redMul(e).redIAdd(t.redMul(n)).redIAdd(i.redMul(e))
        }
        _elligator2(e) {
          let t = this.a0.redNeg(),
            i = this.one.redAdd(this.z.redMul(e.redSqr()));
          i.isZero() && i.inject(this.one);
          let n = t.redMul(i.redInvert()),
            s = n.redNeg().redISub(this.a0),
            o = this._solveY0(n),
            a = this._solveY0(s),
            c = o.redIsSquare() | 0,
            u = [n, s][c ^ 1],
            f = [o, a][c ^ 1].redSqrt();
          f.redIsOdd() !== e.redIsOdd() && f.redINeg();
          let h = this.b.redMul(u),
            d = this.b.redMul(f);
          return this.point(h, d)
        }
        _invert2(e, t) {
          let {
            x: i,
            y: n
          } = e, s = t & 1, o = i.redMul(this.bi), a = n.redMul(this.bi), c = o.redAdd(this.a0), u = o, f = [c, u][s].redINeg(), h = [u, c][s].redMul(this.z), d = f.redDivSqrt(h);
          return d.redIsOdd() !== a.redIsOdd() && d.redINeg(), d
        }
        isElliptic() {
          let e = this.a.redSqr();
          return !this.b.redMul(e.redSub(this.four)).isZero()
        }
        jinv() {
          let {
            a: e,
            three: t,
            four: i
          } = this, n = e.redSqr(), o = n.redSub(t).redPown(3).redIMuln(256), a = n.redSub(i);
          if (a.isZero()) throw new Error("Curve is not elliptic.");
          return o.redDiv(a).fromRed()
        }
        point(e, t) {
          return new On(this, e, t)
        }
        jpoint(e, t, i) {
          return z(e == null && t == null && i == null), this.point()
        }
        xpoint(e, t) {
          return new Ac(this, e, t)
        }
        solveY2(e) {
          z(e instanceof we);
          let t = e.redSqr();
          return t.redMul(e).redIAdd(this.a.redMul(t)).redIAdd(e).redMul(this.bi)
        }
        validate(e) {
          if (z(e instanceof On), e.isInfinity()) return !0;
          let {
            x: t,
            y: i
          } = e, n = this.solveY2(t);
          return i.redSqr().eq(n)
        }
        pointFromX(e, t = null) {
          z(e instanceof we), z(t == null || typeof t == "boolean"), e.red || (e = e.toRed(this.red));
          let i = this.solveY(e);
          if (t != null) {
            if (i.isZero() && t) throw new Error("Invalid point.");
            i.redIsOdd() !== t && i.redINeg()
          }
          return this.point(e, i)
        }
        isIsomorphic(e, t) {
          if (z(e instanceof es), !e.p.eq(this.p)) return !1;
          if (e.type === "mont") {
            let i = this.field(e.a),
              n = this.field(e.b);
            return !this.a.eq(i) || this.b.isZero() ? !1 : n.redDiv(this.b).redJacobi() === 1
          }
          return e.isIsomorphic(this, t)
        }
        isIsogenous(e) {
          return z(e instanceof es), e.type === "mont" ? !1 : e.isIsogenous(this)
        }
        pointFromShort(e) {
          if (z(e instanceof Gr), this.isIsomorphic(e.curve)) {
            if (e.isInfinity()) return this.point();
            let {
              a3: t,
              b: i
            } = this, [n, s] = this._scale(e.curve), o = this.field(e.x).redMul(n), a = this.field(e.y).redMul(s), c = i.redMul(o).redISub(t), u = i.redMul(a);
            return this.point(c, u)
          }
          throw new Error("Not implemented.")
        }
        pointFromMont(e) {
          if (z(e instanceof On), this.isIsomorphic(e.curve)) {
            if (e.isInfinity()) return this.point();
            let t = this._scale(e.curve),
              i = this.field(e.x),
              n = this.field(e.y),
              s = i,
              o = t.redMul(n);
            return this.point(s, o)
          }
          throw new Error("Not implemented.")
        }
        pointFromEdwards(e) {
          z(e instanceof Nn), z(e.curve.p.eq(this.p));
          let t = this.field(e.x),
            i = this.field(e.y),
            n = this.field(e.z);
          if (this.isIsogenous(e.curve)) {
            if (e.isInfinity()) return this.point();
            if (e.x.isZero()) return this.point(this.zero, this.zero);
            let s = n.redSqr().redIMuln(2),
              o = i.redSqr(),
              a = t.redSqr(),
              c = s.redISub(a).redISub(o).redMul(i),
              u = a.redMul(t);
            return this.cpoint(o, a, c, u)
          }
          if (this.isIsomorphic(e.curve, !0)) {
            if (e.isInfinity()) return this.point();
            if (e.x.isZero()) return this.point(this.zero, this.zero);
            let s = this._scale(e.curve, !0),
              o = i.redAdd(n),
              a = i.redSub(n),
              c = s.redMul(n).redMul(o),
              u = t.redMul(a);
            return this.cpoint(o, a, c, u)
          }
          if (this.isIsomorphic(e.curve, !1)) {
            if (e.isInfinity()) return this.point();
            if (e.x.isZero()) return this.point(this.zero, this.zero);
            let s = this._scale(e.curve, !1),
              o = n.redAdd(i),
              a = n.redSub(i),
              c = s.redMul(n).redMul(o),
              u = t.redMul(a);
            return this.cpoint(o, a, c, u)
          }
          throw new Error("Not implemented.")
        }
        pointFromUniform(e) {
          if (z(e instanceof we), this.z.isZero() || this.a.isZero()) throw new Error("Not implemented.");
          return this._elligator2(e)
        }
        pointToUniform(e, t) {
          if (z(e instanceof On), z(t >>> 0 === t), this.z.isZero() || this.a.isZero()) throw new Error("Not implemented.");
          if (e.isInfinity()) throw new Error("Invalid point.");
          let i = (t >>> 4 & 15) % this.torsion.length,
            n = e.add(this.torsion[i]);
          return h2e(() => this._invert2(n, t))
        }
        decodePoint(e, t) {
          return On.decode(this, e, t)
        }
        encodeX(e) {
          return z(e instanceof Ac), e.encode()
        }
        decodeX(e) {
          return Ac.decode(this, e)
        }
        toShort(e, t, i = null) {
          let [n, s] = this._short(e, t), o = new Ir({
            red: this.red,
            prime: this.prime,
            p: this.p,
            a: n,
            b: s,
            n: this.n,
            h: this.h
          });
          if (i != null) {
            let [, a] = o._scale(this);
            a.redIsOdd() !== i && a.redINeg()
          }
          this.g.isInfinity() || (o.g = o.pointFromMont(this.g));
          for (let a = 0; a < this.h.word(0); a++) o.torsion[a] = o.pointFromMont(this.torsion[a]);
          return o
        }
        toMont(e, t = null) {
          let [i, n] = this._mont(e), s = new $r({
            red: this.red,
            prime: this.prime,
            p: this.p,
            a: i,
            b: n,
            n: this.n,
            h: this.h,
            z: this.z
          });
          if (t != null) {
            let o = s._scale(this);
            o.redIsOdd() !== t && o.redINeg()
          }
          this.g.isInfinity() || (s.g = s.pointFromMont(this.g));
          for (let o = 0; o < this.h.word(0); o++) s.torsion[o] = s.pointFromMont(this.torsion[o]);
          return s
        }
        toEdwards(e, t, i = null) {
          let [n, s] = this._edwards(e, t), o = new sn({
            red: this.red,
            prime: this.prime,
            p: this.p,
            a: n,
            d: s,
            n: this.n,
            h: this.h,
            z: this.z
          });
          if (i != null) {
            let a = o._scale(this, t);
            a.redIsOdd() !== i && a.redINeg()
          }
          if (this.g.isInfinity() || (o.g = o.pointFromMont(this.g), o.g.normalize()), o.isComplete())
            for (let a = 0; a < this.h.word(0); a++) o.torsion[a] = o.pointFromMont(this.torsion[a]), o.torsion[a].normalize();
          return o
        }
        pointFromJSON(e) {
          return On.fromJSON(this, e)
        }
        toJSON(e) {
          let t = super.toJSON(e);
          return t.a = this.a.fromRed().toJSON(), t.b = this.b.fromRed().toJSON(), t
        }
      }, On = class extends Dr {
        constructor(e, t, i) {
          z(e instanceof $r), super(e, xc.AFFINE), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = !0, t != null && this._init(t, i)
        }
        _init(e, t) {
          z(e instanceof we), z(t instanceof we), this.x = e, this.y = t, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1
        }
        clone() {
          return this.inf ? this.curve.point() : this.curve.point(this.x, this.y)
        }
        scale(e) {
          return this.clone()
        }
        randomize(e) {
          return this.clone()
        }
        neg() {
          return this.inf ? this : this.curve.point(this.x, this.y.redNeg())
        }
        add(e) {
          if (z(e instanceof On), this.inf) return e;
          if (e.inf) return this;
          if (this.x.eq(e.x)) return this.y.eq(e.y) ? this.dbl() : this.curve.point();
          let t = e.x.redSub(this.x),
            n = e.y.redSub(this.y).redDiv(t),
            o = this.curve.b.redMul(n.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(e.x),
            a = n.redMul(this.x.redSub(o)).redISub(this.y);
          return this.curve.point(o, a)
        }
        dbl() {
          if (this.inf) return this;
          if (this.y.isZero()) return this.curve.point();
          let e = this.x.redSqr().redIMuln(3),
            t = this.curve.a.redMul(this.x).redIMuln(2),
            i = e.redIAdd(t).redIAdd(this.curve.one),
            n = this.curve.b.redMul(this.y).redIMuln(2),
            s = i.redDiv(n),
            a = this.curve.b.redMul(s.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(this.x),
            c = s.redMul(this.x.redSub(a)).redISub(this.y);
          return this.curve.point(a, c)
        }
        getX() {
          if (this.inf) throw new Error("Invalid point.");
          return this.x.fromRed()
        }
        getY() {
          if (this.inf) throw new Error("Invalid point.");
          return this.y.fromRed()
        }
        eq(e) {
          return z(e instanceof On), this === e ? !0 : this.inf ? e.inf : e.inf ? !1 : this.x.eq(e.x) && this.y.eq(e.y)
        }
        cmp(e) {
          return z(e instanceof On), this.inf && !e.inf ? -1 : !this.inf && e.inf ? 1 : this.inf && e.inf ? 0 : this.order().cmp(e.order()) || this.getX().cmp(e.getX()) || this.getY().cmp(e.getY())
        }
        isInfinity() {
          return this.inf
        }
        isOrder2() {
          return this.inf ? !1 : this.y.isZero()
        }
        isOdd() {
          return this.inf ? !1 : this.y.redIsOdd()
        }
        isEven() {
          return this.inf ? !1 : this.y.redIsEven()
        }
        toP() {
          return this
        }
        toJ() {
          return this
        }
        toX() {
          return this.inf ? this.curve.xpoint() : this.curve.xpoint(this.x, this.curve.one)
        }
        encode() {
          return this.toX().encode()
        }
        static decode(e, t, i) {
          return z(e instanceof $r), e.decodeX(t).toP(i)
        }
        toJSON(e) {
          if (this.inf) return [];
          let t = this.getX().toJSON(),
            i = this.getY().toJSON();
          return [t, i]
        }
        toPretty() {
          if (this.inf) return [];
          let e = this.curve.fieldSize * 2,
            t = e1(this.getX(), e),
            i = e1(this.getY(), e);
          return [t, i]
        }
        static fromJSON(e, t) {
          if (z(e instanceof $r), z(Array.isArray(t)), z(t.length === 0 || t.length === 2 || t.length === 3), t.length === 0) return e.point();
          let i = we.fromJSON(t[0]),
            n = we.fromJSON(t[1]);
          return e.point(i, n)
        } [Qp]() {
          return this.inf ? "<MontPoint: Infinity>" : "<MontPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">"
        }
      }, Ac = class extends Dr {
        constructor(e, t, i) {
          z(e instanceof $r), super(e, xc.PROJECTIVE), this.x = this.curve.one, this.z = this.curve.zero, t != null && this._init(t, i)
        }
        _init(e, t) {
          z(e instanceof we), z(t == null || t instanceof we), this.x = e, this.z = t || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red))
        }
        clone() {
          return this.curve.xpoint(this.x, this.z)
        }
        precompute(e, t) {
          return this
        }
        validate() {
          if (this.isInfinity()) return !0;
          let {
            x: e,
            z: t
          } = this, i = e.redSqr(), n = i.redMul(e), s = t.redSqr(), o = this.curve.a.redMul(i).redMul(t);
          return n.redIAdd(o).redIAdd(e.redMul(s)).redMul(this.curve.bi).redMul(t).redJacobi() !== -1
        }
        normalize() {
          return this.isInfinity() ? this : this.z.eq(this.curve.one) ? this : (this.x = this.x.redDiv(this.z), this.z = this.curve.one, this)
        }
        scale(e) {
          if (z(e instanceof we), this.isInfinity()) return this.curve.xpoint();
          let t = this.x.redMul(e),
            i = this.z.redMul(e);
          return this.curve.xpoint(t, i)
        }
        neg() {
          return this
        }
        dbl() {
          let t = this.x.redAdd(this.z).redSqr(),
            n = this.x.redSub(this.z).redSqr(),
            s = t.redSub(n),
            o = t.redMul(n),
            a = s.redMul(n.redIAdd(this.curve.a24.redMul(s)));
          return this.curve.xpoint(o, a)
        }
        diffAddDbl(e, t) {
          z(e instanceof Ac), z(t instanceof Ac);
          let i = e.x.redAdd(e.z),
            n = i.redSqr(),
            s = e.x.redSub(e.z),
            o = s.redSqr(),
            a = n.redSub(o),
            c = t.x.redAdd(t.z),
            f = t.x.redSub(t.z).redMul(i),
            h = c.redMul(s),
            d = this.z.redMul(f.redAdd(h).redSqr()),
            p = this.x.redMul(f.redISub(h).redSqr()),
            g = n.redMul(o),
            m = a.redMul(o.redIAdd(this.curve.a24.redMul(a)));
          return [this.curve.xpoint(g, m), this.curve.xpoint(d, p)]
        }
        getX() {
          if (this.isInfinity()) throw new Error("Invalid point.");
          return this.normalize(), this.x.fromRed()
        }
        getY(e) {
          return this.toP(e).getY()
        }
        eq(e) {
          if (z(e instanceof Ac), this === e) return !0;
          if (this.isInfinity()) return e.isInfinity();
          if (e.isInfinity()) return !1;
          if (this.z.eq(e.z)) return this.x.eq(e.x);
          let t = this.x.redMul(e.z),
            i = e.x.redMul(this.z);
          return t.eq(i)
        }
        cmp(e) {
          z(e instanceof Ac);
          let t = this.isInfinity(),
            i = e.isInfinity();
          return t && !i ? -1 : !t && i ? 1 : t && i ? 0 : this.order().cmp(e.order()) || this.getX().cmp(e.getX())
        }
        isInfinity() {
          return this.z.isZero()
        }
        isOrder2() {
          return this.isInfinity() ? !1 : this.x.isZero()
        }
        isOdd() {
          return !1
        }
        isEven() {
          return !1
        }
        hasTorsion() {
          return this.isInfinity() ? !1 : this.x.isZero() ? !0 : super.hasTorsion()
        }
        order() {
          try {
            return this.toP().order()
          } catch (e) {
            return new we(1)
          }
        }
        jmul(e) {
          z(e instanceof we), z(!e.red);
          let t = e.bitLength(),
            i = this.curve.xpoint(),
            n = this;
          for (let s = t - 1; s >= 0; s--) e.bit(s) === 0 ? [i, n] = this.diffAddDbl(i, n) : [n, i] = this.diffAddDbl(n, i);
          return i
        }
        jmulBlind(e, t) {
          return t ? this.randomize(t).jmul(e) : this.jmul(e)
        }
        jmulAdd(e, t, i) {
          throw new Error("Not implemented.")
        }
        toP(e = null) {
          return z(e == null || typeof e == "boolean"), this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.pointFromX(this.x, e))
        }
        toJ() {
          return this
        }
        toX() {
          return this
        }
        key() {
          if (this.isInfinity()) return `${this.curve.uid}:oo`;
          this.normalize();
          let e = this.getX().toString(16);
          return `${this.curve.uid}:${e}`
        }
        encode() {
          return this.curve.encodeField(this.getX())
        }
        static decode(e, t) {
          z(e instanceof $r);
          let i = e.decodeField(t);
          i.iumaskn(e.fieldBits);
          let n = e.xpoint(i, e.one);
          return z(!n.isInfinity()), n
        }
        toJSON(e) {
          return this.toP().toJSON(e)
        }
        toPretty() {
          return this.toP().toPretty()
        }
        static fromJSON(e, t) {
          return On.fromJSON(e, t).toX()
        } [Qp]() {
          return this.isInfinity() ? "<XPoint: Infinity>" : "<XPoint: x=" + this.x.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">"
        }
      }, sn = class extends es {
        constructor(e) {
          super(Nn, "edwards", e);
          this.a = we.fromJSON(e.a).toRed(this.red), this.d = we.fromJSON(e.d).toRed(this.red), this.s = we.fromJSON(e.s || "0").toRed(this.red), this.si = this.s.isZero() ? this.zero : this.s.redInvert(), this.k = this.d.redMuln(2), this.smi = -this.d.redNeg().word(0), this.ad6 = this.a.redAdd(this.d).redMul(this.i6), this.twisted = !this.a.eq(this.one), this.oneA = this.a.eq(this.one), this.mOneA = this.a.eq(this.one.redNeg()), this.smallD = this.prime != null && this.d.redNeg().length === 1, this.alt = null, this._finalize(e)
        }
        static _isomorphism(e, t, i) {
          z(e instanceof we), z(t instanceof we), z(i instanceof we);
          let n = i.clone(),
            s = i.redMul(t).redDiv(e);
          if (e.redDiv(i).redJacobi() !== 1) throw new Error("Invalid `a` coefficient.");
          return [n, s]
        }
        _short(e, t) {
          let {
            a: i,
            d: n
          } = this, s = i.redSqr(), o = s.redMul(i), a = n.redSqr(), c = a.redMul(n), u = i.redMul(n).redIMuln(14), f = s.redMul(n), h = i.redMul(a), d = f.redIAdd(h).redIMuln(33), p = s.redAdd(u).redIAdd(a).redDivn(-48), g = d.redISub(o).redISub(c).redDivn(864);
          return e != null ? Ir._isomorphism(p, g, e, t) : [p, g]
        }
        _mont(e, t = !1) {
          z(typeof t == "boolean");
          let i, n;
          t ? (i = this.d.redAdd(this.a), n = this.d.redSub(this.a)) : (i = this.a.redAdd(this.d), n = this.a.redSub(this.d));
          let s = n.redInvert(),
            o = i.redMuln(2).redMul(s),
            a = s.redMuln(4);
          return e != null ? $r._isomorphism(o, a, e) : [o, a]
        }
        _edwards(e) {
          return sn._isomorphism(this.a, this.d, e)
        }
        _scaleShort(e) {
          z(e instanceof Ir);
          let [t, i] = e._scale(this);
          return [this.field(t.redInvert()), this.field(i.redInvert())]
        }
        _scaleMont(e, t = !1) {
          if (z(e instanceof $r), z(typeof t == "boolean"), this.g.isInfinity() || e.g.isInfinity()) {
            let [n] = e._edwards(null, t);
            return this.field(n).redDivSqrt(this.a)
          }
          let i = e.g.x.redDiv(e.g.y);
          return this.g.x.redDiv(this.field(i))
        }
        _scaleEdwards(e) {
          return z(e instanceof sn), this.g.isInfinity() || e.g.isInfinity() ? this.field(e.a).redDivSqrt(this.a) : this.g.x.redDiv(this.field(e.g.x))
        }
        _mulA(e) {
          return z(e instanceof we), this.oneA ? e.clone() : this.mOneA ? e.redNeg() : this.a.redMul(e)
        }
        _mulD(e) {
          return z(e instanceof we), this.smallD ? e.redMuln(this.smi) : this.d.redMul(e)
        }
        _elligator1(e) {
          let {
            s: t,
            si: i,
            i2: n,
            one: s,
            two: o
          } = this, a = i.redSqr().redIMuln(2), c = t.redSqr().redMul(n), u = c.redSqr(), f = a.redAdd(c), h = f.redSqr().redISub(o), d = a.redSub(s), p = s.redSub(e), g = s.redAdd(e), m = g.isZero() ? g : p.redDiv(g), E = m.redSqr(), w = E.redMul(m), q = w.redMul(E).redAdd(h.redMul(w)).redIAdd(m), J = this.field(q.redJacobi()), Z = this.field(E.redAdd(u).redJacobi()), H = J.redMul(Z), te = J.redMul(m), ae = J.redMul(q).redSqrt().redMul(H), oe = s.redAdd(te), U = f.redMul(te), b = oe.redSqr(), _ = d.redMul(t).redMul(te).redMul(oe), R = m.isZero() ? this.one : ae, D = U.redSub(b), K = U.redAdd(b);
          return this.cpoint(_, R, D, K)
        }
        _invert1(e, t) {
          let {
            s: i,
            si: n,
            i2: s,
            one: o
          } = this, {
            x: a,
            y: c,
            z: u
          } = e, f = t & 1, h = n.redSqr().redIMuln(2), d = i.redSqr().redMul(s), p = d.redSqr(), g = h.redAdd(d), m = h.redSub(o), E = c.redSub(u), w = c.redAdd(u).redIMuln(2), O = w.isZero() ? w : E.redDiv(w), q = o.redAdd(O.redMul(g)), H = q.redSqr().redISub(o).redSqrt().redSub(q), te = o.redAdd(H), oe = m.redMul(i).redMul(H).redMul(te).redMul(a.redMul(u)), U = H.redSqr().redIAdd(p), _ = this.field(oe.redMul(U).redJacobi()).redMul(H), R = o.redSub(_), D = o.redAdd(_), K = D.isZero() ? D : R.redDiv(D);
          return K.redIsOdd() !== Boolean(f) && K.redINeg(), K
        }
        _alt() {
          return this.alt || (this.alt = this.toMont()), this.alt
        }
        isElliptic() {
          let e = this.a.redMul(this.d),
            t = this.a.redSub(this.d);
          return !e.redMul(t).isZero()
        }
        jinv() {
          let {
            a: e,
            d: t
          } = this, i = e.redMul(t), n = e.redSub(t).redPown(4), s = e.redSqr(), o = t.redSqr(), c = s.redAdd(i.redMuln(14)).redIAdd(o).redPown(3).redIMuln(16), u = i.redMul(n);
          if (u.isZero()) throw new Error("Curve is not elliptic.");
          return c.redDiv(u).fromRed()
        }
        isComplete() {
          return this.a.redJacobi() === 1 && this.d.redJacobi() === -1
        }
        point(e, t, i, n) {
          return new Nn(this, e, t, i, n)
        }
        jpoint(e, t, i) {
          return z(e == null && t == null && i == null), this.point()
        }
        cpoint(e, t, i, n) {
          z(e instanceof we), z(t instanceof we), z(i instanceof we), z(n instanceof we);
          let s = e.redMul(n),
            o = i.redMul(t),
            a = t.redMul(n),
            c = e.redMul(i);
          return this.point(s, o, a, c)
        }
        solveX2(e) {
          z(e instanceof we);
          let t = e.redSqr(),
            i = this._mulD(t).redISub(this.a);
          return t.redISub(this.one).redDiv(i)
        }
        solveX(e) {
          let t = e.redSqr(),
            i = this._mulD(t).redISub(this.a);
          return t.redISub(this.one).redDivSqrt(i)
        }
        solveY2(e) {
          z(e instanceof we);
          let t = e.redSqr(),
            i = this._mulA(t).redISub(this.one),
            n = this._mulD(t).redISub(this.one);
          return i.redDiv(n)
        }
        solveY(e) {
          let t = e.redSqr(),
            i = this._mulA(t).redISub(this.one),
            n = this._mulD(t).redISub(this.one);
          return i.redDivSqrt(n)
        }
        validate(e) {
          if (z(e instanceof Nn), e.zOne) {
            let h = e.x.redSqr(),
              d = e.y.redSqr(),
              p = this._mulD(h).redMul(d),
              g = this._mulA(h).redIAdd(d),
              m = this.one.redAdd(p),
              E = e.t,
              w = e.x.redMul(e.y);
            return g.eq(m) && E.eq(w)
          }
          let t = e.x.redSqr(),
            i = e.y.redSqr(),
            n = e.z.redSqr(),
            s = n.redSqr(),
            o = this._mulD(t).redMul(i),
            a = this._mulA(t).redIAdd(i).redMul(n),
            c = s.redIAdd(o),
            u = e.t.redMul(e.z),
            f = e.x.redMul(e.y);
          return a.eq(c) && u.eq(f)
        }
        pointFromX(e, t = null) {
          z(e instanceof we), z(t == null || typeof t == "boolean"), e.red || (e = e.toRed(this.red));
          let i = this.solveY(e);
          if (t != null) {
            if (i.isZero() && t) throw new Error("Invalid point.");
            i.redIsOdd() !== t && i.redINeg()
          }
          return this.point(e, i)
        }
        pointFromY(e, t = null) {
          z(e instanceof we), z(t == null || typeof t == "boolean"), e.red || (e = e.toRed(this.red));
          let i = this.solveX(e);
          if (t != null) {
            if (i.isZero() && t) throw new Error("Invalid point.");
            i.redIsOdd() !== t && i.redINeg()
          }
          return this.point(i, e)
        }
        isIsomorphic(e, t = !1) {
          if (z(e instanceof es), z(typeof t == "boolean"), !e.p.eq(this.p)) return !1;
          if (e.type === "short") return e.isIsomorphic(this);
          if (e.type === "mont") {
            let i = this.field(e.a),
              n, s;
            return t ? (n = this.d.redAdd(this.a), s = this.d.redSub(this.a)) : (n = this.a.redAdd(this.d), s = this.a.redSub(this.d)), i.redMul(s).eq(n.redIMuln(2))
          }
          if (e.type === "edwards") {
            let i = this.field(e.a),
              n = this.field(e.d);
            return this.a.redMul(n).eq(i.redMul(this.d))
          }
          return !1
        }
        isIsogenous(e) {
          if (z(e instanceof es), !e.p.eq(this.p)) return !1;
          if (e.type === "mont") {
            if (!this.a.eq(this.one)) return !1;
            let t = this.field(e.a),
              i = this.field(e.b),
              n = this.two.redSub(this.d.redMuln(4));
            return t.eq(n) && i.eq(this.one)
          }
          if (e.type === "edwards") {
            let t = this.field(e.a),
              i = this.field(e.d);
            return t.eq(this.a.redNeg()) && i.eq(this.d.redSub(this.a))
          }
          return !1
        }
        pointFromShort(e) {
          if (z(e instanceof Gr), this.isIsomorphic(e.curve)) {
            if (e.isInfinity()) return this.point();
            if (e.y.isZero()) return this.point(this.zero, this.one.redNeg());
            let {
              a: t,
              d: i
            } = this, [n, s] = this._scale(e.curve), o = t.redMuln(5), a = i.redMuln(5), c = this.field(e.x).redMul(n), u = this.field(e.y).redMul(s), f = c.redMuln(6), h = c.redMuln(12), d = f.redSub(t).redISub(i), p = u.redMuln(6), g = h.redSub(o).redIAdd(i), m = h.redAdd(t).redISub(a);
            return this.cpoint(d, p, g, m)
          }
          throw new Error("Not implemented.")
        }
        pointFromMont(e) {
          z(e instanceof On), z(e.curve.p.eq(this.p));
          let t = this.field(e.x),
            i = this.field(e.y);
          if (this.isIsogenous(e.curve)) {
            if (e.isInfinity()) return this.point();
            if (e.x.isZero()) return this.point();
            let n = t.redSqr(),
              s = n.redMul(t),
              o = s.redMul(t),
              a = o.redMul(t),
              c = i.redSqr(),
              u = i.redMuln(4),
              f = n.redSub(this.one),
              h = n.redMuln(2),
              d = c.redMuln(4),
              p = s.redIMuln(2),
              g = t.redMul(c).redIMuln(4),
              m = n.redMul(c).redIMuln(2),
              E = c.redIMuln(2),
              w = u.redMul(f),
              O = o.redISub(h).redIAdd(d).redIAdd(this.one),
              q = a.redSub(p).redISub(g).redIAdd(t).redINeg(),
              J = a.redISub(m).redISub(p).redISub(E).redIAdd(t);
            return this.cpoint(w, O, q, J).divn(4)
          }
          if (this.isIsomorphic(e.curve, !0)) {
            if (e.isInfinity()) return this.point();
            if (e.x.isZero()) return this.point(this.zero, this.one.redNeg());
            let s = this._scale(e.curve, !0).redMul(t),
              o = i,
              a = t.redAdd(this.one),
              c = t.redSub(this.one);
            return this.cpoint(s, o, a, c)
          }
          if (this.isIsomorphic(e.curve, !1)) {
            if (e.isInfinity()) return this.point();
            if (e.x.isZero()) return this.point(this.zero, this.one.redNeg());
            let s = this._scale(e.curve, !1).redMul(t),
              o = i,
              a = t.redSub(this.one),
              c = t.redAdd(this.one);
            return this.cpoint(s, o, a, c)
          }
          throw new Error("Not implemented.")
        }
        pointFromEdwards(e) {
          z(e instanceof Nn), z(e.curve.p.eq(this.p));
          let t = this.field(e.curve.a),
            i = this.field(e.x),
            n = this.field(e.y),
            s = this.field(e.z),
            o = this.field(e.t);
          if (this.isIsogenous(e.curve)) {
            let a = i.redMul(n),
              c = i.redSqr(),
              u = n.redSqr(),
              f = s.redSqr(),
              h = t.redMul(c),
              d = a.redIMuln(2),
              p = u.redSub(h),
              g = u.redAdd(h),
              m = f.redIMuln(2).redISub(g),
              E = this.cpoint(d, p, g, m);
            return this.twisted ? E : E.divn(4)
          }
          if (this.isIsomorphic(e.curve)) {
            let a = this._scale(e.curve),
              c = a.redMul(i),
              u = n,
              f = s,
              h = a.redMul(o);
            return this.point(c, u, f, h)
          }
          throw new Error("Not implemented.")
        }
        pointFromUniform(e, t = null) {
          z(e instanceof we), z(e.red === this.red), z(t == null || t instanceof $r), t || (t = this._alt());
          let i = t.field(e),
            n = t.pointFromUniform(i);
          return this.pointFromMont(n)
        }
        pointToUniform(e, t, i = null) {
          z(e instanceof Nn), z(t >>> 0 === t), z(i == null || i instanceof $r), i || (i = this._alt());
          let n = (t >> 4 & 15) % this.torsion.length,
            s = e.add(this.torsion[n]),
            o = i.pointFromEdwards(s),
            a = i.pointToUniform(o, t & 15);
          return this.field(a)
        }
        pointFromHash(e, t, i = null) {
          z(i == null || i instanceof $r), i || (i = this._alt());
          let n = i.pointFromHash(e, t);
          return this.pointFromMont(n)
        }
        pointToHash(e, t, i, n = null) {
          z(e instanceof Nn), z(t >>> 0 === t), z(n == null || n instanceof $r), n || (n = this._alt());
          let s = t % this.torsion.length,
            o = e.add(this.torsion[s]),
            a = n.pointFromEdwards(o);
          return n.pointToHash(a, 0, i)
        }
        decodePoint(e) {
          return Nn.decode(this, e)
        }
        toShort(e, t, i = null) {
          let [n, s] = this._short(e, t), o = new Ir({
            red: this.red,
            prime: this.prime,
            p: this.p,
            a: n,
            b: s,
            n: this.n,
            h: this.h
          });
          if (i != null) {
            let [, a] = o._scale(this);
            a.redIsOdd() !== i && a.redINeg()
          }
          this.g.isInfinity() || (o.g = o.pointFromEdwards(this.g));
          for (let a = 0; a < this.h.word(0); a++) o.torsion[a] = o.pointFromEdwards(this.torsion[a]);
          return o
        }
        toMont(e, t, i = null) {
          let [n, s] = this._mont(e, t), o = new $r({
            red: this.red,
            prime: this.prime,
            p: this.p,
            a: n,
            b: s,
            n: this.n,
            h: this.h,
            z: this.z
          });
          if (i != null) {
            let a = this._scale(o, t);
            a.redIsOdd() !== i && a.redINeg()
          }
          this.g.isInfinity() || (o.g = o.pointFromEdwards(this.g));
          for (let a = 0; a < this.h.word(0); a++) o.torsion[a] = o.pointFromEdwards(this.torsion[a]);
          return o
        }
        toEdwards(e, t = null) {
          let [i, n] = this._edwards(e), s = new sn({
            red: this.red,
            prime: this.prime,
            p: this.p,
            a: i,
            d: n,
            n: this.n,
            h: this.h,
            z: this.z
          });
          if (t != null) {
            let o = s._scale(this);
            o.redIsOdd() !== t && o.redINeg()
          }
          if (this.g.isInfinity() || (s.g = s.pointFromEdwards(this.g), s.g.normalize()), s.isComplete())
            for (let o = 0; o < this.h.word(0); o++) s.torsion[o] = s.pointFromEdwards(this.torsion[o]), s.torsion[o].normalize();
          return s
        }
        pointFromJSON(e) {
          return Nn.fromJSON(this, e)
        }
        toJSON(e) {
          let t = super.toJSON(e);
          return t.a = this.a.fromRed().toJSON(), t.d = this.d.fromRed().toJSON(), this.s.isZero() || (t.s = this.s.fromRed().toJSON()), t
        }
      }, Nn = class extends Dr {
        constructor(e, t, i, n, s) {
          z(e instanceof sn), super(e, xc.EXTENDED), this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0, t != null && this._init(t, i, n, s)
        }
        _init(e, t, i, n) {
          z(e instanceof we), z(t instanceof we), z(i == null || i instanceof we), z(n == null || n instanceof we), this.x = e, this.y = t, this.z = i || this.curve.one, this.t = n || null, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z.eq(this.curve.one), this._check(), this.t || (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redDiv(this.z)))
        }
        _check() {
          if (this.z.isZero()) throw new Error("Invalid point.")
        }
        clone() {
          return this.curve.point(this.x, this.y, this.z, this.t)
        }
        normalize() {
          if (this.zOne) return this;
          let e = this.z.redInvert();
          return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t = this.t.redMul(e), this.z = this.curve.one, this.zOne = !0, this
        }
        scale(e) {
          z(e instanceof we);
          let t = this.x.redMul(e),
            i = this.y.redMul(e),
            n = this.z.redMul(e),
            s = this.t.redMul(e);
          return this.curve.point(t, i, n, s)
        }
        neg() {
          let e = this.x.redNeg(),
            t = this.y,
            i = this.z,
            n = this.t.redNeg();
          return this.curve.point(e, t, i, n)
        }
        add(e) {
          return z(e instanceof Nn), this.isInfinity() ? e : e.isInfinity() ? this : this.zOne ? e._add(this) : this._add(e)
        }
        _add(e) {
          return this.curve.mOneA ? this._addM1(e) : this._addA(e)
        }
        _addM1(e) {
          let t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)),
            i = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),
            n = this.t.redMul(this.curve.k).redMul(e.t),
            s = e.zOne ? this.z.redAdd(this.z) : this.z.redMul(e.z).redIMuln(2),
            o = i.redSub(t),
            a = s.redSub(n),
            c = s.redIAdd(n),
            u = i.redIAdd(t),
            f = o.redMul(a),
            h = c.redMul(u),
            d = o.redMul(u),
            p = a.redMul(c);
          return this.curve.point(f, h, p, d)
        }
        _addA(e) {
          let t = this.x.redMul(e.x),
            i = this.y.redMul(e.y),
            n = this.curve._mulD(this.t).redMul(e.t),
            s = e.zOne ? this.z.clone() : this.z.redMul(e.z),
            a = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(t).redISub(i),
            c = s.redSub(n),
            u = s.redIAdd(n),
            f = i.redISub(this.curve._mulA(t)),
            h = a.redMul(c),
            d = u.redMul(f),
            p = a.redMul(f),
            g = c.redMul(u);
          return this.curve.point(h, d, g, p)
        }
        dbl() {
          return this.isInfinity() ? this : this._dbl()
        }
        _dbl() {
          let e = this.x.redSqr(),
            t = this.y.redSqr(),
            i = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2),
            n = this.curve._mulA(e),
            s = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),
            o = n.redAdd(t),
            a = o.redSub(i),
            c = n.redISub(t),
            u = s.redMul(a),
            f = o.redMul(c),
            h = s.redMul(c),
            d = a.redMul(o);
          return this.curve.point(u, f, d, h)
        }
        getX() {
          return this.normalize(), this.x.fromRed()
        }
        getY() {
          return this.normalize(), this.y.fromRed()
        }
        eq(e) {
          if (z(e instanceof Nn), z(!this.z.isZero()), z(!e.z.isZero()), this === e) return !0;
          if (this.z.eq(e.z)) return this.x.eq(e.x) && this.y.eq(e.y);
          let t = this.x.redMul(e.z),
            i = e.x.redMul(this.z);
          if (!t.eq(i)) return !1;
          let n = this.y.redMul(e.z),
            s = e.y.redMul(this.z);
          return n.eq(s)
        }
        cmp(e) {
          return z(e instanceof Nn), this.order().cmp(e.order()) || this.getY().cmp(e.getY()) || this.getX().cmp(e.getX())
        }
        isInfinity() {
          return z(!this.z.isZero()), this.x.isZero() ? this.y.eq(this.z) : !1
        }
        isOrder2() {
          return this.isInfinity() ? !1 : this.x.isZero()
        }
        isOdd() {
          return this.normalize(), this.x.redIsOdd()
        }
        isEven() {
          return this.normalize(), this.x.redIsEven()
        }
        toP() {
          return this.normalize()
        }
        toJ() {
          return this
        }
        encode() {
          let e = this.getY();
          return e.setn(this.curve.signBit, this.x.redIsOdd()), this.curve.encodeAdjusted(e)
        }
        static decode(e, t) {
          z(e instanceof sn);
          let i = e.decodeAdjusted(t),
            n = i.testn(e.signBit) !== 0;
          if (i.setn(e.signBit, 0), i.cmp(e.p) >= 0) throw new Error("Invalid point.");
          return e.pointFromY(i, n)
        }
        toJSON(e) {
          if (this.isInfinity()) return [];
          let t = this.getX().toJSON(),
            i = this.getY().toJSON();
          return e === !0 && this.pre ? [t, i, this.pre.toJSON()] : [t, i]
        }
        toPretty() {
          let e = this.curve.fieldSize * 2,
            t = e1(this.getX(), e),
            i = e1(this.getY(), e);
          return [t, i]
        }
        static fromJSON(e, t) {
          if (z(e instanceof sn), z(Array.isArray(t)), z(t.length === 0 || t.length === 2 || t.length === 3), t.length === 0) return e.point();
          let i = we.fromJSON(t[0]),
            n = we.fromJSON(t[1]),
            s = e.point(i, n);
          return t.length > 2 && t[2] != null && (s.pre = t4.fromJSON(s, t[2])), s
        } [Qp]() {
          return this.isInfinity() ? "<EdwardsPoint: Infinity>" : "<EdwardsPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">"
        }
      }, t4 = class {
        constructor() {
          this.naf = null, this.windows = null, this.doubles = null, this.blinding = null, this.beta = null
        }
        map(e) {
          z(typeof e == "function");
          let t = new this.constructor;
          return this.naf && (t.naf = this.naf.map(e)), this.doubles && (t.doubles = this.doubles.map(e)), t
        }
        toJSON() {
          return {
            naf: this.naf ? this.naf.toJSON() : null,
            windows: this.windows ? this.windows.toJSON() : null,
            doubles: this.doubles ? this.doubles.toJSON() : null,
            blinding: this.blinding ? this.blinding.toJSON() : void 0
          }
        }
        fromJSON(e, t) {
          return z(e instanceof Dr), z(t && typeof t == "object"), t.naf != null && (this.naf = r4.fromJSON(e, t.naf)), t.windows != null && (this.windows = pk.fromJSON(e, t.windows)), t.doubles != null && (this.doubles = yk.fromJSON(e, t.doubles)), t.blinding != null && (this.blinding = gk.fromJSON(e, t.blinding)), this
        }
        static fromJSON(e, t) {
          return new this().fromJSON(e, t)
        }
      }, r4 = class {
        constructor(e, t) {
          this.width = e, this.points = t
        }
        map(e) {
          z(typeof e == "function");
          let {
            width: t
          } = this, i = [];
          for (let n of this.points) i.push(e(n));
          return new this.constructor(t, i)
        }
        toJSON() {
          return {
            width: this.width,
            points: this.points.slice(1).map(e => e.toJSON())
          }
        }
        static fromJSON(e, t) {
          z(e instanceof Dr), z(t && typeof t == "object"), z(t.width >>> 0 === t.width), z(Array.isArray(t.points));
          let {
            curve: i
          } = e, {
            width: n
          } = t, s = [e];
          for (let o of t.points) s.push(i.pointFromJSON(o));
          return new this(n, s)
        }
      }, pk = class {
        constructor(e, t, i) {
          this.width = e, this.bits = t, this.points = i
        }
        toJSON() {
          return {
            width: this.width,
            bits: this.bits,
            points: this.points.slice(1).map(e => e.toJSON())
          }
        }
        static fromJSON(e, t) {
          z(e instanceof Dr), z(t && typeof t == "object"), z(t.width >>> 0 === t.width), z(t.bits >>> 0 === t.bits), z(Array.isArray(t.points));
          let {
            curve: i
          } = e, {
            width: n,
            bits: s
          } = t, o = [e];
          for (let a of t.points) o.push(i.pointFromJSON(a));
          return new this(n, s, o)
        }
      }, yk = class {
        constructor(e, t) {
          this.step = e, this.points = t
        }
        map(e) {
          z(typeof e == "function");
          let {
            step: t
          } = this, i = [];
          for (let n of this.points) i.push(e(n));
          return new this.constructor(t, i)
        }
        toJSON() {
          return {
            step: this.step,
            points: this.points.slice(1).map(e => e.toJSON())
          }
        }
        static fromJSON(e, t) {
          z(e instanceof Dr), z(t && typeof t == "object"), z(t.step >>> 0 === t.step), z(Array.isArray(t.points));
          let {
            curve: i
          } = e, {
            step: n
          } = t, s = [e];
          for (let o of t.points) s.push(i.pointFromJSON(o));
          return new this(n, s)
        }
      }, gk = class {
        constructor(e, t) {
          this.blind = e, this.unblind = t
        }
        toJSON() {
          return {
            blind: this.blind.toJSON(),
            unblind: this.unblind.toJSON()
          }
        }
        static fromJSON(e, t) {
          z(e instanceof Dr), z(t && typeof t == "object");
          let {
            curve: i
          } = e, n = we.fromJSON(t.blind), s = i.pointFromJSON(t.unblind);
          return new this(n, s)
        }
      }, bk = class {
        constructor(e, t, i, n) {
          this.beta = e, this.lambda = t, this.basis = i, this.pre = n
        }
        toJSON() {
          return {
            beta: this.beta.fromRed().toJSON(),
            lambda: this.lambda.toJSON(),
            basis: [this.basis[0].toJSON(), this.basis[1].toJSON()],
            pre: [this.pre[0], this.pre[1].toJSON(), this.pre[2].toJSON()]
          }
        }
        static fromJSON(e, t) {
          z(e instanceof es), z(t && typeof t == "object"), z(Array.isArray(t.basis)), z(Array.isArray(t.pre)), z(t.basis.length === 2), z(t.pre.length === 3), z(t.pre[0] >>> 0 === t.pre[0]);
          let i = we.fromJSON(t.beta).toRed(e.red),
            n = we.fromJSON(t.lambda),
            s = [Fh.fromJSON(t.basis[0]), Fh.fromJSON(t.basis[1])],
            o = [t.pre[0], we.fromJSON(t.pre[1]), we.fromJSON(t.pre[2])];
          return new this(i, n, s, o)
        }
      }, Fh = class {
        constructor(e, t) {
          this.a = e, this.b = t
        }
        toJSON() {
          return {
            a: this.a.toJSON(),
            b: this.b.toJSON()
          }
        }
        static fromJSON(e) {
          z(e && typeof e == "object");
          let t = we.fromJSON(e.a),
            i = we.fromJSON(e.b);
          return new this(t, i)
        }
      }, y2e = class extends Ir {
        constructor(e) {
          super({
            id: "P192",
            ossl: "prime192v1",
            type: "short",
            endian: "be",
            hash: "SHA256",
            prime: "p192",
            p: ["ffffffff ffffffff ffffffff fffffffe", "ffffffff ffffffff"],
            a: ["ffffffff ffffffff ffffffff fffffffe", "ffffffff fffffffc"],
            b: ["64210519 e59c80e7 0fa7e9ab 72243049", "feb8deec c146b9b1"],
            n: ["ffffffff ffffffff ffffffff 99def836", "146bc9b1 b4d22831"],
            h: "1",
            z: "-5",
            g: [
              ["188da80e b03090f6 7cbf20eb 43a18800", "f4ff0afd 82ff1012"],
              ["07192b95 ffc8da78 631011ed 6b24cdd5", "73f977a1 1e794811"], e
            ]
          })
        }
      }, g2e = class extends Ir {
        constructor(e) {
          super({
            id: "P224",
            ossl: "secp224r1",
            type: "short",
            endian: "be",
            hash: "SHA256",
            prime: "p224",
            p: ["ffffffff ffffffff ffffffff ffffffff", "00000000 00000000 00000001"],
            a: ["ffffffff ffffffff ffffffff fffffffe", "ffffffff ffffffff fffffffe"],
            b: ["b4050a85 0c04b3ab f5413256 5044b0b7", "d7bfd8ba 270b3943 2355ffb4"],
            n: ["ffffffff ffffffff ffffffff ffff16a2", "e0b8f03e 13dd2945 5c5c2a3d"],
            h: "1",
            z: "1f",
            g: [
              ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3", "56c21122 343280d6 115c1d21"],
              ["bd376388 b5f723fb 4c22dfe6 cd4375a0", "5a074764 44d58199 85007e34"], e
            ]
          })
        }
      }, b2e = class extends Ir {
        constructor(e) {
          super({
            id: "P256",
            ossl: "prime256v1",
            type: "short",
            endian: "be",
            hash: "SHA256",
            prime: null,
            p: ["ffffffff 00000001 00000000 00000000", "00000000 ffffffff ffffffff ffffffff"],
            a: ["ffffffff 00000001 00000000 00000000", "00000000 ffffffff ffffffff fffffffc"],
            b: ["5ac635d8 aa3a93e7 b3ebbd55 769886bc", "651d06b0 cc53b0f6 3bce3c3e 27d2604b"],
            n: ["ffffffff 00000000 ffffffff ffffffff", "bce6faad a7179e84 f3b9cac2 fc632551"],
            h: "1",
            z: "-a",
            g: [
              ["6b17d1f2 e12c4247 f8bce6e5 63a440f2", "77037d81 2deb33a0 f4a13945 d898c296"],
              ["4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16", "2bce3357 6b315ece cbb64068 37bf51f5"], e
            ]
          })
        }
      }, m2e = class extends Ir {
        constructor(e) {
          super({
            id: "P384",
            ossl: "secp384r1",
            type: "short",
            endian: "be",
            hash: "SHA384",
            prime: null,
            p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff fffffffe", "ffffffff 00000000 00000000 ffffffff"],
            a: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff fffffffe", "ffffffff 00000000 00000000 fffffffc"],
            b: ["b3312fa7 e23ee7e4 988e056b e3f82d19", "181d9c6e fe814112 0314088f 5013875a", "c656398d 8a2ed19d 2a85c8ed d3ec2aef"],
            n: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff c7634d81 f4372ddf", "581a0db2 48b0a77a ecec196a ccc52973"],
            h: "1",
            z: "-c",
            g: [
              ["aa87ca22 be8b0537 8eb1c71e f320ad74", "6e1d3b62 8ba79b98 59f741e0 82542a38", "5502f25d bf55296c 3a545e38 72760ab7"],
              ["3617de4a 96262c6f 5d9e98bf 9292dc29", "f8f41dbd 289a147c e9da3113 b5f0b8c0", "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"], e
            ]
          })
        }
      }, v2e = class extends Ir {
        constructor(e) {
          super({
            id: "P521",
            ossl: "secp521r1",
            type: "short",
            endian: "be",
            hash: "SHA512",
            prime: "p521",
            p: ["000001ff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff"],
            a: ["000001ff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "fffffffc"],
            b: ["00000051 953eb961 8e1c9a1f 929a21a0", "b68540ee a2da725b 99b315f3 b8b48991", "8ef109e1 56193951 ec7e937b 1652c0bd", "3bb1bf07 3573df88 3d2c34f1 ef451fd4", "6b503f00"],
            n: ["000001ff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "fffffffa 51868783 bf2f966b 7fcc0148", "f709a5d0 3bb5c9b8 899c47ae bb6fb71e", "91386409"],
            h: "1",
            z: "-4",
            g: [
              ["000000c6 858e06b7 0404e9cd 9e3ecb66", "2395b442 9c648139 053fb521 f828af60", "6b4d3dba a14b5e77 efe75928 fe1dc127", "a2ffa8de 3348b3c1 856a429b f97e7e31", "c2e5bd66"],
              ["00000118 39296a78 9a3bc004 5c8a5fb4", "2c7d1bd9 98f54449 579b4468 17afbd17", "273e662c 97ee7299 5ef42640 c550b901", "3fad0761 353c7086 a272c240 88be9476", "9fd16650"], e
            ]
          })
        }
      }, w2e = class extends Ir {
        constructor(e) {
          super({
            id: "SECP256K1",
            ossl: "secp256k1",
            type: "short",
            endian: "be",
            hash: "SHA256",
            prime: "k256",
            p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe fffffc2f"],
            a: "0",
            b: "7",
            n: ["ffffffff ffffffff ffffffff fffffffe", "baaedce6 af48a03b bfd25e8c d0364141"],
            h: "1",
            z: "1",
            c: ["0a2d2ba9 3507f1df 233770c2 a797962c", "c61f6d15 da14ecd4 7d8d27ae 1cd5f852"],
            g: [
              ["79be667e f9dcbbac 55a06295 ce870b07", "029bfcdb 2dce28d9 59f2815b 16f81798"],
              ["483ada77 26a3c465 5da4fbfc 0e1108a8", "fd17b448 a6855419 9c47d08f fb10d4b8"], e
            ],
            endo: {
              beta: ["7ae96a2b 657c0710 6e64479e ac3434e9", "9cf04975 12f58995 c1396c28 719501ee"],
              lambda: ["5363ad4c c05c30e0 a5261c02 8812645a", "122e22ea 20816678 df02967c 1b23bd72"],
              basis: [{
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
              }, {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
              }],
              pre: [384, ["3086d221 a7d46bcd e86c90e4 9284eb15", "3daa8a14 71e8ca7f e893209a 45dbb031"],
                ["-", "e4437ed6 010e8828 6f547fa9 0abfe4c4", "221208ac 9df506c6 1571b4ae 8ac47f71"]
              ]
            }
          })
        }
      }, _2e = class extends Ir {
        constructor(e) {
          super({
            id: "BRAINPOOLP256",
            ossl: "brainpoolP256r1",
            type: "short",
            endian: "be",
            hash: "SHA256",
            prime: null,
            p: ["a9fb57db a1eea9bc 3e660a90 9d838d72", "6e3bf623 d5262028 2013481d 1f6e5377"],
            a: ["7d5a0975 fc2c3057 eef67530 417affe7", "fb8055c1 26dc5c6c e94a4b44 f330b5d9"],
            b: ["26dc5c6c e94a4b44 f330b5d9 bbd77cbf", "95841629 5cf7e1ce 6bccdc18 ff8c07b6"],
            n: ["a9fb57db a1eea9bc 3e660a90 9d838d71", "8c397aa3 b561a6f7 901e0e82 974856a7"],
            h: "1",
            z: "-2",
            g: [
              ["8bd2aeb9 cb7e57cb 2c4b482f fc81b7af", "b9de27e1 e3bd23c2 3a4453bd 9ace3262"],
              ["547ef835 c3dac4fd 97f8461a 14611dc9", "c2774513 2ded8e54 5c1d54c7 2f046997"], e
            ]
          })
        }
      }, E2e = class extends Ir {
        constructor(e) {
          super({
            id: "BRAINPOOLP384",
            ossl: "brainpoolP384r1",
            type: "short",
            endian: "be",
            hash: "SHA384",
            prime: null,
            p: ["8cb91e82 a3386d28 0f5d6f7e 50e641df", "152f7109 ed5456b4 12b1da19 7fb71123", "acd3a729 901d1a71 87470013 3107ec53"],
            a: ["7bc382c6 3d8c150c 3c72080a ce05afa0", "c2bea28e 4fb22787 139165ef ba91f90f", "8aa5814a 503ad4eb 04a8c7dd 22ce2826"],
            b: ["04a8c7dd 22ce2826 8b39b554 16f0447c", "2fb77de1 07dcd2a6 2e880ea5 3eeb62d5", "7cb43902 95dbc994 3ab78696 fa504c11"],
            n: ["8cb91e82 a3386d28 0f5d6f7e 50e641df", "152f7109 ed5456b3 1f166e6c ac0425a7", "cf3ab6af 6b7fc310 3b883202 e9046565"],
            h: "1",
            z: "-5",
            g: [
              ["1d1c64f0 68cf45ff a2a63a81 b7c13f6b", "8847a3e7 7ef14fe3 db7fcafe 0cbd10e8", "e826e034 36d646aa ef87b2e2 47d4af1e"],
              ["8abe1d75 20f9c2a4 5cb1eb8e 95cfd552", "62b70b29 feec5864 e19c054f f9912928", "0e464621 77918111 42820341 263c5315"], e
            ]
          })
        }
      }, S2e = class extends Ir {
        constructor(e) {
          super({
            id: "BRAINPOOLP512",
            ossl: "brainpoolP512r1",
            type: "short",
            endian: "be",
            hash: "SHA512",
            prime: null,
            p: ["aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07", "cb308db3 b3c9d20e d6639cca 70330871", "7d4d9b00 9bc66842 aecda12a e6a380e6", "2881ff2f 2d82c685 28aa6056 583a48f3"],
            a: ["7830a331 8b603b89 e2327145 ac234cc5", "94cbdd8d 3df91610 a83441ca ea9863bc", "2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5", "7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca"],
            b: ["3df91610 a83441ca ea9863bc 2ded5d5a", "a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7", "2bf2c7b9 e7c1ac4d 77fc94ca dc083e67", "984050b7 5ebae5dd 2809bd63 8016f723"],
            n: ["aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07", "cb308db3 b3c9d20e d6639cca 70330870", "553e5c41 4ca92619 41866119 7fac1047", "1db1d381 085ddadd b5879682 9ca90069"],
            h: "1",
            z: "7",
            g: [
              ["81aee4bd d82ed964 5a21322e 9c4c6a93", "85ed9f70 b5d916c1 b43b62ee f4d0098e", "ff3b1f78 e2d0d48d 50d1687b 93b97d5f", "7c6d5047 406a5e68 8b352209 bcb9f822"],
              ["7dde385d 566332ec c0eabfa9 cf7822fd", "f209f700 24a57b1a a000c55b 881f8111", "b2dcde49 4a5f485e 5bca4bd8 8a2763ae", "d1ca2b2f a8f05406 78cd1e0f 3ad80892"], e
            ]
          })
        }
      }, x2e = class extends $r {
        constructor() {
          super({
            id: "X25519",
            ossl: "X25519",
            type: "mont",
            endian: "le",
            hash: "SHA512",
            prime: "p25519",
            p: ["7fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffed"],
            a: "76d06",
            b: "1",
            n: ["10000000 00000000 00000000 00000000", "14def9de a2f79cd6 5812631a 5cf5d3ed"],
            h: "8",
            z: "2",
            g: [
              ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000009"],
              ["5f51e65e 475f794b 1fe122d3 88b72eb3", "6dc2b281 92839e4d d6163a5d 81312c14"]
            ],
            torsion: [
              [],
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"]
              ],
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000001"],
                ["6be4f497 f9a9c2af c21fa77a d7f4a6ef", "635a11c7 284a9363 e9a248ef 9c884415"]
              ],
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000001"],
                ["141b0b68 06563d50 3de05885 280b5910", "9ca5ee38 d7b56c9c 165db710 6377bbd8"]
              ],
              [
                ["57119fd0 dd4e22d8 868e1c58 c45c4404", "5bef839c 55b1d0b1 248c50a3 bc959c5f"],
                ["68c59389 3d458e64 31c6ca00 45fb5015", "20a44346 8eaa68dd 0f103842 048065b7"]
              ],
              [
                ["57119fd0 dd4e22d8 868e1c58 c45c4404", "5bef839c 55b1d0b1 248c50a3 bc959c5f"],
                ["173a6c76 c2ba719b ce3935ff ba04afea", "df5bbcb9 71559722 f0efc7bd fb7f9a36"]
              ],
              [
                ["00b8495f 16056286 fdb1329c eb8d09da", "6ac49ff1 fae35616 aeb8413b 7c7aebe0"],
                ["3931c129 569e83a5 29482c14 e628b457", "933bfc29 ed801b4d 68871483 92507b1a"]
              ],
              [
                ["00b8495f 16056286 fdb1329c eb8d09da", "6ac49ff1 fae35616 aeb8413b 7c7aebe0"],
                ["46ce3ed6 a9617c5a d6b7d3eb 19d74ba8", "6cc403d6 127fe4b2 9778eb7c 6daf84d3"]
              ]
            ]
          })
        }
      }, A2e = class extends $r {
        constructor() {
          super({
            id: "X448",
            ossl: "X448",
            type: "mont",
            endian: "le",
            hash: "SHAKE256",
            prime: "p448",
            p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff"],
            a: "262a6",
            b: "1",
            n: ["3fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff 7cca23e9", "c44edb49 aed63690 216cc272 8dc58f55", "2378c292 ab5844f3"],
            h: "4",
            z: "-1",
            g: [
              ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000005"],
              ["7d235d12 95f5b1f6 6c98ab6e 58326fce", "cbae5d34 f55545d0 60f75dc2 8df3f6ed", "b8027e23 46430d21 1312c4b1 50677af7", "6fd7223d 457b5b1a"]
            ],
            torsion: [
              [],
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]
              ],
              [
                ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"],
                ["ba4d3a08 29b6112f 8812e51b a0bb2abe", "bc1cb08e b48e5569 36ba50fd d2e7d68a", "f8cb3216 0522425b 3f990812 abbe635a", "d37a21e1 7551b193"]
              ],
              [
                ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"],
                ["45b2c5f7 d649eed0 77ed1ae4 5f44d541", "43e34f71 4b71aa96 c945af01 2d182975", "0734cde9 faddbda4 c066f7ed 54419ca5", "2c85de1e 8aae4e6c"]
              ]
            ]
          })
        }
      }, I2e = class extends $r {
        constructor() {
          super({
            id: "MONT448",
            ossl: null,
            type: "mont",
            endian: "le",
            hash: "SHAKE256",
            prime: "p448",
            p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff"],
            a: ["b2cf97d2 d43459a9 31ed36b1 fc4e3cb5", "5d93f8d2 22746997 60ccffc6 49961ed6", "c5b05fca c24864ed 6fb59697 931b78da", "84ddecd8 ca2b5cfb"],
            b: "1",
            n: ["3fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff 7cca23e9", "c44edb49 aed63690 216cc272 8dc58f55", "2378c292 ab5844f3"],
            h: "4",
            z: "-1",
            g: [
              ["ac0d24cc c6c75cb0 eb71f81e 7a6edf51", "48e88aee 009a2a24 e795687e c28e125a", "3e6730a6 0d46367b aa7fe99d 152128dc", "41321bc7 7817f059"],
              ["5a4437f6 80c0d0db 9b061276 d5d0ffcc", "e786ff33 b6a53d30 98746425 82e66f09", "4433dae7 7244a6e2 6b11e905 7228f483", "556c41a5 913f55fe"]
            ],
            torsion: [
              [],
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]
              ],
              [
                ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"],
                ["bec92fd0 6da2acf2 b4e261e8 7cef0d34", "22e75c18 3c589857 b71924e5 73c2f9ce", "e18da5f2 466e2f39 3c2eedf0 f105a60a", "b40c717d 4f1e1fd7"]
              ],
              [
                ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"],
                ["4136d02f 925d530d 4b1d9e17 8310f2cb", "dd18a3e7 c3a767a8 48e6db19 8c3d0631", "1e725a0d b991d0c6 c3d1120f 0efa59f5", "4bf38e82 b0e1e028"]
              ]
            ]
          })
        }
      }, T2e = class extends sn {
        constructor(e) {
          super({
            id: "ED25519",
            ossl: "ED25519",
            type: "edwards",
            endian: "le",
            hash: "SHA512",
            prefix: "SigEd25519 no Ed25519 collisions",
            context: !1,
            prime: "p25519",
            p: ["7fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffed"],
            a: "-1",
            d: ["52036cee 2b6ffe73 8cc74079 7779e898", "00700a4d 4141d8ab 75eb4dca 135978a3"],
            n: ["10000000 00000000 00000000 00000000", "14def9de a2f79cd6 5812631a 5cf5d3ed"],
            h: "8",
            z: "2",
            g: [
              ["216936d3 cd6e53fe c0a4e231 fdd6dc5c", "692cc760 9525a7b2 c9562d60 8f25d51a"],
              ["66666666 66666666 66666666 66666666", "66666666 66666666 66666666 66666658"], e
            ],
            torsion: [
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000001"]
              ],
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"],
                ["7fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffec"]
              ],
              [
                ["2b832480 4fc1df0b 2b4d0099 3dfbd7a7", "2f431806 ad2fe478 c4ee1b27 4a0ea0b0"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"]
              ],
              [
                ["547cdb7f b03e20f4 d4b2ff66 c2042858", "d0bce7f9 52d01b87 3b11e4d8 b5f15f3d"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"]
              ],
              [
                ["1fd5b9a0 06394a28 e9339932 38de4abb", "5c193c70 13e5e238 dea14646 c545d14a"],
                ["05fc536d 880238b1 3933c6d3 05acdfd5", "f098eff2 89f4c345 b027b2c2 8f95e826"]
              ],
              [
                ["602a465f f9c6b5d7 16cc66cd c721b544", "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"],
                ["05fc536d 880238b1 3933c6d3 05acdfd5", "f098eff2 89f4c345 b027b2c2 8f95e826"]
              ],
              [
                ["1fd5b9a0 06394a28 e9339932 38de4abb", "5c193c70 13e5e238 dea14646 c545d14a"],
                ["7a03ac92 77fdc74e c6cc392c fa53202a", "0f67100d 760b3cba 4fd84d3d 706a17c7"]
              ],
              [
                ["602a465f f9c6b5d7 16cc66cd c721b544", "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"],
                ["7a03ac92 77fdc74e c6cc392c fa53202a", "0f67100d 760b3cba 4fd84d3d 706a17c7"]
              ]
            ]
          })
        }
      }, R2e = class extends sn {
        constructor(e) {
          super({
            id: "ISO448",
            ossl: null,
            type: "edwards",
            endian: "le",
            hash: "SHAKE256",
            prefix: "SigEd448",
            context: !0,
            prime: "p448",
            p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff"],
            a: "1",
            d: ["d78b4bdc 7f0daf19 f24f38c2 9373a2cc", "ad461572 42a50f37 809b1da3 412a12e7", "9ccc9c81 264cfe9a d0809970 58fb61c4", "243cc32d baa156b9"],
            n: ["3fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff 7cca23e9", "c44edb49 aed63690 216cc272 8dc58f55", "2378c292 ab5844f3"],
            h: "4",
            z: "-1",
            g: [
              ["79a70b2b 70400553 ae7c9df4 16c792c6", "1128751a c9296924 0c25a07d 728bdc93", "e21f7787 ed697224 9de732f3 8496cd11", "69871309 3e9c04fc"],
              ["7fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff 80000000", "00000000 00000000 00000000 00000000", "00000000 00000001"], e
            ],
            torsion: [
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000001"]
              ],
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"],
                ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"]
              ],
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000001"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]
              ],
              [
                ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]
              ]
            ]
          })
        }
      }, k2e = class extends sn {
        constructor(e) {
          super({
            id: "ED448",
            ossl: "ED448",
            type: "edwards",
            endian: "le",
            hash: "SHAKE256",
            prefix: "SigEd448",
            context: !0,
            prime: "p448",
            p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff"],
            a: "1",
            d: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffff6756"],
            n: ["3fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff 7cca23e9", "c44edb49 aed63690 216cc272 8dc58f55", "2378c292 ab5844f3"],
            h: "4",
            z: "-1",
            g: [
              ["4f1970c6 6bed0ded 221d15a6 22bf36da", "9e146570 470f1767 ea6de324 a3d3a464", "12ae1af7 2ab66511 433b80e1 8b00938e", "2626a82b c70cc05e"],
              ["693f4671 6eb6bc24 88762037 56c9c762", "4bea7373 6ca39840 87789c1e 05a0c2d7", "3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad", "9808795b f230fa14"], e
            ],
            torsion: [
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000001"]
              ],
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"],
                ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"]
              ],
              [
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000001"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]
              ],
              [
                ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"],
                ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]
              ]
            ]
          })
        }
      }, i4 = {
        __proto__: null,
        P192: y2e,
        P224: g2e,
        P256: b2e,
        P384: m2e,
        P521: v2e,
        SECP256K1: w2e,
        BRAINPOOLP256: _2e,
        BRAINPOOLP384: E2e,
        BRAINPOOLP512: S2e,
        X25519: x2e,
        X448: A2e,
        MONT448: I2e,
        ED25519: T2e,
        ISO448: R2e,
        ED448: k2e
      }, mk = {
        __proto__: null,
        P192: null,
        P224: null,
        P256: null,
        P384: null,
        P521: null,
        SECP256K1: null,
        BRAINPOOLP256: null,
        BRAINPOOLP384: null,
        BRAINPOOLP512: null,
        X25519: null,
        X448: null,
        MONT448: null,
        ED25519: null,
        ISO448: null,
        ED448: null
      };

      function _lt(r, ...e) {
        z(typeof r == "string");
        let t = r.toUpperCase(),
          i = mk[t];
        if (!i) {
          let n = i4[t];
          if (!n) throw new Error(`Curve not found: "${r}".`);
          i = new n(...e), mk[t] = i
        }
        return i
      }

      function Elt(r, e) {
        z(typeof r == "string"), z(typeof e == "function");
        let t = r.toUpperCase();
        if (i4[t]) throw new Error(`Curve already registered: "${r}".`);
        i4[t] = e, mk[t] = null
      }

      function e4(r, e, t) {
        z(r instanceof we), z(!r.red), z(e >>> 0 === e), z(t >>> 0 === t);
        let i = new Array(t),
          n = r.bitLength() + 1,
          s = r.sign() | 1;
        z(n <= t);
        for (let u = 0; u < t; u++) i[u] = 0;
        let o = 0,
          a = 0,
          c;
        for (; o < n;) {
          if (r.bit(o) === a) {
            o += 1;
            continue
          }
          c = r.bits(o, e) + a, a = c >> e - 1 & 1, c -= a << e, i[o] = s * c, o += e
        }
        return z(a === 0), i
      }

      function mlt(r, e, t, i) {
        z(i >>> 0 === i);
        let n = e4(r, e, t),
          s = Math.ceil(n.length / i),
          o = new Array(s),
          a = 0;
        for (let c = 0; c < n.length; c += i) {
          let u = 0;
          for (let f = c + i - 1; f >= c; f--) u = (u << 1) + n[f];
          o[a++] = u
        }
        return z(a === s), o
      }

      function Slt(r, e, t) {
        z(r instanceof we), z(e instanceof we), z(!r.red), z(!e.red), z(t >>> 0 === t);
        let i = [new Array(t), new Array(t)],
          n = Math.max(r.bitLength(), e.bitLength()) + 1,
          s = r.sign() | 1,
          o = e.sign() | 1;
        z(n <= t);
        let a = 0,
          c = 0;
        for (let u = 0; u < n; u++) {
          let f = r.bits(u, 3),
            h = e.bits(u, 3),
            d = (f & 3) + a & 3,
            p = (h & 3) + c & 3,
            g = 0,
            m = 0;
          if (d === 3 && (d = -1), p === 3 && (p = -1), d & 1) {
            let E = (f & 7) + a & 7;
            (E === 3 || E === 5) && p === 2 ? g = -d : g = d
          }
          if (p & 1) {
            let E = (h & 7) + c & 7;
            (E === 3 || E === 5) && d === 2 ? m = -p : m = p
          }
          i[0][u] = g * s, i[1][u] = m * o, 2 * a === 1 + g && (a = 1 - a), 2 * c === 1 + m && (c = 1 - c)
        }
        for (let u = n; u < t; u++) i[0][u] = 0, i[1][u] = 0;
        return i
      }

      function vlt(r, e, t) {
        let i = Slt(r, e, t),
          n = new Array(t);
        for (let s = 0; s < t; s++) {
          let o = i[0][s],
            a = i[1][s];
          n[s] = glt[(o + 1) * 3 + (a + 1)]
        }
        return n
      }

      function z(r, e) {
        if (!r) {
          let t = new Error(e || "Assertion failed");
          throw Error.captureStackTrace && Error.captureStackTrace(t, z), t
        }
      }

      function h2e(r) {
        z(typeof r == "function");
        try {
          return r()
        } catch (e) {
          throw e.message === "X is not a square mod P." || e.message === "Not invertible." ? new Error("Invalid point.") : e
        }
      }

      function wlt(r, e) {
        let t = r % e;
        return t < 0 && (e < 0 ? t -= e : t += e), t
      }

      function xlt(r) {
        z(r instanceof we), z(r.red);
        let e = r.red.m;
        if (e.cmpn(3) <= 0) return r.clone();
        if (e.modrn(3) === 2) {
          let i = e.ushln(1).isubn(1).idivn(3);
          return r.redPow(i)
        }
        let t = e.modrn(9);
        if (t === 4) {
          let i = e.ushln(1).iaddn(1).idivn(9),
            n = r.redPow(i);
          if (!n.redSqr().redMul(n).eq(r)) throw new Error("X is not a cube mod P.");
          return n
        }
        if (t === 7) {
          let i = e.addn(2).idivn(9),
            n = r.redPow(i);
          if (!n.redSqr().redMul(n).eq(r)) throw new Error("X is not a cube mod P.");
          return n
        }
        throw new Error("Not implemented.")
      }

      function d2e(r) {
        let e = xlt(r);
        if (r.red.m.modrn(3) === 1) {
          let t = new we(2).toRed(r.red),
            i = new we(3).toRed(r.red),
            n = t.redInvert(),
            s = i.redNeg().redSqrt().redMul(n),
            o = s.redNeg(),
            a = s.redSub(n),
            c = o.redSub(n),
            u = e.redMul(a),
            f = e.redMul(c);
          return [e, u, f]
        }
        return [e]
      }

      function p2e(r) {
        for (let e of d2e(r))
          if (e.redJacobi() >= 0) return e;
        throw new Error("X^(1/3) is not a square mod P.")
      }

      function l2e(r) {
        return we.randomBits(r, 32).toNumber()
      }

      function dk(r, e) {
        let t = new WeakMap;
        return function (n, s) {
          let o = s & 1,
            a = t.get(n);
          if (a && a[o] !== null) return a[o];
          let c = r.call(e, n, s);
          return t.has(n) || t.set(n, [null, null]), t.get(n)[o] = c, c
        }
      }

      function e1(r, e) {
        z(r instanceof we), z(e >>> 0 === e), e & 7 && (e += 8 - (e & 7));
        let t = r.toString(16, e),
          i = [],
          n = [];
        z((t.length & 7) == 0);
        for (let s = 0; s < t.length; s += 8) i.push(t.slice(s, s + 8));
        for (let s = 0; s < i.length; s += 4) n.push(i.slice(s, s + 4).join(" "));
        return n
      }
      Es.Curve = es;
      Es.Point = Dr;
      Es.ShortCurve = Ir;
      Es.ShortPoint = Gr;
      Es.JPoint = Lh;
      Es.MontCurve = $r;
      Es.MontPoint = On;
      Es.XPoint = Ac;
      Es.EdwardsCurve = sn;
      Es.EdwardsPoint = Nn;
      Es.curves = i4;
      Es.curve = _lt;
      Es.register = Elt
    });
    var M2e = y(t1 => {
      l();
      "use strict";
      var ts = Su(),
        n4 = globalThis.crypto || globalThis.msCrypto,
        C2e = n4 && typeof n4.getRandomValues == "function",
        Alt = C2e ? n4.getRandomValues.bind(n4) : null,
        O2e = new Uint32Array(16),
        vk = 65536,
        wk = 0;

      function Ilt(r) {
        ts(r >>> 0 === r);
        let e = Buffer.alloc(r);
        return N2e(e, 0, r), e
      }

      function Tlt(r, e, t) {
        return ts(Buffer.isBuffer(r)), e == null && (e = 0), ts(e >>> 0 === e), t == null && (t = r.length - e), ts(t >>> 0 === t), ts(e + t <= r.length), N2e(r, e, t), r
      }

      function q2e() {
        return (wk & 15) == 0 && (_k(O2e), wk = 0), O2e[wk++]
      }

      function Rlt(r, e) {
        ts(r >>> 0 === r), ts(e >>> 0 === e), ts(e >= r);
        let t = e - r;
        if (t === 0) return r;
        let i = -t >>> 0,
          n, s;
        do n = q2e(), s = n % t; while (n - s > i);
        return s + r
      }

      function _k(r) {
        if (!C2e) throw new Error("Entropy source not available.");
        return Alt(r)
      }

      function N2e(r, e, t) {
        if (ts(Buffer.isBuffer(r)), ts(r.buffer instanceof ArrayBuffer), ts(r.byteOffset >>> 0 === r.byteOffset), ts(r.byteLength >>> 0 === r.byteLength), ts(e >>> 0 === e), ts(t >>> 0 === t), ts(e + t <= r.byteLength), t > 2 ** 31 - 1) throw new RangeError('The value "size" is out of range.');
        let i = r.byteOffset + e,
          n = new Uint8Array(r.buffer, i, t);
        if (n.length > vk)
          for (let s = 0; s < n.length; s += vk) {
            let o = s + vk;
            o > n.length && (o = n.length), _k(n.subarray(s, o))
          } else n.length > 0 && _k(n)
      }
      t1.native = 0;
      t1.randomBytes = Ilt;
      t1.randomFill = Tlt;
      t1.randomInt = q2e;
      t1.randomRange = Rlt
    });
    var D2e = y((ATt, B2e) => {
      l();
      "use strict";
      B2e.exports = M2e()
    });
    var K2e = y((ITt, L2e) => {
      l();
      "use strict";
      var xu = Su(),
        Ek = hk(),
        F2e = P2e(),
        Uh = D2e(),
        U2e = class {
          constructor(e, t, i) {
            xu(typeof e == "string"), xu(!t || typeof t == "string"), this.id = e, this.type = "ecdh", this.eid = t || null, this._pre = i || null, this._curve = null, this._edwards = null, this.native = 0
          }
          get curve() {
            return this._curve || (this._curve = F2e.curve(this.id)), this._curve
          }
          get edwards() {
            return this.eid && !this._edwards && (this._edwards = F2e.curve(this.eid, this._pre), this._edwards.precompute(Uh), this._pre = null), this._edwards
          }
          get size() {
            return this.curve.fieldSize
          }
          get bits() {
            return this.curve.fieldBits
          }
          privateKeyGenerate() {
            let e = Uh.randomBytes(this.curve.scalarSize);
            return this.curve.clamp(e)
          }
          privateKeyVerify(e) {
            return xu(Buffer.isBuffer(e)), e.length === this.curve.scalarSize
          }
          privateKeyExport(e, t) {
            let i = this.publicKeyCreate(e),
              {
                x: n,
                y: s
              } = this.publicKeyExport(i, t);
            return {
              d: Buffer.from(e),
              x: n,
              y: s
            }
          }
          privateKeyImport(e) {
            xu(e && typeof e == "object");
            let t = Ek.decode(e.d, this.curve.endian);
            if (t.byteLength() > this.curve.scalarSize) throw new Error("Invalid private key.");
            return this.curve.encodeScalar(t)
          }
          publicKeyCreate(e) {
            let t = this.curve.decodeClamped(e);
            if (this.edwards && this.edwards.g.pre) {
              let s = this.edwards.g.mulBlind(t);
              return this.curve.pointFromEdwards(s).encode()
            }
            return this.curve.g.toX().mulBlind(t, Uh).encode()
          }
          publicKeyConvert(e, t) {
            if (xu(t == null || typeof t == "boolean"), !this.edwards) throw new Error("No equivalent edwards curve.");
            let i = this.curve.decodePoint(e),
              n = this.edwards.pointFromMont(i);
            return t != null && n.isOdd() !== t ? n.neg().encode() : n.encode()
          }
          publicKeyFromUniform(e) {
            let t = this.curve.decodeUniform(e);
            return this.curve.pointFromUniform(t).encode()
          }
          publicKeyToUniform(e, t = Uh.randomInt()) {
            let i = this.curve.decodePoint(e),
              n = this.curve.pointToUniform(i, t);
            return this.curve.encodeUniform(n, t >>> 8)
          }
          publicKeyFromHash(e, t = !1) {
            return this.curve.pointFromHash(e, t).encode()
          }
          publicKeyToHash(e, t = Uh.randomInt()) {
            let i = this.curve.decodePoint(e);
            return this.curve.pointToHash(i, t, Uh)
          }
          publicKeyVerify(e) {
            xu(Buffer.isBuffer(e));
            let t;
            try {
              t = this.curve.decodeX(e)
            } catch (i) {
              return !1
            }
            return t.validate()
          }
          publicKeyIsSmall(e) {
            xu(Buffer.isBuffer(e));
            let t;
            try {
              t = this.curve.decodeX(e)
            } catch (i) {
              return !1
            }
            return t.validate() ? t.isSmall() : !1
          }
          publicKeyHasTorsion(e) {
            xu(Buffer.isBuffer(e));
            let t;
            try {
              t = this.curve.decodeX(e)
            } catch (i) {
              return !1
            }
            return t.validate() ? t.hasTorsion() : !1
          }
          publicKeyExport(e, t) {
            let {
              x: i,
              y: n
            } = this.curve.decodePoint(e, t);
            return {
              x: this.curve.encodeField(i.fromRed()),
              y: this.curve.encodeField(n.fromRed())
            }
          }
          publicKeyImport(e) {
            xu(e && typeof e == "object");
            let t = Ek.decode(e.x, this.curve.endian);
            if (t.cmp(this.curve.p) >= 0) throw new Error("Invalid point.");
            if (e.y != null) {
              let n = Ek.decode(e.y, this.curve.endian);
              if (n.cmp(this.curve.p) >= 0) throw new Error("Invalid point.");
              let s = this.curve.point(t, n);
              if (!s.validate()) throw new Error("Invalid point.");
              return s.encode()
            }
            return this.curve.pointFromX(t).encode()
          }
          derive(e, t) {
            let i = this.curve.decodeX(e),
              n = this.curve.decodeClamped(t);
            return i.mulBlind(n, Uh).encode()
          }
        };
      L2e.exports = U2e
    });
    var j2e = y((TTt, z2e) => {
      z2e.exports = {
        naf: {
          width: 9,
          points: [
            ["67ae9c4a22928f491ff4ae743edac83a6343981981624886ac62485fd3f8e25c", "1267b1d177ee69aba126a18e60269ef79f16ec176724030402c3684878f5b4d4"],
            ["49fda73eade3587bfcef7cf7d12da5de5c2819f93e1be1a591409cc0322ef233", "5f4825b298feae6fe02c6e148992466631282eca89430b5d10d21f83d676c8ed"],
            ["14568685fcf4bd4ee9e3ee194b1d810783e809f3bbf1ce955855981af50e4107", "31c563e32b47d52f87ce6468dd36ad41f0882b46f7abf23d12c4c4b59f4062b8"],
            ["357cc970c80071651bf336e06f9422b886d80e5c2e4e0294d3e023065185715c", "7f3d23c2c2dd0df4b2befce956f2d2fd1f789013236e4430c74e44845522f1c0"],
            ["14e528b1154be417b6cf078dd6712438d381a5b2c593d552ff2fd2c1207cf3cb", "2d9082313f21ab975a6f7ce340ff0fce1258591c3c9c58d4308f2dc36a033713"],
            ["107427e0d5f366ccdb33adf0282d304f8843e3e88d22b7b83780e073b7c05fed", "12dbb00ded538b7478466022d2da89b83740cfb2289a272387efe1aeea401f80"],
            ["4f162deaec2ec435dc5ac6f95d20419ed9631374770189cb90617f3e66a18dc1", "12cbfb2d04ff22f55162f70164d29331ace5af18a19a9aa1946d4cc4ad2e5cdf"],
            ["7dc52d5a7db816e9b850741ea2fd72918d94985b85a20b4dc5597853a876df6a", "6f6d2bca60003ef9f24ac245cc919fb717b188723b34f901cd6cfe9bec97be04"],
            ["1d81f74a5ba45c7022e8c140d763b9c1b0e281a5304696e74f791a3a04a94472", "3f185a93d95a4347227c5bb6ddd65cf42e1830823f435f3083fe6102691d55b9"],
            ["6f0ac78e5eb90e87958588f9d47541edf252cb1dde3d073cc45e3e7ef9365716", "6628d116b7975ae5f323e5ddf4f8cc35ae06d5c5c7d8a56effc66051336d289e"],
            ["2188ac423c67db5625915e05222a391bcaf91f05d9b7cc2cab5798b2d2e14d95", "23240c559c57b79a4df69a23fc46e50504277b1fa49369ab663d79782b33c0ee"],
            ["794241471ed9ceb009384b370cb8790fca98552ecb822dc06b19362c36353455", "71e918c03cdfca7207772e8d18ee8f9d92d79a0a83f378912362bc68d311dcd0"],
            ["163bc180c22dfc5da23c5c052107bba93a88b4360aa1d4e729611d8f5a7f8079", "631107a6ba83f7458194b9766a0a54f638ca20daf800384dbae1498677501939"],
            ["39a32a30f3eb1da0eb7e3903b8ace3da3890b24b61a3a9e79db663b5db0f7a5d", "4d4c54675dc1f1c9a1af9ca0010045dc803c16af345823136dd203715d67c491"],
            ["38085391a0e2831f59c33fcce7591515784d359925f11ff958e0e4658efac0e9", "42918001a829f49b5634e34ab7fac21b30e24660669ed91955cc31944a19e62a"],
            ["5e3573b049d6135ffbbbbd9a480617434f2455b4a591f719e91153eeb75a32a1", "54bc665420c789da1105d53983c1a0fc33bcc2690cd9b37d6566e21a85892871"],
            ["7ed068b25b82c05fdc0e46bd80a357f3acd2f5c3b9330bc8d474e5b28270f6eb", "01da83a187da8ccca704d46557a462551d70df7f943a681c3b97b1db6a21b7d3"],
            ["05ca3370e7516f6686111b72650aab4c5484407f14b515ade03951c6a14a0aa3", "6f407fc537b95277966e7f0f5e64b86904bf7baee091cee6011a3611834c6903"],
            ["624cb312b698bbd6dbca79b8d2b53cb5d8b3ab33c19306e87c18211f095ab9c3", "5b3336b2751e97c793731ac9b9a2243b6229f6d0bbea6b619395d0e5200bd8a3"],
            ["1ddf6ece608fe2901b34b7e4f47cfcb75e947e293c704d8121b11a31a051b5f9", "5e2dc58e9a48a749ce5296d229cfb34f96a147a8246d2e9844d52b52112ea94e"],
            ["396b384f3d61cfc060308fbb1c941ebc9418e2d9abd81316e08d625f48c0e101", "7223e5f7b66d1ca24962bac273a7aa6618cc60cb8a64a8837e0261107e7ad644"],
            ["53cc3dca3410277fb38d75e4ac0dde8e77a99c817170dbc9696cffe7890fbd50", "2592a3aafce64d7c69f4de468d5d5aa19845f5ca08f64a0a40e37d23ececbbe1"],
            ["34705fe600f5aed77b29d3eacdffcd45d886904156d43dc550bb7fc889cc1368", "299153c141a8950ffbcc8e9352993e642fa39a476200dd4acf42e158dbe3b01e"],
            ["5969255bd089181b991fce96b1792ba330a14f8a0b061f8118c9c336b8504618", "680a805fa0ae93c2a12b193517fb1147d355547e4ab18a9d6ca21575bbb4d7a4"],
            ["27d1d57fa8808d3d452df14bda4248b37902752163b1fd499a92456c59918ecb", "0a42f1c0f4c5d7de9e82904f0b4ff63988d31fedb8aad9d8ae009c7a1dff09c3"],
            ["0811d14bfdfdcf2144edd9cf55bce584a9ba17aec3eac8aaa82987ad703d9b8a", "42bea70d46f3ee0df0ec77d24c5495ea56ada2e0415920470c4746b68306376e"],
            ["4de090761b863cb0f0650297f154a8e66d00c5119c38e5dd05303d905d527a4a", "5eef0efd105361ce198a30e09e7e7edffbe3d70189e63ca68cf6057b9772baa8"],
            ["1d45517858ce45556aaee056ebab7e0ef3dc9ae3740aed570f3e76bfb4fc4817", "0b5a9d8fe8b7ccb04c0a5ef77798a3ec6e1bc1138604eb05e83844f0d4c5c699"],
            ["4285edbe9117f30aae1ef5ee419eb1d472106c6b3d7f3ce3701e39324b0eeafc", "503aa6104a682bcf2c0a60c84f4c22b50b0caa0fed8db87dedc7173eae04bdbd"],
            ["3ef830cbeff9b79039b1b6bd9bb52bbcfa56d008d91b9703ea1c80351f8687d6", "62349ff5d8dbd216a874769eec152ef9734bea9240eed623992c7553dc8ee4c8"],
            ["649a996e6d4d3b60ccb526939ed8929134107e03e2fd4648eaa2fa9830822c1a", "1648311b942fe95d492a1ace5e5235c1aea860d036d2475cc8964cd1acedee9c"],
            ["3a95596d97770d050d1ecc075d58a74f5fe6b4b8222740534ba22c8be73f9d56", "15a80cdcc03317a830fa4a7461de6bac136993e0a797f83b405c161a34c98fd7"],
            ["2d265d3fe1c88903ca93685209418deec5af886bf0d9fdb3f499d831cbb76ce1", "08376fb0663d3aa220948612b519af4a6a1f956622b15a305fb2e60a84210b3c"],
            ["642cb15498d8c6b25803f3e56b98e2ea185ac808cbeab5eb0a610ed5babb9385", "21b5ca5020a9e5a2334c0bee15193ea16c909963ffa6e1d93df4b239abeaeb3e"],
            ["38e576301ff6cdd0822a19c6d610d445d3967e2bada903abb6220f68c6e79bef", "458fe689e31a24952d2817dda4349109c1b26ef31699fa36c4f8389eeb60eac0"],
            ["372bec78d75011a0ef2233cd08790a7f15c1ec1e3a78cac8d6652678641780db", "32e9e47cf2f48612ed3e2c2006ea0c0c8476d3562aa88cefb67ec97abdb538e8"],
            ["1aa3756aabcc3eb65afee34e0a15dd67bfb9fb199eb131f4cc6a3ca9ec4d1c77", "42333e27831add6eb49af80e17347c63c26dd684758096ee3dbdbe03a49159ae"],
            ["38db16447d79d3590c4a36e20286beadfbae91a4eed2e5e7dd4f975ac0537dc5", "1c48ccaed60ec12ce862ea71165bba7df1739845df2a857f4ef0a0f714f96daa"],
            ["176b78984cddfddef90bae619c6a98e951d9a7ac7d6af218ae7e76b273212fb7", "7b5b93eda77443f366e2a127abe12212aad8536767ec1c5861143f777db85852"],
            ["042d154bf7b4a7bd73897ae528c6bc552ea58d74f8109e8e4052d3e9d38bb0f6", "42d1831323e279f9f7ee9e3470ba20ca7edc3245eca5d8ffa182de120a71fc90"],
            ["1f8d28dd4f286a8d0687b626b01204434bf5874a9550d6e375116490c154e108", "1ce82e2360367e06f41757fd45239f9bc2c61609139446b09b55a9c43da98bb8"],
            ["613eb914c015076e9ae8356bf508c289e50b1c87d9e2546f6e406362e248e5e5", "3edbaafcd8c41ef4aa18b254137d201a2ef0ca4ca28807156bc949e920b97353"],
            ["27bf43826bf0310b4b3e3a405eff790a1d77a8d48b04891246cff8e193cb03a9", "16a24d749cc1d234fbe8af9cfd782c3aaa5869d6db0afa7b4d4c67037514f2ea"],
            ["769a6a59746d7bead417bdd9c3b5f5ae1dbd924083ffd9e88df7714f57a675c2", "22dc1267cfb2b41c590abb7dc3df45619af688d0421f2bdfb50748335ec5da25"],
            ["795734ee4fcc24194219d25d41a2889cdb942f765848e9df63bff0b158c7224d", "756420ab5c71127d39d2e79907634a177af0e483e08484ea4d7b76f7100669b5"],
            ["644d12fc5e7fcac5aeb5911d8240971a99fc59fdd2903f46958e6896aefbcf46", "173450789fcd40172e8124fea56f7aedad2ee13fa8fc5209cc8cb572175216dc"],
            ["5deca767ef17b9e8d4f351f5c8ad1fcc50e97a2ed687516bf5210679fd6c1110", "4ddf2207da12f700708089989da016f3307ce5721c9e27c952599d67898aa396"],
            ["296dcb24cb3185d037a94bef93c97cacd09fc7050ba8472da59d4a689d9d2848", "0b17dc85a4acf73833fab728f15abccac97cd09e57975bd996d3e1dd8b060f7b"],
            ["408a3f1af2e77dfe94f8e225b40dfc146abb1002db7bcf15fde61c1a6cf1b93f", "4f01ec38854c15a879e7c7924f048e2ec951dcdf04a614088b68fbcc0954e1c8"],
            ["07d2d9234970cdc9483e0a7c5ec52c49077c440e0a993a1e624f90b8fafbbf07", "6ac2190030c210ae3e07b9239f6ee7affba263866ee7831a564c511f703f2295"],
            ["2982d553002082320aa899b9b6887e40dedf11868fa931689795d93d58452873", "215e16ca447978624cad0ea6bf45aada4eca914425ee275db2a26e980dc349b6"],
            ["1d8649515cb49e136d2895b6276569e5c711fe1a343eeb5a3daaa8d0e7b42d1a", "5b21e2f2978f343a3e9ec3316cdc111af3b55f34afa5fc3fcbf6c26c1bb7fb6c"],
            ["5460df4d607147939cdbc04dbdcbdffd37c5eafdd501b50a67213a23ee724a97", "69dfc7004263ccb52487d34ab134b80bb3030273999739cb9cdc16d71b9abcd8"],
            ["24623476f0af9f42ca15a0697ad23abeaf5ed9dc4d2b44f7e8175486598125bb", "6aebe4a1a22d9e31194dcde6d33ff3af77dda15c22b2ecba9329849b8c042687"],
            ["64e507a02bfd8a8413117bac253b17f94b2911681ebc07c92da0de6a651dd538", "513ac992d72b463da110afb612fbae36590248a0507d845ee95fab2d1caa03a4"],
            ["47f3bd11324f6bee230a22a5bb06a3ccddbc0473b810689efaeef894a654bf0e", "7e05db9b3ff886bf32608dfc8d14eaa91e2e2ef230e7c75618060e4285c492be"],
            ["4a6d22703a7045d02d656015ea2d168385d42963a739a895e4fd87b3e55c5e0f", "4c58d7a8c6ded0451798e51f16ffa5b637a87aa5defb119ba868d8cccf61776d"],
            ["3e22af70a548097244d7798964598172a90391f84c59b04cea7af283ba368eb5", "689d8b7cda23b8dea197c5119fbbbd81dd4b59a36cc283dbe292b5b6519a2968"],
            ["61a6ba2ca42d9d557b3a2ff0867c1b8bb8fc40192d31ff637431a302bc065a10", "63d805f5a79f845ea2915a25cf0a8cab2e0255212a1bd3c8852b25579b63721d"],
            ["03d963eeae48556e88305f91c478efcfd2168c346b9ba185884ec8621e8cb414", "74b75cc839a944ad8c639719d20fd9d48d2099ef24c8633eabec7a9ec1e7e183"],
            ["0f04da69e0202f7b44c58b103c88de09a0599951fedb17e7f2152d6b93a58ae9", "1fbc1c9cd03c4cfd46e8e90019debf86e8036587eade038346f91070c800b8c4"],
            ["797899e488353ed0c6666aff11913b33be0190833766e809b2a68cbc671a9cfe", "5dd70a33ff94a84b3fe660f7070e6179e86b5c846689265bf985ce424b8909cc"],
            ["735b64bb872606510e4e7d57833eb7ffdc4aa0dbaa242439806be68379f77cdd", "384aaaee3ca7ba2436fcb65910859ca5ec30c10af11df7d777d287bc1a2bce2c"],
            ["6f6ea532a62cf4766f55a0a72a86b55e73fe9d3328ee94bfc271e122f99dc1ac", "61d8203ef6da5d0b584541c02331c7f58617cf8d4f26d11776236ce8b113ac10"],
            ["5d99a2a3d4aed730b827b68ed836a9910dce4e7b93faf456981ad6cd85748773", "7eeacf5680fb6108a8b7edb45f7134644111b08e17c236469685af5a79474b9e"],
            ["31d0b4bb57bd7b69363c064a49bf3c3b9d7635bcc287e7b3059d3d99fd8382e8", "1592e581034e13d47d02b8966f5359097e652391be8fb1e803f4219a22aba2c0"],
            ["424cf5c498bbbe8fa7e5c3247049cc3f45946d0e5f38c44a36a6c84b60a84aa0", "34acd712d334a2315dc8fd00c5c9b7c5c9f29bca27380a018882a5ab4a0fcb43"],
            ["33a6ae0522936ba774837aa7959972f9804e3ef02ae84c8039be6595598be247", "37022798cc08be9b4ded34c1c5062ab3a26081d375cadf517972fb48135a6602"],
            ["5939635b72aeba595b5f6e376d11a3e07d4b1153ab4d0a7ab267b8bcc47cc3cb", "382162eb33db2322cbe01a38fa4d13720b6d8edfaf8116a628725ef4293a6c27"],
            ["3649e78d2ae9fb0ee86b691c27386efce4f3e383790e3cfee2bd59c2e85c4036", "09b0d9e0dd82e697b9be9d61ce0d1410e281122b483125c48f7942b22f5d5be4"],
            ["62c7585d1677b7619d8200175346ec99118416d8fdf0103730d165934e96a973", "5fef7955ee07304429995433a468d68dec4ecf6b08bbe8cd06869080094044de"],
            ["0c94537d311e17f5b0c58989b5be7e40c88b978a8c074a1e9bb07a713f77f6d3", "6deaaa5001bcbbbe9ae436fe42f7042ce74fbf83c14058427fad4587ed33c4e2"],
            ["6f5c6894a8d3877312e608c11809c15dffec3df551711095c8cfc810533e1b3e", "74eadab9389b40d6ac6cc0d6e333d628ced60a9ef7617751c20630d23477af7b"],
            ["4e16e88e171f9a07e11f97bba65c0fe5483501f255343afb3335ed47fbcee08f", "41bcd7dd328871247cb7995bc6bd2e1961e94b0fb12e5fb2f264f9ad2cf47d4c"],
            ["65d8484cef146e6c232fb262c2ac8200a52c63ccec26ff6f038aa5c74982c741", "67283346bbae9391952b141e57ca8e3a36f0363d3b81b1c0f2b3c30a92c74235"],
            ["1c588485b64be8cb99bf97f065e75a82138ea2e035ba90b63745354e9cf729f8", "7c9a18d6ebf5465a197989cfb9b5b2a66a5402f46c4708ac04187c6b157a0d77"],
            ["2c80c4ad0aebcafab7e9d2519a329f8a1c7df21cb6b1acec7403c0204d6dce71", "7f8e62983160756e35356df95d44467e621c7274372997ca74a9fb760b4db36f"],
            ["1e1e5fc87fa2c49e2c44d5718e3d73c73a91a64ac1374652080bd9004291b9c6", "153828e90ed8d94c0f86e0eb54ccb31073cd29ed62c34cd9f2dbc5d98872e597"],
            ["0ce0488a30ed446d445efb1bd21ba32ec3d05d538e6393bc0e58e0849ad57129", "7278074ac66ac779136f4d6a334b27633645dea0fc98d137e3dbd4015d12b5a1"],
            ["01a6b81f7285f293f19ba019b009aed8280ce285af42fab91e87fb0bbfa6dea4", "60f910dc7c9a82e7836f36acfe7ec26b9babfa8bf26b2945b3c1a43b0c19b4dc"],
            ["79b4ce3c6990023859646690c9ea800174902acfa1aad7ff34eca032dbde7150", "53a1053d3fc6c749bf8a928854f392d09fa851ba963ca661bffbe74f012ba45b"],
            ["220ee355b5c39c1901ed34c0f50f7778ad1bedcd7259ae167c16514ffe333498", "05fd9374986e1e06035dbfada0117035b96b159354262f2b2695af1256d6aa2a"],
            ["1e2f97d2cb4a19ca40403b364253da71f65d2d4665894267e3c6a9db8b4a3a18", "22804fb035acb519210ff99ed7a974a725d896a77933789b4dd45a37dea3466d"],
            ["35b8699fa20987876ac3b3086965b05f8cc809d71cab45e017c68ac96e24ed5b", "155079de21981778dc438353bf2c6a65967a1a33ebb74c866fb42f4e3cce3e39"],
            ["3cb40c55f5f19c52958e8c4ecd9c459b1d3268b3971b2286d3e58d1fc6b6a6bd", "379e1f1f59df05c74485615b87441ba6203f0cdddc6873a883d4cc6dd1b75921"],
            ["6ad916290e0d003ce5c961679f77704dcd768589d7cb728c60f56852031803bf", "1e602b4a6725832a56944234f84c4f85f79911b55beef903549089925f2ccbea"],
            ["7c0162492ae668160aa56a60e8bd43ec088555f750d2223cc37362dead5de123", "34e60b446eae100d4c3abc6cb02e4ca559457fb5a9030a290a2568fa4cbf118f"],
            ["354c25bf7b3e83dd0c5e1f39b82e3567edeb5337634056c1091cd6a016caacdf", "7abb271ef121630f85a9a1049b3ad78d5b889f533b37a713b8801de46770fc3a"],
            ["1e581a4bcf7504f33f4342b2097504d13f9b5a27f4790a6cdde1242209862850", "2164d56564360fd2b5dba2f2c6ef1045ab448c3b60b2f2196c2f74625fc39e07"],
            ["533b56f18283ee79b9a180b887c298961bd9aaa6fa3ef97fcb0d5688e694bc3d", "6011366753812df2bce83634a92dbac18dd1cffdbf9a97fa1b1d5b49e0026764"],
            ["4b508b94e6e2e6cd260a20664ea7d727ad20587b63ebe826032e0d20cdc6627b", "1e8ecd6ff5aabae78172a0214d07a5013992d133af58afa74049de726df2a6c4"],
            ["3398c0c0219f5ac87a8c73fcd17b89311d120a53f5231cb761030c194fed4265", "025b234a1dc8662c068c4ba903939c2f79f3f7a3ae64e5edbf667b13599142d9"],
            ["5941a17b04cd3465031cb6745cb94eed24e1ff8d38a6e832f1637ae8e89c78e6", "5309792c546b6cda458be331957763b5adb5d535d54a4a61023678faa2ee02ee"],
            ["2cb490d2c0047fcbaffe1df26640bee73c158af6fec91343d606ce9d124a20c9", "2e2952ebf089200aebfa3947f241e2fe85797afebdc1ea06d9d26de1b446a964"],
            ["79305236b583232a91c63c7d9ca3750be7ee21711e4d6d257c39ae398212bde1", "6f9ecdfa953e302c2014fd8512405e4be0d48302acd15e93936e8dba7d01053b"],
            ["57d9fcb884b94664f35387fa6665cd9bc8136f90d804d77416ea99c3c653ee63", "14197e65f0a3599c0b9fcef75b5fbb93580d1b2457b59fb70ce7b9bac88d0fbc"],
            ["6d99df2c28c9fa1e38acddefd3e0931109143d873f3330377a9926bdacdd6523", "2f21987905f397f092fc56c5ccd301a1e6afa3c4611627e25017b2e68d07c150"],
            ["749d19591f1755bd481fa12a288166aac42911654c8c551395b265116269ceb9", "7ec145aa7558d0342cd87b1750933cb6f3717e727a86a1cc1f2b0c274213688d"],
            ["340f7f5ae19292957902635a5786d14fa38036b324ae759da501e32b8c4073f1", "64e231a413f1379a26f4e8223ff91fe2ccd865549571d3c6c28871964b40a0ea"],
            ["4aa33e00bf6e92cac4e84384e5dde0727394233afd5d24d357a8afeb94b08109", "3385bb4fbc441937ee01b671d506227a654fd6c1c532cf5221710c6c56ec7e21"],
            ["34b2ffca05f01088de266306c5cc122661e9308eab16929774e58565afc0e4eb", "7662faf0f70e82c062c2b835fc6da3353d3cb20b80611ffa6ef2982cf62fa605"],
            ["820fcb51326f1536ddb8dc1052aa198406c7e48f2c81e7664d15f8f9d3715e", "756574c23bb01170b97d9fa1663a8ff2f5b97eaa5cd53f34140c1bcec8c262d9"],
            ["0861d7e84cec6d6e33641ff6c85202fc0e9160797809ddc2193802499caf05d3", "34936e0a5dc7e2a6217d475fbb8c1c607fb8b3565908a04fd5948abdd399c59f"],
            ["5b4a1dc887ef684d7b4b165b70acb70842a2fa105935af15ecb4a097e33b8f2b", "54d21511c05805e5298a72372b8289e9d59c46dc8b5c368bbfda620b68aa652c"],
            ["755493ed60b13f03f9c019362a5af73fb49842dd6916e2572b1b6a312cd20cfc", "0750bcbf7e449cec422b93ace1489e1b177d4dbbaa781d315c74d54bb444e9a9"],
            ["5f1c341065b6a81ed2edb6bc38ba81b4c2e3fe2058e5baa13e1406eb2c5b4b4b", "6179ebfa7f8086f26820fc99ca2f94c1be19bca672d79cea5b02a836119e06ba"],
            ["1915024ee86acfba3f61ced9707521197195166fb1c4639bf3b3fcf0bf0ded46", "5f2e0547032221d2b00937cf524590e3d90901ef0286ea0b032c1a81461b6d92"],
            ["4e942d95930f38c8786ff4a8e576e7a29fb7627afe1fff91cda5006ba0624f5d", "45902f695d512d70ce4c1e0520c0060896b94e14d2960b2fcf2ed5e138e0217b"],
            ["63e45f3d91ab915d412bbaa17d1d249e1a1445077fbfaa6be7d35041c5116a91", "46dad5a4ec2ad0b86938f5e09f1c03b53b660fc5137648b08527cd20708003da"],
            ["5e2ddd2175417f72c9962c503ac5adf94ed11f28b9d41fccb6a4512886f3cc87", "3523b218478911145af1dc431feb7db0a04066eb6e2ade3c7b67d11bc55323aa"],
            ["62ff30a6b179a26e7247a8312cb3af3289e5d722f76a29f203aa623889aa05ec", "562beb7999019346beaa80dfd5b95d614e1ff96c1cb1037f65c44997b797d066"],
            ["14988b5d62084fb8335c2f261cdeddc1b634b09cedfce713ff5f0a0bb588a556", "447068731fb98e821b8e413b3b48f2d1c8bea308f05aac877006b0f4c3b0cab3"],
            ["1ac777f708a5942cc434236920e82ccc6af920c0a0676712255aa7082b37a5b6", "52a6f88d92af1887c781501c6e3a88169a2831b74aefd416f22b47e8335ce317"],
            ["5959792833b71bd5042b78e42212af671f5f87a08eafd8cdde2dcec8140e4bb3", "41ce94633eabb8a1b08fac66f762997ed8c9e2af3558e1f6586ad6a5bf5b7b64"],
            ["4464a7962e6722b457336fe98c91765b1ff178f9e892e90129e65fa7688a0607", "3d1510b92fd33c501f058a7a86bddedf1b83f9b6e4f04829d321117013f891fe"],
            ["62906d81e7f800e662519f4324ab4c8aac197661c729eed3e744d09efe721c08", "4b68efb5b1b709ab86e3253d70bee87ba07875c04a64ecf7e35cd8cdc6c0f7d8"],
            ["4300ff025ac78ef36e58ee7d0d732cf76cd0929fe265b3a093a57f23fc326757", "2f92880570846ff2e90d91f16bce3705c9c3ca8011cc543091463b623e4b3c01"],
            ["5427ba28d94652527a9b0c76f57a451e46bdc06cbc8a2481df17f66ffb1524e3", "547a97c4afc8d1f74a5d51f7e524f68472f589cc0b396b21368628721537d722"],
            ["424c4493810bfd5e3ffa21776326d8ff62bf8fe74504d7a2db5d3f74e5ce1015", "74d0daa832d40405d01551a58b330ffc5abd5356230d6d7cabeb5b1a55046f32"],
            ["54e10980d81b4ae8778896684295fa5c5475e8d68ec2a26e1b0a65383507b3cd", "6b1eb48da6886c4d88cea720e9dc8b0d8c51a8f0e1943afa31a40eeb553c0676"],
            ["732eb9e9ebb556e9f024c5574166738f4707b0fd005f568212ab575c1db71ddb", "1fc6b00c89e48114d6b13d9920a0c78093994f2b08df147bdbb56bead2cea165"],
            ["74029c04b34b7f314855fee42a04d0ddfdeb92ef3bf7cff629928a97733d96fb", "501f63a252dfbc090733b5a208bfe08f81c91419ce3d2d6c0de8cdc5a5625014"],
            ["04524402ebb71a60bf1055001000203a6d4917f112e50dd766cdd7b718a6edd7", "71c9e2d15cdc47c565a696ffbe55277570930ed7ade13b9a254059365d5bf338"],
            ["2555c620a50f2bbeeacac66228a96941fa733aa6070855331613578ed7c12794", "2b3c1bc5cda7f93242561dbf7572237ac43bf013553230633a5e18b7e71597e5"],
            ["555ea607b0ad18afaf70d7450543d7ffb5b883a3cad3e2778826ca97bf3211a6", "6df903158f51aa530d411720a760f8ad0ce9904d54955fda74a349be58eddf5f"],
            ["4db3cfa284207a250a9c83e1fec07e804d70065da586ff2c2a7d2bcb92e6fca6", "2a4fbf1c51dc0b2a7783db2be3bd35c2d6462470c88c8b73ae3ce8503fa07154"],
            ["5174e33ffdf28a87184a4d6427d821cbaa3b88ac293a90ca7e1eeae8c5050b16", "315ca6bc8e35e4a3d06f89e1db1575b16197963ee8e64746fa998ccd403561cc"]
          ]
        },
        doubles: {
          step: 4,
          points: [
            ["23a4860627e53aeeb8e22b1508249c9109578d33e7bf237459b2596d6c28f9f8", "709696f2827fc3729f980f2e3aad6e78b06a11ff8e079c27d87aab37c16727eb"],
            ["5e7e07ed4e1decbfe6e9cbc126905449d4b578fbb561576d20b8bcdd0cc2a556", "0f55755c51f102796bf5ebaa81d3260e7d1b3d9ac127d9a80e142031566cf6c7"],
            ["7d13c0248b891b47eb524f2692008e2f97b199bac426cb5902b9003a29ded6ea", "59a976ab2c01a81a91f1a56c75ccc77a9e1e9e878e9fe9c3952080a6805b20d5"],
            ["5de7faa2ee4e70132f541f79ca07cd54a39fe1347a6844d19e9d678a8411a565", "2c9f23641e1c2e0aab8ea9926b432d92c0e8bc08901d6ff6df85e4cef854ec36"],
            ["06b349eebfed4dad4a805b63a6ed2231a565cda752d9477ff427dd9a8c9ab5ed", "07a09289ff3e1f9aab68aa374c48df65f550c2323607b97744dee990608b64f8"],
            ["0af367956af630266b1cc760154256ed79da960dddca9d72a1e8cf27d8d43a77", "21108d900134d3b3708dd28ace96b0b23dda9100e4b6a62a8131bd2f2ba408c5"],
            ["1e45a60140a3b2dee9b8dc6ff307154a1b410bcd38e0e38fb10b2f6da1afbe2b", "0e730da473dffd60d2f3241a85e68acb47d26e5043ad047d893f072c8dda0a76"],
            ["4d1e116d136158c5ddabd4276832800f2c081c1072de6f2d931797a46abc0cbb", "6d415be49d4e35b65cc51354b5008f8c43e84b7b5e8a4b84f44e1efb10c9b91a"],
            ["2b6b892ae94b454b2c2d92bb947fc4d506d173d281779c2c153c001ded42d3d0", "7f1cf64e0e180fc4d6e12c1b5c5285f376e979616a52c94a0dea4d48c5880cd2"],
            ["0f6c3a96e0032a9394337a02ffb2c83ba70efb8f566feab530fc90fa3b4710e5", "3d4e97e286378675038a4b58e84224ee515e1d6697ac79389f78479be167635a"],
            ["52ee53b981dfbc41ddaa5ddc2754c4175f4811aa45f8e2b19a425657c238a83e", "7eb0a1be3400dec87b388cad51613957643cdf0595b891cc6f925fb36da7f1c3"],
            ["52a837bc7a7bc9459bcc2ecf80f74d9ed99def0342e18cfbe8e799fbc504fd52", "50d6460185d8924e5485f23f36a98c86053514d163547adab6fe91478a411196"],
            ["6b2bd5d00fab38ceca21a27d6aaec82626b14b555d859527718f8ca404eba4", "727340c27a15f6ab3d80547f0827c56ab1ba33bc30d1ef3909ea9a3af10c67e5"],
            ["71dd75fe35761c01a48597ec730bc33237902fd4ad8612cbed1031eebdf40de4", "39674a4532078e34378667beae5cb55f814ead9bbaf7e01b3b69533e9f88a411"],
            ["57426aefc21be9ccf162e23d25ac3002ba8534351e65613f870f690f2fd46cf5", "6b45b002fb4e8a6f59a6ffb006ed71f75434217333b266325204c7d1ac2e1f34"],
            ["6222bd88bf2df9d5d44b60cfb4a08a960078db7ed51a35eb3e0b6b8ff4eda202", "0325bb42ea4ed025dd6bdaed261b7c4f5410b608ba902b068f1efa5782e45313"],
            ["71ac99647b61b9eca6f0c23432a518f738aee708d5932d4ef0f172240250a226", "3a96c2c028ebe5f48913be30147e41bc5e1cab9595d5404138a9aa1b5574cf25"],
            ["1f6a1fd8cc0e05b2742ba0fc0369b5247670543637dd033e64dbce90b2f23e9f", "779964401ee869a9b31c0ef874a86440ba85d25c2ce932bd31a0865869605e19"],
            ["22e2c039067920c42980dcb3a905fc91601c2b34e819ce1532ada4a5fc39d5cc", "631cf9945a09bf26d7e595b3f8e3390696870512820df63c5418577089e1a8bb"],
            ["608de273a9f6a534219d7aaede3cf65a81e4dc03d7a2765eced1d2b7be4610f4", "3b31d0113f98d81ab1312fb2837aa9c8dcc7960f84eb371358c6d841f67144fa"],
            ["3f748617ca63ab3e44c6e34f63e7328ea56a2a146da34368a57dca181254fe02", "0fed89e6420fc47b3938a2891ba9acee4cbb2899ee4e9ca15a13dc527dc1641e"],
            ["69d98b5ecc35d56c97c0bf312955d199befe116b417d70f5f57e2dfd0af81ce5", "3e26d487fbfe36ab44e0ca3b248fe94bce92a69b8154d50e2d5481f8259f4e8e"],
            ["1e34443347f9e627b3531157faab6eaca1bc3114df4a1423cc12bf8417b5d622", "295955a5ed061eca7f87b9485666ba9489ec20a9c484224dc920350bb4a6fc79"],
            ["51f4ff8c599b1c96da82941520a9f5abf4a31eb8b84fc95056145ceb3b5775d0", "35ac9588d46e41f3f6f99aee3852eeb4b12e807807d4bd1b7f8406b0d7863ac1"],
            ["3faa2a093a19a02424f65a10955101f4dc015c43b2dfce8e001507abd741b845", "7a1de10dacfda389ca663b15574bdc8ae8c5b6e7cee647e77b11ddbfc6eb8edc"],
            ["1924416956ea2c1269062588569b18178011ea7cba1a3266284f48aa01d5a90f", "0c8e28127b7dcdd206fb6fee96eb88cfc7db7319826ac8cdb8b1fb8adaf021de"],
            ["49761c57ce3c8c4f1435d495903e2f536f3be3712e76af8d0b5a8b7d1ebc8fac", "3225035e1065094ef32d7f3e7a6f8ff2748025f96e0c0b44eb35576b61e150a8"],
            ["4339fa86a23242851a16afc3ab05b352a7b4bf53599a49dd7e29d364fc3a757b", "6d07cc3462bae9160bbebb997510817040767faa9dbd13f158a5fe8a63a34b0e"],
            ["6bda13918dcbaf8529d6326ae7a9c278b72417c2188c5ea4f062fc50639295fb", "2c3fa803b162ee887d0d97a6734866f992f846625f314117075da54bb6c20a36"],
            ["4da4821314574d4fed4dcf692c8b15b99b73f13633210333ce7871359b6e6424", "314016034673d2d20529bc93a2dab6e462bcb5f66e1f4a6bf2170759a40a6e65"],
            ["0b2cea0029ee963c0034b61bf19e384435f14554a7d297b5144838c38e375586", "47ea95da28d39aaade5edb8ed941c687603cfdd1508776e96d6683199e99daea"],
            ["4c27afff3c45f32c952d3984e14e29a098e685c9c2e723e5fc8047ae60b7e824", "5f2c99e6526dc87d95f11eb626c29c3a90d0be1e51a4c49e5bbabd114bf5a66b"],
            ["53e2a4ed1bbb48bd016c524a02f797654cfc969849f867681da94e341f377534", "5a2334fdda642732a3c9520ce06581aa7f0f082882554c37b8d390a25a9bd559"],
            ["7b8d2c823baafe0d878a55e8af1db150dec85b1424a4901f9beffd3a6196e3d6", "1c45a557b3624f9b89ed15b3c3e1a065f1b453d948f7cf45d9494483f8af0c85"],
            ["78877b5d8777410997dacaeea59400fc9db4421fac02c4282301c67d35fb7ffe", "0341b46c328333e4484ce8607619014d41775c408c88856d2f9e19812d90fbf5"],
            ["2b556bbc070b5c4bae9e575836d1d68ee9fbe800448c0d2c233f78185eed3f91", "7ba01332807ebd892e00ddb368c0fa1b3f19b5b32efd90b178d984e1d7174d6f"],
            ["0f72556998b0044799f0fd03210ded3d984e3843bbaf3c1d5d692bc94d43c4e7", "16c19c5037c103d447caef4efe6bd81a490e7c668f6870f1b080863b5315df5e"],
            ["1cd96ef237b213cd446f13b3ec40d32ecc593bc6ea71e77efc284341a5f3da1a", "7a626aeb91efcb5f9777264f5e17ced8b411f68c713673ef0f184a5ccd60dbe3"],
            ["31a75b21cb532622a7caf9e29e652ac4e47b1450edf6655acaf3797b55a7ca46", "77006e7cf104982f8865081a2ff8a6911546755e31c3586353b0bd0826c5d790"],
            ["543d84cb04fb2bf787b7aa382eaab5cd8d050ad8ee52aa8a285b945652014031", "0358fdc5b63ed49e693d838f182b275846f42dd49a42ec2e6e932ba4de59ef20"],
            ["0a2818f5f5d8937800c30ac6b847db2cdef655b864126302249144a5a15b205a", "187c76a49af10851bb049ba97c0fbbb14b2621522a4e8d9670ea46e56c9a1bd6"],
            ["7efb45d3a2851109d7a8d50ddb08fe308bbf674c019b965cdad4570a141e648a", "0fe1198b11a1bf56867091c69d71f8b7792257dda321d43652e818acd0c28cda"],
            ["472e960dd122a534f52377235350549df4a1dd7a08cfc580bff5fb4b0a70aa7b", "10585d04fc529fef4c0c0776154fc7ebbaedbae8a99937e47598d0578932b7cc"],
            ["04892cfff7f94ff7f07c1241e3ac4945bc46ea9d6a3c1c3adbce109a9afceb6a", "3ae2aa25e2555135a7a3251c11a3f8eebe81758bc1c3e2cbc6e6ca461a543130"],
            ["2401d311a3abfd2583f1c6aa519c1f18ff730a0abf730ddcc9c9739b04d8a85e", "653224f3488cae1ae19a414a9932035a2bf2c46803b5532bbb645e62387ee34d"],
            ["0ea2c846a535a115972161612a192588d92d68a3c9050eae91b2817b94e68325", "3b82a8337b05f11bbac176a113be183a50a0331f3d3116f24b971b5a8b0d031b"],
            ["0fb3f87c2c6c89c65b74299b77f3736546a8b9e41b19197476bff27354e1c128", "1034d42c15a2bfe3e682fad49dbc2812caadf0c584bc30b51625b85d74e9d5f7"],
            ["1bc7af1e38185e7c2d8d04371c7e177d7a9ddee1b81d7d26db7ad644c7dad28d", "61d909d855661f2f7a5eef87795dc0491d027e12631b270fcaf2f65900314833"],
            ["469d0960dbd0ef9c91c4597ccf7c209549b187ff63bd378b7dac577198d74a4d", "0b5f21c7f86832241f2157c288bdc9394f83f8d57457f6d9f6b345e4909478cb"],
            ["5e9ac4ab2f4a3c3526e1317f913d69e3826fe862efd0c80d9310319170c5cbeb", "505f00fa8aee03ccbd2f33529ae1e4e4bcf2644fe673d0b0290ec32be5b51bab"],
            ["11cd80e1fdcbc565efed81d17f3f54643ffeed1cff38f3825e115adbd82759f1", "43f11943f7ef3fa68b980fee45e98134f1df22263b2d14419d61ffe62822dbe0"],
            ["3328bc121616a9477165ed282053d203c24f4826076c638a2c6723d42c9bfadb", "2bbf3f26c21b5cb273e5f4f0114c6718c5eb7291939b7697c74333cdfafac039"],
            ["0ba774bb605dd804cae6887e81f6bd2c59e024fac8bf5f5c48a841a037c28398", "54ba013ad2d04dcdfb5a151b7347ee9a10067ddd0a3907e9bc337a77bf911321"],
            ["1074ff0267662dc2b4ce65aaa0229c375a3d0d843ce9349233949581c869b64c", "299be0decb680ec28923da4d049770107d42c180b460da13a7b1efc7e6d5b022"],
            ["25ed76d78c87c3bd64b4331902c5a853734283e25f19f320295667b80a340d35", "179b5f92f545c7b326b3a63fb0b32a0f52b4159988436d5af50c1d0d76373947"],
            ["75d942c04210dcde5d1bd4fabfc732d3f95568e399382c0423c83c41cb05dc3f", "696cc14856cdc13c8fd7e2c5771731cbf38e3fad47a424679765c4874e35ab2d"],
            ["5d9324f56975477d5945599eeeccec67708c996cd3f3f2818bf2591507e3502a", "10985a3cfd573205281aec24e2c8b41f5cd8cdfc9d7be34675cf306bbe1b4f6a"],
            ["7511066c0e12105a7b937c7ecef367d5afe6e621e5cabf4e490b09b7ada7ee07", "604df365b8391cbca8848f88daa700b770da5bb136f70bfb0a3ea33ba386fcd5"],
            ["2596e5b3cf5494e60d2a750d03c66abc2e0183af53620b893f9cf9fc3b76dc26", "68a0a7ac9a0cc093884a6b84f45a2cde595194e0f48dbd566fa78a3174b182fe"],
            ["28bd38d44030dd9ca028b2a2f31a795f4c7a5e85a785df7847e3d525e99d4787", "552dd7405c4183733ad3c4e7ccb999b4fed81b7a4444aab499d41d6d78d5bbfc"],
            ["59233a3346f61135f431f96cf0197e24ad38240b222c010a6ce538cf4c24347b", "3cce55908611d2b93f221613f09cfc4dbcd2e2b609233eea5439ad1908a10b20"],
            ["5830f025f1078d408948f73096af97de1e9e70b3be85890acb21132c34ff961f", "67d451752c2433ffe66e47242e301e56db2b2f8203553cab9de717e25793d41e"],
            ["6a0c8b194571e874b82d904da36d43096bbe36d512e24ff8dcb2b00b57ffd3ec", "5f85adb7749cc735ec838bcccfe7d4b52902c6132998d7ac8e032cad031c42b8"],
            ["53b3f967bff8760948dec5e9282f35d1434a5503790b9012e17faefbe7c4d699", "404462283c8664a17daa5b4059dcd10e2699fd86d0140de9f3e8ad0566098ae5"]
          ]
        }
      }
    });
    var s4 = y((RTt, V2e) => {
      l();
      "use strict";
      var klt = K2e(),
        Plt = j2e();
      V2e.exports = new klt("X25519", "ED25519", Plt)
    });
    var G2e = y((kTt, H2e) => {
      l();
      H2e.exports = function (e) {
        return e != null && e.constructor != null && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e)
      }
    });
    var Y2e = y((PTt, $2e) => {
      l();
      "use strict";
      var Clt = G2e(),
        Olt = gp(),
        W2e = da();
      $2e.exports = (r, e = {}) => {
        let t = Olt(r),
          i = W2e.decode.fromReader(t.reader, e),
          n = !1,
          s = {
            read: async o => {
              let {
                value: a,
                done: c
              } = await t.reader.next(o);
              if (c && a.length < o) throw new Error("Couldn't read enough bytes");
              if (n = c, !a) throw new Error("Value is null");
              return a
            },
            readLP: async () => {
              let {
                value: o,
                done: a
              } = await i.next();
              if (n = a, !o) throw new Error("Value is null");
              return o
            },
            readPB: async o => {
              let a = await s.readLP();
              if (!a) throw new Error("Value is null");
              let c = Clt(a) ? a : a.slice();
              return o.decode(c)
            },
            write: o => {
              t.writer.push(o)
            },
            writeLP: o => {
              s.write(W2e.encode.single(o, e))
            },
            writePB: (o, a) => {
              s.writeLP(a.encode(o))
            },
            pb: o => ({
              read: () => s.readPB(o),
              write: a => s.writePB(a, o)
            }),
            unwrap: () => (t.rest(), t.stream)
          };
        return s
      }
    });
    var X2e = y((CTt, J2e) => {
      l();
      "use strict";
      var Nlt = __();
      J2e.exports = function () {
        let e, t, i = async s => {
          if (e) throw new Error("already piped");
          e = Nlt(s), t && t(e)
        }, n = {
          [Symbol.asyncIterator]() {
            return this
          },
          next() {
            return e ? e.next() : new Promise(s => {
              t = o => {
                t = null, s(o.next())
              }
            })
          }
        };
        return {
          sink: i,
          source: n
        }
      }
    });
    var eve = y((OTt, Z2e) => {
      l();
      var Q2e = X2e();
      Z2e.exports = function () {
        var r = Q2e(),
          e = Q2e();
        return [{
          source: r.source,
          sink: e.sink
        }, {
          source: e.source,
          sink: r.sink
        }]
      }
    });
    var ive = y(Gb => {
      l();
      "use strict";
      var $b = Su();

      function tve(r, e, t) {
        return $b(r && typeof r.id == "string"), e == null && (e = Buffer.alloc(0)), t == null && (t = Buffer.alloc(r.size, 0)), r.mac(e, t)
      }

      function rve(r, e, t, i) {
        if (t == null && (t = Buffer.alloc(0)), $b(r && typeof r.id == "string"), $b(Buffer.isBuffer(e)), $b(Buffer.isBuffer(t)), $b(i >>> 0 === i), e.length !== r.size) throw new RangeError("Invalid PRK length.");
        let n = Math.ceil(i / r.size);
        if (n > 255) throw new RangeError("Invalid output length.");
        let s = Buffer.alloc(n * r.size),
          o = Buffer.from([0]),
          a = r.hmac(),
          c = Buffer.alloc(0),
          u = 0;
        for (let f = 0; f < n; f++) o[0] += 1, a.init(e), a.update(c), a.update(t), a.update(o), c = a.final(), u += c.copy(s, u);
        return s.slice(0, i)
      }

      function qlt(r, e, t, i, n) {
        let s = tve(r, e, t);
        return rve(r, s, i, n)
      }
      Gb.native = 0;
      Gb.extract = tve;
      Gb.expand = rve;
      Gb.derive = qlt
    });
    var sve = y((qTt, nve) => {
      l();
      "use strict";
      nve.exports = ive()
    });
    var cve = y((MTt, ove) => {
      l();
      "use strict";
      var r1 = Su(),
        ave = class {
          constructor(e, t, i = [], n = []) {
            r1(typeof e == "function"), r1(t >>> 0 === t), r1(Array.isArray(i)), r1(Array.isArray(n)), this.hash = e, this.size = t, this.x = i, this.y = n, this.inner = new e, this.outer = new e
          }
          init(e) {
            if (r1(Buffer.isBuffer(e)), e.length > this.size) {
              let i = this.hash,
                n = new i;
              n.init(...this.x), n.update(e), e = n.final(...this.y), r1(e.length <= this.size)
            }
            let t = Buffer.alloc(this.size);
            for (let i = 0; i < e.length; i++) t[i] = e[i] ^ 54;
            for (let i = e.length; i < t.length; i++) t[i] = 54;
            this.inner.init(...this.x), this.inner.update(t);
            for (let i = 0; i < e.length; i++) t[i] = e[i] ^ 92;
            for (let i = e.length; i < t.length; i++) t[i] = 92;
            return this.outer.init(...this.x), this.outer.update(t), this
          }
          update(e) {
            return this.inner.update(e), this
          }
          final() {
            return this.outer.update(this.inner.final(...this.y)), this.outer.final(...this.y)
          }
        };
      ove.exports = ave
    });
    var Ak = y((BTt, uve) => {
      l();
      "use strict";
      var Wb = Su(),
        Mlt = cve(),
        o4 = -1,
        Sk = Buffer.alloc(8, 0),
        fve = Buffer.alloc(64, 0);
      fve[0] = 128;
      var Blt = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
        vn = class {
          constructor() {
            this.state = new Uint32Array(8), this.msg = new Uint32Array(64), this.block = Buffer.alloc(64), this.size = o4
          }
          init() {
            return this.state[0] = 1779033703, this.state[1] = 3144134277, this.state[2] = 1013904242, this.state[3] = 2773480762, this.state[4] = 1359893119, this.state[5] = 2600822924, this.state[6] = 528734635, this.state[7] = 1541459225, this.size = 0, this
          }
          update(e) {
            return Wb(Buffer.isBuffer(e)), this._update(e, e.length), this
          }
          final() {
            return this._final(Buffer.alloc(32))
          }
          _update(e, t) {
            Wb(this.size !== o4, "Context is not initialized.");
            let i = this.size & 63,
              n = 0;
            if (this.size += t, i > 0) {
              let s = 64 - i;
              if (s > t && (s = t), e.copy(this.block, i, n, n + s), i += s, t -= s, n += s, i < 64) return;
              this._transform(this.block, 0)
            }
            for (; t >= 64;) this._transform(e, n), n += 64, t -= 64;
            t > 0 && e.copy(this.block, 0, n, n + t)
          }
          _final(e) {
            Wb(this.size !== o4, "Context is not initialized.");
            let t = this.size & 63,
              i = this.size * 8;
            xk(Sk, i * (1 / 4294967296) >>> 0, 0), xk(Sk, i >>> 0, 4), this._update(fve, 1 + (119 - t & 63)), this._update(Sk, 8);
            for (let n = 0; n < 8; n++) xk(e, this.state[n], n * 4), this.state[n] = 0;
            for (let n = 0; n < 64; n++) this.msg[n] = 0;
            for (let n = 0; n < 64; n++) this.block[n] = 0;
            return this.size = o4, e
          }
          _transform(e, t) {
            let i = this.msg,
              n = this.state[0],
              s = this.state[1],
              o = this.state[2],
              a = this.state[3],
              c = this.state[4],
              u = this.state[5],
              f = this.state[6],
              h = this.state[7],
              d = 0;
            for (; d < 16; d++) i[d] = jlt(e, t + d * 4);
            for (; d < 64; d++) i[d] = Ult(i[d - 2]) + i[d - 7] + Flt(i[d - 15]) + i[d - 16];
            for (d = 0; d < 64; d++) {
              let p = h + Llt(c) + Klt(c, u, f) + Blt[d] + i[d],
                g = Dlt(n) + zlt(n, s, o);
              h = f, f = u, u = c, c = a + p >>> 0, a = o, o = s, s = n, n = p + g >>> 0
            }
            this.state[0] += n, this.state[1] += s, this.state[2] += o, this.state[3] += a, this.state[4] += c, this.state[5] += u, this.state[6] += f, this.state[7] += h
          }
          static hash() {
            return new vn
          }
          static hmac() {
            return new Mlt(vn, 64)
          }
          static digest(e) {
            return vn.ctx.init().update(e).final()
          }
          static root(e, t) {
            return Wb(Buffer.isBuffer(e) && e.length === 32), Wb(Buffer.isBuffer(t) && t.length === 32), vn.ctx.init().update(e).update(t).final()
          }
          static multi(e, t, i) {
            let {
              ctx: n
            } = vn;
            return n.init(), n.update(e), n.update(t), i && n.update(i), n.final()
          }
          static mac(e, t) {
            return vn.hmac().init(t).update(e).final()
          }
        };
      vn.native = 0;
      vn.id = "SHA256";
      vn.size = 32;
      vn.bits = 256;
      vn.blockSize = 64;
      vn.zero = Buffer.alloc(32, 0);
      vn.ctx = new vn;

      function Dlt(r) {
        return (r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10)
      }

      function Llt(r) {
        return (r >>> 6 | r << 26) ^ (r >>> 11 | r << 21) ^ (r >>> 25 | r << 7)
      }

      function Flt(r) {
        return (r >>> 7 | r << 25) ^ (r >>> 18 | r << 14) ^ r >>> 3
      }

      function Ult(r) {
        return (r >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10
      }

      function Klt(r, e, t) {
        return t ^ r & (e ^ t)
      }

      function zlt(r, e, t) {
        return r & e | t & (r | e)
      }

      function jlt(r, e) {
        return r[e++] * 16777216 + r[e++] * 65536 + r[e++] * 256 + r[e]
      }

      function xk(r, e, t) {
        return r[t++] = e >>> 24, r[t++] = e >>> 16, r[t++] = e >>> 8, r[t++] = e, t
      }
      uve.exports = vn
    });
    var hve = y((lve, Yb) => {
      l();
      "use strict";
      (function (r, e) {
        typeof define == "function" && define.amd ? define(["protobufjs/minimal"], e) : typeof Yb == "object" && Yb && Yb.exports && (Yb.exports = e(bi()))
      })(lve, function (r) {
        "use strict";
        var e = r.Reader,
          t = r.Writer,
          i = r.util,
          n = r.roots["libp2p-noise"] || (r.roots["libp2p-noise"] = {});
        return n.pb = function () {
          var s = {};
          return s.NoiseHandshakePayload = function () {
            function o(a) {
              if (a)
                for (var c = Object.keys(a), u = 0; u < c.length; ++u) a[c[u]] != null && (this[c[u]] = a[c[u]])
            }
            return o.prototype.identityKey = i.newBuffer([]), o.prototype.identitySig = i.newBuffer([]), o.prototype.data = i.newBuffer([]), o.create = function (c) {
              return new o(c)
            }, o.encode = function (c, u) {
              return u || (u = t.create()), c.identityKey != null && Object.hasOwnProperty.call(c, "identityKey") && u.uint32(10).bytes(c.identityKey), c.identitySig != null && Object.hasOwnProperty.call(c, "identitySig") && u.uint32(18).bytes(c.identitySig), c.data != null && Object.hasOwnProperty.call(c, "data") && u.uint32(26).bytes(c.data), u
            }, o.encodeDelimited = function (c, u) {
              return this.encode(c, u).ldelim()
            }, o.decode = function (c, u) {
              c instanceof e || (c = e.create(c));
              for (var f = u === void 0 ? c.len : c.pos + u, h = new n.pb.NoiseHandshakePayload; c.pos < f;) {
                var d = c.uint32();
                switch (d >>> 3) {
                  case 1:
                    h.identityKey = c.bytes();
                    break;
                  case 2:
                    h.identitySig = c.bytes();
                    break;
                  case 3:
                    h.data = c.bytes();
                    break;
                  default:
                    c.skipType(d & 7);
                    break
                }
              }
              return h
            }, o.decodeDelimited = function (c) {
              return c instanceof e || (c = new e(c)), this.decode(c, c.uint32())
            }, o.verify = function (c) {
              return typeof c != "object" || c === null ? "object expected" : c.identityKey != null && c.hasOwnProperty("identityKey") && !(c.identityKey && typeof c.identityKey.length == "number" || i.isString(c.identityKey)) ? "identityKey: buffer expected" : c.identitySig != null && c.hasOwnProperty("identitySig") && !(c.identitySig && typeof c.identitySig.length == "number" || i.isString(c.identitySig)) ? "identitySig: buffer expected" : c.data != null && c.hasOwnProperty("data") && !(c.data && typeof c.data.length == "number" || i.isString(c.data)) ? "data: buffer expected" : null
            }, o.fromObject = function (c) {
              if (c instanceof n.pb.NoiseHandshakePayload) return c;
              var u = new n.pb.NoiseHandshakePayload;
              return c.identityKey != null && (typeof c.identityKey == "string" ? i.base64.decode(c.identityKey, u.identityKey = i.newBuffer(i.base64.length(c.identityKey)), 0) : c.identityKey.length && (u.identityKey = c.identityKey)), c.identitySig != null && (typeof c.identitySig == "string" ? i.base64.decode(c.identitySig, u.identitySig = i.newBuffer(i.base64.length(c.identitySig)), 0) : c.identitySig.length && (u.identitySig = c.identitySig)), c.data != null && (typeof c.data == "string" ? i.base64.decode(c.data, u.data = i.newBuffer(i.base64.length(c.data)), 0) : c.data.length && (u.data = c.data)), u
            }, o.toObject = function (c, u) {
              u || (u = {});
              var f = {};
              return u.defaults && (u.bytes === String ? f.identityKey = "" : (f.identityKey = [], u.bytes !== Array && (f.identityKey = i.newBuffer(f.identityKey))), u.bytes === String ? f.identitySig = "" : (f.identitySig = [], u.bytes !== Array && (f.identitySig = i.newBuffer(f.identitySig))), u.bytes === String ? f.data = "" : (f.data = [], u.bytes !== Array && (f.data = i.newBuffer(f.data)))), c.identityKey != null && c.hasOwnProperty("identityKey") && (f.identityKey = u.bytes === String ? i.base64.encode(c.identityKey, 0, c.identityKey.length) : u.bytes === Array ? Array.prototype.slice.call(c.identityKey) : c.identityKey), c.identitySig != null && c.hasOwnProperty("identitySig") && (f.identitySig = u.bytes === String ? i.base64.encode(c.identitySig, 0, c.identitySig.length) : u.bytes === Array ? Array.prototype.slice.call(c.identitySig) : c.identitySig), c.data != null && c.hasOwnProperty("data") && (f.data = u.bytes === String ? i.base64.encode(c.data, 0, c.data.length) : u.bytes === Array ? Array.prototype.slice.call(c.data) : c.data), f
            }, o.prototype.toJSON = function () {
              return this.constructor.toObject(this, r.util.toJSONOptions)
            }, o
          }(), s
        }(), n
      })
    });
    var Hf = y(Wr => {
      l();
      "use strict";
      var Jb = Wr && Wr.__importDefault || function (r) {
        return r && r.__esModule ? r : {
          default: r
        }
      };
      Object.defineProperty(Wr, "__esModule", {
        value: !0
      });
      Wr.isValidPublicKey = Wr.getHkdf = Wr.verifySignedPayload = Wr.getHandshakePayload = Wr.decodePayload = Wr.getPeerIdFromPayload = Wr.signPayload = Wr.createHandshakePayload = Wr.getPayload = Wr.generateKeypair = void 0;
      var dve = Jb(sve()),
        Ik = Jb(s4()),
        pve = Jb(Ak()),
        Ea = Wt(),
        Tk = Jb(Et()),
        Vlt = Ja(),
        Hlt = hve(),
        Glt = Jb(Lr()),
        a4 = Hlt.pb.NoiseHandshakePayload;

      function $lt() {
        let r = Ik.default.privateKeyGenerate();
        return {
          publicKey: Ik.default.publicKeyCreate(r),
          privateKey: r
        }
      }
      Wr.generateKeypair = $lt;
      async function Wlt(r, e, t) {
        let i = await gve(r, Rk(e)),
          n = t ?? Ea.Buffer.alloc(0);
        return yve(r.marshalPubKey(), i, n)
      }
      Wr.getPayload = Wlt;

      function yve(r, e, t) {
        let i = a4.create({
          identityKey: Ea.Buffer.from(r),
          identitySig: e,
          data: t ?? null
        });
        return Ea.Buffer.from(a4.encode(i).finish())
      }
      Wr.createHandshakePayload = yve;
      async function gve(r, e) {
        return Ea.Buffer.from(await r.privKey.sign(e))
      }
      Wr.signPayload = gve;
      async function Ylt(r) {
        return await Tk.default.createFromPubKey(Ea.Buffer.from(r.identityKey))
      }
      Wr.getPeerIdFromPayload = Ylt;

      function Jlt(r) {
        return a4.toObject(a4.decode(Ea.Buffer.from(r)))
      }
      Wr.decodePayload = Jlt;

      function Rk(r) {
        return Ea.Buffer.concat([Ea.Buffer.from("noise-libp2p-static-key:"), r])
      }
      Wr.getHandshakePayload = Rk;
      async function Xlt(r, e) {
        let t = await Tk.default.createFromPubKey(e);
        return Glt.default(t.id, r)
      }
      async function Zlt(r, e, t) {
        let i = Ea.Buffer.from(e.identityKey);
        if (!await Xlt(t.id, i)) throw new Error("Peer ID doesn't match libp2p public key.");
        let n = Rk(r),
          s = Vlt.keys.unmarshalPublicKey(i);
        if (!e.identitySig || !s.verify(n, Ea.Buffer.from(e.identitySig))) throw new Error("Static key doesn't match to peer that signed payload!");
        return await Tk.default.createFromPubKey(i)
      }
      Wr.verifySignedPayload = Zlt;

      function Qlt(r, e) {
        let t = Ea.Buffer.alloc(0),
          i = dve.default.extract(pve.default, e, r),
          n = dve.default.expand(pve.default, i, t, 96),
          s = n.slice(0, 32),
          o = n.slice(32, 64),
          a = n.slice(64, 96);
        return [s, o, a]
      }
      Wr.getHkdf = Qlt;

      function eht(r) {
        return Ik.default.publicKeyVerify(r.slice(0, 32))
      }
      Wr.isValidPublicKey = eht
    });
    var mve = y((LTt, bve) => {
      l();
      "use strict";
      var i1 = Su(),
        kk = new Int8Array(new Int16Array([1]).buffer)[0] === 0,
        Xb = class {
          constructor() {
            this.state = new Uint32Array(16), this.stream = new Uint32Array(16), this.bytes = new Uint8Array(this.stream.buffer), this.pos = -1, kk && (this.bytes = Buffer.alloc(64))
          }
          init(e, t, i) {
            if (i == null && (i = 0), i1(Buffer.isBuffer(e)), i1(Buffer.isBuffer(t)), i1(Number.isSafeInteger(i)), e.length !== 16 && e.length !== 32) throw new RangeError("Invalid key size.");
            if (t.length >= 24 && (e = Xb.derive(e, t.slice(0, 16)), t = t.slice(16)), this.state[0] = 1634760805, this.state[1] = e.length < 32 ? 824206446 : 857760878, this.state[2] = e.length < 32 ? 2036477238 : 2036477234, this.state[3] = 1797285236, this.state[4] = yr(e, 0), this.state[5] = yr(e, 4), this.state[6] = yr(e, 8), this.state[7] = yr(e, 12), this.state[8] = yr(e, 16 % e.length), this.state[9] = yr(e, 20 % e.length), this.state[10] = yr(e, 24 % e.length), this.state[11] = yr(e, 28 % e.length), this.state[12] = i >>> 0, t.length === 8) this.state[13] = i / 4294967296 >>> 0, this.state[14] = yr(t, 0), this.state[15] = yr(t, 4);
            else if (t.length === 12) this.state[13] = yr(t, 0), this.state[14] = yr(t, 4), this.state[15] = yr(t, 8);
            else if (t.length === 16) this.state[12] = yr(t, 0), this.state[13] = yr(t, 4), this.state[14] = yr(t, 8), this.state[15] = yr(t, 12);
            else throw new RangeError("Invalid nonce size.");
            return this.pos = 0, this
          }
          encrypt(e) {
            if (i1(Buffer.isBuffer(e)), this.pos === -1) throw new Error("Context is not initialized.");
            for (let t = 0; t < e.length; t++)(this.pos & 63) == 0 && (this._block(), this.pos = 0), e[t] ^= this.bytes[this.pos++];
            return e
          }
          _block() {
            for (let e = 0; e < 16; e++) this.stream[e] = this.state[e];
            for (let e = 0; e < 10; e++) qn(this.stream, 0, 4, 8, 12), qn(this.stream, 1, 5, 9, 13), qn(this.stream, 2, 6, 10, 14), qn(this.stream, 3, 7, 11, 15), qn(this.stream, 0, 5, 10, 15), qn(this.stream, 1, 6, 11, 12), qn(this.stream, 2, 7, 8, 13), qn(this.stream, 3, 4, 9, 14);
            for (let e = 0; e < 16; e++) this.stream[e] += this.state[e];
            if (kk)
              for (let e = 0; e < 16; e++) Au(this.bytes, this.stream[e], e * 4);
            this.state[12] += 1, this.state[12] === 0 && (this.state[13] += 1)
          }
          destroy() {
            for (let e = 0; e < 16; e++) this.state[e] = 0, this.stream[e] = 0;
            if (kk)
              for (let e = 0; e < 64; e++) this.bytes[e] = 0;
            return this.pos = -1, this
          }
          static derive(e, t) {
            if (i1(Buffer.isBuffer(e)), i1(Buffer.isBuffer(t)), e.length !== 16 && e.length !== 32) throw new RangeError("Invalid key size.");
            if (t.length !== 16) throw new RangeError("Invalid nonce size.");
            let i = new Uint32Array(16);
            i[0] = 1634760805, i[1] = e.length < 32 ? 824206446 : 857760878, i[2] = e.length < 32 ? 2036477238 : 2036477234, i[3] = 1797285236, i[4] = yr(e, 0), i[5] = yr(e, 4), i[6] = yr(e, 8), i[7] = yr(e, 12), i[8] = yr(e, 16 % e.length), i[9] = yr(e, 20 % e.length), i[10] = yr(e, 24 % e.length), i[11] = yr(e, 28 % e.length), i[12] = yr(t, 0), i[13] = yr(t, 4), i[14] = yr(t, 8), i[15] = yr(t, 12);
            for (let s = 0; s < 10; s++) qn(i, 0, 4, 8, 12), qn(i, 1, 5, 9, 13), qn(i, 2, 6, 10, 14), qn(i, 3, 7, 11, 15), qn(i, 0, 5, 10, 15), qn(i, 1, 6, 11, 12), qn(i, 2, 7, 8, 13), qn(i, 3, 4, 9, 14);
            let n = Buffer.alloc(32);
            return Au(n, i[0], 0), Au(n, i[1], 4), Au(n, i[2], 8), Au(n, i[3], 12), Au(n, i[12], 16), Au(n, i[13], 20), Au(n, i[14], 24), Au(n, i[15], 28), n
          }
        };
      Xb.native = 0;

      function qn(r, e, t, i, n) {
        r[e] += r[t], r[n] = c4(r[n] ^ r[e], 16), r[i] += r[n], r[t] = c4(r[t] ^ r[i], 12), r[e] += r[t], r[n] = c4(r[n] ^ r[e], 8), r[i] += r[n], r[t] = c4(r[t] ^ r[i], 7)
      }

      function c4(r, e) {
        return r << e | r >>> 32 - e
      }

      function yr(r, e) {
        return r[e++] + r[e++] * 256 + r[e++] * 65536 + r[e] * 16777216
      }

      function Au(r, e, t) {
        return r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, t
      }
      bve.exports = Xb
    });
    var wve = y((FTt, vve) => {
      l();
      "use strict";
      var u4 = Su(),
        Pk = class {
          constructor() {
            this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.buffer = Buffer.alloc(16), this.fin = -1, this.leftover = 0
          }
          init(e) {
            u4(Buffer.isBuffer(e) && e.length >= 32);
            let t = wn(e, 0),
              i = wn(e, 2),
              n = wn(e, 4),
              s = wn(e, 6),
              o = wn(e, 8),
              a = wn(e, 10),
              c = wn(e, 12),
              u = wn(e, 14);
            this.r[0] = t & 8191, this.r[1] = (t >>> 13 | i << 3) & 8191, this.r[2] = (i >>> 10 | n << 6) & 7939, this.r[3] = (n >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | o << 12) & 255, this.r[5] = o >>> 1 & 8190, this.r[6] = (o >>> 14 | a << 2) & 8191, this.r[7] = (a >>> 11 | c << 5) & 8065, this.r[8] = (c >>> 8 | u << 8) & 8191, this.r[9] = u >>> 5 & 127;
            for (let f = 0; f < 10; f++) this.h[f] = 0;
            for (let f = 0; f < 8; f++) this.pad[f] = wn(e, 16 + 2 * f);
            return this.fin = 0, this.leftover = 0, this
          }
          _blocks(e, t, i) {
            let n = this.fin ? 0 : 1 << 11,
              s = new Uint32Array(10);
            for (; t >= 16;) {
              let o = wn(e, i + 0),
                a = wn(e, i + 2),
                c = wn(e, i + 4),
                u = wn(e, i + 6),
                f = wn(e, i + 8),
                h = wn(e, i + 10),
                d = wn(e, i + 12),
                p = wn(e, i + 14);
              this.h[0] += o & 8191, this.h[1] += (o >>> 13 | a << 3) & 8191, this.h[2] += (a >>> 10 | c << 6) & 8191, this.h[3] += (c >>> 7 | u << 9) & 8191, this.h[4] += (u >>> 4 | f << 12) & 8191, this.h[5] += f >>> 1 & 8191, this.h[6] += (f >>> 14 | h << 2) & 8191, this.h[7] += (h >>> 11 | d << 5) & 8191, this.h[8] += (d >>> 8 | p << 8) & 8191, this.h[9] += p >>> 5 | n;
              let g = 0;
              for (let m = 0; m < 10; m++) {
                s[m] = g;
                for (let E = 0; E < 10; E++) {
                  let w = this.h[E];
                  E <= m ? w *= this.r[m - E] : w *= 5 * this.r[m + 10 - E], s[m] += w, E === 4 && (g = s[m] >>> 13, s[m] &= 8191)
                }
                g += s[m] >>> 13, s[m] &= 8191
              }
              g = (g << 2) + g, g += s[0], s[0] = g & 8191, g = g >>> 13, s[1] += g;
              for (let m = 0; m < 10; m++) this.h[m] = s[m];
              i += 16, t -= 16
            }
          }
          update(e) {
            if (u4(Buffer.isBuffer(e)), this.fin === -1) throw new Error("Context is not initialized.");
            let t = e.length,
              i = 0;
            if (this.leftover) {
              let n = 16 - this.leftover;
              n > t && (n = t);
              for (let s = 0; s < n; s++) this.buffer[this.leftover + s] = e[i + s];
              if (t -= n, i += n, this.leftover += n, this.leftover < 16) return this;
              this._blocks(this.buffer, 16, 0), this.leftover = 0
            }
            if (t >= 16) {
              let n = t & ~(16 - 1);
              this._blocks(e, n, i), i += n, t -= n
            }
            if (t) {
              for (let n = 0; n < t; n++) this.buffer[this.leftover + n] = e[i + n];
              this.leftover += t
            }
            return this
          }
          final() {
            if (this.fin === -1) throw new Error("Context is not initialized.");
            let e = Buffer.alloc(16),
              t = new Uint16Array(10);
            if (this.leftover) {
              let o = this.leftover;
              for (this.buffer[o++] = 1; o < 16; o++) this.buffer[o] = 0;
              this.fin = 1, this._blocks(this.buffer, 16, 0)
            }
            let i = this.h[1] >>> 13;
            this.h[1] &= 8191;
            for (let o = 2; o < 10; o++) this.h[o] += i, i = this.h[o] >>> 13, this.h[o] &= 8191;
            this.h[0] += i * 5, i = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += i, i = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += i, t[0] = this.h[0] + 5, i = t[0] >>> 13, t[0] &= 8191;
            for (let o = 1; o < 10; o++) t[o] = this.h[o] + i, i = t[o] >>> 13, t[o] &= 8191;
            let n = (i ^ 1) - 1;
            for (let o = 0; o < 10; o++) t[o] &= n;
            n = ~n;
            for (let o = 0; o < 10; o++) this.h[o] = this.h[o] & n | t[o];
            this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
            let s = this.h[0] + this.pad[0];
            this.h[0] = s;
            for (let o = 1; o < 8; o++) s = this.h[o] + this.pad[o] + (s >>> 16), this.h[o] = s;
            for (let o = 0; o < 8; o++) tht(e, this.h[o], o * 2);
            return this.destroy(), e
          }
          destroy() {
            for (let e = 0; e < 10; e++) this.r[e] = 0, this.h[e] = 0;
            for (let e = 0; e < 8; e++) this.pad[e] = 0;
            for (let e = 0; e < 16; e++) this.buffer[e] = 0;
            this.fin = -1, this.leftover = 0
          }
          verify(e) {
            u4(Buffer.isBuffer(e)), u4(e.length === 16);
            let t = this.final(),
              i = 0;
            for (let n = 0; n < 16; n++) i |= t[n] ^ e[n];
            return i - 1 >>> 31 != 0
          }
        };
      Pk.native = 0;

      function wn(r, e) {
        return r[e++] + r[e] * 256
      }

      function tht(r, e, t) {
        return r[t++] = e, r[t++] = e >>> 8, t
      }
      vve.exports = Pk
    });
    var Ave = y((UTt, _ve) => {
      l();
      "use strict";
      var n1 = Su(),
        Eve = mve(),
        rht = wve(),
        iht = Buffer.alloc(16, 0),
        Kh = class {
          constructor() {
            this.chacha = new Eve, this.poly = new rht, this.key = Buffer.alloc(64), this.mode = -1, this.aadLen = 0, this.cipherLen = 0
          }
          init(e, t) {
            return n1(Buffer.isBuffer(e)), n1(Buffer.isBuffer(t)), this.key.fill(0), this.chacha.init(e, t, 0), this.chacha.encrypt(this.key), this.poly.init(this.key), this.mode = 0, this.aadLen = 0, this.cipherLen = 0, this
          }
          aad(e) {
            if (this.mode === -1) throw new Error("Context is not initialized.");
            if (this.mode !== 0) throw new Error("Invalid state for aad.");
            return this.poly.update(e), this.aadLen += e.length, this
          }
          encrypt(e) {
            if (this.mode === -1) throw new Error("Context is not initialized.");
            if (this.mode !== 0 && this.mode !== 1) throw new Error("Invalid state for encrypt.");
            return this.mode === 0 && (this._pad16(this.aadLen), this.mode = 1), this.chacha.encrypt(e), this.poly.update(e), this.cipherLen += e.length, e
          }
          decrypt(e) {
            if (n1(Buffer.isBuffer(e)), this.mode === -1) throw new Error("Context is not initialized.");
            if (this.mode !== 0 && this.mode !== 2) throw new Error("Invalid state for decrypt.");
            return this.mode === 0 && (this._pad16(this.aadLen), this.mode = 2), this.cipherLen += e.length, this.poly.update(e), this.chacha.encrypt(e), e
          }
          auth(e) {
            if (n1(Buffer.isBuffer(e)), this.mode === -1) throw new Error("Context is not initialized.");
            if (this.mode !== 0 && this.mode !== 3) throw new Error("Invalid state for auth.");
            return this.mode === 0 && (this._pad16(this.aadLen), this.mode = 3), this.cipherLen += e.length, this.poly.update(e), e
          }
          final() {
            if (this.mode === -1) throw new Error("Context is not initialized.");
            let e = Buffer.alloc(16);
            Sve(e, this.aadLen, 0), Sve(e, this.cipherLen, 8), this.mode === 0 && this._pad16(this.aadLen), this._pad16(this.cipherLen), this.poly.update(e);
            let t = this.poly.final();
            return this.destroy(), t
          }
          destroy() {
            this.chacha.destroy(), this.poly.destroy();
            for (let e = 0; e < 64; e++) this.key[e] = 0;
            return this.mode = -1, this.aadLen = 0, this.cipherLen = 0, this
          }
          verify(e) {
            n1(Buffer.isBuffer(e)), n1(e.length === 16);
            let t = this.final(),
              i = 0;
            for (let n = 0; n < 16; n++) i |= t[n] ^ e[n];
            return i - 1 >>> 31 != 0
          }
          _pad16(e) {
            let t = e & 15;
            t > 0 && this.poly.update(iht.slice(0, 16 - t))
          }
          static encrypt(e, t, i, n) {
            let s = new Kh;
            return s.init(e, t), n && s.aad(n), s.encrypt(i), s.final()
          }
          static decrypt(e, t, i, n, s) {
            let o = new Kh;
            return o.init(e, t), s && o.aad(s), o.decrypt(i), o.verify(n)
          }
          static auth(e, t, i, n, s) {
            let o = new Kh;
            return o.init(e, t), s && o.aad(s), o.auth(i), o.verify(n)
          }
        };
      Kh.native = Eve.native;

      function xve(r, e, t) {
        return r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, e >>>= 8, r[t++] = e, t
      }

      function Sve(r, e, t) {
        let i = e * (1 / 4294967296) >>> 0,
          n = e >>> 0;
        return xve(r, n, t + 0), xve(r, i, t + 4), t + 8
      }
      _ve.exports = Kh
    });
    var f4 = y(Iu => {
      l();
      "use strict";
      Object.defineProperty(Iu, "__esModule", {
        value: !0
      });
      Iu.DUMP_SESSION_KEYS = Iu.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = Iu.NOISE_MSG_MAX_LENGTH_BYTES = void 0;
      Iu.NOISE_MSG_MAX_LENGTH_BYTES = 65535;
      Iu.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = Iu.NOISE_MSG_MAX_LENGTH_BYTES - 16;
      Iu.DUMP_SESSION_KEYS = process.env.DUMP_SESSION_KEYS
    });
    var s1 = y(_n => {
      l();
      "use strict";
      var nht = _n && _n.__importDefault || function (r) {
        return r && r.__esModule ? r : {
          default: r
        }
      };
      Object.defineProperty(_n, "__esModule", {
        value: !0
      });
      _n.logCipherState = _n.logRemoteEphemeralKey = _n.logRemoteStaticKey = _n.logLocalEphemeralKeys = _n.logLocalStaticKeys = _n.logger = void 0;
      var sht = nht(Oe()),
        oht = f4();
      _n.logger = sht.default("libp2p:noise");
      var Oo;
      oht.DUMP_SESSION_KEYS ? Oo = _n.logger : Oo = () => { };

      function aht(r) {
        Oo(`LOCAL_STATIC_PUBLIC_KEY ${r.publicKey.toString("hex")}`), Oo(`LOCAL_STATIC_PRIVATE_KEY ${r.privateKey.toString("hex")}`)
      }
      _n.logLocalStaticKeys = aht;

      function cht(r) {
        r ? (Oo(`LOCAL_PUBLIC_EPHEMERAL_KEY ${r.publicKey.toString("hex")}`), Oo(`LOCAL_PRIVATE_EPHEMERAL_KEY ${r.privateKey.toString("hex")}`)) : Oo("Missing local ephemeral keys.")
      }
      _n.logLocalEphemeralKeys = cht;

      function uht(r) {
        Oo(`REMOTE_STATIC_PUBLIC_KEY ${r.toString("hex")}`)
      }
      _n.logRemoteStaticKey = uht;

      function fht(r) {
        Oo(`REMOTE_EPHEMERAL_PUBLIC_KEY ${r.toString("hex")}`)
      }
      _n.logRemoteEphemeralKey = fht;

      function lht(r) {
        r.cs1 && r.cs2 ? (Oo(`CIPHER_STATE_1 ${r.cs1.n} ${r.cs1.k.toString("hex")}`), Oo(`CIPHER_STATE_2 ${r.cs2.n} ${r.cs2.k.toString("hex")}`)) : Oo("Missing cipher state.")
      }
      _n.logCipherState = lht
    });
    var Ok = y(Tu => {
      l();
      "use strict";
      var Ck = Tu && Tu.__importDefault || function (r) {
        return r && r.__esModule ? r : {
          default: r
        }
      };
      Object.defineProperty(Tu, "__esModule", {
        value: !0
      });
      Tu.AbstractHandshake = Tu.MIN_NONCE = void 0;
      var rs = Wt(),
        Ive = Ck(Ave()),
        hht = Ck(s4()),
        dht = Ck(Ak()),
        Tve = Hf(),
        pht = s1();
      Tu.MIN_NONCE = 0;
      var Rve = class {
        encryptWithAd(e, t, i) {
          let n = this.encrypt(e.k, e.n, t, i);
          return this.setNonce(e, this.incrementNonce(e.n)), n
        }
        decryptWithAd(e, t, i) {
          let {
            plaintext: n,
            valid: s
          } = this.decrypt(e.k, e.n, t, i);
          return this.setNonce(e, this.incrementNonce(e.n)), {
            plaintext: n,
            valid: s
          }
        }
        hasKey(e) {
          return !this.isEmptyKey(e.k)
        }
        setNonce(e, t) {
          e.n = t
        }
        createEmptyKey() {
          return rs.Buffer.alloc(32)
        }
        isEmptyKey(e) {
          return this.createEmptyKey().equals(e)
        }
        incrementNonce(e) {
          return e + 1
        }
        nonceToBytes(e) {
          let t = rs.Buffer.alloc(12);
          return t.writeUInt32LE(e, 4), t
        }
        encrypt(e, t, i, n) {
          let s = this.nonceToBytes(t),
            o = new Ive.default;
          return n = rs.Buffer.from(n), o.init(e, s), o.aad(i), o.encrypt(n), rs.Buffer.concat([n, o.final()])
        }
        encryptAndHash(e, t) {
          let i;
          return this.hasKey(e.cs) ? i = this.encryptWithAd(e.cs, e.h, t) : i = t, this.mixHash(e, i), i
        }
        decrypt(e, t, i, n) {
          let s = this.nonceToBytes(t),
            o = new Ive.default;
          n = rs.Buffer.from(n);
          let a = n.slice(n.length - 16);
          return n = n.slice(0, n.length - 16), o.init(e, s), o.aad(i), o.decrypt(n), {
            plaintext: n,
            valid: o.verify(a)
          }
        }
        decryptAndHash(e, t) {
          let i, n = !0;
          return this.hasKey(e.cs) ? {
            plaintext: i,
            valid: n
          } = this.decryptWithAd(e.cs, e.h, t) : i = t, this.mixHash(e, t), {
            plaintext: i,
            valid: n
          }
        }
        dh(e, t) {
          try {
            let i = hht.default.derive(t, e),
              n = rs.Buffer.alloc(32);
            return i.copy(n), n
          } catch (i) {
            return pht.logger(i.message), rs.Buffer.alloc(32)
          }
        }
        mixHash(e, t) {
          e.h = this.getHash(e.h, t)
        }
        getHash(e, t) {
          return dht.default.digest(rs.Buffer.from([...e, ...t]))
        }
        mixKey(e, t) {
          let [i, n] = Tve.getHkdf(e.ck, t);
          e.cs = this.initializeKey(n), e.ck = i
        }
        initializeKey(e) {
          let t = Tu.MIN_NONCE;
          return {
            k: e,
            n: t
          }
        }
        initializeSymmetric(e) {
          let t = rs.Buffer.from(e, "utf-8"),
            i = this.hashProtocolName(t),
            n = i,
            s = this.createEmptyKey();
          return {
            cs: this.initializeKey(s),
            ck: n,
            h: i
          }
        }
        hashProtocolName(e) {
          if (e.length <= 32) {
            let t = rs.Buffer.alloc(32);
            return e.copy(t), t
          } else return this.getHash(e, rs.Buffer.alloc(0))
        }
        split(e) {
          let [t, i] = Tve.getHkdf(e.ck, rs.Buffer.alloc(0)), n = this.initializeKey(t), s = this.initializeKey(i);
          return {
            cs1: n,
            cs2: s
          }
        }
        writeMessageRegular(e, t) {
          let i = this.encryptWithAd(e, rs.Buffer.alloc(0), t),
            n = this.createEmptyKey(),
            s = rs.Buffer.alloc(0);
          return {
            ne: n,
            ns: s,
            ciphertext: i
          }
        }
        readMessageRegular(e, t) {
          return this.decryptWithAd(e, rs.Buffer.alloc(0), t.ciphertext)
        }
      };
      Tu.AbstractHandshake = Rve
    });
    var Pve = y(l4 => {
      l();
      "use strict";
      Object.defineProperty(l4, "__esModule", {
        value: !0
      });
      l4.XX = void 0;
      var zh = Wt(),
        o1 = Hf(),
        yht = Ok(),
        kve = class extends yht.AbstractHandshake {
          initializeInitiator(e, t, i, n) {
            let s = "Noise_XX_25519_ChaChaPoly_SHA256",
              o = this.initializeSymmetric(s);
            this.mixHash(o, e);
            let a = zh.Buffer.alloc(32);
            return {
              ss: o,
              s: t,
              rs: i,
              psk: n,
              re: a
            }
          }
          initializeResponder(e, t, i, n) {
            let s = "Noise_XX_25519_ChaChaPoly_SHA256",
              o = this.initializeSymmetric(s);
            this.mixHash(o, e);
            let a = zh.Buffer.alloc(32);
            return {
              ss: o,
              s: t,
              rs: i,
              psk: n,
              re: a
            }
          }
          writeMessageA(e, t, i) {
            let n = zh.Buffer.alloc(0);
            i !== void 0 ? e.e = i : e.e = o1.generateKeypair();
            let s = e.e.publicKey;
            this.mixHash(e.ss, s);
            let o = this.encryptAndHash(e.ss, t);
            return {
              ne: s,
              ns: n,
              ciphertext: o
            }
          }
          writeMessageB(e, t) {
            e.e = o1.generateKeypair();
            let i = e.e.publicKey;
            this.mixHash(e.ss, i), this.mixKey(e.ss, this.dh(e.e.privateKey, e.re));
            let n = zh.Buffer.from(e.s.publicKey),
              s = this.encryptAndHash(e.ss, n);
            this.mixKey(e.ss, this.dh(e.s.privateKey, e.re));
            let o = this.encryptAndHash(e.ss, t);
            return {
              ne: i,
              ns: s,
              ciphertext: o
            }
          }
          writeMessageC(e, t) {
            let i = zh.Buffer.from(e.s.publicKey),
              n = this.encryptAndHash(e.ss, i);
            this.mixKey(e.ss, this.dh(e.s.privateKey, e.re));
            let s = this.encryptAndHash(e.ss, t),
              a = {
                ne: this.createEmptyKey(),
                ns: n,
                ciphertext: s
              },
              {
                cs1: c,
                cs2: u
              } = this.split(e.ss);
            return {
              h: e.ss.h,
              messageBuffer: a,
              cs1: c,
              cs2: u
            }
          }
          readMessageA(e, t) {
            return o1.isValidPublicKey(t.ne) && (e.re = t.ne), this.mixHash(e.ss, e.re), this.decryptAndHash(e.ss, t.ciphertext)
          }
          readMessageB(e, t) {
            if (o1.isValidPublicKey(t.ne) && (e.re = t.ne), this.mixHash(e.ss, e.re), !e.e) throw new Error("Handshake state `e` param is missing.");
            this.mixKey(e.ss, this.dh(e.e.privateKey, e.re));
            let {
              plaintext: i,
              valid: n
            } = this.decryptAndHash(e.ss, t.ns);
            n && i.length === 32 && o1.isValidPublicKey(i) && (e.rs = i), this.mixKey(e.ss, this.dh(e.e.privateKey, e.rs));
            let {
              plaintext: s,
              valid: o
            } = this.decryptAndHash(e.ss, t.ciphertext);
            return {
              plaintext: s,
              valid: n && o
            }
          }
          readMessageC(e, t) {
            let {
              plaintext: i,
              valid: n
            } = this.decryptAndHash(e.ss, t.ns);
            if (n && i.length === 32 && o1.isValidPublicKey(i) && (e.rs = i), !e.e) throw new Error("Handshake state `e` param is missing.");
            this.mixKey(e.ss, this.dh(e.e.privateKey, e.rs));
            let {
              plaintext: s,
              valid: o
            } = this.decryptAndHash(e.ss, t.ciphertext), {
              cs1: a,
              cs2: c
            } = this.split(e.ss);
            return {
              h: e.ss.h,
              plaintext: s,
              valid: n && o,
              cs1: a,
              cs2: c
            }
          }
          initSession(e, t, i) {
            let n = this.createEmptyKey(),
              s = zh.Buffer.alloc(32),
              o;
            return e ? o = this.initializeInitiator(t, i, s, n) : o = this.initializeResponder(t, i, s, n), {
              hs: o,
              i: e,
              mc: 0
            }
          }
          sendMessage(e, t, i) {
            let n;
            if (e.mc === 0) n = this.writeMessageA(e.hs, t, i);
            else if (e.mc === 1) n = this.writeMessageB(e.hs, t);
            else if (e.mc === 2) {
              let {
                h: s,
                messageBuffer: o,
                cs1: a,
                cs2: c
              } = this.writeMessageC(e.hs, t);
              n = o, e.h = s, e.cs1 = a, e.cs2 = c
            } else if (e.mc > 2)
              if (e.i) {
                if (!e.cs1) throw new Error("CS1 (cipher state) is not defined");
                n = this.writeMessageRegular(e.cs1, t)
              } else {
                if (!e.cs2) throw new Error("CS2 (cipher state) is not defined");
                n = this.writeMessageRegular(e.cs2, t)
              }
            else throw new Error("Session invalid.");
            return e.mc++, n
          }
          recvMessage(e, t) {
            let i = zh.Buffer.alloc(0),
              n = !1;
            if (e.mc === 0) ({
              plaintext: i,
              valid: n
            } = this.readMessageA(e.hs, t));
            else if (e.mc === 1) ({
              plaintext: i,
              valid: n
            } = this.readMessageB(e.hs, t));
            else if (e.mc === 2) {
              let {
                h: s,
                plaintext: o,
                valid: a,
                cs1: c,
                cs2: u
              } = this.readMessageC(e.hs, t);
              i = o, n = a, e.h = s, e.cs1 = c, e.cs2 = u
            }
            return e.mc++, {
              plaintext: i,
              valid: n
            }
          }
        };
      l4.XX = kve
    });
    var Zb = y(Ei => {
      l();
      "use strict";
      Object.defineProperty(Ei, "__esModule", {
        value: !0
      });
      Ei.decode2 = Ei.decode1 = Ei.decode0 = Ei.encode2 = Ei.encode1 = Ei.encode0 = Ei.uint16BEDecode = Ei.uint16BEEncode = void 0;
      var a1 = Wt(),
        ght = (r, e, t) => (e = e || a1.Buffer.allocUnsafe(2), e.writeUInt16BE(r, t), e);
      Ei.uint16BEEncode = ght;
      Ei.uint16BEEncode.bytes = 2;
      var bht = r => {
        if (r.length < 2) throw RangeError("Could not decode int16BE");
        return r.readUInt16BE(0)
      };
      Ei.uint16BEDecode = bht;
      Ei.uint16BEDecode.bytes = 2;

      function mht(r) {
        return a1.Buffer.concat([r.ne, r.ciphertext])
      }
      Ei.encode0 = mht;

      function vht(r) {
        return a1.Buffer.concat([r.ne, r.ns, r.ciphertext])
      }
      Ei.encode1 = vht;

      function wht(r) {
        return a1.Buffer.concat([r.ns, r.ciphertext])
      }
      Ei.encode2 = wht;

      function _ht(r) {
        if (r.length < 32) throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
        return {
          ne: r.slice(0, 32),
          ciphertext: r.slice(32, r.length),
          ns: a1.Buffer.alloc(0)
        }
      }
      Ei.decode0 = _ht;

      function Eht(r) {
        if (r.length < 80) throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
        return {
          ne: r.slice(0, 32),
          ns: r.slice(32, 80),
          ciphertext: r.slice(80, r.length)
        }
      }
      Ei.decode1 = Eht;

      function Sht(r) {
        if (r.length < 48) throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
        return {
          ne: a1.Buffer.alloc(0),
          ns: r.slice(0, 48),
          ciphertext: r.slice(48, r.length)
        }
      }
      Ei.decode2 = Sht
    });
    var Nk = y(h4 => {
      l();
      "use strict";
      Object.defineProperty(h4, "__esModule", {
        value: !0
      });
      h4.XXHandshake = void 0;
      var Qb = Wt(),
        xht = Pve(),
        c1 = Hf(),
        di = s1(),
        u1 = Zb(),
        Cve = class {
          constructor(e, t, i, n, s, o, a) {
            this.isInitiator = e, this.payload = t, this.prologue = i, this.staticKeypair = n, this.connection = s, o && (this.remotePeer = o), this.xx = a ?? new xht.XX, this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair), this.remoteEarlyData = Qb.Buffer.alloc(0)
          }
          async propose() {
            if (di.logLocalStaticKeys(this.session.hs.s), this.isInitiator) {
              di.logger("Stage 0 - Initiator starting to send first message.");
              let e = this.xx.sendMessage(this.session, Qb.Buffer.alloc(0));
              this.connection.writeLP(u1.encode0(e)), di.logger("Stage 0 - Initiator finished sending first message."), di.logLocalEphemeralKeys(this.session.hs.e)
            } else {
              di.logger("Stage 0 - Responder waiting to receive first message...");
              let e = u1.decode0((await this.connection.readLP()).slice()),
                {
                  valid: t
                } = this.xx.recvMessage(this.session, e);
              if (!t) throw new Error("xx handshake stage 0 validation fail");
              di.logger("Stage 0 - Responder received first message."), di.logRemoteEphemeralKey(this.session.hs.re)
            }
          }
          async exchange() {
            if (this.isInitiator) {
              di.logger("Stage 1 - Initiator waiting to receive first message from responder...");
              let e = u1.decode1((await this.connection.readLP()).slice()),
                {
                  plaintext: t,
                  valid: i
                } = this.xx.recvMessage(this.session, e);
              if (!i) throw new Error("xx handshake stage 1 validation fail");
              di.logger("Stage 1 - Initiator received the message."), di.logRemoteEphemeralKey(this.session.hs.re), di.logRemoteStaticKey(this.session.hs.rs), di.logger("Initiator going to check remote's signature...");
              try {
                let n = await c1.decodePayload(t);
                this.remotePeer = this.remotePeer || await c1.getPeerIdFromPayload(n), this.remotePeer = await c1.verifySignedPayload(e.ns, n, this.remotePeer), this.setRemoteEarlyData(n.data)
              } catch (n) {
                let s = n;
                throw new Error(`Error occurred while verifying signed payload: ${s.message}`)
              }
              di.logger("All good with the signature!")
            } else {
              di.logger("Stage 1 - Responder sending out first message with signed payload and static key.");
              let e = this.xx.sendMessage(this.session, this.payload);
              this.connection.writeLP(u1.encode1(e)), di.logger("Stage 1 - Responder sent the second handshake message with signed payload."), di.logLocalEphemeralKeys(this.session.hs.e)
            }
          }
          async finish() {
            if (this.isInitiator) {
              di.logger("Stage 2 - Initiator sending third handshake message.");
              let e = this.xx.sendMessage(this.session, this.payload);
              this.connection.writeLP(u1.encode2(e)), di.logger("Stage 2 - Initiator sent message with signed payload.")
            } else {
              di.logger("Stage 2 - Responder waiting for third handshake message...");
              let e = u1.decode2((await this.connection.readLP()).slice()),
                {
                  plaintext: t,
                  valid: i
                } = this.xx.recvMessage(this.session, e);
              if (!i) throw new Error("xx handshake stage 2 validation fail");
              di.logger("Stage 2 - Responder received the message, finished handshake.");
              try {
                let n = await c1.decodePayload(t);
                this.remotePeer = this.remotePeer || await c1.getPeerIdFromPayload(n), await c1.verifySignedPayload(this.session.hs.rs, n, this.remotePeer), this.setRemoteEarlyData(n.data)
              } catch (n) {
                let s = n;
                throw new Error(`Error occurred while verifying signed payload: ${s.message}`)
              }
            }
            di.logCipherState(this.session)
          }
          encrypt(e, t) {
            let i = this.getCS(t);
            return this.xx.encryptWithAd(i, Qb.Buffer.alloc(0), e)
          }
          decrypt(e, t) {
            let i = this.getCS(t, !1);
            return this.xx.decryptWithAd(i, Qb.Buffer.alloc(0), e)
          }
          getRemoteStaticKey() {
            return this.session.hs.rs
          }
          getCS(e, t = !0) {
            if (!e.cs1 || !e.cs2) throw new Error("Handshake not completed properly, cipher state does not exist.");
            return this.isInitiator ? t ? e.cs1 : e.cs2 : t ? e.cs2 : e.cs1
          }
          setRemoteEarlyData(e) {
            e && (this.remoteEarlyData = Qb.Buffer.from(e.buffer, e.byteOffset, e.length))
          }
        };
      h4.XXHandshake = Cve
    });
    var Nve = y(d4 => {
      l();
      "use strict";
      Object.defineProperty(d4, "__esModule", {
        value: !0
      });
      d4.IK = void 0;
      var p4 = Wt(),
        em = Hf(),
        Aht = Ok(),
        Ove = class extends Aht.AbstractHandshake {
          initSession(e, t, i, n) {
            let s = this.createEmptyKey(),
              o;
            return e ? o = this.initializeInitiator(t, i, n, s) : o = this.initializeResponder(t, i, n, s), {
              hs: o,
              i: e,
              mc: 0
            }
          }
          sendMessage(e, t) {
            let i;
            if (e.mc === 0) i = this.writeMessageA(e.hs, t);
            else if (e.mc === 1) {
              let {
                messageBuffer: n,
                h: s,
                cs1: o,
                cs2: a
              } = this.writeMessageB(e.hs, t);
              i = n, e.h = s, e.cs1 = o, e.cs2 = a
            } else if (e.mc > 1)
              if (e.i) {
                if (!e.cs1) throw new Error("CS1 (cipher state) is not defined");
                i = this.writeMessageRegular(e.cs1, t)
              } else {
                if (!e.cs2) throw new Error("CS2 (cipher state) is not defined");
                i = this.writeMessageRegular(e.cs2, t)
              }
            else throw new Error("Session invalid.");
            return e.mc++, i
          }
          recvMessage(e, t) {
            let i = p4.Buffer.alloc(0),
              n = !1;
            if (e.mc === 0 && ({
              plaintext: i,
              valid: n
            } = this.readMessageA(e.hs, t)), e.mc === 1) {
              let {
                plaintext: s,
                valid: o,
                h: a,
                cs1: c,
                cs2: u
              } = this.readMessageB(e.hs, t);
              i = s, n = o, e.h = a, e.cs1 = c, e.cs2 = u
            }
            return e.mc++, {
              plaintext: i,
              valid: n
            }
          }
          writeMessageA(e, t) {
            e.e = em.generateKeypair();
            let i = e.e.publicKey;
            this.mixHash(e.ss, i), this.mixKey(e.ss, this.dh(e.e.privateKey, e.rs));
            let n = p4.Buffer.from(e.s.publicKey),
              s = this.encryptAndHash(e.ss, n);
            this.mixKey(e.ss, this.dh(e.s.privateKey, e.rs));
            let o = this.encryptAndHash(e.ss, t);
            return {
              ne: i,
              ns: s,
              ciphertext: o
            }
          }
          writeMessageB(e, t) {
            e.e = em.generateKeypair();
            let i = e.e.publicKey;
            this.mixHash(e.ss, i), this.mixKey(e.ss, this.dh(e.e.privateKey, e.re)), this.mixKey(e.ss, this.dh(e.e.privateKey, e.rs));
            let n = this.encryptAndHash(e.ss, t),
              s = this.createEmptyKey(),
              o = {
                ne: i,
                ns: s,
                ciphertext: n
              },
              {
                cs1: a,
                cs2: c
              } = this.split(e.ss);
            return {
              messageBuffer: o,
              cs1: a,
              cs2: c,
              h: e.ss.h
            }
          }
          readMessageA(e, t) {
            em.isValidPublicKey(t.ne) && (e.re = t.ne), this.mixHash(e.ss, e.re), this.mixKey(e.ss, this.dh(e.s.privateKey, e.re));
            let {
              plaintext: i,
              valid: n
            } = this.decryptAndHash(e.ss, t.ns);
            n && i.length === 32 && em.isValidPublicKey(i) && (e.rs = i), this.mixKey(e.ss, this.dh(e.s.privateKey, e.rs));
            let {
              plaintext: s,
              valid: o
            } = this.decryptAndHash(e.ss, t.ciphertext);
            return {
              plaintext: s,
              valid: n && o
            }
          }
          readMessageB(e, t) {
            if (em.isValidPublicKey(t.ne) && (e.re = t.ne), this.mixHash(e.ss, e.re), !e.e) throw new Error("Handshake state should contain ephemeral key by now.");
            this.mixKey(e.ss, this.dh(e.e.privateKey, e.re)), this.mixKey(e.ss, this.dh(e.s.privateKey, e.re));
            let {
              plaintext: i,
              valid: n
            } = this.decryptAndHash(e.ss, t.ciphertext), {
              cs1: s,
              cs2: o
            } = this.split(e.ss);
            return {
              h: e.ss.h,
              valid: n,
              plaintext: i,
              cs1: s,
              cs2: o
            }
          }
          initializeInitiator(e, t, i, n) {
            let s = "Noise_IK_25519_ChaChaPoly_SHA256",
              o = this.initializeSymmetric(s);
            this.mixHash(o, e), this.mixHash(o, i);
            let a = p4.Buffer.alloc(32);
            return {
              ss: o,
              s: t,
              rs: i,
              re: a,
              psk: n
            }
          }
          initializeResponder(e, t, i, n) {
            let s = "Noise_IK_25519_ChaChaPoly_SHA256",
              o = this.initializeSymmetric(s);
            this.mixHash(o, e), this.mixHash(o, t.publicKey);
            let a = p4.Buffer.alloc(32);
            return {
              ss: o,
              s: t,
              rs: i,
              re: a,
              psk: n
            }
          }
        };
      d4.IK = Ove
    });
    var Mve = y(y4 => {
      l();
      "use strict";
      Object.defineProperty(y4, "__esModule", {
        value: !0
      });
      y4.FailedIKError = void 0;
      var qve = class extends Error {
        constructor(e, t) {
          super(t);
          this.initialMsg = e, this.name = "FailedIKhandshake"
        }
      };
      y4.FailedIKError = qve
    });
    var Lve = y(g4 => {
      l();
      "use strict";
      Object.defineProperty(g4, "__esModule", {
        value: !0
      });
      g4.IKHandshake = void 0;
      var Iht = Nve(),
        f1 = Wt(),
        b4 = Zb(),
        l1 = Hf(),
        Bve = Mve(),
        Di = s1(),
        Dve = class {
          constructor(e, t, i, n, s, o, a, c) {
            this.isInitiator = e, this.payload = f1.Buffer.from(t), this.prologue = i, this.staticKeypair = n, this.connection = s, a && (this.remotePeer = a), this.ik = c ?? new Iht.IK, this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, o), this.remoteEarlyData = f1.Buffer.alloc(0)
          }
          async stage0() {
            if (Di.logLocalStaticKeys(this.session.hs.s), Di.logRemoteStaticKey(this.session.hs.rs), this.isInitiator) {
              Di.logger("IK Stage 0 - Initiator sending message...");
              let e = this.ik.sendMessage(this.session, this.payload);
              this.connection.writeLP(b4.encode1(e)), Di.logger("IK Stage 0 - Initiator sent message."), Di.logLocalEphemeralKeys(this.session.hs.e)
            } else {
              Di.logger("IK Stage 0 - Responder receiving message...");
              let e = await this.connection.readLP();
              try {
                let t = b4.decode1(e.slice()),
                  {
                    plaintext: i,
                    valid: n
                  } = this.ik.recvMessage(this.session, t);
                if (!n) throw new Error("ik handshake stage 0 decryption validation fail");
                Di.logger("IK Stage 0 - Responder got message, going to verify payload.");
                let s = await l1.decodePayload(i);
                this.remotePeer = this.remotePeer || await l1.getPeerIdFromPayload(s), await l1.verifySignedPayload(this.session.hs.rs, s, this.remotePeer), this.setRemoteEarlyData(s.data), Di.logger("IK Stage 0 - Responder successfully verified payload!"), Di.logRemoteEphemeralKey(this.session.hs.re)
              } catch (t) {
                let i = t;
                throw Di.logger("Responder breaking up with IK handshake in stage 0."), new Bve.FailedIKError(e, `Error occurred while verifying initiator's signed payload: ${i.message}`)
              }
            }
          }
          async stage1() {
            if (this.isInitiator) {
              Di.logger("IK Stage 1 - Initiator receiving message...");
              let e = (await this.connection.readLP()).slice(),
                t = b4.decode0(f1.Buffer.from(e)),
                {
                  plaintext: i,
                  valid: n
                } = this.ik.recvMessage(this.session, t);
              Di.logger("IK Stage 1 - Initiator got message, going to verify payload.");
              try {
                if (!n) throw new Error("ik stage 1 decryption validation fail");
                let s = await l1.decodePayload(i);
                this.remotePeer = this.remotePeer || await l1.getPeerIdFromPayload(s), await l1.verifySignedPayload(t.ns.slice(0, 32), s, this.remotePeer), this.setRemoteEarlyData(s.data), Di.logger("IK Stage 1 - Initiator successfully verified payload!"), Di.logRemoteEphemeralKey(this.session.hs.re)
              } catch (s) {
                let o = s;
                throw Di.logger("Initiator breaking up with IK handshake in stage 1."), new Bve.FailedIKError(e, `Error occurred while verifying responder's signed payload: ${o.message}`)
              }
            } else {
              Di.logger("IK Stage 1 - Responder sending message...");
              let e = this.ik.sendMessage(this.session, this.payload);
              this.connection.writeLP(b4.encode0(e)), Di.logger("IK Stage 1 - Responder sent message..."), Di.logLocalEphemeralKeys(this.session.hs.e)
            }
            Di.logCipherState(this.session)
          }
          decrypt(e, t) {
            let i = this.getCS(t, !1);
            return this.ik.decryptWithAd(i, f1.Buffer.alloc(0), e)
          }
          encrypt(e, t) {
            let i = this.getCS(t);
            return this.ik.encryptWithAd(i, f1.Buffer.alloc(0), e)
          }
          getLocalEphemeralKeys() {
            if (!this.session.hs.e) throw new Error("Ephemeral keys do not exist.");
            return this.session.hs.e
          }
          getCS(e, t = !0) {
            if (!e.cs1 || !e.cs2) throw new Error("Handshake not completed properly, cipher state does not exist.");
            return this.isInitiator ? t ? e.cs1 : e.cs2 : t ? e.cs2 : e.cs1
          }
          setRemoteEarlyData(e) {
            e && (this.remoteEarlyData = f1.Buffer.from(e.buffer, e.byteOffset, e.length))
          }
        };
      g4.IKHandshake = Dve
    });
    var Kve = y(m4 => {
      l();
      "use strict";
      Object.defineProperty(m4, "__esModule", {
        value: !0
      });
      m4.XXFallbackHandshake = void 0;
      var qk = Wt(),
        Tht = Nk(),
        Mk = Hf(),
        No = s1(),
        Fve = Zb(),
        Uve = class extends Tht.XXHandshake {
          constructor(e, t, i, n, s, o, a, c, u) {
            super(e, t, i, n, s, a, u);
            c && (this.ephemeralKeys = c), this.initialMsg = o
          }
          async propose() {
            if (this.isInitiator) this.xx.sendMessage(this.session, qk.Buffer.alloc(0), this.ephemeralKeys), No.logger("XX Fallback Stage 0 - Initialized state as the first message was sent by initiator."), No.logLocalEphemeralKeys(this.session.hs.e);
            else {
              No.logger("XX Fallback Stage 0 - Responder decoding initial msg from IK.");
              let e = Fve.decode0(this.initialMsg),
                {
                  valid: t
                } = this.xx.recvMessage(this.session, {
                  ne: e.ne,
                  ns: qk.Buffer.alloc(0),
                  ciphertext: qk.Buffer.alloc(0)
                });
              if (!t) throw new Error("xx fallback stage 0 decryption validation fail");
              No.logger("XX Fallback Stage 0 - Responder used received message from IK."), No.logRemoteEphemeralKey(this.session.hs.re)
            }
          }
          async exchange() {
            if (this.isInitiator) {
              let e = Fve.decode1(this.initialMsg),
                {
                  plaintext: t,
                  valid: i
                } = this.xx.recvMessage(this.session, e);
              if (!i) throw new Error("xx fallback stage 1 decryption validation fail");
              No.logger("XX Fallback Stage 1 - Initiator used received message from IK."), No.logRemoteEphemeralKey(this.session.hs.re), No.logRemoteStaticKey(this.session.hs.rs), No.logger("Initiator going to check remote's signature...");
              try {
                let n = await Mk.decodePayload(t);
                this.remotePeer = this.remotePeer || await Mk.getPeerIdFromPayload(n), await Mk.verifySignedPayload(this.session.hs.rs, n, this.remotePeer), this.setRemoteEarlyData(n.data)
              } catch (n) {
                let s = n;
                throw new Error(`Error occurred while verifying signed payload from responder: ${s.message}`)
              }
              No.logger("All good with the signature!")
            } else No.logger("XX Fallback Stage 1 - Responder start"), await super.exchange(), No.logger("XX Fallback Stage 1 - Responder end")
          }
        };
      m4.XXFallbackHandshake = Uve
    });
    var jve = y(h1 => {
      l();
      "use strict";
      Object.defineProperty(h1, "__esModule", {
        value: !0
      });
      h1.decryptStream = h1.encryptStream = void 0;
      var zve = Wt(),
        v4 = f4();

      function Rht(r) {
        return async function* (e) {
          for await (let t of e) {
            let i = zve.Buffer.from(t.buffer, t.byteOffset, t.length);
            for (let n = 0; n < i.length; n += v4.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
              let s = n + v4.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
              s > i.length && (s = i.length), yield r.encrypt(i.slice(n, s), r.session)
            }
          }
        }
      }
      h1.encryptStream = Rht;

      function kht(r) {
        return async function* (e) {
          for await (let t of e) {
            let i = zve.Buffer.from(t.buffer, t.byteOffset, t.length);
            for (let n = 0; n < i.length; n += v4.NOISE_MSG_MAX_LENGTH_BYTES) {
              let s = n + v4.NOISE_MSG_MAX_LENGTH_BYTES;
              s > i.length && (s = i.length);
              let o = i.slice(n, s),
                {
                  plaintext: a,
                  valid: c
                } = await r.decrypt(o, r.session);
              if (!c) throw new Error("Failed to validate decrypted chunk");
              yield a
            }
          }
        }
      }
      h1.decryptStream = kht
    });
    var Hve = y(w4 => {
      l();
      "use strict";
      Object.defineProperty(w4, "__esModule", {
        value: !0
      });
      w4.KeyCache = void 0;
      var Vve = class {
        constructor() {
          this.storage = new Map
        }
        store(e, t) {
          this.storage.set(e.id, t)
        }
        load(e) {
          var t;
          return e && (t = this.storage.get(e.id)) !== null && t !== void 0 ? t : null
        }
        resetStorage() {
          this.storage.clear()
        }
      },
        Pht = new Vve;
      w4.KeyCache = Pht
    });
    var Lk = y(d1 => {
      l();
      "use strict";
      var tm = d1 && d1.__importDefault || function (r) {
        return r && r.__esModule ? r : {
          default: r
        }
      };
      Object.defineProperty(d1, "__esModule", {
        value: !0
      });
      d1.Noise = void 0;
      var Cht = tm(s4()),
        Bk = Wt(),
        Gve = tm(Y2e()),
        Oht = tm(eve()),
        $ve = tm(c6()),
        Nht = tm(vi()),
        Wve = da(),
        qht = Nk(),
        Mht = Lve(),
        Bht = Kve(),
        Yve = Hf(),
        p1 = Zb(),
        Jve = jve(),
        Dk = Hve(),
        Dht = s1(),
        Xve = f4(),
        Zve = class {
          constructor(e, t) {
            if (this.protocol = "/noise", this.prologue = Bk.Buffer.alloc(0), this.earlyData = t ?? Bk.Buffer.alloc(0), this.useNoisePipes = !1, e) {
              let i = Cht.default.publicKeyCreate(e);
              this.staticKeys = {
                privateKey: e,
                publicKey: i
              }
            } else this.staticKeys = Yve.generateKeypair()
          }
          async secureOutbound(e, t, i) {
            let n = Gve.default(t, {
              lengthEncoder: p1.uint16BEEncode,
              lengthDecoder: p1.uint16BEDecode,
              maxDataLength: Xve.NOISE_MSG_MAX_LENGTH_BYTES
            }),
              s = await this.performHandshake({
                connection: n,
                isInitiator: !0,
                localPeer: e,
                remotePeer: i
              });
            return {
              conn: await this.createSecureConnection(n, s),
              remoteEarlyData: s.remoteEarlyData,
              remotePeer: s.remotePeer
            }
          }
          async secureInbound(e, t, i) {
            let n = Gve.default(t, {
              lengthEncoder: p1.uint16BEEncode,
              lengthDecoder: p1.uint16BEDecode,
              maxDataLength: Xve.NOISE_MSG_MAX_LENGTH_BYTES
            }),
              s = await this.performHandshake({
                connection: n,
                isInitiator: !1,
                localPeer: e,
                remotePeer: i
              });
            return {
              conn: await this.createSecureConnection(n, s),
              remoteEarlyData: s.remoteEarlyData,
              remotePeer: s.remotePeer
            }
          }
          async performHandshake(e) {
            var t;
            let i = await Yve.getPayload(e.localPeer, this.staticKeys.publicKey, this.earlyData),
              n = this.useNoisePipes;
            if (e.isInitiator && Dk.KeyCache.load(e.remotePeer) === null && (n = !1), n) {
              let {
                remotePeer: s,
                connection: o,
                isInitiator: a
              } = e, c = new Mht.IKHandshake(a, i, this.prologue, this.staticKeys, o, (t = Dk.KeyCache.load(e.remotePeer)) !== null && t !== void 0 ? t : Bk.Buffer.alloc(32), s);
              try {
                return await this.performIKHandshake(c)
              } catch (u) {
                let f;
                return e.isInitiator && (f = c.getLocalEphemeralKeys()), await this.performXXFallbackHandshake(e, i, u.initialMsg, f)
              }
            } else return await this.performXXHandshake(e, i)
          }
          async performXXFallbackHandshake(e, t, i, n) {
            let {
              isInitiator: s,
              remotePeer: o,
              connection: a
            } = e, c = new Bht.XXFallbackHandshake(s, t, this.prologue, this.staticKeys, a, i, o, n);
            try {
              await c.propose(), await c.exchange(), await c.finish()
            } catch (u) {
              Dht.logger(u);
              let f = u;
              throw new Error(`Error occurred during XX Fallback handshake: ${f.message}`)
            }
            return c
          }
          async performXXHandshake(e, t) {
            let {
              isInitiator: i,
              remotePeer: n,
              connection: s
            } = e, o = new qht.XXHandshake(i, t, this.prologue, this.staticKeys, s, n);
            try {
              await o.propose(), await o.exchange(), await o.finish(), this.useNoisePipes && o.remotePeer && Dk.KeyCache.store(o.remotePeer, o.getRemoteStaticKey())
            } catch (a) {
              let c = a;
              throw new Error(`Error occurred during XX handshake: ${c.message}`)
            }
            return o
          }
          async performIKHandshake(e) {
            return await e.stage0(), await e.stage1(), e
          }
          async createSecureConnection(e, t) {
            let [i, n] = Oht.default(), s = e.unwrap();
            return await Nht.default(i, $ve.default, Jve.encryptStream(t), Wve.encode({
              lengthEncoder: p1.uint16BEEncode
            }), s, Wve.decode({
              lengthDecoder: p1.uint16BEDecode
            }), $ve.default, Jve.decryptStream(t), i), n
          }
        };
      d1.Noise = Zve
    });
    var Qve = y(Ru => {
      l();
      "use strict";
      var Lht = Ru && Ru.__createBinding || (Object.create ? function (r, e, t, i) {
        i === void 0 && (i = t), Object.defineProperty(r, i, {
          enumerable: !0,
          get: function () {
            return e[t]
          }
        })
      } : function (r, e, t, i) {
        i === void 0 && (i = t), r[i] = e[t]
      }),
        Fht = Ru && Ru.__exportStar || function (r, e) {
          for (var t in r) t !== "default" && !Object.prototype.hasOwnProperty.call(e, t) && Lht(e, r, t)
        };
      Object.defineProperty(Ru, "__esModule", {
        value: !0
      });
      Ru.NOISE = void 0;
      var Uht = Lk();
      Fht(Lk(), Ru);
      Ru.NOISE = new Uht.Noise
    });
    var rwe = y((t7t, ewe) => {
      l();
      "use strict";
      var Kht = _9(),
        {
          EventEmitter: zht
        } = Br();

      function twe(r, e) {
        if (r === e) return !0;
        if (r.length !== e.length) return !1;
        for (let t = 0, i = r.length; t < i; ++t)
          if (r[t] !== e[t]) return !1;
        return !0
      }

      function Fk() {
        return {
          contacts: [],
          dontSplit: !1,
          left: null,
          right: null
        }
      }

      function rm(r, e) {
        if (!(e instanceof Uint8Array)) throw new TypeError(r + " is not a Uint8Array")
      }
      var im = class extends zht {
        constructor(e = {}) {
          super();
          this.localNodeId = e.localNodeId || Kht(20), this.numberOfNodesPerKBucket = e.numberOfNodesPerKBucket || 20, this.numberOfNodesToPing = e.numberOfNodesToPing || 3, this.distance = e.distance || im.distance, this.arbiter = e.arbiter || im.arbiter, this.metadata = Object.assign({}, e.metadata), rm("option.localNodeId as parameter 1", this.localNodeId), this.root = Fk()
        }
        static arbiter(e, t) {
          return e.vectorClock > t.vectorClock ? e : t
        }
        static distance(e, t) {
          let i = 0,
            n = 0,
            s = Math.min(e.length, t.length),
            o = Math.max(e.length, t.length);
          for (; n < s; ++n) i = i * 256 + (e[n] ^ t[n]);
          for (; n < o; ++n) i = i * 256 + 255;
          return i
        }
        add(e) {
          rm("contact.id", (e || {}).id);
          let t = 0,
            i = this.root;
          for (; i.contacts === null;) i = this._determineNode(i, e.id, t++);
          let n = this._indexOf(i, e.id);
          return n >= 0 ? (this._update(i, n, e), this) : i.contacts.length < this.numberOfNodesPerKBucket ? (i.contacts.push(e), this.emit("added", e), this) : i.dontSplit ? (this.emit("ping", i.contacts.slice(0, this.numberOfNodesToPing), e), this) : (this._split(i, t), this.add(e))
        }
        closest(e, t = Infinity) {
          if (rm("id", e), !Number.isInteger(t) && t !== Infinity || t <= 0) throw new TypeError("n is not positive number");
          let i = [];
          for (let n = [this.root], s = 0; n.length > 0 && i.length < t;) {
            let o = n.pop();
            if (o.contacts === null) {
              let a = this._determineNode(o, e, s++);
              n.push(o.left === a ? o.right : o.left), n.push(a)
            } else i = i.concat(o.contacts)
          }
          return i.map(n => [this.distance(n.id, e), n]).sort((n, s) => n[0] - s[0]).slice(0, t).map(n => n[1])
        }
        count() {
          let e = 0;
          for (let t = [this.root]; t.length > 0;) {
            let i = t.pop();
            i.contacts === null ? t.push(i.right, i.left) : e += i.contacts.length
          }
          return e
        }
        _determineNode(e, t, i) {
          let n = i >> 3,
            s = i % 8;
          return t.length <= n && s !== 0 ? e.left : t[n] & 1 << 7 - s ? e.right : e.left
        }
        get(e) {
          rm("id", e);
          let t = 0,
            i = this.root;
          for (; i.contacts === null;) i = this._determineNode(i, e, t++);
          let n = this._indexOf(i, e);
          return n >= 0 ? i.contacts[n] : null
        }
        _indexOf(e, t) {
          for (let i = 0; i < e.contacts.length; ++i)
            if (twe(e.contacts[i].id, t)) return i;
          return -1
        }
        remove(e) {
          rm("the id as parameter 1", e);
          let t = 0,
            i = this.root;
          for (; i.contacts === null;) i = this._determineNode(i, e, t++);
          let n = this._indexOf(i, e);
          if (n >= 0) {
            let s = i.contacts.splice(n, 1)[0];
            this.emit("removed", s)
          }
          return this
        }
        _split(e, t) {
          e.left = Fk(), e.right = Fk();
          for (let s of e.contacts) this._determineNode(e, s.id, t).contacts.push(s);
          e.contacts = null;
          let i = this._determineNode(e, this.localNodeId, t),
            n = e.left === i ? e.right : e.left;
          n.dontSplit = !0
        }
        toArray() {
          let e = [];
          for (let t = [this.root]; t.length > 0;) {
            let i = t.pop();
            i.contacts === null ? t.push(i.right, i.left) : e = e.concat(i.contacts)
          }
          return e
        } * toIterable() {
          for (let e = [this.root]; e.length > 0;) {
            let t = e.pop();
            t.contacts === null ? e.push(t.right, t.left) : yield* t.contacts
          }
        }
        _update(e, t, i) {
          if (!twe(e.contacts[t].id, i.id)) throw new Error("wrong index for _update");
          let n = e.contacts[t],
            s = this.arbiter(n, i);
          s === n && n !== i || (e.contacts.splice(t, 1), e.contacts.push(s), this.emit("updated", n, s))
        }
      };
      ewe.exports = im
    });
    var _4 = y((r7t, iwe) => {
      l();
      iwe.exports = Gf;

      function Gf(r, e) {
        if (r.length !== e.length) throw new Error("Inputs should have the same length");
        for (var t = Buffer.allocUnsafe(r.length), i = 0; i < r.length; i++) t[i] = r[i] ^ e[i];
        return t
      }
      Gf.compare = function (e, t) {
        if (e.length !== t.length) throw new Error("Inputs should have the same length");
        for (var i = 0; i < e.length; i++)
          if (e[i] !== t[i]) return e[i] < t[i] ? -1 : 1;
        return 0
      };
      Gf.gt = function (e, t) {
        return Gf.compare(e, t) === 1
      };
      Gf.lt = function (e, t) {
        return Gf.compare(e, t) === -1
      };
      Gf.eq = function (e, t) {
        return Gf.compare(e, t) === 0
      }
    });
    var E4 = y((i7t, nwe) => {
      l();
      "use strict";
      var jht = lR();
      nwe.exports = async (r, e, {
        concurrency: t = Infinity,
        stopOnError: i = !0
      } = {}) => new Promise((n, s) => {
        if (typeof e != "function") throw new TypeError("Mapper function is required");
        if (!((Number.isSafeInteger(t) || t === Infinity) && t >= 1)) throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${t}\` (${typeof t})`);
        let o = [],
          a = [],
          c = r[Symbol.iterator](),
          u = !1,
          f = !1,
          h = 0,
          d = 0,
          p = () => {
            if (u) return;
            let g = c.next(),
              m = d;
            if (d++, g.done) {
              f = !0, h === 0 && (!i && a.length !== 0 ? s(new jht(a)) : n(o));
              return
            }
            h++, (async () => {
              try {
                let E = await g.value;
                o[m] = await e(E, m), h--, p()
              } catch (E) {
                i ? (u = !0, s(E)) : (a.push(E), h--, p())
              }
            })()
          };
        for (let g = 0; g < t && (p(), !f); g++);
      })
    });
    var yi = y(pi => {
      l();
      "use strict";
      var Uk = Oe(),
        Kk = cr(),
        Vht = Kk.multihash,
        {
          Key: Hht
        } = fr(),
        swe = _4(),
        Ght = E4(),
        {
          Record: $ht
        } = Nl(),
        Wht = Et(),
        Yht = xe(),
        Jht = xi(),
        owe = gt(),
        awe = ct();
      pi.convertBuffer = r => Kk.digest(r, "sha2-256");
      pi.convertPeerId = r => Kk.digest(r.id, "sha2-256");
      pi.bufferToKey = r => new Hht("/" + pi.encodeBase32(r), !1);
      pi.keyForPublicKey = r => Jht([owe("/pk/"), r.id]);
      pi.isPublicKeyKey = r => awe(r.slice(0, 4)) === "/pk/";
      pi.fromPublicKeyKey = r => new Wht(r.slice(4));
      pi.now = () => Date.now();
      pi.encodeBase32 = r => awe(r, "base32");
      pi.decodeBase32 = r => owe(r, "base32");
      pi.sortClosestPeers = async (r, e) => (await Ght(r, async i => {
        let n = await pi.convertPeerId(i);
        return {
          peer: i,
          distance: swe(n, e)
        }
      })).sort(pi.xorCompare).map(i => i.peer);
      pi.xorCompare = (r, e) => swe.compare(r.distance, e.distance);
      pi.pathSize = (r, e) => Math.ceil(r / e);
      pi.createPutRecord = (r, e) => {
        let t = new Date;
        return new $ht(r, e, t).serialize()
      };
      pi.logger = (r, e) => {
        let t = ["libp2p", "dht"];
        return e && t.push(e), r && t.push(`${r.toB58String().slice(0, 8)}`), Uk.formatters.b = n => Vht.toB58String(n), Object.assign(Uk(t.join(":")), {
          error: Uk(t.concat(["error"]).join(":"))
        })
      };
      pi.TimeoutError = class extends Error {
        get code() {
          return "ETIMEDOUT"
        }
      };
      pi.withTimeout = (r, e) => {
        function t(...i) {
          return Promise.race([r(...i), new Promise((n, s) => {
            setTimeout(() => {
              s(Yht(new Error("Async function did not complete before timeout"), "ETIMEDOUT"))
            }, e)
          })])
        }
        return t
      };
      pi.mapParallel = async function (r, e) {
        let t = [];
        for await (let i of r) t.push(e(i));
        return Promise.all(t)
      }
    });
    var fwe = y((o7t, cwe) => {
      l();
      "use strict";
      var Xht = rwe(),
        S4 = yi(),
        uwe = class {
          constructor(e, t) {
            this.self = e, this._onPing = this._onPing.bind(this), this._onInit(t)
          }
          async _onInit(e) {
            let t = await S4.convertPeerId(this.self);
            this.kb = new Xht({
              localNodeId: t,
              numberOfNodesPerKBucket: e,
              numberOfNodesToPing: 1
            }), this.kb.on("ping", this._onPing)
          }
          _onPing(e, t) {
            let i = e[0];
            i && this.kb.remove(i.id), this.kb.add(t)
          }
          get size() {
            return this.kb.count()
          }
          async find(e) {
            let t = await S4.convertPeerId(e),
              i = this.closestPeer(t);
            if (i && e.equals(i)) return i
          }
          closestPeer(e) {
            let t = this.closestPeers(e, 1);
            if (t.length > 0) return t[0]
          }
          closestPeers(e, t) {
            return this.kb.closest(e, t).map(n => n.peer)
          }
          async add(e) {
            let t = await S4.convertPeerId(e);
            this.kb.add({
              id: t,
              peer: e
            })
          }
          async remove(e) {
            let t = await S4.convertPeerId(e);
            this.kb.remove(t)
          }
        };
      cwe.exports = uwe
    });
    var $f = y(is => {
      l();
      "use strict";
      var x4 = is.second = 1e3,
        lwe = is.minute = 60 * x4,
        zk = is.hour = 60 * lwe;
      is.MAX_RECORD_AGE = 36 * zk;
      is.PROTOCOL_DHT = "/kad/1.0.0";
      is.PROVIDERS_KEY_PREFIX = "/providers/";
      is.PROVIDERS_LRU_CACHE_SIZE = 256;
      is.PROVIDERS_VALIDITY = 24 * zk;
      is.PROVIDERS_CLEANUP_INTERVAL = zk;
      is.READ_MESSAGE_TIMEOUT = 10 * x4;
      is.GET_MANY_RECORD_COUNT = 16;
      is.K = 20;
      is.ALPHA = 3;
      is.defaultRandomWalk = {
        enabled: !0,
        queriesPerPeriod: 1,
        interval: 5 * lwe,
        timeout: 10 * x4,
        delay: 10 * x4
      }
    });
    var dwe = y((c7t, hwe) => {
      l();
      "use strict";
      var Wf = bi(),
        y1 = Wf.Reader,
        jk = Wf.Writer,
        pt = Wf.util,
        ai = Wf.roots["libp2p-dht-message"] || (Wf.roots["libp2p-dht-message"] = {});
      ai.Record = function () {
        function r(e) {
          if (e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.key = pt.newBuffer([]), r.prototype.value = pt.newBuffer([]), r.prototype.author = pt.newBuffer([]), r.prototype.signature = pt.newBuffer([]), r.prototype.timeReceived = "", r.encode = function (t, i) {
          return i || (i = jk.create()), t.key != null && Object.hasOwnProperty.call(t, "key") && i.uint32(10).bytes(t.key), t.value != null && Object.hasOwnProperty.call(t, "value") && i.uint32(18).bytes(t.value), t.author != null && Object.hasOwnProperty.call(t, "author") && i.uint32(26).bytes(t.author), t.signature != null && Object.hasOwnProperty.call(t, "signature") && i.uint32(34).bytes(t.signature), t.timeReceived != null && Object.hasOwnProperty.call(t, "timeReceived") && i.uint32(42).string(t.timeReceived), i
        }, r.decode = function (t, i) {
          t instanceof y1 || (t = y1.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new ai.Record; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.key = t.bytes();
                break;
              case 2:
                s.value = t.bytes();
                break;
              case 3:
                s.author = t.bytes();
                break;
              case 4:
                s.signature = t.bytes();
                break;
              case 5:
                s.timeReceived = t.string();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof ai.Record) return t;
          var i = new ai.Record;
          return t.key != null && (typeof t.key == "string" ? pt.base64.decode(t.key, i.key = pt.newBuffer(pt.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.value != null && (typeof t.value == "string" ? pt.base64.decode(t.value, i.value = pt.newBuffer(pt.base64.length(t.value)), 0) : t.value.length && (i.value = t.value)), t.author != null && (typeof t.author == "string" ? pt.base64.decode(t.author, i.author = pt.newBuffer(pt.base64.length(t.author)), 0) : t.author.length && (i.author = t.author)), t.signature != null && (typeof t.signature == "string" ? pt.base64.decode(t.signature, i.signature = pt.newBuffer(pt.base64.length(t.signature)), 0) : t.signature.length && (i.signature = t.signature)), t.timeReceived != null && (i.timeReceived = String(t.timeReceived)), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          return i.defaults && (i.bytes === String ? n.key = "" : (n.key = [], i.bytes !== Array && (n.key = pt.newBuffer(n.key))), i.bytes === String ? n.value = "" : (n.value = [], i.bytes !== Array && (n.value = pt.newBuffer(n.value))), i.bytes === String ? n.author = "" : (n.author = [], i.bytes !== Array && (n.author = pt.newBuffer(n.author))), i.bytes === String ? n.signature = "" : (n.signature = [], i.bytes !== Array && (n.signature = pt.newBuffer(n.signature))), n.timeReceived = ""), t.key != null && t.hasOwnProperty("key") && (n.key = i.bytes === String ? pt.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.value != null && t.hasOwnProperty("value") && (n.value = i.bytes === String ? pt.base64.encode(t.value, 0, t.value.length) : i.bytes === Array ? Array.prototype.slice.call(t.value) : t.value), t.author != null && t.hasOwnProperty("author") && (n.author = i.bytes === String ? pt.base64.encode(t.author, 0, t.author.length) : i.bytes === Array ? Array.prototype.slice.call(t.author) : t.author), t.signature != null && t.hasOwnProperty("signature") && (n.signature = i.bytes === String ? pt.base64.encode(t.signature, 0, t.signature.length) : i.bytes === Array ? Array.prototype.slice.call(t.signature) : t.signature), t.timeReceived != null && t.hasOwnProperty("timeReceived") && (n.timeReceived = t.timeReceived), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, Wf.util.toJSONOptions)
        }, r
      }();
      ai.Message = function () {
        function r(e) {
          if (this.closerPeers = [], this.providerPeers = [], e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.type = 0, r.prototype.clusterLevelRaw = 0, r.prototype.key = pt.newBuffer([]), r.prototype.record = pt.newBuffer([]), r.prototype.closerPeers = pt.emptyArray, r.prototype.providerPeers = pt.emptyArray, r.encode = function (t, i) {
          if (i || (i = jk.create()), t.type != null && Object.hasOwnProperty.call(t, "type") && i.uint32(8).int32(t.type), t.key != null && Object.hasOwnProperty.call(t, "key") && i.uint32(18).bytes(t.key), t.record != null && Object.hasOwnProperty.call(t, "record") && i.uint32(26).bytes(t.record), t.closerPeers != null && t.closerPeers.length)
            for (var n = 0; n < t.closerPeers.length; ++n) ai.Message.Peer.encode(t.closerPeers[n], i.uint32(66).fork()).ldelim();
          if (t.providerPeers != null && t.providerPeers.length)
            for (var n = 0; n < t.providerPeers.length; ++n) ai.Message.Peer.encode(t.providerPeers[n], i.uint32(74).fork()).ldelim();
          return t.clusterLevelRaw != null && Object.hasOwnProperty.call(t, "clusterLevelRaw") && i.uint32(80).int32(t.clusterLevelRaw), i
        }, r.decode = function (t, i) {
          t instanceof y1 || (t = y1.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new ai.Message; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.type = t.int32();
                break;
              case 10:
                s.clusterLevelRaw = t.int32();
                break;
              case 2:
                s.key = t.bytes();
                break;
              case 3:
                s.record = t.bytes();
                break;
              case 8:
                s.closerPeers && s.closerPeers.length || (s.closerPeers = []), s.closerPeers.push(ai.Message.Peer.decode(t, t.uint32()));
                break;
              case 9:
                s.providerPeers && s.providerPeers.length || (s.providerPeers = []), s.providerPeers.push(ai.Message.Peer.decode(t, t.uint32()));
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof ai.Message) return t;
          var i = new ai.Message;
          switch (t.type) {
            case "PUT_VALUE":
            case 0:
              i.type = 0;
              break;
            case "GET_VALUE":
            case 1:
              i.type = 1;
              break;
            case "ADD_PROVIDER":
            case 2:
              i.type = 2;
              break;
            case "GET_PROVIDERS":
            case 3:
              i.type = 3;
              break;
            case "FIND_NODE":
            case 4:
              i.type = 4;
              break;
            case "PING":
            case 5:
              i.type = 5;
              break
          }
          if (t.clusterLevelRaw != null && (i.clusterLevelRaw = t.clusterLevelRaw | 0), t.key != null && (typeof t.key == "string" ? pt.base64.decode(t.key, i.key = pt.newBuffer(pt.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.record != null && (typeof t.record == "string" ? pt.base64.decode(t.record, i.record = pt.newBuffer(pt.base64.length(t.record)), 0) : t.record.length && (i.record = t.record)), t.closerPeers) {
            if (!Array.isArray(t.closerPeers)) throw TypeError(".Message.closerPeers: array expected");
            i.closerPeers = [];
            for (var n = 0; n < t.closerPeers.length; ++n) {
              if (typeof t.closerPeers[n] != "object") throw TypeError(".Message.closerPeers: object expected");
              i.closerPeers[n] = ai.Message.Peer.fromObject(t.closerPeers[n])
            }
          }
          if (t.providerPeers) {
            if (!Array.isArray(t.providerPeers)) throw TypeError(".Message.providerPeers: array expected");
            i.providerPeers = [];
            for (var n = 0; n < t.providerPeers.length; ++n) {
              if (typeof t.providerPeers[n] != "object") throw TypeError(".Message.providerPeers: object expected");
              i.providerPeers[n] = ai.Message.Peer.fromObject(t.providerPeers[n])
            }
          }
          return i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if ((i.arrays || i.defaults) && (n.closerPeers = [], n.providerPeers = []), i.defaults && (n.type = i.enums === String ? "PUT_VALUE" : 0, i.bytes === String ? n.key = "" : (n.key = [], i.bytes !== Array && (n.key = pt.newBuffer(n.key))), i.bytes === String ? n.record = "" : (n.record = [], i.bytes !== Array && (n.record = pt.newBuffer(n.record))), n.clusterLevelRaw = 0), t.type != null && t.hasOwnProperty("type") && (n.type = i.enums === String ? ai.Message.MessageType[t.type] : t.type), t.key != null && t.hasOwnProperty("key") && (n.key = i.bytes === String ? pt.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.record != null && t.hasOwnProperty("record") && (n.record = i.bytes === String ? pt.base64.encode(t.record, 0, t.record.length) : i.bytes === Array ? Array.prototype.slice.call(t.record) : t.record), t.closerPeers && t.closerPeers.length) {
            n.closerPeers = [];
            for (var s = 0; s < t.closerPeers.length; ++s) n.closerPeers[s] = ai.Message.Peer.toObject(t.closerPeers[s], i)
          }
          if (t.providerPeers && t.providerPeers.length) {
            n.providerPeers = [];
            for (var s = 0; s < t.providerPeers.length; ++s) n.providerPeers[s] = ai.Message.Peer.toObject(t.providerPeers[s], i)
          }
          return t.clusterLevelRaw != null && t.hasOwnProperty("clusterLevelRaw") && (n.clusterLevelRaw = t.clusterLevelRaw), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, Wf.util.toJSONOptions)
        }, r.MessageType = function () {
          var e = {},
            t = Object.create(e);
          return t[e[0] = "PUT_VALUE"] = 0, t[e[1] = "GET_VALUE"] = 1, t[e[2] = "ADD_PROVIDER"] = 2, t[e[3] = "GET_PROVIDERS"] = 3, t[e[4] = "FIND_NODE"] = 4, t[e[5] = "PING"] = 5, t
        }(), r.ConnectionType = function () {
          var e = {},
            t = Object.create(e);
          return t[e[0] = "NOT_CONNECTED"] = 0, t[e[1] = "CONNECTED"] = 1, t[e[2] = "CAN_CONNECT"] = 2, t[e[3] = "CANNOT_CONNECT"] = 3, t
        }(), r.Peer = function () {
          function e(t) {
            if (this.addrs = [], t)
              for (var i = Object.keys(t), n = 0; n < i.length; ++n) t[i[n]] != null && (this[i[n]] = t[i[n]])
          }
          return e.prototype.id = pt.newBuffer([]), e.prototype.addrs = pt.emptyArray, e.prototype.connection = 0, e.encode = function (i, n) {
            if (n || (n = jk.create()), i.id != null && Object.hasOwnProperty.call(i, "id") && n.uint32(10).bytes(i.id), i.addrs != null && i.addrs.length)
              for (var s = 0; s < i.addrs.length; ++s) n.uint32(18).bytes(i.addrs[s]);
            return i.connection != null && Object.hasOwnProperty.call(i, "connection") && n.uint32(24).int32(i.connection), n
          }, e.decode = function (i, n) {
            i instanceof y1 || (i = y1.create(i));
            for (var s = n === void 0 ? i.len : i.pos + n, o = new ai.Message.Peer; i.pos < s;) {
              var a = i.uint32();
              switch (a >>> 3) {
                case 1:
                  o.id = i.bytes();
                  break;
                case 2:
                  o.addrs && o.addrs.length || (o.addrs = []), o.addrs.push(i.bytes());
                  break;
                case 3:
                  o.connection = i.int32();
                  break;
                default:
                  i.skipType(a & 7);
                  break
              }
            }
            return o
          }, e.fromObject = function (i) {
            if (i instanceof ai.Message.Peer) return i;
            var n = new ai.Message.Peer;
            if (i.id != null && (typeof i.id == "string" ? pt.base64.decode(i.id, n.id = pt.newBuffer(pt.base64.length(i.id)), 0) : i.id.length && (n.id = i.id)), i.addrs) {
              if (!Array.isArray(i.addrs)) throw TypeError(".Message.Peer.addrs: array expected");
              n.addrs = [];
              for (var s = 0; s < i.addrs.length; ++s) typeof i.addrs[s] == "string" ? pt.base64.decode(i.addrs[s], n.addrs[s] = pt.newBuffer(pt.base64.length(i.addrs[s])), 0) : i.addrs[s].length && (n.addrs[s] = i.addrs[s])
            }
            switch (i.connection) {
              case "NOT_CONNECTED":
              case 0:
                n.connection = 0;
                break;
              case "CONNECTED":
              case 1:
                n.connection = 1;
                break;
              case "CAN_CONNECT":
              case 2:
                n.connection = 2;
                break;
              case "CANNOT_CONNECT":
              case 3:
                n.connection = 3;
                break
            }
            return n
          }, e.toObject = function (i, n) {
            n || (n = {});
            var s = {};
            if ((n.arrays || n.defaults) && (s.addrs = []), n.defaults && (n.bytes === String ? s.id = "" : (s.id = [], n.bytes !== Array && (s.id = pt.newBuffer(s.id))), s.connection = n.enums === String ? "NOT_CONNECTED" : 0), i.id != null && i.hasOwnProperty("id") && (s.id = n.bytes === String ? pt.base64.encode(i.id, 0, i.id.length) : n.bytes === Array ? Array.prototype.slice.call(i.id) : i.id), i.addrs && i.addrs.length) {
              s.addrs = [];
              for (var o = 0; o < i.addrs.length; ++o) s.addrs[o] = n.bytes === String ? pt.base64.encode(i.addrs[o], 0, i.addrs[o].length) : n.bytes === Array ? Array.prototype.slice.call(i.addrs[o]) : i.addrs[o]
            }
            return i.connection != null && i.hasOwnProperty("connection") && (s.connection = n.enums === String ? ai.Message.ConnectionType[i.connection] : i.connection), s
          }, e.prototype.toJSON = function () {
            return this.constructor.toObject(this, Wf.util.toJSONOptions)
          }, e
        }(), r
      }();
      hwe.exports = ai
    });
    var Ic = y((u7t, pwe) => {
      l();
      "use strict";
      var Zht = Et(),
        {
          Multiaddr: Qht
        } = pr(),
        {
          Record: edt
        } = Nl(),
        A4 = dwe(),
        tdt = A4.Message.MessageType,
        ywe = A4.Message.ConnectionType,
        g1 = class {
          constructor(e, t, i) {
            if (t && !(t instanceof Uint8Array)) throw new Error("Key must be a Uint8Array");
            this.type = e, this.key = t, this._clusterLevelRaw = i, this.closerPeers = [], this.providerPeers = [], this.record = void 0
          }
          get clusterLevel() {
            let e = this._clusterLevelRaw - 1;
            return e < 0 ? 0 : e
          }
          set clusterLevel(e) {
            this._clusterLevelRaw = e
          }
          serialize() {
            let e = {
              key: this.key,
              type: this.type,
              clusterLevelRaw: this._clusterLevelRaw,
              closerPeers: this.closerPeers.map(gwe),
              providerPeers: this.providerPeers.map(gwe),
              record: void 0
            };
            return this.record && (this.record instanceof Uint8Array ? e.record = this.record : e.record = this.record.serialize()), A4.Message.encode(e).finish()
          }
          static deserialize(e) {
            let t = A4.Message.decode(e),
              i = new g1(t.type, t.key, t.clusterLevelRaw);
            return i.closerPeers = t.closerPeers.map(bwe), i.providerPeers = t.providerPeers.map(bwe), t.record && t.record.length && (i.record = edt.deserialize(t.record)), i
          }
        };
      g1.TYPES = tdt;
      g1.CONNECTION_TYPES = ywe;

      function gwe(r) {
        return {
          id: r.id.id,
          addrs: (r.multiaddrs || []).map(t => t.bytes),
          connection: ywe.CONNECTED
        }
      }

      function bwe(r) {
        return {
          id: new Zht(r.id),
          multiaddrs: (r.addrs || []).map(e => new Qht(e))
        }
      }
      pwe.exports = g1
    });
    var wwe = y((f7t, mwe) => {
      l();
      "use strict";
      var {
        Record: rdt
      } = Nl(), idt = xe(), vwe = Ic(), Vk = yi();
      mwe.exports = r => {
        let e = Vk.logger(r.peerId, "rpc:get-value");
        async function t(i, n) {
          let s = n.key;
          if (e("key: %b", s), !s || s.length === 0) throw idt(new Error("Invalid key"), "ERR_INVALID_KEY");
          let o = new vwe(vwe.TYPES.GET_VALUE, s, n.clusterLevel);
          if (Vk.isPublicKeyKey(s)) {
            e("is public key");
            let u = Vk.fromPublicKeyKey(s),
              f;
            if (r._isSelf(u)) f = r.peerId;
            else {
              let h = r.peerStore.get(u);
              f = h && h.id
            }
            if (f && f.pubKey) return e("returning found public key"), o.record = new rdt(s, f.pubKey.bytes), o
          }
          let [a, c] = await Promise.all([r._checkLocalDatastore(s), r._betterPeersToQuery(n, i)]);
          return a && (e("got record"), o.record = a), c.length > 0 && (e("got closer %s", c.length), o.closerPeers = c), o
        }
        return t
      }
    });
    var Swe = y((l7t, _we) => {
      l();
      "use strict";
      var Ewe = yi(),
        ndt = xe();
      _we.exports = r => {
        let e = Ewe.logger(r.peerId, "rpc:put-value");
        async function t(i, n) {
          let s = n.key;
          e("key: %b", s);
          let o = n.record;
          if (!o) {
            let c = `Empty record from: ${i.toB58String()}`;
            throw e.error(c), ndt(new Error(c), "ERR_EMPTY_RECORD")
          }
          await r._verifyRecordLocally(o), o.timeReceived = new Date;
          let a = Ewe.bufferToKey(o.key);
          return await r.datastore.put(a, o.serialize()), r.onPut(o, i), n
        }
        return t
      }
    });
    var Awe = y((h7t, xwe) => {
      l();
      "use strict";
      var sdt = Lr(),
        odt = Ic(),
        adt = yi();
      xwe.exports = r => {
        let e = adt.logger(r.peerId, "rpc:find-node");
        async function t(i, n) {
          e("start");
          let s;
          sdt(n.key, r.peerId.id) ? s = [{
            id: r.peerId,
            multiaddrs: r.libp2p.multiaddrs
          }] : s = await r._betterPeersToQuery(n, i);
          let o = new odt(n.type, new Uint8Array(0), n.clusterLevel);
          return s.length > 0 ? o.closerPeers = s : e("handle FindNode %s: could not find anything", i.toB58String()), o
        }
        return t
      }
    });
    var Rwe = y((d7t, Iwe) => {
      l();
      "use strict";
      var cdt = at(),
        Twe = xe(),
        udt = yi();
      Iwe.exports = r => {
        let e = udt.logger(r.peerId, "rpc:add-provider");
        async function t(i, n) {
          if (e("start"), !n.key || n.key.length === 0) throw Twe(new Error("Missing key"), "ERR_MISSING_KEY");
          let s;
          try {
            s = new cdt(n.key)
          } catch (o) {
            let a = `Invalid CID: ${o.message}`;
            throw Twe(new Error(a), "ERR_INVALID_CID")
          }
          return n.providerPeers.forEach(o => {
            if (!o.id.isEqual(i)) {
              e("invalid provider peer %s from %s", o.id.toB58String(), i.toB58String());
              return
            }
            if (o.multiaddrs.length < 1) {
              e("no valid addresses for provider %s. Ignore", i.toB58String());
              return
            }
            if (e("received provider %s for %s (addrs %s)", i.toB58String(), s.toBaseEncodedString(), o.multiaddrs.map(a => a.toString())), !r._isSelf(o.id)) return r.peerStore.addressBook.add(o.id, o.multiaddrs), r.providers.addProvider(s, o.id)
          }), r.providers.addProvider(s, i)
        }
        return t
      }
    });
    var Cwe = y((p7t, kwe) => {
      l();
      "use strict";
      var fdt = at(),
        ldt = xe(),
        hdt = Ic(),
        Pwe = yi();
      kwe.exports = r => {
        let e = Pwe.logger(r.peerId, "rpc:get-providers");
        async function t(i, n) {
          let s;
          try {
            s = new fdt(n.key)
          } catch (p) {
            throw ldt(new Error(`Invalid CID: ${p.message}`), "ERR_INVALID_CID")
          }
          e("%s", s.toBaseEncodedString());
          let o = Pwe.bufferToKey(s.bytes),
            [a, c, u] = await Promise.all([r.datastore.has(o), r.providers.getProviders(s), r._betterPeersToQuery(n, i)]),
            f = c.map(p => ({
              id: p,
              multiaddrs: []
            })),
            h = u.map(p => ({
              id: p.id,
              multiaddrs: []
            }));
          a && f.push({
            id: r.peerId,
            multiaddrs: []
          });
          let d = new hdt(n.type, n.key, n.clusterLevel);
          return f.length > 0 && (d.providerPeers = f), h.length > 0 && (d.closerPeers = h), e("got %s providers %s closerPeers", f.length, h.length), d
        }
        return t
      }
    });
    var Nwe = y((y7t, Owe) => {
      l();
      "use strict";
      var ddt = yi();
      Owe.exports = r => {
        let e = ddt.logger(r.peerId, "rpc:ping");

        function t(i, n) {
          return e("from %s", i.toB58String()), n
        }
        return t
      }
    });
    var Mwe = y((g7t, qwe) => {
      l();
      "use strict";
      var b1 = Ic().TYPES;
      qwe.exports = r => {
        let e = {
          [b1.GET_VALUE]: wwe()(r),
          [b1.PUT_VALUE]: Swe()(r),
          [b1.FIND_NODE]: Awe()(r),
          [b1.ADD_PROVIDER]: Rwe()(r),
          [b1.GET_PROVIDERS]: Cwe()(r),
          [b1.PING]: Nwe()(r)
        };

        function t(i) {
          return e[i]
        }
        return t
      }
    });
    var Lwe = y((b7t, Bwe) => {
      l();
      "use strict";
      var {
        pipe: pdt
      } = vi(), Dwe = da(), ydt = Ic(), gdt = Mwe(), bdt = yi();
      Bwe.exports = r => {
        let e = bdt.logger(r.peerId, "rpc"),
          t = gdt(r);
        async function i(s, o) {
          let a = t(o.type);
          try {
            await r._add(s)
          } catch (c) {
            e.error("Failed to update the kbucket store", c)
          }
          if (!a) {
            e.error(`no handler found for message type: ${o.type}`);
            return
          }
          return a(s, o)
        }
        async function n({
          stream: s,
          connection: o
        }) {
          let a = o.remotePeer;
          try {
            await r._add(a)
          } catch (u) {
            e.error(u)
          }
          let c = a.toB58String();
          e("from: %s", c), await pdt(s.source, Dwe.decode(), u => async function* () {
            for await (let f of u) {
              let h = ydt.deserialize(f.slice()),
                d = await i(a, h);
              d && (yield d.serialize())
            }
          }(), Dwe.encode(), s.sink)
        }
        return n
      }
    });
    var zwe = y((m7t, Fwe) => {
      l();
      "use strict";
      var I4 = xe(),
        {
          pipe: Uwe
        } = vi(),
        Hk = da(),
        mdt = jp(),
        {
          consume: vdt
        } = Ml(),
        wdt = r0(),
        _dt = b_(),
        Edt = Lwe(),
        Sdt = $f(),
        xdt = Ic(),
        Adt = yi(),
        Kwe = class {
          constructor(e) {
            this.dht = e, this.readMessageTimeout = Sdt.READ_MESSAGE_TIMEOUT, this._log = Adt.logger(this.dht.peerId, "net"), this._rpc = Edt(this.dht), this._onPeerConnected = this._onPeerConnected.bind(this), this._running = !1
          }
          async start() {
            if (this._running) return;
            if (!this.dht.isStarted) throw I4(new Error("Can not start network"), "ERR_CANNOT_START_NETWORK");
            this._running = !0, this.dht._clientMode === !1 && this.dht.registrar.handle(this.dht.protocol, this._rpc);
            let e = new _dt({
              multicodecs: [this.dht.protocol],
              handlers: {
                onConnect: this._onPeerConnected,
                onDisconnect: () => { }
              }
            });
            this._registrarId = await this.dht.registrar.register(e)
          }
          async stop() {
            !this.dht.isStarted && !this.isStarted || (this._running = !1, this._registrarId && await this.dht.registrar.unregister(this._registrarId))
          }
          get isStarted() {
            return this._running
          }
          get isConnected() {
            return this.dht.isStarted && this.isStarted
          }
          async _onPeerConnected(e) {
            await this.dht._add(e), this._log("added to the routing table: %s", e.toB58String())
          }
          async sendRequest(e, t) {
            if (!this.isConnected) throw I4(new Error("Network is offline"), "ERR_NETWORK_OFFLINE");
            let i = e.toB58String();
            this._log("sending to: %s", i);
            let n = this.dht.registrar.connectionManager.get(e);
            n || (n = await this.dht.dialer.connectToPeer(e));
            let {
              stream: s
            } = await n.newStream(this.dht.protocol);
            return this._writeReadMessage(s, t.serialize())
          }
          async sendMessage(e, t) {
            if (!this.isConnected) throw I4(new Error("Network is offline"), "ERR_NETWORK_OFFLINE");
            let i = e.toB58String();
            this._log("sending to: %s", i);
            let n = this.dht.registrar.connectionManager.get(e);
            n || (n = await this.dht.dialer.connectToPeer(e));
            let {
              stream: s
            } = await n.newStream(this.dht.protocol);
            return this._writeMessage(s, t.serialize())
          }
          async _writeReadMessage(e, t) {
            return mdt(Idt(e, t), this.readMessageTimeout)
          }
          _writeMessage(e, t) {
            return Uwe([t], Hk.encode(), e, vdt)
          }
        };
      async function Idt(r, e) {
        let t = await Uwe([e], Hk.encode(), r, Hk.decode(), async i => {
          let n = await wdt(i);
          if (n) return n.slice()
        });
        if (t.length === 0) throw I4(new Error("No message received"), "ERR_NO_MESSAGE_RECEIVED");
        return xdt.deserialize(t)
      }
      Fwe.exports = Kwe
    });
    var Gwe = y((v7t, jwe) => {
      l();
      "use strict";
      var T4 = _4(),
        Vwe = yi(),
        Tdt = E4(),
        Rdt = Lr(),
        Hwe = class {
          constructor(e, t) {
            this.originDhtKey = e, this.capacity = t, this.peerDistances = []
          }
          get length() {
            return this.peerDistances.length
          }
          get peers() {
            return this.peerDistances.map(e => e.peerId)
          }
          async add(e) {
            if (this.peerDistances.find(n => Rdt(n.peerId.id, e.id))) return;
            let t = await Vwe.convertPeerId(e),
              i = {
                peerId: e,
                distance: T4(this.originDhtKey, t)
              };
            this.peerDistances.push(i), this.peerDistances.sort((n, s) => T4.compare(n.distance, s.distance)), this.peerDistances = this.peerDistances.slice(0, this.capacity)
          }
          async anyCloser(e) {
            if (!e.length) return !1;
            if (!this.length) return !0;
            let t = await Tdt(e, n => Vwe.convertPeerId(n)),
              i = this.peerDistances[this.peerDistances.length - 1].distance;
            for (let n of t) {
              let s = T4(this.originDhtKey, n);
              if (T4.compare(s, i) < 0) return !0
            }
            return !1
          }
        };
      jwe.exports = Hwe
    });
    var Wwe = y((Gk, $we) => {
      l();
      (function () {
        var r, e, t, i, n, s, o, a, c, u, f, h, d, p, g;
        t = Math.floor, u = Math.min, e = function (m, E) {
          return m < E ? -1 : m > E ? 1 : 0
        }, c = function (m, E, w, O, q) {
          var J;
          if (w == null && (w = 0), q == null && (q = e), w < 0) throw new Error("lo must be non-negative");
          for (O == null && (O = m.length); w < O;) J = t((w + O) / 2), q(E, m[J]) < 0 ? O = J : w = J + 1;
          return [].splice.apply(m, [w, w - w].concat(E)), E
        }, s = function (m, E, w) {
          return w == null && (w = e), m.push(E), p(m, 0, m.length - 1, w)
        }, n = function (m, E) {
          var w, O;
          return E == null && (E = e), w = m.pop(), m.length ? (O = m[0], m[0] = w, g(m, 0, E)) : O = w, O
        }, a = function (m, E, w) {
          var O;
          return w == null && (w = e), O = m[0], m[0] = E, g(m, 0, w), O
        }, o = function (m, E, w) {
          var O;
          return w == null && (w = e), m.length && w(m[0], E) < 0 && (O = [m[0], E], E = O[0], m[0] = O[1], g(m, 0, w)), E
        }, i = function (m, E) {
          var w, O, q, J, Z, H, te, ae;
          for (E == null && (E = e), H = function () {
            ae = [];
            for (var oe = 0, U = t(m.length / 2); 0 <= U ? oe < U : oe > U; 0 <= U ? oe++ : oe--) ae.push(oe);
            return ae
          }.apply(this).reverse(), te = [], O = 0, J = H.length; O < J; O++) w = H[O], te.push(g(m, w, E));
          return te
        }, d = function (m, E, w) {
          var O;
          if (w == null && (w = e), O = m.indexOf(E), O !== -1) return p(m, 0, O, w), g(m, O, w)
        }, f = function (m, E, w) {
          var O, q, J, Z, H;
          if (w == null && (w = e), q = m.slice(0, E), !q.length) return q;
          for (i(q, w), H = m.slice(E), J = 0, Z = H.length; J < Z; J++) O = H[J], o(q, O, w);
          return q.sort(w).reverse()
        }, h = function (m, E, w) {
          var O, q, J, Z, H, te, ae, oe, U, b;
          if (w == null && (w = e), E * 10 <= m.length) {
            if (Z = m.slice(0, E).sort(w), !Z.length) return Z;
            for (J = Z[Z.length - 1], oe = m.slice(E), H = 0, ae = oe.length; H < ae; H++) O = oe[H], w(O, J) < 0 && (c(Z, O, 0, null, w), Z.pop(), J = Z[Z.length - 1]);
            return Z
          }
          for (i(m, w), b = [], q = te = 0, U = u(E, m.length); 0 <= U ? te < U : te > U; q = 0 <= U ? ++te : --te) b.push(n(m, w));
          return b
        }, p = function (m, E, w, O) {
          var q, J, Z;
          for (O == null && (O = e), q = m[w]; w > E;) {
            if (Z = w - 1 >> 1, J = m[Z], O(q, J) < 0) {
              m[w] = J, w = Z;
              continue
            }
            break
          }
          return m[w] = q
        }, g = function (m, E, w) {
          var O, q, J, Z, H;
          for (w == null && (w = e), q = m.length, H = E, J = m[E], O = 2 * E + 1; O < q;) Z = O + 1, Z < q && !(w(m[O], m[Z]) < 0) && (O = Z), m[E] = m[O], E = O, O = 2 * E + 1;
          return m[E] = J, p(m, H, E, w)
        }, r = function () {
          m.push = s, m.pop = n, m.replace = a, m.pushpop = o, m.heapify = i, m.updateItem = d, m.nlargest = f, m.nsmallest = h;

          function m(E) {
            this.cmp = E ?? e, this.nodes = []
          }
          return m.prototype.push = function (E) {
            return s(this.nodes, E, this.cmp)
          }, m.prototype.pop = function () {
            return n(this.nodes, this.cmp)
          }, m.prototype.peek = function () {
            return this.nodes[0]
          }, m.prototype.contains = function (E) {
            return this.nodes.indexOf(E) !== -1
          }, m.prototype.replace = function (E) {
            return a(this.nodes, E, this.cmp)
          }, m.prototype.pushpop = function (E) {
            return o(this.nodes, E, this.cmp)
          }, m.prototype.heapify = function () {
            return i(this.nodes, this.cmp)
          }, m.prototype.updateItem = function (E) {
            return d(this.nodes, E, this.cmp)
          }, m.prototype.clear = function () {
            return this.nodes = []
          }, m.prototype.empty = function () {
            return this.nodes.length === 0
          }, m.prototype.size = function () {
            return this.nodes.length
          }, m.prototype.clone = function () {
            var E;
            return E = new m, E.nodes = this.nodes.slice(0), E
          }, m.prototype.toArray = function () {
            return this.nodes.slice(0)
          }, m.prototype.insert = m.prototype.push, m.prototype.top = m.prototype.peek, m.prototype.front = m.prototype.peek, m.prototype.has = m.prototype.contains, m.prototype.copy = m.prototype.clone, m
        }(),
          function (m, E) {
            return typeof define == "function" && define.amd ? define([], E) : typeof Gk == "object" ? $we.exports = E() : m.Heap = E()
          }(this, function () {
            return r
          })
      }).call(Gk)
    });
    var Jwe = y((w7t, Ywe) => {
      l();
      Ywe.exports = Wwe()
    });
    var Zwe = y((_7t, Xwe) => {
      l();
      "use strict";
      var kdt = Jwe(),
        Pdt = _4(),
        Cdt = Oe(),
        R4 = yi(),
        $k = Cdt("libp2p:dht:peer-queue"),
        nm = class {
          static async fromPeerId(e) {
            let t = await R4.convertPeerId(e);
            return new nm(t)
          }
          static async fromKey(e) {
            let t = await R4.convertBuffer(e);
            return new nm(t)
          }
          constructor(e) {
            $k("create: %b", e), this.from = e, this.heap = new kdt(R4.xorCompare)
          }
          async enqueue(e) {
            $k("enqueue %s", e.toB58String());
            let t = await R4.convertPeerId(e),
              i = {
                id: e,
                distance: Pdt(this.from, t)
              };
            this.heap.push(i)
          }
          dequeue() {
            let e = this.heap.pop();
            return $k("dequeue %s", e.id.toB58String()), e.id
          }
          get length() {
            return this.heap.size()
          }
        };
      Xwe.exports = nm
    });
    var t3e = y((E7t, Qwe) => {
      l();
      "use strict";
      var Odt = Zwe(),
        Ndt = yi(),
        qdt = 3e4,
        e3e = class {
          constructor(e, t) {
            if (this.run = e, this.queryFunc = Ndt.withTimeout(t, qdt), !this.queryFunc) throw new Error("Path requires a `queryFn` to be specified");
            if (typeof this.queryFunc != "function") throw new Error("Path expected `queryFn` to be a function. Got " + typeof this.queryFunc);
            this.initialPeers = [], this.peersToQuery = null, this.res = null
          }
          addInitialPeer(e) {
            this.initialPeers.push(e)
          }
          async execute() {
            let e = await Odt.fromKey(this.run.query.key);
            this.peersToQuery = e, await Promise.all(this.initialPeers.map(t => this.addPeerToQuery(t))), await this.run.workerQueue(this)
          }
          async addPeerToQuery(e) {
            this.run.query.dht._isSelf(e) || this.run.peersSeen.has(e.toB58String()) || this.peersToQuery && await this.peersToQuery.enqueue(e)
          }
        };
      Qwe.exports = e3e
    });
    var n3e = y((S7t, r3e) => {
      l();
      "use strict";
      var {
        default: Mdt
      } = Tl(), i3e = class {
        constructor(e, t, i, n) {
          this.dht = e, this.run = t, this.path = i, this.log = n, this.concurrency = this.dht.concurrency, this.queue = this.setupQueue(), this.execution = null, this.queuedPeerIds = new Set
        }
        setupQueue() {
          let e = new Mdt({
            concurrency: this.concurrency
          });
          return e.on("idle", () => {
            this.path.peersToQuery && !this.path.peersToQuery.length && (this.log("queue:drain"), this.stop())
          }), e.on("next", () => {
            !this.running || e.pending < this.concurrency && this.fill()
          }), e
        }
        stop(e) {
          !this.running || (this.running = !1, this.queue.clear(), this.log("worker:stop, %d workers still running", this.run.workers.filter(t => t.running).length), this.execution && (e ? this.execution.reject(e) : this.execution.resolve()))
        }
        async execute() {
          this.running = !0, this.execution = null;
          let e = new Promise((t, i) => {
            this.execution = {
              resolve: t,
              reject: i
            }
          });
          this.fill(), await e
        }
        fill() {
          if (!!this.path.peersToQuery)
            for (; this.queue.pending + this.queue.size < this.concurrency && this.path.peersToQuery.length > 0;) {
              let e = this.path.peersToQuery.dequeue();
              this.queuedPeerIds.add(e), this.queue.add(() => this.processNext(e).catch(t => {
                this.log.error("queue", t), this.stop(t)
              }).finally(() => {
                this.queuedPeerIds.delete(e)
              }))
            }
        }
        async processNext(e) {
          if (!this.running || this.run.peersSeen.has(e.toB58String())) return;
          let t, i;
          try {
            t = await this.run.continueQuerying(this)
          } catch (o) {
            i = o
          }
          if (!this.running) return;
          if (i) throw i;
          if (!t) {
            this.stop();
            return
          }
          if (this.run.peersSeen.has(e.toB58String())) return;
          this.run.peersSeen.add(e.toB58String()), this.log("queue:work");
          let n, s;
          try {
            n = await this.execQuery(e)
          } catch (o) {
            s = o
          }
          if (!!this.running) {
            if (this.log("queue:work:done", s, n), s) throw s;
            if (n && n.queryComplete) {
              this.log("query:complete"), this.run.stop();
              return
            }
            n && n.pathComplete && this.stop()
          }
        }
        async execQuery(e) {
          let t, i;
          try {
            t = await this.path.queryFunc(e)
          } catch (n) {
            i = n
          }
          if (!!this.running) {
            if (i) {
              this.run.errors.push(i);
              return
            }
            if (this.run.peersQueried && await this.run.peersQueried.add(e), !!t) {
              if (t.pathComplete || t.queryComplete) return this.path.res = t, {
                pathComplete: t.pathComplete,
                queryComplete: t.queryComplete
              };
              if (t.closerPeers && t.closerPeers.length > 0) {
                let n = async s => {
                  this.dht._isSelf(s.id) || (this.dht._peerDiscovered(s.id, s.multiaddrs), await this.path.addPeerToQuery(s.id))
                };
                await Promise.all(t.closerPeers.map(n))
              }
            }
          }
        }
      };
      r3e.exports = i3e
    });
    var a3e = y((x7t, s3e) => {
      l();
      "use strict";
      var Bdt = Gwe(),
        Ddt = Br(),
        Ldt = t3e(),
        Fdt = n3e(),
        Udt = yi(),
        o3e = class extends Ddt {
          constructor(e) {
            super();
            this.query = e, this.running = !1, this.workers = [], this.peersSeen = new Set, this.errors = [], this.peersQueried = null
          }
          stop() {
            if (!!this.running) {
              this.running = !1;
              for (let e of this.workers) e.stop()
            }
          }
          async execute(e) {
            let t = [],
              i = Math.min(this.query.dht.disjointPaths, e.length);
            for (let s = 0; s < i; s++) t.push(new Ldt(this, this.query.makePath(s, i)));
            e.forEach((s, o) => {
              t[o % i].addInitialPeer(s)
            }), await this.executePaths(t);
            let n = {
              finalSet: new Set(this.peersQueried && this.peersQueried.peers),
              paths: []
            };
            for (let s of t) s.res && (s.res.pathComplete || s.res.queryComplete) && (s.res.success = !0, n.paths.push(s.res));
            return n
          }
          async executePaths(e) {
            this.running = !0, this.emit("start");
            try {
              await Promise.all(e.map(t => t.execute()))
            } finally {
              this.stop(), this.emit("complete")
            }
            if (this.errors.length === this.peersSeen.size) throw this.errors[0]
          }
          async workerQueue(e) {
            await this.init(), await this.startWorker(e)
          }
          async startWorker(e) {
            let t = new Fdt(this.query.dht, this, e, this.query._log);
            this.workers.push(t), await t.execute()
          }
          async init() {
            if (!this.peersQueried) {
              if (this.peersQueriedPromise) {
                await this.peersQueriedPromise;
                return
              }
              this.peersQueriedPromise = (async () => {
                let e = await Udt.convertBuffer(this.query.key);
                this.peersQueried = new Bdt(e, this.query.dht.kBucketSize)
              })(), await this.peersQueriedPromise, delete this.peersQueriedPromise
            }
          }
          async continueQuerying(e) {
            if (this.peersQueried && this.peersQueried.length < this.peersQueried.capacity) return !0;
            let t = Array.from(e.queuedPeerIds);
            return !!(this.peersQueried && await this.peersQueried.anyCloser(t))
          }
        };
      s3e.exports = o3e
    });
    var k4 = y((A7t, c3e) => {
      l();
      "use strict";
      var Kdt = cr().multihash,
        zdt = yi(),
        jdt = a3e(),
        u3e = class {
          constructor(e, t, i) {
            this.dht = e, this.key = t, this.makePath = i, this._log = zdt.logger(this.dht.peerId, "query:" + Kdt.toB58String(t)), this.running = !1, this._onStart = this._onStart.bind(this), this._onComplete = this._onComplete.bind(this)
          }
          async run(e) {
            return this.dht._queryManager.running ? e.length === 0 ? (this._log.error("Running query with no peers"), {
              finalSet: new Set,
              paths: []
            }) : (this._run = new jdt(this), this._log(`query running with K=${this.dht.kBucketSize}, A=${this.dht.concurrency}, D=${Math.min(this.dht.disjointPaths, e.length)}`), this._run.once("start", this._onStart), this._run.once("complete", this._onComplete), this._run.execute(e)) : (this._log.error("Attempt to run query after shutdown"), {
              finalSet: new Set,
              paths: []
            })
          }
          _onStart() {
            this.running = !0, this._startTime = Date.now(), this._log("query:start"), this.dht._queryManager.queryStarted(this)
          }
          _onComplete() {
            this.stop()
          }
          stop() {
            this._log(`query:done in ${Date.now() - (this._startTime || 0)}ms`), this._run && this._log(`${this._run.errors.length} of ${this._run.peersSeen.size} peers errored (${this._run.errors.length / this._run.peersSeen.size * 100}% fail rate)`), !!this.running && (this.running = !1, this._run && (this._run.removeListener("start", this._onStart), this._run.removeListener("complete", this._onComplete), this._run.stop()), this.dht._queryManager.queryCompleted(this))
          }
        };
      c3e.exports = u3e
    });
    var d3e = y((I7t, f3e) => {
      l();
      "use strict";
      var Wk = xe(),
        Vdt = jp(),
        Hdt = Lr(),
        l3e = ct(),
        h3e = Nl(),
        Yk = $f(),
        Gdt = k4(),
        jh = yi(),
        $dt = h3e.Record;
      f3e.exports = r => {
        let e = async (n, s) => r.datastore.put(jh.bufferToKey(n), s), t = async n => {
          r._log(`getLocal ${l3e(n, "base32")}`);
          let s = await r.datastore.get(jh.bufferToKey(n));
          r._log(`found ${l3e(n, "base32")} in local datastore`);
          let o = $dt.deserialize(s);
          return await r._verifyRecordLocally(o), o
        }, i = async (n, s, o) => {
          let a = await jh.createPutRecord(n, o);
          return Promise.all(s.map(async c => {
            if (!Hdt(c.val, o)) {
              if (r._isSelf(c.from)) {
                try {
                  await r._putLocal(n, a)
                } catch (u) {
                  r._log.error("Failed error correcting self", u)
                }
                return
              }
              try {
                await r._putValueToPeer(n, a, c.from)
              } catch (u) {
                r._log.error("Failed error correcting entry", u)
              }
            }
          }))
        };
        return {
          async _putLocal(n, s) {
            return e(n, s)
          },
          async put(n, s, o = {}) {
            r._log("PutValue %b", n);
            let a = await jh.createPutRecord(n, s);
            await e(n, a);
            let c = 0,
              u = 0;
            await jh.mapParallel(r.getClosestPeers(n, {
              shallow: !0
            }), async h => {
              try {
                c += 1, await r._putValueToPeer(n, a, h), u += 1
              } catch (d) {
                r._log.error("Failed to put to peer (%b): %s", h.id, d)
              }
            });
            let f = o.minPeers || c;
            if (f > u) {
              let h = Wk(new Error(`Failed to put value to enough peers: ${u}/${f}`), "ERR_NOT_ENOUGH_PUT_PEERS");
              throw r._log.error(h), h
            }
          },
          async get(n, s = {}) {
            s.timeout = s.timeout || Yk.minute, r._log("_get %b", n);
            let o = await r.getMany(n, Yk.GET_MANY_RECORD_COUNT, s),
              a = o.map(f => f.val),
              c = 0;
            try {
              c = h3e.selection.bestRecord(r.selectors, n, a)
            } catch (f) {
              if (f.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY") throw f
            }
            let u = a[c];
            if (r._log("GetValue %b %s", n, u), !u) throw Wk(new Error("best value was not found"), "ERR_NOT_FOUND");
            return await i(n, o, u), u
          },
          async getMany(n, s, o = {}) {
            o.timeout = o.timeout || Yk.minute, r._log("getMany %b (%s)", n, s);
            let a = [],
              c;
            try {
              c = await t(n)
            } catch (g) {
              if (s === 0) throw g
            }
            if (c && a.push({
              val: c.value,
              from: r.peerId
            }), a.length >= s) return a;
            let u = await jh.convertBuffer(n),
              f = r.routingTable.closestPeers(u, r.kBucketSize);
            if (r._log("peers in rt: %d", f.length), f.length === 0) {
              let g = "Failed to lookup key! No peers from routing table!";
              if (r._log.error(g), a.length === 0) throw Wk(new Error(g), "ERR_NO_PEERS_IN_ROUTING_TABLE");
              return a
            }
            let h = a.length;

            function d(g, m) {
              let E = jh.pathSize(s - h, m),
                w = 0;
              async function O(q) {
                let J, Z, H;
                try {
                  let ae = await r._getValueOrPeers(q, n);
                  J = ae.record, Z = ae.peers
                } catch (ae) {
                  if (ae.code !== "ERR_INVALID_RECORD") throw ae;
                  H = ae
                }
                let te = {
                  closerPeers: Z
                };
                return J && J.value ? (a.push({
                  val: J.value,
                  from: q
                }), w++) : H && (a.push({
                  err: H,
                  from: q
                }), w++), w >= E && (te.pathComplete = !0), te
              }
              return O
            }
            let p = new Gdt(r, n, d);
            try {
              await Vdt(p.run(f), o.timeout)
            } catch (g) {
              if (a.length === 0) throw g
            } finally {
              p.stop()
            }
            return a
          }
        }
      }
    });
    var g3e = y((T7t, p3e) => {
      l();
      "use strict";
      var y3e = class {
        constructor() {
          this.list = []
        }
        push(e) {
          return this.has(e.id) ? !1 : (this.list.push(e), !0)
        }
        has(e) {
          let t = this.list.find(i => i.id.equals(e));
          return Boolean(t)
        }
        toArray() {
          return this.list.slice()
        }
        pop() {
          return this.list.pop()
        }
        get length() {
          return this.list.length
        }
      };
      p3e.exports = y3e
    });
    var v3e = y((R7t, b3e) => {
      l();
      "use strict";
      var Wdt = g3e(),
        m3e = class extends Wdt {
          constructor(e) {
            super();
            this.limit = e
          }
          push(e) {
            return this.length < this.limit ? super.push(e) : !1
          }
        };
      b3e.exports = m3e
    });
    var A3e = y((k7t, w3e) => {
      l();
      "use strict";
      var Ydt = xe(),
        _3e = jp(),
        E3e = $f(),
        S3e = v3e(),
        P4 = Ic(),
        Jdt = k4(),
        x3e = yi();
      w3e.exports = r => {
        let e = async (t, i) => {
          let n = new P4(P4.TYPES.GET_PROVIDERS, i.bytes, 0);
          return r.network.sendRequest(t, n)
        };
        return {
          async provide(t) {
            r._log(`provide: ${t}`);
            let i = [];
            await r.providers.addProvider(t, r.peerId);
            let n = r.libp2p ? r.libp2p.multiaddrs : [],
              s = new P4(P4.TYPES.ADD_PROVIDER, t.bytes, 0);
            s.providerPeers = [{
              id: r.peerId,
              multiaddrs: n
            }];
            async function o(a) {
              r._log(`putProvider ${t} to ${a.toB58String()}`);
              try {
                await r.network.sendMessage(a, s)
              } catch (c) {
                i.push(c)
              }
            }
            if (await x3e.mapParallel(r.getClosestPeers(t.bytes), o), i.length) throw Ydt(new Error(`Failed to provide to ${i.length} of ${r.kBucketSize} peers`), "ERR_SOME_PROVIDES_FAILED", {
              errors: i
            })
          },
          async *findProviders(t, i = {
            timeout: 6e4,
            maxNumProviders: 5
          }) {
            let n = i.timeout || E3e.minute,
              s = i.maxNumProviders || E3e.K;
            r._log(`findProviders ${t}`);
            let o = new S3e(s);
            if ((await r.providers.getProviders(t)).forEach(d => {
              let p = r.peerStore.get(d);
              p ? o.push({
                id: p.id,
                multiaddrs: p.addresses.map(g => g.multiaddr)
              }) : o.push({
                id: d,
                multiaddrs: []
              })
            }), o.length >= s) {
              for (let d of o.toArray()) yield d;
              return
            }
            let c = [];

            function u(d, p) {
              let g = x3e.pathSize(s - o.length, p),
                m = new S3e(g);
              c.push(m);
              async function E(w) {
                let O = await e(w, t),
                  q = O.providerPeers;
                return r._log(`Found ${q.length} provider entries for ${t}`), q.forEach(J => {
                  m.push({
                    ...J
                  })
                }), m.length >= g ? {
                  pathComplete: !0
                } : {
                    closerPeers: O.closerPeers
                  }
              }
              return E
            }
            let f = new Jdt(r, t.bytes, u),
              h = r.routingTable.closestPeers(t.bytes, r.kBucketSize);
            try {
              await _3e(f.run(h), n)
            } catch (d) {
              if (d.name !== _3e.TimeoutError.name) throw d
            } finally {
              f.stop()
            }
            c.forEach(d => {
              d.toArray().forEach(p => {
                o.push(p)
              })
            });
            for (let d of o.toArray()) yield d
          }
        }
      }
    });
    var R3e = y((P7t, I3e) => {
      l();
      "use strict";
      var sm = xe(),
        Xdt = jp(),
        Jk = Et(),
        Zdt = Ja(),
        Qdt = ct(),
        e0t = $f(),
        C4 = Ic(),
        T3e = k4(),
        om = yi();
      I3e.exports = r => {
        let e = async s => {
          r._log(`findPeerLocal ${s.toB58String()}`);
          let o = await r.routingTable.find(s),
            a = o && r.peerStore.get(o);
          if (a) return {
            id: a.id,
            multiaddrs: a.addresses.map(c => c.multiaddr)
          }
        }, t = async (s, o) => {
          let a = new C4(C4.TYPES.GET_VALUE, o, 0);
          return r.network.sendRequest(s, a)
        }, i = async (s, o) => (r._log(`closerPeersSingle ${Qdt(s, "base32")} from ${o.toB58String()}`), (await r.peerRouting._findPeerSingle(o, new Jk(s))).closerPeers.filter(c => !r._isSelf(c.id)).map(c => (r.peerStore.addressBook.add(c.id, c.multiaddrs), c))), n = async s => {
          let o = om.keyForPublicKey(s),
            a = await t(s, o);
          if (!a.record || !a.record.value) throw sm(new Error(`Node not responding with its public key: ${s.toB58String()}`), "ERR_INVALID_RECORD");
          let c = await Jk.createFromPubKey(a.record.value);
          if (!c.equals(s)) throw sm(new Error("public key does not match id"), "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
          return c.pubKey
        };
        return {
          async _findPeerSingle(s, o) {
            r._log("findPeerSingle %s", s.toB58String());
            let a = new C4(C4.TYPES.FIND_NODE, o.id, 0);
            return r.network.sendRequest(s, a)
          },
          async findPeer(s, o = {
            timeout: 6e4
          }) {
            o.timeout = o.timeout || e0t.minute, r._log("findPeer %s", s.toB58String());
            let a = await e(s);
            if (a != null) return r._log("found local"), a;
            let c = await om.convertPeerId(s),
              u = r.routingTable.closestPeers(c, r.kBucketSize);
            if (u.length === 0) throw sm(new Error("Peer lookup failed"), "ERR_LOOKUP_FAILED");
            if (u.find(m => m.isEqual(s))) {
              let m = r.peerStore.get(s);
              if (m) return r._log("found in peerStore"), {
                id: m.id,
                multiaddrs: m.addresses.map(E => E.multiaddr)
              }
            }
            let h = new T3e(r, s.id, () => async E => {
              let w = await this._findPeerSingle(E, s),
                O = w.closerPeers.find(q => q.id.isEqual(s));
              return O ? {
                peer: O,
                queryComplete: !0
              } : {
                closerPeers: w.closerPeers
              }
            }),
              d;
            try {
              d = await Xdt(h.run(u), o.timeout)
            } finally {
              h.stop()
            }
            let p = !1;
            if (d.paths.forEach(m => {
              m.success && m.peer && (p = !0, r.peerStore.addressBook.add(m.peer.id, m.peer.multiaddrs))
            }), r._log("findPeer %s: %s", s.toB58String(), p), !p) throw sm(new Error("No peer found"), "ERR_NOT_FOUND");
            let g = r.peerStore.get(s);
            if (!g) throw sm(new Error("No peer found in peer store"), "ERR_NOT_FOUND");
            return {
              id: g.id,
              multiaddrs: g.addresses.map(m => m.multiaddr)
            }
          },
          async *getClosestPeers(s, o = {
            shallow: !1
          }) {
            r._log("getClosestPeers to %b", s);
            let a = await om.convertBuffer(s),
              c = r.routingTable.closestPeers(a, r.kBucketSize),
              f = await new T3e(r, s, () => async d => ({
                closerPeers: await i(s, d),
                pathComplete: o.shallow ? !0 : void 0
              })).run(c);
            if (!f || !f.finalSet) return [];
            let h = await om.sortClosestPeers(Array.from(f.finalSet), a);
            for (let d of h.slice(0, r.kBucketSize)) yield d
          },
          async getPublicKey(s) {
            r._log("getPublicKey %s", s.toB58String());
            let o = r.peerStore.get(s);
            if (o && o.id.pubKey) return r._log("getPublicKey: found local copy"), o.id.pubKey;
            let a;
            try {
              a = await n(s)
            } catch (f) {
              let h = om.keyForPublicKey(s),
                d = await r.get(h);
              a = Zdt.keys.unmarshalPublicKey(d)
            }
            let c = new Jk(s.id, void 0, a),
              u = (o && o.addresses || []).map(f => f.multiaddr);
            return r.peerStore.addressBook.add(c, u), r.peerStore.keyBook.set(c, a), a
          }
        }
      }
    });
    var q3e = y((C7t, k3e) => {
      l();
      "use strict";
      var t0t = ky(),
        P3e = Yo(),
        r0t = Et(),
        {
          Key: i0t
        } = fr(),
        {
          default: n0t
        } = Tl(),
        am = $f(),
        cm = yi(),
        C3e = class {
          constructor(e, t, i) {
            this.datastore = e, this._log = cm.logger(t, "providers"), this.cleanupInterval = am.PROVIDERS_CLEANUP_INTERVAL, this.provideValidity = am.PROVIDERS_VALIDITY, this.lruCacheSize = i || am.PROVIDERS_LRU_CACHE_SIZE, this.providers = t0t(this.lruCacheSize), this.syncQueue = new n0t({
              concurrency: 1
            })
          }
          start() {
            this._cleaner = setInterval(() => this._cleanup(), this.cleanupInterval)
          }
          stop() {
            this._cleaner && (clearInterval(this._cleaner), this._cleaner = null)
          }
          _cleanup() {
            return this.syncQueue.add(async () => {
              this._log("start cleanup");
              let e = Date.now(),
                t = 0,
                i = 0,
                n = new Map,
                s = this.datastore.batch(),
                o = this.datastore.query({
                  prefix: am.PROVIDERS_KEY_PREFIX
                });
              for await (let a of o) try {
                let {
                  cid: c,
                  peerId: u
                } = O3e(a.key), f = N3e(a.value), h = Date.now(), d = h - f, p = d > this.provideValidity;
                if (this._log("comparing: %d - %d = %d > %d %s", h, f, d, this.provideValidity, p ? "(expired)" : ""), p) {
                  i++, s.delete(a.key);
                  let g = n.get(c) || new Set;
                  g.add(u), n.set(c, g)
                }
                t++
              } catch (c) {
                this._log.error(c.message)
              }
              this._log("deleting %d / %d entries", i, t), n.size && await s.commit();
              for (let [a, c] of n) {
                let u = um(a),
                  f = this.providers.get(u);
                if (f) {
                  for (let h of c) f.delete(h);
                  f.size === 0 ? this.providers.remove(u) : this.providers.set(u, f)
                }
              }
              this._log("Cleanup successful (%dms)", Date.now() - e)
            })
          }
          async _getProvidersMap(e) {
            let t = um(e),
              i = this.providers.get(t);
            return i || (i = await o0t(this.datastore, e), this.providers.set(t, i)), i
          }
          async addProvider(e, t) {
            return this.syncQueue.add(async () => {
              this._log("addProvider %s", e.toBaseEncodedString());
              let i = await this._getProvidersMap(e);
              this._log("loaded %s provs", i.size);
              let n = new Date;
              i.set(cm.encodeBase32(t.id), n);
              let s = um(e);
              return this.providers.set(s, i), s0t(this.datastore, e, t, n)
            })
          }
          async getProviders(e) {
            return this.syncQueue.add(async () => (this._log("getProviders %s", e.toBaseEncodedString()), [...(await this._getProvidersMap(e)).keys()].map(i => new r0t(cm.decodeBase32(i)))))
          }
        };

      function um(r) {
        return r = typeof r == "string" ? r : cm.encodeBase32(r.bytes), am.PROVIDERS_KEY_PREFIX + r
      }
      async function s0t(r, e, t, i) {
        let n = [um(e), "/", cm.encodeBase32(t.id)].join(""),
          s = new i0t(n),
          o = Uint8Array.from(P3e.encode(i.getTime()));
        return r.put(s, o)
      }

      function O3e(r) {
        let e = r.toString().split("/");
        if (e.length !== 4) throw new Error("incorrectly formatted provider entry key in datastore: " + r);
        return {
          cid: e[2],
          peerId: e[3]
        }
      }
      async function o0t(r, e) {
        let t = new Map,
          i = r.query({
            prefix: um(e)
          });
        for await (let n of i) {
          let {
            peerId: s
          } = O3e(n.key);
          t.set(s, N3e(n.value))
        }
        return t
      }

      function N3e(r) {
        return P3e.decode(r)
      }
      k3e.exports = C3e
    });
    var B3e = y((O7t, Xk) => {
      l();
      "use strict";
      var a0t = E4(),
        M3e = async (r, e, t) => a0t(new Array(r).fill(), (i, n) => e(n), t);
      Xk.exports = M3e;
      Xk.exports.default = M3e
    });
    var F3e = y((N7t, D3e) => {
      l();
      "use strict";
      var c0t = Ja(),
        u0t = cr(),
        f0t = Et(),
        {
          AbortController: l0t
        } = Zf(),
        h0t = xe(),
        d0t = B3e(),
        p0t = $f(),
        {
          logger: y0t
        } = yi(),
        L3e = class {
          constructor(e, t) {
            if (!e) throw new Error("Random Walk needs an instance of the Kademlia DHT");
            this._kadDHT = e, this._options = {
              ...p0t.defaultRandomWalk,
              ...t
            }, this.log = y0t(e.peerId, "random-walk"), this._timeoutId = void 0
          }
          start() {
            this._timeoutId || !this._options.enabled || (this._timeoutId = setTimeout(() => {
              this._runPeriodically()
            }, this._options.delay))
          }
          stop() {
            this._timeoutId && (clearTimeout(this._timeoutId), this._timeoutId = void 0), this._controller && this._controller.abort()
          }
          async _runPeriodically() {
            for (; this._timeoutId;) {
              try {
                await this._walk(this._options.queriesPerPeriod, this._options.timeout)
              } catch (e) {
                this._kadDHT._log.error("random-walk:error", e)
              }
              await new Promise(e => {
                this._timeoutId = setTimeout(e, this._options.interval)
              })
            }
          }
          async _walk(e, t) {
            this.log("start"), this._controller = new l0t;
            try {
              await d0t(e, async i => {
                this.log("running query %d", i);
                try {
                  let n = await this._randomPeerId();
                  if (!this._controller) return;
                  await this._query(n, {
                    timeout: t,
                    signal: this._controller.signal
                  })
                } catch (n) {
                  if (n && n.code !== "ETIMEDOUT") throw this.log.error("query %d finished with error", i, n), n
                }
                this.log("finished query %d", i)
              })
            } finally {
              this._controller = null, this.log("finished queries")
            }
          }
          async _query(e, t) {
            this.log("query:%s", e.toB58String());
            let i;
            try {
              i = await this._kadDHT.findPeer(e, t)
            } catch (n) {
              if (n && n.code === "ERR_NOT_FOUND") return;
              throw n
            }
            throw this.log("query:found", i), h0t(new Error(`random-walk: ACTUALLY FOUND PEER: ${i}, ${e.toB58String()}`), "ERR_FOUND_RANDOM_PEER")
          }
          async _randomPeerId() {
            let e = await u0t(c0t.randomBytes(16), "sha2-256");
            return new f0t(e)
          }
        };
      D3e.exports = L3e
    });
    var z3e = y((q7t, U3e) => {
      l();
      "use strict";
      var K3e = class {
        constructor() {
          this.queries = new Set, this.running = !1
        }
        queryStarted(e) {
          this.queries.add(e)
        }
        queryCompleted(e) {
          this.queries.delete(e)
        }
        start() {
          this.running = !0
        }
        stop() {
          this.running = !1;
          for (let e of this.queries) e.stop();
          this.queries.clear()
        }
      };
      U3e.exports = K3e
    });
    var H3e = y((M7t, Zk) => {
      l();
      "use strict";
      var {
        EventEmitter: g0t
      } = Br(), O4 = xe(), fm = Nl(), {
        MemoryDatastore: b0t
      } = fr(), j3e = Lr(), Qk = ct(), m0t = fwe(), m1 = yi(), lm = $f(), v0t = zwe(), w0t = d3e(), _0t = A3e(), E0t = R3e(), N4 = Ic(), S0t = q3e(), x0t = F3e(), A0t = z3e(), eP = fm.Record, V3e = class extends g0t {
        constructor({
          libp2p: e,
          dialer: t,
          peerId: i,
          peerStore: n,
          registrar: s,
          protocolPrefix: o = "/ipfs",
          forceProtocolLegacy: a = !1,
          datastore: c = new b0t,
          kBucketSize: u = lm.K,
          clientMode: f = !1,
          concurrency: h = lm.ALPHA,
          validators: d = {},
          selectors: p = {},
          randomWalk: g = {
            enabled: !1,
            queriesPerPeriod: 1,
            interval: 3e5,
            timeout: 3e4,
            delay: 1e4
          },
          onPut: m = () => { },
          onRemove: E = () => { }
        }) {
          super();
          if (!t) throw new Error("libp2p-kad-dht requires an instance of Dialer");
          this.libp2p = e, this.dialer = t, this.peerId = i, this.peerStore = n, this.registrar = s, this.protocol = o + (a ? "" : lm.PROTOCOL_DHT), this.kBucketSize = u, this._clientMode = f, this.concurrency = h, this.disjointPaths = Math.ceil(this.kBucketSize / 2), this.routingTable = new m0t(this.peerId, this.kBucketSize), this.datastore = c, this.providers = new S0t(this.datastore, this.peerId), this.validators = {
            pk: fm.validator.validators.pk,
            ...d
          }, this.selectors = {
            pk: fm.selection.selectors.pk,
            ...p
          }, this.network = new v0t(this), this._log = m1.logger(this.peerId), this.randomWalk = new x0t(this, g), this._queryManager = new A0t, this._running = !1, this.contentFetching = w0t(this), this.contentRouting = _0t(this), this.peerRouting = E0t(this), this.onPut = m, this.onRemove = E
        }
        get isStarted() {
          return this._running
        }
        async start() {
          this._running = !0, this.providers.start(), this._queryManager.start(), await this.network.start(), this.randomWalk.start()
        }
        stop() {
          return this._running = !1, this.randomWalk.stop(), this.providers.stop(), this._queryManager.stop(), this.network.stop()
        }
        async put(e, t, i = {}) {
          return this.contentFetching.put(e, t, i)
        }
        async get(e, t = {}) {
          return this.contentFetching.get(e, t)
        }
        async getMany(e, t, i = {}) {
          return this.contentFetching.getMany(e, t, i)
        }
        async removeLocal(e) {
          this._log(`removeLocal: ${Qk(e, "base32")}`);
          let t = m1.bufferToKey(e);
          try {
            await this.datastore.delete(t)
          } catch (i) {
            if (i.code === "ERR_NOT_FOUND") return;
            throw i
          }
        }
        async _putLocal(e, t) {
          this._log(`_putLocal: ${Qk(e, "base32")}`);
          let i = m1.bufferToKey(e);
          await this.datastore.put(i, t)
        }
        async provide(e) {
          return this.contentRouting.provide(e)
        }
        async *findProviders(e, t = {
          timeout: 6e3,
          maxNumProviders: 5
        }) {
          for await (let i of this.contentRouting.findProviders(e, t)) yield i
        }
        async findPeer(e, t = {
          timeout: 6e4
        }) {
          return this.peerRouting.findPeer(e, t)
        }
        async *getClosestPeers(e, t = {
          shallow: !1
        }) {
          yield* this.peerRouting.getClosestPeers(e, t)
        }
        getPublicKey(e) {
          return this.peerRouting.getPublicKey(e)
        }
        _peerDiscovered(e, t) {
          this.emit("peer", {
            id: e,
            multiaddrs: t
          })
        }
        async _nearestPeersToQuery(e) {
          let t = await m1.convertBuffer(e.key);
          return this.routingTable.closestPeers(t, this.kBucketSize).map(n => {
            let s = this.peerStore.get(n);
            return {
              id: n,
              multiaddrs: s ? s.addresses.map(o => o.multiaddr) : []
            }
          })
        }
        async _betterPeersToQuery(e, t) {
          return this._log("betterPeersToQuery"), (await this._nearestPeersToQuery(e)).filter(n => this._isSelf(n.id) ? (this._log.error("trying to return self as closer"), !1) : !n.id.isEqual(t))
        }
        async _checkLocalDatastore(e) {
          this._log(`checkLocalDatastore: ${Qk(e)} %b`, e);
          let t = m1.bufferToKey(e),
            i;
          try {
            i = await this.datastore.get(t)
          } catch (s) {
            if (s.code === "ERR_NOT_FOUND") return;
            throw s
          }
          let n = eP.deserialize(i);
          if (!n) throw O4(new Error("Invalid record"), "ERR_INVALID_RECORD");
          if (n.timeReceived == null || m1.now() - n.timeReceived.getTime() > lm.MAX_RECORD_AGE) {
            await this.datastore.delete(t), this.onRemove(n);
            return
          }
          return n
        }
        async _add(e) {
          await this.routingTable.add(e)
        }
        async _verifyRecordLocally(e) {
          this._log("verifyRecordLocally"), await fm.validator.verifyRecord(this.validators, e)
        }
        _isSelf(e) {
          return e && j3e(this.peerId.id, e.id)
        }
        async _putValueToPeer(e, t, i) {
          let n = new N4(N4.TYPES.PUT_VALUE, e, 0);
          n.record = eP.deserialize(t);
          let s = await this.network.sendRequest(i, n);
          if (s.record && !j3e(s.record.value, eP.deserialize(t).value)) throw O4(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID")
        }
        async _getValueOrPeers(e, t) {
          let i = await this._getValueSingle(e, t),
            n = i.closerPeers,
            s = i.record;
          if (s) {
            try {
              await this._verifyRecordOnline(s)
            } catch (o) {
              let a = "invalid record received, discarded";
              throw this._log(a), O4(new Error(a), "ERR_INVALID_RECORD")
            }
            return {
              record: s,
              peers: n
            }
          }
          if (n.length > 0) return {
            peers: n
          };
          throw O4(new Error("Not found"), "ERR_NOT_FOUND")
        }
        async _getValueSingle(e, t) {
          let i = new N4(N4.TYPES.GET_VALUE, t, 0);
          return this.network.sendRequest(e, i)
        }
        async _verifyRecordOnline(e) {
          await fm.validator.verifyRecord(this.validators, e)
        }
      };
      Zk.exports = V3e;
      Zk.exports.multicodec = "/ipfs" + lm.PROTOCOL_DHT
    });
    var W3e = y((B7t, G3e) => {
      l();
      "use strict";
      var I0t = Ege(),
        T0t = gme(),
        R0t = Bme(),
        {
          NOISE: k0t
        } = Qve(),
        P0t = H3e(),
        C0t = B7(),
        x0t = Z3e(),
        $3e = wx();
      G3e.exports = () => ({
        dialer: {
          maxParallelDials: 150,
          maxDialsPerPeer: 4,
          dialTimeout: 1e4
        },
        modules: {
          transport: [I0t, T0t],
          streamMuxer: [R0t],
          connEncryption: [k0t],
          peerDiscovery: [x0t],
          dht: P0t,
          pubsub: C0t
        },
        config: {
          peerDiscovery: {
            autoDial: !0,
            bootstrap: {
              enabled: !0
            },
            webRTCStar: {
              enabled: !0
            }
          },
          dht: {
            kBucketSize: 20,
            enabled: !1,
            clientMode: !0,
            randomWalk: {
              enabled: !1
            },
            validators: {
              ipns: $3e.validator
            },
            selectors: {
              ipns: $3e.selector
            }
          },
          pubsub: {
            enabled: !0,
            emitSelf: !0
          },
          nat: {
            enabled: !1
          }
        },
        metrics: {
          enabled: !0
        },
        peerStore: {
          persistence: !0,
          threshold: 1
        }
      })
    });
    var Z3e = y((tP, Y3e) => {
      l();
      "use strict";
      var O0t = Et(),
        {
          Multiaddr: N0t
        } = pr(),
        q0t = El(),
        {
          EventEmitter: M0t
        } = Br(),
        J3e = Oe(),
        q4 = Object.assign(J3e("libp2p:bootstrap"), {
          error: J3e("libp2p:bootstrap:error")
        }),
        X3e = class extends M0t {
          constructor(e = {
            list: []
          }) {
            if (!e.list || !e.list.length) throw new Error("Bootstrap requires a list of peer addresses");
            super();
            this._list = e.list, this._interval = e.interval || 1e4, this._timer = null
          }
          start() {
            this._timer || (this._timer = setInterval(() => this._discoverBootstrapPeers(), this._interval), q4("Starting bootstrap node discovery"), this._discoverBootstrapPeers())
          }
          _discoverBootstrapPeers() {
            !this._timer || this._list.forEach(e => {
              if (!q0t.P2P.matches(e)) return q4.error("Invalid multiaddr");
              let t = new N0t(e),
                i = t.getPeerId();
              if (!i) {
                q4.error("Invalid bootstrap multiaddr without peer id");
                return
              }
              let n = O0t.createFromB58String(i);
              try {
                this.emit("peer", {
                  id: n,
                  multiaddrs: [t]
                })
              } catch (s) {
                q4.error("Invalid bootstrap peer id", s)
              }
            })
          }
          stop() {
            this._timer && clearInterval(this._timer), this._timer = null
          }
        };
      tP = Y3e.exports = X3e;
      tP.tag = "bootstrap"
    });
    var rP = y((D7t, Q3e) => {
      l();
      "use strict";
      var hr = Qy(),
        B0t = Yr(),
        D0t = xe(),
        e_e = fle(),
        L0t = mw().version;
      Q3e.exports = ({
        options: r = {},
        peerId: e,
        multiaddrs: t = [],
        repo: i,
        keychainConfig: n = {},
        config: s = {}
      }) => {
        let {
          datastore: o,
          keys: a
        } = i, c = F0t({
          options: r,
          config: s,
          datastore: o,
          keys: a,
          keychainConfig: n,
          peerId: e,
          multiaddrs: t
        });
        return typeof r.libp2p == "function" ? r.libp2p({
          libp2pOptions: c,
          options: r,
          config: s,
          datastore: o,
          peerId: e
        }) : Aye().create(c)
      };

      function F0t({
        options: r,
        config: e,
        datastore: t,
        keys: i,
        keychainConfig: n,
        peerId: s,
        multiaddrs: o
      }) {
        let a = () => {
          let g = hr(e, "Pubsub.Router") || "gossipsub";
          if (!e_e[g]) throw D0t(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${g} router.`), "ERR_NOT_SUPPORTED");
          return e_e[g]
        },
          c = {
            datastore: t,
            peerId: s,
            modules: {}
          },
          u = {
            modules: {
              pubsub: a()
            },
            config: {
              peerDiscovery: {
                mdns: {
                  enabled: hr(r, "config.Discovery.MDNS.Enabled", hr(e, "Discovery.MDNS.Enabled", !0))
                },
                webRTCStar: {
                  enabled: hr(r, "config.Discovery.webRTCStar.Enabled", hr(e, "Discovery.webRTCStar.Enabled", !0))
                },
                bootstrap: {
                  list: hr(r, "config.Bootstrap", hr(e, "Bootstrap", []))
                }
              },
              relay: {
                enabled: hr(r, "relay.enabled", hr(e, "relay.enabled", !0)),
                hop: {
                  enabled: hr(r, "relay.hop.enabled", hr(e, "relay.hop.enabled", !1)),
                  active: hr(r, "relay.hop.active", hr(e, "relay.hop.active", !1))
                }
              },
              dht: {
                enabled: hr(e, "Routing.Type", "none") !== "none",
                clientMode: hr(e, "Routing.Type", "dht") !== "dhtserver",
                kBucketSize: hr(r, "dht.kBucketSize", 20)
              },
              pubsub: {
                enabled: hr(r, "config.Pubsub.Enabled", hr(e, "Pubsub.Enabled", !0))
              },
              nat: {
                enabled: !hr(e, "Swarm.DisableNatPortMap", !1)
              }
            },
            addresses: {
              listen: o.map(g => g.toString()),
              announce: hr(r, "addresses.announce", hr(e, "Addresses.Announce", [])),
              noAnnounce: hr(r, "addresses.noAnnounce", hr(e, "Addresses.NoAnnounce", []))
            },
            connectionManager: hr(r, "connectionManager", {
              maxConnections: hr(r, "config.Swarm.ConnMgr.HighWater", hr(e, "Swarm.ConnMgr.HighWater")),
              minConnections: hr(r, "config.Swarm.ConnMgr.LowWater", hr(e, "Swarm.ConnMgr.LowWater"))
            }),
            keychain: {
              datastore: i,
              ...n
            },
            host: {
              agentVersion: `js-ipfs/${L0t}`
            }
          },
          f = W3e(),
          h = hr(r, "libp2p", void 0);
        typeof h == "function" && (h = void 0);
        let d = B0t(c, f(), u, h);
        return hr(d, "config.peerDiscovery.bootstrap.list", []).length > 0 && d.modules.peerDiscovery.push(Z3e()), d
      }
    });
    var o_e = y((L7t, t_e) => {
      l();
      "use strict";
      var hm = Oe()("ipfs:components:peer:storage"),
        U0t = pue(),
        K0t = tw(),
        {
          ERR_REPO_NOT_INITIALIZED: z0t
        } = o_().errors,
        j0t = gt(),
        V0t = ct(),
        iP = Et(),
        {
          mergeOptions: r_e
        } = Ji(),
        H0t = rA(),
        {
          NotEnabledError: G0t
        } = of(),
        i_e = rP(),
        M4 = class {
          constructor(e, t, i, n, s) {
            this.print = n, this.peerId = e, this.keychain = t, this.repo = i, this.print = n, this.isNew = s
          }
          static async start(e, t) {
            let {
              repoAutoMigrate: i,
              repo: n
            } = t, s = typeof n == "string" || n == null ? U0t(e, {
              path: n,
              autoMigrate: Boolean(i)
            }) : n, {
              peerId: o,
              keychain: a,
              isNew: c
            } = await $0t(e, s, t);
            return new M4(o, a, s, e, c)
          }
        };
      t_e.exports = M4;
      var $0t = async (r, e, t) => {
        if (!e.closed) return {
          ...await n_e(e, t),
          isNew: !1
        };
        try {
          return await e.open(), {
            ...await n_e(e, t),
            isNew: !1
          }
        } catch (i) {
          if (i.code !== z0t) throw i;
          if (t.init && t.init.allowNew === !1) throw new G0t("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");
          return {
            ...await W0t(r, e, t),
            isNew: !0
          }
        }
      }, W0t = async (r, e, t) => {
        let i = t.init || {},
          n = await e.exists();
        if (hm("repo exists?", n), n === !0) throw new Error("repo already exists");
        let s = i.privateKey ? await Y0t(i.privateKey) : await J0t(r, i),
          o = X0t(s);
        hm("peer identity: %s", o.PeerID);
        let a = {
          ...r_e(s_e(K0t(), i.profiles), t.config),
          Identity: o
        };
        await e.init(a), await e.open(), hm("repo opened");
        let c = await i_e({
          options: void 0,
          multiaddrs: void 0,
          peerId: s,
          repo: e,
          config: a,
          keychainConfig: {
            pass: t.pass
          }
        });
        return c.keychain && c.keychain.opts && (await c.loadKeychain(), await e.config.set("Keychain", {
          dek: c.keychain.opts.dek
        })), {
          peerId: s,
          keychain: c.keychain
        }
      }, Y0t = r => (hm("using user-supplied private-key"), typeof r == "object" ? r : iP.createFromPrivKey(j0t(r, "base64pad"))), J0t = (r, {
        algorithm: e = "RSA",
        bits: t = 2048
      }) => (r("generating %s-bit (rsa only) %s keypair...", t, e), iP.create({
        keyType: e,
        bits: t
      })), X0t = r => ({
        PeerID: r.toB58String(),
        PrivKey: V0t(r.privKey.bytes, "base64pad")
      }), n_e = async (r, e) => {
        let t = e.config,
          i = e.init && e.init.profiles || [],
          n = e.pass,
          s = await r.config.getAll(),
          o = Z0t(s_e(s, i), t);
        s !== o && await r.config.replace(o);
        let a = await iP.createFromPrivKey(o.Identity.PrivKey),
          c = await i_e({
            options: void 0,
            multiaddrs: void 0,
            peerId: a,
            repo: r,
            config: o,
            keychainConfig: {
              pass: n,
              ...o.Keychain
            }
          });
        return c.keychain && await c.loadKeychain(), {
          peerId: a,
          keychain: c.keychain
        }
      }, Z0t = (r, e) => e ? r_e(r, e) : r, s_e = (r, e) => (e || []).reduce((t, i) => {
        let n = H0t.profiles[i];
        if (!n) throw new Error(`Could not find profile with name '${i}'`);
        return hm("applying profile %s", i), n.transform(t)
      }, r)
    });
    var f_e = y((F7t, a_e) => {
      l();
      a_e.exports = c_e;
      var u_e = 128,
        Q0t = 127,
        ept = ~Q0t,
        tpt = Math.pow(2, 31);

      function c_e(r, e, t) {
        e = e || [], t = t || 0;
        for (var i = t; r >= tpt;) e[t++] = r & 255 | u_e, r /= 128;
        for (; r & ept;) e[t++] = r & 255 | u_e, r >>>= 7;
        return e[t] = r | 0, c_e.bytes = t - i + 1, e
      }
    });
    var d_e = y((U7t, l_e) => {
      l();
      l_e.exports = nP;
      var rpt = 128,
        h_e = 127;

      function nP(r, e) {
        var t = 0,
          e = e || 0,
          i = 0,
          n = e,
          s, o = r.length;
        do {
          if (n >= o) throw nP.bytes = 0, new RangeError("Could not decode varint");
          s = r[n++], t += i < 28 ? (s & h_e) << i : (s & h_e) * Math.pow(2, i), i += 7
        } while (s >= rpt);
        return nP.bytes = n - e, t
      }
    });
    var y_e = y((K7t, p_e) => {
      l();
      var ipt = Math.pow(2, 7),
        npt = Math.pow(2, 14),
        spt = Math.pow(2, 21),
        opt = Math.pow(2, 28),
        apt = Math.pow(2, 35),
        cpt = Math.pow(2, 42),
        upt = Math.pow(2, 49),
        fpt = Math.pow(2, 56),
        lpt = Math.pow(2, 63);
      p_e.exports = function (r) {
        return r < ipt ? 1 : r < npt ? 2 : r < spt ? 3 : r < opt ? 4 : r < apt ? 5 : r < cpt ? 6 : r < upt ? 7 : r < fpt ? 8 : r < lpt ? 9 : 10
      }
    });
    var b_e = y((z7t, g_e) => {
      l();
      g_e.exports = {
        encode: f_e(),
        decode: d_e(),
        encodingLength: y_e()
      }
    });
    var w_e = y((j7t, m_e) => {
      l();
      "use strict";
      var v_e = b_e();
      m_e.exports = r => {
        if (!(r instanceof Uint8Array)) throw new Error("arg needs to be a Uint8Array");
        let e = [];
        for (; r.length > 0;) {
          let t = v_e.decode(r);
          e.push(t), r = r.slice(v_e.decode.bytes)
        }
        return e
      }
    });
    var ku = y((V7t, __e) => {
      l();
      "use strict";
      var E_e = Oe(),
        hpt = Lr(),
        dpt = (r, e) => {
          let t = ["bitswap"];
          return e && t.push(e), r && t.push(`${r.toB58String().slice(0, 8)}`), Object.assign(E_e(t.join(":")), {
            error: E_e(t.concat(["error"]).join(":"))
          })
        },
        sP = (r, e, t) => {
          let i = 0,
            n = t.length;
          for (; i < n;) {
            if (r(e, t[i])) return !0;
            i += 1
          }
          return !1
        },
        ppt = (r, e) => {
          let t = 0,
            i = e.length,
            n = [],
            s;
          for (; t < i;) s = e[t], sP(r, s, n) || (n[n.length] = s), t += 1;
          return n
        },
        ypt = (r, e) => e.reduce((t, i) => {
          let n = r(i);
          return t[n] ? t[n].push(i) : t[n] = [i], t
        }, {}),
        gpt = (r, e, t) => e.filter(i => !sP(r, i, t)),
        bpt = (r, e) => Array.prototype.slice.call(e, 0).sort((t, i) => {
          let n = r(t),
            s = r(i);
          return n < s ? -1 : n > s ? 1 : 0
        }),
        mpt = (r, e) => {
          if (r.size !== e.size) return !1;
          for (let [t, i] of r) {
            let n = e.get(t);
            if (n === void 0 || typeof i.equals == "function" && !i.equals(n) || i.data && !(n.data && hpt(i.data, n.data))) return !1
          }
          return !0
        };
      __e.exports = {
        logger: dpt,
        includesWith: sP,
        uniqWith: ppt,
        groupBy: ypt,
        pullAllWith: gpt,
        sortBy: bpt,
        isMapEqual: mpt
      }
    });
    var x_e = y((H7t, S_e) => {
      l();
      "use strict";
      var Tc = bi(),
        Rc = Tc.Reader,
        dm = Tc.Writer,
        ir = Tc.util,
        Ut = Tc.roots["ipfs-bitswap"] || (Tc.roots["ipfs-bitswap"] = {});
      Ut.Message = function () {
        function r(e) {
          if (this.blocks = [], this.payload = [], this.blockPresences = [], e)
            for (var t = Object.keys(e), i = 0; i < t.length; ++i) e[t[i]] != null && (this[t[i]] = e[t[i]])
        }
        return r.prototype.wantlist = null, r.prototype.blocks = ir.emptyArray, r.prototype.payload = ir.emptyArray, r.prototype.blockPresences = ir.emptyArray, r.prototype.pendingBytes = 0, r.encode = function (t, i) {
          if (i || (i = dm.create()), t.wantlist != null && Object.hasOwnProperty.call(t, "wantlist") && Ut.Message.Wantlist.encode(t.wantlist, i.uint32(10).fork()).ldelim(), t.blocks != null && t.blocks.length)
            for (var n = 0; n < t.blocks.length; ++n) i.uint32(18).bytes(t.blocks[n]);
          if (t.payload != null && t.payload.length)
            for (var n = 0; n < t.payload.length; ++n) Ut.Message.Block.encode(t.payload[n], i.uint32(26).fork()).ldelim();
          if (t.blockPresences != null && t.blockPresences.length)
            for (var n = 0; n < t.blockPresences.length; ++n) Ut.Message.BlockPresence.encode(t.blockPresences[n], i.uint32(34).fork()).ldelim();
          return t.pendingBytes != null && Object.hasOwnProperty.call(t, "pendingBytes") && i.uint32(40).int32(t.pendingBytes), i
        }, r.decode = function (t, i) {
          t instanceof Rc || (t = Rc.create(t));
          for (var n = i === void 0 ? t.len : t.pos + i, s = new Ut.Message; t.pos < n;) {
            var o = t.uint32();
            switch (o >>> 3) {
              case 1:
                s.wantlist = Ut.Message.Wantlist.decode(t, t.uint32());
                break;
              case 2:
                s.blocks && s.blocks.length || (s.blocks = []), s.blocks.push(t.bytes());
                break;
              case 3:
                s.payload && s.payload.length || (s.payload = []), s.payload.push(Ut.Message.Block.decode(t, t.uint32()));
                break;
              case 4:
                s.blockPresences && s.blockPresences.length || (s.blockPresences = []), s.blockPresences.push(Ut.Message.BlockPresence.decode(t, t.uint32()));
                break;
              case 5:
                s.pendingBytes = t.int32();
                break;
              default:
                t.skipType(o & 7);
                break
            }
          }
          return s
        }, r.fromObject = function (t) {
          if (t instanceof Ut.Message) return t;
          var i = new Ut.Message;
          if (t.wantlist != null) {
            if (typeof t.wantlist != "object") throw TypeError(".Message.wantlist: object expected");
            i.wantlist = Ut.Message.Wantlist.fromObject(t.wantlist)
          }
          if (t.blocks) {
            if (!Array.isArray(t.blocks)) throw TypeError(".Message.blocks: array expected");
            i.blocks = [];
            for (var n = 0; n < t.blocks.length; ++n) typeof t.blocks[n] == "string" ? ir.base64.decode(t.blocks[n], i.blocks[n] = ir.newBuffer(ir.base64.length(t.blocks[n])), 0) : t.blocks[n].length && (i.blocks[n] = t.blocks[n])
          }
          if (t.payload) {
            if (!Array.isArray(t.payload)) throw TypeError(".Message.payload: array expected");
            i.payload = [];
            for (var n = 0; n < t.payload.length; ++n) {
              if (typeof t.payload[n] != "object") throw TypeError(".Message.payload: object expected");
              i.payload[n] = Ut.Message.Block.fromObject(t.payload[n])
            }
          }
          if (t.blockPresences) {
            if (!Array.isArray(t.blockPresences)) throw TypeError(".Message.blockPresences: array expected");
            i.blockPresences = [];
            for (var n = 0; n < t.blockPresences.length; ++n) {
              if (typeof t.blockPresences[n] != "object") throw TypeError(".Message.blockPresences: object expected");
              i.blockPresences[n] = Ut.Message.BlockPresence.fromObject(t.blockPresences[n])
            }
          }
          return t.pendingBytes != null && (i.pendingBytes = t.pendingBytes | 0), i
        }, r.toObject = function (t, i) {
          i || (i = {});
          var n = {};
          if ((i.arrays || i.defaults) && (n.blocks = [], n.payload = [], n.blockPresences = []), i.defaults && (n.wantlist = null, n.pendingBytes = 0), t.wantlist != null && t.hasOwnProperty("wantlist") && (n.wantlist = Ut.Message.Wantlist.toObject(t.wantlist, i)), t.blocks && t.blocks.length) {
            n.blocks = [];
            for (var s = 0; s < t.blocks.length; ++s) n.blocks[s] = i.bytes === String ? ir.base64.encode(t.blocks[s], 0, t.blocks[s].length) : i.bytes === Array ? Array.prototype.slice.call(t.blocks[s]) : t.blocks[s]
          }
          if (t.payload && t.payload.length) {
            n.payload = [];
            for (var s = 0; s < t.payload.length; ++s) n.payload[s] = Ut.Message.Block.toObject(t.payload[s], i)
          }
          if (t.blockPresences && t.blockPresences.length) {
            n.blockPresences = [];
            for (var s = 0; s < t.blockPresences.length; ++s) n.blockPresences[s] = Ut.Message.BlockPresence.toObject(t.blockPresences[s], i)
          }
          return t.pendingBytes != null && t.hasOwnProperty("pendingBytes") && (n.pendingBytes = t.pendingBytes), n
        }, r.prototype.toJSON = function () {
          return this.constructor.toObject(this, Tc.util.toJSONOptions)
        }, r.Wantlist = function () {
          function e(t) {
            if (this.entries = [], t)
              for (var i = Object.keys(t), n = 0; n < i.length; ++n) t[i[n]] != null && (this[i[n]] = t[i[n]])
          }
          return e.prototype.entries = ir.emptyArray, e.prototype.full = !1, e.encode = function (i, n) {
            if (n || (n = dm.create()), i.entries != null && i.entries.length)
              for (var s = 0; s < i.entries.length; ++s) Ut.Message.Wantlist.Entry.encode(i.entries[s], n.uint32(10).fork()).ldelim();
            return i.full != null && Object.hasOwnProperty.call(i, "full") && n.uint32(16).bool(i.full), n
          }, e.decode = function (i, n) {
            i instanceof Rc || (i = Rc.create(i));
            for (var s = n === void 0 ? i.len : i.pos + n, o = new Ut.Message.Wantlist; i.pos < s;) {
              var a = i.uint32();
              switch (a >>> 3) {
                case 1:
                  o.entries && o.entries.length || (o.entries = []), o.entries.push(Ut.Message.Wantlist.Entry.decode(i, i.uint32()));
                  break;
                case 2:
                  o.full = i.bool();
                  break;
                default:
                  i.skipType(a & 7);
                  break
              }
            }
            return o
          }, e.fromObject = function (i) {
            if (i instanceof Ut.Message.Wantlist) return i;
            var n = new Ut.Message.Wantlist;
            if (i.entries) {
              if (!Array.isArray(i.entries)) throw TypeError(".Message.Wantlist.entries: array expected");
              n.entries = [];
              for (var s = 0; s < i.entries.length; ++s) {
                if (typeof i.entries[s] != "object") throw TypeError(".Message.Wantlist.entries: object expected");
                n.entries[s] = Ut.Message.Wantlist.Entry.fromObject(i.entries[s])
              }
            }
            return i.full != null && (n.full = Boolean(i.full)), n
          }, e.toObject = function (i, n) {
            n || (n = {});
            var s = {};
            if ((n.arrays || n.defaults) && (s.entries = []), n.defaults && (s.full = !1), i.entries && i.entries.length) {
              s.entries = [];
              for (var o = 0; o < i.entries.length; ++o) s.entries[o] = Ut.Message.Wantlist.Entry.toObject(i.entries[o], n)
            }
            return i.full != null && i.hasOwnProperty("full") && (s.full = i.full), s
          }, e.prototype.toJSON = function () {
            return this.constructor.toObject(this, Tc.util.toJSONOptions)
          }, e.WantType = function () {
            var t = {},
              i = Object.create(t);
            return i[t[0] = "Block"] = 0, i[t[1] = "Have"] = 1, i
          }(), e.Entry = function () {
            function t(i) {
              if (i)
                for (var n = Object.keys(i), s = 0; s < n.length; ++s) i[n[s]] != null && (this[n[s]] = i[n[s]])
            }
            return t.prototype.block = ir.newBuffer([]), t.prototype.priority = 0, t.prototype.cancel = !1, t.prototype.wantType = 0, t.prototype.sendDontHave = !1, t.encode = function (n, s) {
              return s || (s = dm.create()), n.block != null && Object.hasOwnProperty.call(n, "block") && s.uint32(10).bytes(n.block), n.priority != null && Object.hasOwnProperty.call(n, "priority") && s.uint32(16).int32(n.priority), n.cancel != null && Object.hasOwnProperty.call(n, "cancel") && s.uint32(24).bool(n.cancel), n.wantType != null && Object.hasOwnProperty.call(n, "wantType") && s.uint32(32).int32(n.wantType), n.sendDontHave != null && Object.hasOwnProperty.call(n, "sendDontHave") && s.uint32(40).bool(n.sendDontHave), s
            }, t.decode = function (n, s) {
              n instanceof Rc || (n = Rc.create(n));
              for (var o = s === void 0 ? n.len : n.pos + s, a = new Ut.Message.Wantlist.Entry; n.pos < o;) {
                var c = n.uint32();
                switch (c >>> 3) {
                  case 1:
                    a.block = n.bytes();
                    break;
                  case 2:
                    a.priority = n.int32();
                    break;
                  case 3:
                    a.cancel = n.bool();
                    break;
                  case 4:
                    a.wantType = n.int32();
                    break;
                  case 5:
                    a.sendDontHave = n.bool();
                    break;
                  default:
                    n.skipType(c & 7);
                    break
                }
              }
              return a
            }, t.fromObject = function (n) {
              if (n instanceof Ut.Message.Wantlist.Entry) return n;
              var s = new Ut.Message.Wantlist.Entry;
              switch (n.block != null && (typeof n.block == "string" ? ir.base64.decode(n.block, s.block = ir.newBuffer(ir.base64.length(n.block)), 0) : n.block.length && (s.block = n.block)), n.priority != null && (s.priority = n.priority | 0), n.cancel != null && (s.cancel = Boolean(n.cancel)), n.wantType) {
                case "Block":
                case 0:
                  s.wantType = 0;
                  break;
                case "Have":
                case 1:
                  s.wantType = 1;
                  break
              }
              return n.sendDontHave != null && (s.sendDontHave = Boolean(n.sendDontHave)), s
            }, t.toObject = function (n, s) {
              s || (s = {});
              var o = {};
              return s.defaults && (s.bytes === String ? o.block = "" : (o.block = [], s.bytes !== Array && (o.block = ir.newBuffer(o.block))), o.priority = 0, o.cancel = !1, o.wantType = s.enums === String ? "Block" : 0, o.sendDontHave = !1), n.block != null && n.hasOwnProperty("block") && (o.block = s.bytes === String ? ir.base64.encode(n.block, 0, n.block.length) : s.bytes === Array ? Array.prototype.slice.call(n.block) : n.block), n.priority != null && n.hasOwnProperty("priority") && (o.priority = n.priority), n.cancel != null && n.hasOwnProperty("cancel") && (o.cancel = n.cancel), n.wantType != null && n.hasOwnProperty("wantType") && (o.wantType = s.enums === String ? Ut.Message.Wantlist.WantType[n.wantType] : n.wantType), n.sendDontHave != null && n.hasOwnProperty("sendDontHave") && (o.sendDontHave = n.sendDontHave), o
            }, t.prototype.toJSON = function () {
              return this.constructor.toObject(this, Tc.util.toJSONOptions)
            }, t
          }(), e
        }(), r.Block = function () {
          function e(t) {
            if (t)
              for (var i = Object.keys(t), n = 0; n < i.length; ++n) t[i[n]] != null && (this[i[n]] = t[i[n]])
          }
          return e.prototype.prefix = ir.newBuffer([]), e.prototype.data = ir.newBuffer([]), e.encode = function (i, n) {
            return n || (n = dm.create()), i.prefix != null && Object.hasOwnProperty.call(i, "prefix") && n.uint32(10).bytes(i.prefix), i.data != null && Object.hasOwnProperty.call(i, "data") && n.uint32(18).bytes(i.data), n
          }, e.decode = function (i, n) {
            i instanceof Rc || (i = Rc.create(i));
            for (var s = n === void 0 ? i.len : i.pos + n, o = new Ut.Message.Block; i.pos < s;) {
              var a = i.uint32();
              switch (a >>> 3) {
                case 1:
                  o.prefix = i.bytes();
                  break;
                case 2:
                  o.data = i.bytes();
                  break;
                default:
                  i.skipType(a & 7);
                  break
              }
            }
            return o
          }, e.fromObject = function (i) {
            if (i instanceof Ut.Message.Block) return i;
            var n = new Ut.Message.Block;
            return i.prefix != null && (typeof i.prefix == "string" ? ir.base64.decode(i.prefix, n.prefix = ir.newBuffer(ir.base64.length(i.prefix)), 0) : i.prefix.length && (n.prefix = i.prefix)), i.data != null && (typeof i.data == "string" ? ir.base64.decode(i.data, n.data = ir.newBuffer(ir.base64.length(i.data)), 0) : i.data.length && (n.data = i.data)), n
          }, e.toObject = function (i, n) {
            n || (n = {});
            var s = {};
            return n.defaults && (n.bytes === String ? s.prefix = "" : (s.prefix = [], n.bytes !== Array && (s.prefix = ir.newBuffer(s.prefix))), n.bytes === String ? s.data = "" : (s.data = [], n.bytes !== Array && (s.data = ir.newBuffer(s.data)))), i.prefix != null && i.hasOwnProperty("prefix") && (s.prefix = n.bytes === String ? ir.base64.encode(i.prefix, 0, i.prefix.length) : n.bytes === Array ? Array.prototype.slice.call(i.prefix) : i.prefix), i.data != null && i.hasOwnProperty("data") && (s.data = n.bytes === String ? ir.base64.encode(i.data, 0, i.data.length) : n.bytes === Array ? Array.prototype.slice.call(i.data) : i.data), s
          }, e.prototype.toJSON = function () {
            return this.constructor.toObject(this, Tc.util.toJSONOptions)
          }, e
        }(), r.BlockPresenceType = function () {
          var e = {},
            t = Object.create(e);
          return t[e[0] = "Have"] = 0, t[e[1] = "DontHave"] = 1, t
        }(), r.BlockPresence = function () {
          function e(t) {
            if (t)
              for (var i = Object.keys(t), n = 0; n < i.length; ++n) t[i[n]] != null && (this[i[n]] = t[i[n]])
          }
          return e.prototype.cid = ir.newBuffer([]), e.prototype.type = 0, e.encode = function (i, n) {
            return n || (n = dm.create()), i.cid != null && Object.hasOwnProperty.call(i, "cid") && n.uint32(10).bytes(i.cid), i.type != null && Object.hasOwnProperty.call(i, "type") && n.uint32(16).int32(i.type), n
          }, e.decode = function (i, n) {
            i instanceof Rc || (i = Rc.create(i));
            for (var s = n === void 0 ? i.len : i.pos + n, o = new Ut.Message.BlockPresence; i.pos < s;) {
              var a = i.uint32();
              switch (a >>> 3) {
                case 1:
                  o.cid = i.bytes();
                  break;
                case 2:
                  o.type = i.int32();
                  break;
                default:
                  i.skipType(a & 7);
                  break
              }
            }
            return o
          }, e.fromObject = function (i) {
            if (i instanceof Ut.Message.BlockPresence) return i;
            var n = new Ut.Message.BlockPresence;
            switch (i.cid != null && (typeof i.cid == "string" ? ir.base64.decode(i.cid, n.cid = ir.newBuffer(ir.base64.length(i.cid)), 0) : i.cid.length && (n.cid = i.cid)), i.type) {
              case "Have":
              case 0:
                n.type = 0;
                break;
              case "DontHave":
              case 1:
                n.type = 1;
                break
            }
            return n
          }, e.toObject = function (i, n) {
            n || (n = {});
            var s = {};
            return n.defaults && (n.bytes === String ? s.cid = "" : (s.cid = [], n.bytes !== Array && (s.cid = ir.newBuffer(s.cid))), s.type = n.enums === String ? "Have" : 0), i.cid != null && i.hasOwnProperty("cid") && (s.cid = n.bytes === String ? ir.base64.encode(i.cid, 0, i.cid.length) : n.bytes === Array ? Array.prototype.slice.call(i.cid) : i.cid), i.type != null && i.hasOwnProperty("type") && (s.type = n.enums === String ? Ut.Message.BlockPresenceType[i.type] : i.type), s
          }, e.prototype.toJSON = function () {
            return this.constructor.toObject(this, Tc.util.toJSONOptions)
          }, e
        }(), r
      }();
      S_e.exports = Ut
    });
    var T_e = y((G7t, A_e) => {
      l();
      "use strict";
      var I_e = class {
        constructor(e, t, i) {
          this._refCounter = 1, this.cid = e, this.priority = t || 1, this.wantType = i
        }
        inc() {
          this._refCounter += 1
        }
        dec() {
          this._refCounter = Math.max(0, this._refCounter - 1)
        }
        hasRefs() {
          return this._refCounter > 0
        }
        get [Symbol.toStringTag]() {
          return `WantlistEntry <key: ${this.cid.toString("base58btc")}, priority: ${this.priority}, refs: ${this._refCounter}>`
        }
        equals(e) {
          return this._refCounter === e._refCounter && this.cid.equals(e.cid) && this.priority === e.priority && this.wantType === e.wantType
        }
      };
      A_e.exports = I_e
    });
    var pm = y(($7t, R_e) => {
      l();
      "use strict";
      var {
        sortBy: vpt
      } = ku(), k_e = T_e(), oP = class {
        constructor(e) {
          this.set = new Map, this._stats = e
        }
        get length() {
          return this.set.size
        }
        add(e, t, i) {
          let n = v1(),
            s = e.toString("base58btc"),
            o = this.set.get(s);
          o ? (o.inc(), o.priority = t, o.wantType === n.WantType.Have && i === n.WantType.Block && (o.wantType = i)) : (this.set.set(s, new k_e(e, t, i)), this._stats && this._stats.push(null, "wantListSize", 1))
        }
        remove(e) {
          let t = e.toString("base58btc"),
            i = this.set.get(t);
          !i || (i.dec(), !i.hasRefs() && (this.set.delete(t), this._stats && this._stats.push(null, "wantListSize", -1)))
        }
        removeForce(e) {
          this.set.has(e) && this.set.delete(e)
        }
        forEach(e) {
          return this.set.forEach(e)
        }
        entries() {
          return this.set.entries()
        }
        sortedEntries() {
          return new Map(vpt(e => e[1].key, Array.from(this.set.entries())))
        }
        contains(e) {
          let t = e.toString("base58btc");
          return this.set.get(t)
        }
      };
      oP.Entry = k_e;
      R_e.exports = oP
    });
    var C_e = y((Y7t, P_e) => {
      l();
      "use strict";
      var wpt = pm().Entry;
      P_e.exports = class {
        constructor(e, t, i, n, s) {
          this.entry = new wpt(e, t, i), this.cancel = Boolean(n), this.sendDontHave = Boolean(s)
        }
        get cid() {
          return this.entry.cid
        }
        set cid(e) {
          this.entry.cid = e
        }
        get priority() {
          return this.entry.priority
        }
        set priority(e) {
          this.entry.priority = e
        }
        get wantType() {
          return this.entry.wantType
        }
        set wantType(e) {
          this.entry.wantType = e
        }
        get [Symbol.toStringTag]() {
          return `BitswapMessageEntry ${this.cid.toString("base58btc")} <cancel: ${this.cancel}, priority: ${this.priority}>`
        }
        equals(e) {
          return this.cancel === e.cancel && this.sendDontHave === e.sendDontHave && this.wantType === e.wantType && this.entry.equals(e.entry)
        }
      }
    });
    var v1 = y((J7t, O_e) => {
      l();
      "use strict";
      var N_e = ql(),
        ym = at(),
        {
          getName: _pt
        } = Jr(),
        Ept = w_e(),
        q_e = cr(),
        {
          isMapEqual: aP
        } = ku(),
        {
          Message: Pu
        } = x_e(),
        M_e = C_e(),
        Mn = class {
          constructor(e) {
            this.full = e, this.wantlist = new Map, this.blocks = new Map, this.blockPresences = new Map, this.pendingBytes = 0
          }
          get empty() {
            return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0
          }
          addEntry(e, t, i, n, s) {
            i == null && (i = Mn.WantType.Block);
            let o = e.toString("base58btc"),
              a = this.wantlist.get(o);
            a ? (a.wantType === i && (a.priority = t), n && (a.cancel = Boolean(n)), s && (a.sendDontHave = Boolean(s)), i === Mn.WantType.Block && a.wantType === Mn.WantType.Have && (a.wantType = i)) : this.wantlist.set(o, new M_e(e, t, i, n, s))
          }
          addBlock(e) {
            let t = e.cid.toString("base58btc");
            this.blocks.set(t, e)
          }
          addHave(e) {
            let t = e.toString("base58btc");
            this.blockPresences.has(t) || this.blockPresences.set(t, Mn.BlockPresenceType.Have)
          }
          addDontHave(e) {
            let t = e.toString("base58btc");
            this.blockPresences.has(t) || this.blockPresences.set(t, Mn.BlockPresenceType.DontHave)
          }
          cancel(e) {
            let t = e.toString("base58btc");
            this.wantlist.delete(t), this.addEntry(e, 0, Mn.WantType.Block, !0, !1)
          }
          setPendingBytes(e) {
            this.pendingBytes = e
          }
          serializeToBitswap100() {
            let e = {
              wantlist: {
                entries: Array.from(this.wantlist.values()).map(t => ({
                  block: t.cid.bytes,
                  priority: Number(t.priority),
                  cancel: Boolean(t.cancel)
                })),
                full: this.full ? !0 : void 0
              },
              blocks: Array.from(this.blocks.values()).map(t => t.data)
            };
            return Pu.encode(e).finish()
          }
          serializeToBitswap110() {
            let e = {
              wantlist: {
                entries: Array.from(this.wantlist.values()).map(t => ({
                  block: t.cid.bytes,
                  priority: Number(t.priority),
                  wantType: t.wantType,
                  cancel: Boolean(t.cancel),
                  sendDontHave: Boolean(t.sendDontHave)
                })),
                full: this.full ? !0 : void 0
              },
              blockPresences: [],
              payload: [],
              pendingBytes: this.pendingBytes
            };
            this.blocks.forEach(t => {
              e.payload.push(new Pu.Block({
                prefix: t.cid.prefix,
                data: t.data
              }))
            });
            for (let [t, i] of this.blockPresences) e.blockPresences.push(new Pu.BlockPresence({
              cid: new ym(t).bytes,
              type: i
            }));
            return this.pendingBytes > 0 && (e.pendingBytes = this.pendingBytes), Pu.encode(e).finish()
          }
          equals(e) {
            return !(this.full !== e.full || this.pendingBytes !== e.pendingBytes || !aP(this.wantlist, e.wantlist) || !aP(this.blocks, e.blocks) || !aP(this.blockPresences, e.blockPresences))
          }
          get [Symbol.toStringTag]() {
            let e = Array.from(this.wantlist.keys()),
              t = Array.from(this.blocks.keys());
            return `BitswapMessage <full: ${this.full}, list: ${e}, blocks: ${t}>`
          }
        };
      Mn.deserialize = async r => {
        let e = Pu.decode(r),
          t = e.wantlist && e.wantlist.full || !1,
          i = new Mn(t);
        return e.wantlist && e.wantlist.entries && e.wantlist.entries.forEach(n => {
          if (!n.block) return;
          let s = new ym(n.block);
          i.addEntry(s, n.priority || 0, n.wantType, Boolean(n.cancel), Boolean(n.sendDontHave))
        }), e.blockPresences && e.blockPresences.forEach(n => {
          if (!n.cid) return;
          let s = new ym(n.cid);
          n.type === Mn.BlockPresenceType.Have ? i.addHave(s) : i.addDontHave(s)
        }), e.blocks.length > 0 ? (await Promise.all(e.blocks.map(async n => {
          let s = await q_e(n, "sha2-256"),
            o = new ym(s);
          i.addBlock(new N_e(n, o))
        })), i) : (e.payload.length > 0 && (await Promise.all(e.payload.map(async n => {
          if (!n.prefix || !n.data) return;
          let s = Ept(n.prefix),
            o = s[0],
            a = s[1],
            c = s[2],
            u = await q_e(n.data, c),
            f = new ym(o, _pt(a), u);
          i.addBlock(new N_e(n.data, f))
        })), i.setPendingBytes(e.pendingBytes)), i)
      };
      Mn.blockPresenceSize = r => r.bytes.length + 1;
      Mn.Entry = M_e;
      Mn.WantType = {
        Block: Pu.Wantlist.WantType.Block,
        Have: Pu.Wantlist.WantType.Have
      };
      Mn.BlockPresenceType = {
        Have: Pu.BlockPresenceType.Have,
        DontHave: Pu.BlockPresenceType.DontHave
      };
      O_e.exports = Mn
    });
    var gm = y((X7t, B_e) => {
      l();
      "use strict";
      var cP = 1e3;
      B_e.exports = {
        maxProvidersPerRequest: 3,
        providerRequestTimeout: 10 * cP,
        hasBlockTimeout: 15 * cP,
        provideTimeout: 15 * cP,
        kMaxPriority: Math.pow(2, 31) - 1,
        maxListeners: 1e3,
        wantlistSendDebounceMs: 1
      }
    });
    var L_e = y((Z7t, D_e) => {
      l();
      D_e.exports = Spt;

      function Spt(r, e, t) {
        var i = null,
          n = null,
          s = function () {
            i && (clearTimeout(i), n = null, i = null)
          },
          o = function () {
            var c = n;
            s(), c && c()
          },
          a = function () {
            if (!e) return r.apply(this, arguments);
            var c = this,
              u = arguments,
              f = t && !i;
            if (s(), n = function () {
              r.apply(c, u)
            }, i = setTimeout(function () {
              if (i = null, !f) {
                var h = n;
                return n = null, h()
              }
            }, e), f) return n()
          };
        return a.cancel = s, a.flush = o, a
      }
    });
    var U_e = y((eRt, F_e) => {
      l();
      "use strict";
      var xpt = L_e(),
        Apt = v1(),
        Ipt = ku().logger,
        {
          wantlistSendDebounceMs: Tpt
        } = gm();
      F_e.exports = class {
        constructor(e, t, i) {
          this.peerId = t, this.network = i, this.refcnt = 1, this._entries = [], this._log = Ipt(e, "msgqueue"), this.sendEntries = xpt(this._sendEntries.bind(this), Tpt)
        }
        addMessage(e) {
          e.empty || this.send(e)
        }
        addEntries(e) {
          this._entries = this._entries.concat(e), this.sendEntries()
        }
        _sendEntries() {
          if (!this._entries.length) return;
          let e = new Apt(!1);
          this._entries.forEach(t => {
            t.cancel ? e.cancel(t.cid) : e.addEntry(t.cid, t.priority)
          }), this._entries = [], this.addMessage(e)
        }
        async send(e) {
          try {
            await this.network.connectTo(this.peerId)
          } catch (t) {
            this._log.error("cant connect to peer %s: %s", this.peerId.toB58String(), t.message);
            return
          }
          this._log("sending message to peer %s", this.peerId.toB58String()), this.network.sendMessage(this.peerId, e).catch(t => {
            this._log.error("send error: %s", t.message)
          })
        }
      }
    });
    var z_e = y((rRt, K_e) => {
      l();
      "use strict";
      var uP = v1(),
        Rpt = pm(),
        kpt = gm(),
        Ppt = U_e(),
        Cpt = ku().logger;
      K_e.exports = class {
        constructor(e, t, i) {
          this.peers = new Map, this.wantlist = new Rpt(i), this.network = t, this._stats = i, this._peerId = e, this._log = Cpt(e, "want")
        }
        _addEntries(e, t, i) {
          let n = e.map((s, o) => new uP.Entry(s, kpt.kMaxPriority - o, uP.WantType.Block, t));
          n.forEach(s => {
            s.cancel ? i ? this.wantlist.removeForce(s.cid.toString()) : this.wantlist.remove(s.cid) : (this._log("adding to wl"), this.wantlist.add(s.cid, s.priority))
          });
          for (let s of this.peers.values()) s.addEntries(n)
        }
        _startPeerHandler(e) {
          let t = this.peers.get(e.toB58String());
          if (t) {
            t.refcnt++;
            return
          }
          t = new Ppt(this._peerId, e, this.network);
          let i = new uP(!0);
          for (let n of this.wantlist.entries()) i.addEntry(n[1].cid, n[1].priority);
          return t.addMessage(i), this.peers.set(e.toB58String(), t), t
        }
        _stopPeerHandler(e) {
          let t = this.peers.get(e.toB58String());
          !t || (t.refcnt--, !(t.refcnt > 0) && this.peers.delete(e.toB58String()))
        }
        wantBlocks(e, t = {}) {
          this._addEntries(e, !1), t && t.signal && t.signal.addEventListener("abort", () => {
            this.cancelWants(e)
          })
        }
        unwantBlocks(e) {
          this._log("unwant blocks: %s", e.length), this._addEntries(e, !0, !0)
        }
        cancelWants(e) {
          this._log("cancel wants: %s", e.length), this._addEntries(e, !0)
        }
        connectedPeers() {
          return Array.from(this.peers.keys())
        }
        connected(e) {
          this._startPeerHandler(e)
        }
        disconnected(e) {
          this._stopPeerHandler(e)
        }
        start() { }
        stop() {
          this.peers.forEach(e => this.disconnected(e.peerId))
        }
      }
    });
    var W_e = y((iRt, j_e) => {
      l();
      "use strict";
      var V_e = da(),
        {
          pipe: H_e
        } = vi(),
        Opt = b_(),
        Npt = v1(),
        G_e = gm(),
        qpt = ku().logger,
        fP = "/ipfs/bitswap/1.0.0",
        lP = "/ipfs/bitswap/1.1.0",
        hP = "/ipfs/bitswap/1.2.0",
        $_e = class {
          constructor(e, t, i, n = {}) {
            this._log = qpt(e.peerId, "network"), this._libp2p = e, this._bitswap = t, this._protocols = [fP], n.b100Only || (this._protocols.unshift(lP), this._protocols.unshift(hP)), this._stats = i, this._running = !1, this._onPeerConnect = this._onPeerConnect.bind(this), this._onPeerDisconnect = this._onPeerDisconnect.bind(this), this._onConnection = this._onConnection.bind(this)
          }
          start() {
            this._running = !0, this._libp2p.handle(this._protocols, this._onConnection);
            let e = new Opt({
              multicodecs: this._protocols,
              handlers: {
                onConnect: this._onPeerConnect,
                onDisconnect: this._onPeerDisconnect
              }
            });
            this._registrarId = this._libp2p.registrar.register(e);
            for (let t of this._libp2p.peerStore.peers.values()) {
              let i = this._libp2p.connectionManager.get(t.id);
              i && this._onPeerConnect(i.remotePeer)
            }
          }
          stop() {
            this._running = !1, this._libp2p.unhandle(this._protocols), this._registrarId != null && this._libp2p.registrar.unregister(this._registrarId)
          }
          async _onConnection({
            protocol: e,
            stream: t,
            connection: i
          }) {
            if (!!this._running) {
              this._log("incoming new bitswap %s connection from %s", e, i.remotePeer.toB58String());
              try {
                await H_e(t, V_e.decode(), async n => {
                  for await (let s of n) try {
                    let o = await Npt.deserialize(s.slice());
                    await this._bitswap._receiveMessage(i.remotePeer, o)
                  } catch (o) {
                    this._bitswap._receiveError(o);
                    break
                  }
                })
              } catch (n) {
                this._log(n)
              }
            }
          }
          _onPeerConnect(e) {
            this._bitswap._onPeerConnected(e)
          }
          _onPeerDisconnect(e) {
            this._bitswap._onPeerDisconnected(e)
          }
          findProviders(e, t, i = {}) {
            return this._libp2p.contentRouting.findProviders(e, {
              maxTimeout: G_e.providerRequestTimeout,
              maxNumProviders: t,
              signal: i.signal
            })
          }
          async findAndConnect(e, t) {
            let i = [];
            for await (let n of this.findProviders(e, G_e.maxProvidersPerRequest, t)) this._log(`connecting to provider ${n.id}`), i.push(this.connectTo(n.id, t).catch(s => {
              this._log.error(s)
            }));
            await Promise.all(i)
          }
          async provide(e, t) {
            await this._libp2p.contentRouting.provide(e, t)
          }
          async sendMessage(e, t) {
            if (!this._running) throw new Error("network isn't running");
            let i = e.toB58String();
            this._log("sendMessage to %s", i, t);
            let n = await this._libp2p.dial(e),
              {
                stream: s,
                protocol: o
              } = await n.newStream([hP, lP, fP]),
              a;
            switch (o) {
              case fP:
                a = t.serializeToBitswap100();
                break;
              case lP:
              case hP:
                a = t.serializeToBitswap110();
                break;
              default:
                throw new Error("Unknown protocol: " + o)
            }
            Mpt(s, a, this._log), this._updateSentStats(e, t.blocks)
          }
          async connectTo(e, t) {
            if (!this._running) throw new Error("network isn't running");
            return this._libp2p.dial(e, t)
          }
          _updateSentStats(e, t) {
            let i = e.toB58String();
            this._stats && (t.forEach(n => this._stats.push(i, "dataSent", n.data.length)), this._stats.push(i, "blocksSent", t.size))
          }
        };
      async function Mpt(r, e, t) {
        try {
          await H_e([e], V_e.encode(), r)
        } catch (i) {
          t(i)
        }
      }
      j_e.exports = $_e
    });
    var X_e = y((nRt, Y_e) => {
      l();
      "use strict";
      var Bpt = pm(),
        J_e = class {
          constructor(e) {
            this.partner = e, this.wantlist = new Bpt, this.exchangeCount = 0, this.sentToPeer = new Map, this.accounting = {
              bytesSent: 0,
              bytesRecv: 0
            }
          }
          sentBytes(e) {
            this.exchangeCount++, this.lastExchange = new Date().getTime(), this.accounting.bytesSent += e
          }
          receivedBytes(e) {
            this.exchangeCount++, this.lastExchange = new Date().getTime(), this.accounting.bytesRecv += e
          }
          wants(e, t, i) {
            this.wantlist.add(e, t, i)
          }
          cancelWant(e) {
            this.wantlist.remove(e)
          }
          wantlistContains(e) {
            return this.wantlist.contains(e)
          }
          debtRatio() {
            return this.accounting.bytesSent / (this.accounting.bytesRecv + 1)
          }
        };
      Y_e.exports = J_e
    });
    var e6e = y((sRt, Z_e) => {
      l();
      "use strict";
      var Q_e = class extends Map {
        constructor(e, t) {
          super();
          this._cmp = t || this._defaultSort, this._keys = [];
          for (let [i, n] of e || []) this.set(i, n)
        }
        update(e) {
          if (e < 0 || e >= this._keys.length) return;
          let t = this._keys[e];
          this._keys.splice(e, 1);
          let i = this._find(t);
          this._keys.splice(i, 0, t)
        }
        set(e, t) {
          if (this.has(e)) {
            let n = this.indexOf(e);
            this._keys.splice(n, 1)
          }
          super.set(e, t);
          let i = this._find(e);
          return this._keys.splice(i, 0, e), this
        }
        clear() {
          super.clear(), this._keys = []
        }
        delete(e) {
          if (!this.has(e)) return !1;
          let t = this.indexOf(e);
          return this._keys.splice(t, 1), super.delete(e)
        }
        indexOf(e) {
          if (!this.has(e)) return -1;
          let t = this._find(e);
          if (this._keys[t] === e) return t;
          for (let i = 1; i < this._keys.length; i++) {
            if (this._keys[t + i] === e) return t + i;
            if (this._keys[t - i] === e) return t - i
          }
          return -1
        }
        _find(e) {
          let t = 0,
            i = this._keys.length;
          for (; t < i;) {
            let n = t + i >>> 1,
              s = this._kCmp(this._keys[n], e);
            if (s < 0) t = n + 1;
            else if (s > 0) i = n;
            else return n
          }
          return t
        } * keys() {
          for (let e of this._keys) yield e
        } * values() {
          for (let e of this._keys) yield this.get(e)
        } * entries() {
          for (let e of this._keys) yield [e, this.get(e)]
        } *[Symbol.iterator]() {
          yield* this.entries()
        }
        forEach(e, t) {
          if (!!e)
            for (let i of this._keys) e.apply(t, [
              [i, this.get(i)]
            ])
        }
        _defaultSort(e, t) {
          return e[0] < t[0] ? -1 : t[0] < e[0] ? 1 : 0
        }
        _kCmp(e, t) {
          return this._cmp([e, this.get(e)], [t, this.get(t)])
        }
      };
      Z_e.exports = Q_e
    });
    var s6e = y((oRt, t6e) => {
      l();
      "use strict";
      var r6e = e6e(),
        Dpt = {
          hasNewInfo() {
            return !1
          },
          merge() { }
        },
        i6e = class {
          constructor(e = Dpt) {
            this._taskMerger = e, this._byPeer = new r6e([], dP.compare)
          }
          pushTasks(e, t) {
            let i = this._byPeer.get(e.toB58String());
            i || (i = new dP(e, this._taskMerger)), i.pushTasks(t), this._byPeer.set(e.toB58String(), i)
          }
          popTasks(e) {
            let t = this._head();
            if (t === void 0) return {
              tasks: [],
              pendingSize: 0
            };
            let {
              tasks: i,
              pendingSize: n
            } = t.popTasks(e);
            if (i.length === 0) return {
              tasks: i,
              pendingSize: n
            };
            let s = t.peerId;
            return t.isIdle() ? this._byPeer.delete(s.toB58String()) : this._byPeer.update(0), {
              peerId: s,
              tasks: i,
              pendingSize: n
            }
          }
          _head() {
            if (this._byPeer.size !== 0)
              for (let [, e] of this._byPeer) return e
          }
          remove(e, t) {
            let i = this._byPeer.get(t.toB58String());
            i && i.remove(e)
          }
          tasksDone(e, t) {
            let i = this._byPeer.get(e.toB58String());
            if (!i) return;
            let n = this._byPeer.indexOf(e.toB58String());
            for (let s of t) i.taskDone(s);
            this._byPeer.update(n)
          }
        },
        dP = class {
          constructor(e, t) {
            this.peerId = e, this._taskMerger = t, this._activeTotalSize = 0, this._pending = new n6e, this._active = new Set
          }
          pushTasks(e) {
            for (let t of e) this._pushTask(t)
          }
          _pushTask(e) {
            if (!this._taskHasMoreInfoThanActiveTasks(e)) return;
            let t = this._pending.get(e.topic);
            if (t) {
              e.priority > t.priority && this._pending.updatePriority(e.topic, e.priority), this._taskMerger.merge(e, t);
              return
            }
            this._pending.add(e)
          }
          _taskHasMoreInfoThanActiveTasks(e) {
            let t = [];
            for (let i of this._active) i.topic === e.topic && t.push(i);
            return t.length === 0 ? !0 : this._taskMerger.hasNewInfo(e, t)
          }
          popTasks(e) {
            let t = 0,
              i = [],
              n = this._pending.tasks();
            for (let s = 0; s < n.length && t < e; s++) {
              let o = n[s];
              i.push(o), t += o.size, this._pending.delete(o.topic), this._activeTotalSize += o.size, this._active.add(o)
            }
            return {
              tasks: i,
              pendingSize: this._pending.totalSize
            }
          }
          taskDone(e) {
            this._active.has(e) && (this._activeTotalSize -= e.size, this._active.delete(e))
          }
          remove(e) {
            this._pending.delete(e)
          }
          isIdle() {
            return this._pending.length === 0 && this._active.size === 0
          }
          static compare(e, t) {
            return e[1]._pending.length === 0 ? 1 : t[1]._pending.length === 0 ? -1 : e[1]._activeTotalSize === t[1]._activeTotalSize ? t[1]._pending.length - e[1]._pending.length : e[1]._activeTotalSize - t[1]._activeTotalSize
          }
        },
        n6e = class {
          constructor() {
            this._tasks = new r6e([], this._compare)
          }
          get length() {
            return this._tasks.size
          }
          get totalSize() {
            return [...this._tasks.values()].reduce((e, t) => e + t.task.size, 0)
          }
          get(e) {
            return (this._tasks.get(e) || {}).task
          }
          add(e) {
            this._tasks.set(e.topic, {
              created: Date.now(),
              task: e
            })
          }
          delete(e) {
            this._tasks.delete(e)
          }
          tasks() {
            return [...this._tasks.values()].map(e => e.task)
          }
          updatePriority(e, t) {
            let i = this._tasks.get(e);
            if (!i) return;
            let n = this._tasks.indexOf(e);
            i.task.priority = t, this._tasks.update(n)
          }
          _compare(e, t) {
            return e[1].task.priority === t[1].task.priority ? e[1].created - t[1].created : t[1].task.priority - e[1].task.priority
          }
        };
      t6e.exports = i6e
    });
    var a6e = y((aRt, o6e) => {
      l();
      "use strict";
      var Lpt = {
        hasNewInfo(r, e) {
          let t = !1,
            i = !1;
          for (let n of e) n.data.haveBlock && (t = !0), n.data.isWantBlock && (i = !0);
          return !!(!i && r.data.isWantBlock || !t && r.data.haveBlock)
        },
        merge(r, e) {
          let t = r.data,
            i = e.data;
          !i.haveBlock && t.haveBlock && (i.haveBlock = t.haveBlock, i.blockSize = t.blockSize), !i.isWantBlock && t.isWantBlock && (i.isWantBlock = !0, (!i.haveBlock || t.haveBlock) && (i.haveBlock = t.haveBlock, e.size = r.size)), i.isWantBlock && i.haveBlock && (e.size = i.blockSize)
        }
      };
      o6e.exports = Lpt
    });
    var h6e = y((cRt, c6e) => {
      l();
      "use strict";
      var u6e = at(),
        bm = v1(),
        f6e = bm.WantType,
        Fpt = pm(),
        Upt = X_e(),
        Kpt = s6e(),
        zpt = a6e(),
        {
          logger: jpt
        } = ku(),
        Vpt = 16 * 1024,
        Hpt = 1024,
        l6e = class {
          constructor(e, t, i, n, s = {}) {
            this._log = jpt(e, "engine"), this.blockstore = t, this.network = i, this._stats = n, this._opts = this._processOpts(s), this.ledgerMap = new Map, this._running = !1, this._requestQueue = new Kpt(zpt)
          }
          _processOpts(e) {
            return {
              maxSizeReplaceHasWithBlock: Hpt,
              targetMessageSize: Vpt,
              ...e
            }
          }
          _scheduleProcessTasks() {
            setTimeout(() => {
              this._processTasks()
            })
          }
          async _processTasks() {
            if (!this._running) return;
            let {
              peerId: e,
              tasks: t,
              pendingSize: i
            } = this._requestQueue.popTasks(this._opts.targetMessageSize);
            if (t.length === 0) return;
            let n = new bm(!1);
            n.setPendingBytes(i);
            let s = [],
              o = new Map;
            for (let c of t) {
              let u = new u6e(c.topic);
              c.data.haveBlock ? c.data.isWantBlock ? (s.push(u), o.set(c.topic, c.data)) : n.addHave(u) : n.addDontHave(u)
            }
            let a = await this._getBlocks(s);
            for (let [c, u] of o) {
              let f = a.get(c);
              if (f) n.addBlock(f);
              else if (u.sendDontHave) {
                let h = new u6e(c);
                n.addDontHave(h)
              }
            }
            if (n.empty) {
              e && this._requestQueue.tasksDone(e, t), this._scheduleProcessTasks();
              return
            }
            try {
              e && await this.network.sendMessage(e, n);
              for (let c of a.values()) e && this.messageSent(e, c)
            } catch (c) {
              this._log.error(c)
            }
            e && this._requestQueue.tasksDone(e, t), this._scheduleProcessTasks()
          }
          wantlistForPeer(e) {
            let t = e.toB58String(),
              i = this.ledgerMap.get(t);
            return i ? i.wantlist.sortedEntries() : new Map
          }
          ledgerForPeer(e) {
            let t = e.toB58String(),
              i = this.ledgerMap.get(t);
            return i ? {
              peer: i.partner.toPrint(),
              value: i.debtRatio(),
              sent: i.accounting.bytesSent,
              recv: i.accounting.bytesRecv,
              exchanged: i.exchangeCount
            } : null
          }
          peers() {
            return Array.from(this.ledgerMap.values()).map(e => e.partner)
          }
          receivedBlocks(e) {
            !e.length || (this.ledgerMap.forEach(t => {
              e.forEach(i => {
                let n = t.wantlistContains(i.cid);
                if (!n) return;
                let s = i.data.length,
                  o = this._sendAsBlock(n.wantType, s),
                  a = s;
                o || (a = bm.blockPresenceSize(n.cid)), this._requestQueue.pushTasks(t.partner, [{
                  topic: n.cid.toString(),
                  priority: n.priority,
                  size: a,
                  data: {
                    blockSize: s,
                    isWantBlock: o,
                    haveBlock: !0,
                    sendDontHave: !1
                  }
                }])
              })
            }), this._scheduleProcessTasks())
          }
          async messageReceived(e, t) {
            let i = this._findOrCreate(e);
            if (t.empty) return;
            if (t.full && (i.wantlist = new Fpt), this._updateBlockAccounting(t.blocks, i), t.wantlist.size === 0) {
              this._scheduleProcessTasks();
              return
            }
            let n = [],
              s = [];
            t.wantlist.forEach(o => {
              o.cancel ? (i.cancelWant(o.cid), n.push(o.cid)) : (i.wants(o.cid, o.priority, o.wantType), s.push(o))
            }), this._cancelWants(e, n), await this._addWants(e, s), this._scheduleProcessTasks()
          }
          _cancelWants(e, t) {
            for (let i of t) this._requestQueue.remove(i.toString(), e)
          }
          async _addWants(e, t) {
            let i = await this._getBlockSizes(t.map(s => s.cid)),
              n = [];
            for (let s of t) {
              let o = s.cid.toString(),
                a = i.get(o);
              if (a == null) s.sendDontHave && n.push({
                topic: o,
                priority: s.priority,
                size: bm.blockPresenceSize(s.cid),
                data: {
                  isWantBlock: s.wantType === f6e.Block,
                  blockSize: 0,
                  haveBlock: !1,
                  sendDontHave: s.sendDontHave
                }
              });
              else {
                let c = this._sendAsBlock(s.wantType, a),
                  u = a;
                c || (u = bm.blockPresenceSize(s.cid)), n.push({
                  topic: o,
                  priority: s.priority,
                  size: u,
                  data: {
                    isWantBlock: c,
                    blockSize: a,
                    haveBlock: !0,
                    sendDontHave: s.sendDontHave
                  }
                })
              }
              this._requestQueue.pushTasks(e, n)
            }
          }
          _sendAsBlock(e, t) {
            return e === f6e.Block || t <= this._opts.maxSizeReplaceHasWithBlock
          }
          async _getBlockSizes(e) {
            let t = await this._getBlocks(e);
            return new Map([...t].map(([i, n]) => [i, n.data.length]))
          }
          async _getBlocks(e) {
            let t = new Map;
            return await Promise.all(e.map(async i => {
              try {
                let n = await this.blockstore.get(i);
                t.set(i.toString(), n)
              } catch (n) {
                n.code !== "ERR_NOT_FOUND" && this._log.error("failed to query blockstore for %s: %s", i, n)
              }
            })), t
          }
          _updateBlockAccounting(e, t) {
            e.forEach(i => {
              this._log("got block (%s bytes)", i.data.length), t.receivedBytes(i.data.length)
            })
          }
          messageSent(e, t) {
            let i = this._findOrCreate(e);
            i.sentBytes(t ? t.data.length : 0), t && t.cid && i.wantlist.remove(t.cid)
          }
          numBytesSentTo(e) {
            return this._findOrCreate(e).accounting.bytesSent
          }
          numBytesReceivedFrom(e) {
            return this._findOrCreate(e).accounting.bytesRecv
          }
          peerDisconnected(e) { }
          _findOrCreate(e) {
            let t = e.toB58String(),
              i = this.ledgerMap.get(t);
            if (i) return i;
            let n = new Upt(e);
            return this.ledgerMap.set(t, n), this._stats && this._stats.push(t, "peerCount", 1), n
          }
          start() {
            this._running = !0
          }
          stop() {
            this._running = !1
          }
        };
      c6e.exports = l6e
    });
    var m6e = y((uRt, d6e) => {
      l();
      "use strict";
      var {
        EventEmitter: Gpt
      } = Br(), $pt = ql(), Wpt = Lr(), p6e = ct(), Ypt = gm(), Jpt = ku().logger, y6e = r => `unwant:${p6e(r.multihash, "base64")}`, g6e = r => `block:${p6e(r.multihash, "base64")}`, b6e = class extends Gpt {
        constructor(e) {
          super();
          this.setMaxListeners(Ypt.maxListeners), this._log = Jpt(e, "notif")
        }
        hasBlock(e) {
          let t = g6e(e.cid);
          this._log(t), this.emit(t, e)
        }
        wantBlock(e, t = {}) {
          if (!e) throw new Error("Not a valid cid");
          let i = g6e(e),
            n = y6e(e);
          return this._log(`wantBlock:${e}`), new Promise((s, o) => {
            let a = () => {
              this.removeListener(i, c), o(new Error(`Block for ${e} unwanted`))
            },
              c = u => {
                if (this.removeListener(n, a), Wpt(e.multihash, u.cid.multihash)) (e.version !== u.cid.version || e.codec !== u.cid.codec) && (u = new $pt(u.data, e));
                else return o(new Error(`Incorrect block received for ${e}`));
                s(u)
              };
            this.once(n, a), this.once(i, c), t && t.signal && t.signal.addEventListener("abort", () => {
              this.removeListener(i, c), this.removeListener(n, a), o(new Error(`Want for ${e} aborted`))
            })
          })
        }
        unwantBlock(e) {
          let t = y6e(e);
          this._log(t), this.emit(t)
        }
      };
      d6e.exports = b6e
    });
    var E6e = y((fRt, v6e) => {
      l();
      "use strict";
      var {
        EventEmitter: Xpt
      } = Br(), w6e = IR(), _6e = class extends Xpt {
        constructor(e, t) {
          super();
          this._options = t, this._queue = [], this._stats = {}, this._frequencyLastTime = Date.now(), this._frequencyAccumulators = {}, this._movingAverages = {}, this._update = this._update.bind(this), e.forEach(i => {
            this._stats[i] = BigInt(0), this._movingAverages[i] = {}, this._options.movingAverageIntervals.forEach(n => {
              (this._movingAverages[i][n] = w6e(n)).push(this._frequencyLastTime, 0)
            })
          }), this._enabled = this._options.enabled
        }
        enable() {
          this._enabled = !0
        }
        disable() {
          this._disabled = !0
        }
        stop() {
          this._timeout && clearTimeout(this._timeout)
        }
        get snapshot() {
          return Object.assign({}, this._stats)
        }
        get movingAverages() {
          return Object.assign({}, this._movingAverages)
        }
        push(e, t) {
          this._enabled && (this._queue.push([e, t, Date.now()]), this._resetComputeTimeout())
        }
        _resetComputeTimeout() {
          this._timeout && clearTimeout(this._timeout), this._timeout = setTimeout(this._update, this._nextTimeout())
        }
        _nextTimeout() {
          let e = this._queue.length / this._options.computeThrottleMaxQueueSize;
          return Math.max(this._options.computeThrottleTimeout * (1 - e), 0)
        }
        _update() {
          if (this._timeout = null, this._queue.length) {
            let e;
            for (; this._queue.length;) {
              let t = e = this._queue.shift();
              t && this._applyOp(t)
            }
            e && this._updateFrequency(e[2]), this.emit("update", this._stats)
          }
        }
        _updateFrequency(e) {
          let t = e - this._frequencyLastTime;
          t && Object.keys(this._stats).forEach(i => {
            this._updateFrequencyFor(i, t, e)
          }), this._frequencyLastTime = e
        }
        _updateFrequencyFor(e, t, i) {
          let n = this._frequencyAccumulators[e] || 0;
          this._frequencyAccumulators[e] = 0;
          let s = n / t * 1e3,
            o = this._movingAverages[e];
          o || (o = this._movingAverages[e] = {}), this._options.movingAverageIntervals.forEach(a => {
            let c = o[a];
            c || (c = o[a] = w6e(a)), c.push(i, s)
          })
        }
        _applyOp(e) {
          let t = e[0],
            i = e[1];
          if (typeof i != "number") throw new Error(`invalid increment number: ${i}`);
          Object.prototype.hasOwnProperty.call(this._stats, t) || (this._stats[t] = BigInt(0)), this._stats[t] = BigInt(this._stats[t]) + BigInt(i), this._frequencyAccumulators[t] || (this._frequencyAccumulators[t] = 0), this._frequencyAccumulators[t] += i
        }
      };
      v6e.exports = _6e
    });
    var T6e = y((lRt, S6e) => {
      l();
      "use strict";
      var {
        EventEmitter: Zpt
      } = Br(), x6e = E6e(), A6e = {
        enabled: !1,
        computeThrottleTimeout: 1e3,
        computeThrottleMaxQueueSize: 1e3,
        movingAverageIntervals: [60 * 1e3, 5 * 60 * 1e3, 15 * 60 * 1e3]
      }, I6e = class extends Zpt {
        constructor(e = [], t = A6e) {
          super();
          let i = Object.assign({}, A6e, t);
          if (typeof i.computeThrottleTimeout != "number") throw new Error("need computeThrottleTimeout");
          if (typeof i.computeThrottleMaxQueueSize != "number") throw new Error("need computeThrottleMaxQueueSize");
          this._initialCounters = e, this._options = i, this._enabled = this._options.enabled, this._global = new x6e(e, i), this._global.on("update", n => this.emit("update", n)), this._peers = new Map
        }
        enable() {
          this._enabled = !0, this._options.enabled = !0, this._global.enable()
        }
        disable() {
          this._enabled = !1, this._options.enabled = !1, this._global.disable()
        }
        stop() {
          this._enabled = !1, this._global.stop();
          for (let e of this._peers) e[1].stop()
        }
        get snapshot() {
          return this._global.snapshot
        }
        get movingAverages() {
          return this._global.movingAverages
        }
        forPeer(e) {
          let t = typeof e != "string" && e.toB58String ? e.toB58String() : `${e}`;
          return this._peers.get(t)
        }
        push(e, t, i) {
          if (this._enabled && (this._global.push(t, i), e)) {
            let n = this._peers.get(e);
            n || (n = new x6e(this._initialCounters, this._options), this._peers.set(e, n)), n.push(t, i)
          }
        }
        disconnected(e) {
          let t = e.toB58String(),
            i = this._peers.get(t);
          i && (i.stop(), this._peers.delete(t))
        }
      };
      S6e.exports = I6e
    });
    var P6e = y((hRt, R6e) => {
      l();
      "use strict";
      var Qpt = z_e(),
        e1t = W_e(),
        t1t = h6e(),
        r1t = m6e(),
        i1t = ku().logger,
        n1t = T6e(),
        {
          AbortController: s1t
        } = k1(),
        {
          anySignal: o1t
        } = ed(),
        a1t = {
          statsEnabled: !1,
          statsComputeThrottleTimeout: 1e3,
          statsComputeThrottleMaxQueueSize: 1e3
        },
        c1t = ["blocksReceived", "dataReceived", "dupBlksReceived", "dupDataReceived", "blocksSent", "dataSent", "providesBufferLength", "wantListLength", "peerCount"],
        k6e = class {
          constructor(e, t, i = {}) {
            this._libp2p = e, this._log = i1t(this.peerId), this._options = Object.assign({}, a1t, i), this._stats = new n1t(c1t, {
              enabled: this._options.statsEnabled,
              computeThrottleTimeout: this._options.statsComputeThrottleTimeout,
              computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize
            }), this.network = new e1t(e, this, this._stats), this.blockstore = t, this.engine = new t1t(this.peerId, t, this.network, this._stats), this.wm = new Qpt(this.peerId, this.network, this._stats), this.notifications = new r1t(this.peerId)
          }
          get peerId() {
            return this._libp2p.peerId
          }
          async _receiveMessage(e, t) {
            try {
              await this.engine.messageReceived(e, t)
            } catch (s) {
              this._log("failed to receive message", t)
            }
            if (t.blocks.size === 0) return;
            let i = Array.from(t.blocks.values()),
              n = i.filter(s => this.wm.wantlist.contains(s.cid)).map(s => s.cid);
            this.wm.cancelWants(n), await Promise.all(i.map(async s => {
              let o = n.includes(s.cid);
              await this._handleReceivedBlock(e, s, o)
            }))
          }
          async _handleReceivedBlock(e, t, i) {
            this._log("received block");
            let n = await this.blockstore.has(t.cid);
            this._updateReceiveCounters(e.toB58String(), t, n), !!i && await this.put(t)
          }
          _updateReceiveCounters(e, t, i) {
            this._stats.push(e, "blocksReceived", 1), this._stats.push(e, "dataReceived", t.data.length), i && (this._stats.push(e, "dupBlksReceived", 1), this._stats.push(e, "dupDataReceived", t.data.length))
          }
          _receiveError(e) {
            this._log.error("ReceiveError: %s", e.message)
          }
          _onPeerConnected(e) {
            this.wm.connected(e)
          }
          _onPeerDisconnected(e) {
            this.wm.disconnected(e), this.engine.peerDisconnected(e), this._stats.disconnected(e)
          }
          enableStats() {
            this._stats.enable()
          }
          disableStats() {
            this._stats.disable()
          }
          wantlistForPeer(e, t) {
            return this.engine.wantlistForPeer(e)
          }
          ledgerForPeer(e) {
            return this.engine.ledgerForPeer(e)
          }
          async get(e, t = {}) {
            let i = (u, f) => (this.wm.wantBlocks([u], f), this.notifications.wantBlock(u, f)),
              n = !1,
              s = async (u, f) => {
                try {
                  return await this.blockstore.get(u, f)
                } catch (h) {
                  if (h.code !== "ERR_NOT_FOUND") throw h;
                  return n || (n = !0, this.network.findAndConnect(u).catch(d => this._log.error(d))), i(u, f)
                }
              }, o = new s1t, a = t.signal ? o1t([t.signal, o.signal]) : o.signal, c = await Promise.race([this.notifications.wantBlock(e, {
                signal: a
              }), s(e, {
                signal: a
              })]);
            return o.abort(), c
          }
          async *getMany(e, t = {}) {
            for await (let i of e) yield this.get(i, t)
          }
          unwant(e) {
            let t = Array.isArray(e) ? e : [e];
            this.wm.unwantBlocks(t), t.forEach(i => this.notifications.unwantBlock(i))
          }
          cancelWants(e) {
            this.wm.cancelWants(Array.isArray(e) ? e : [e])
          }
          async put(e, t) {
            await this.blockstore.put(e), this._sendHaveBlockNotifications(e)
          }
          async *putMany(e) {
            for await (let t of this.blockstore.putMany(e)) this._sendHaveBlockNotifications(t), yield t
          }
          _sendHaveBlockNotifications(e) {
            this.notifications.hasBlock(e), this.engine.receivedBlocks([e]), this.network.provide(e.cid).catch(t => {
              this._log.error("Failed to provide: %s", t.message)
            })
          }
          getWantlist() {
            return this.wm.wantlist.entries()
          }
          peers() {
            return this.engine.peers()
          }
          stat() {
            return this._stats
          }
          start() {
            this.wm.start(), this.network.start(), this.engine.start()
          }
          stop() {
            this._stats.stop(), this.wm.stop(), this.network.stop(), this.engine.stop()
          }
        };
      R6e.exports = k6e
    });
    var O6e = y((dRt, C6e) => {
      l();
      "use strict";
      var u1t = P6e(),
        f1t = rP(),
        {
          Multiaddr: l1t
        } = pr(),
        h1t = xe(),
        B4 = class {
          constructor(e, t, i) {
            this.peerId = e, this.libp2p = t, this.bitswap = i
          }
          static async start({
            peerId: e,
            repo: t,
            print: i,
            options: n
          }) {
            t.closed && await t.open();
            let s = await t.config.getAll(),
              o = await f1t({
                options: n,
                repo: t,
                peerId: e,
                multiaddrs: d1t(e, s),
                config: s,
                keychainConfig: void 0
              });
            o.keychain && await o.loadKeychain(), await o.start();
            for (let c of o.multiaddrs) i(`Swarm listening on ${c}/p2p/${e.toB58String()}`);
            let a = new u1t(o, t.blocks, {
              statsEnabled: !0
            });
            return await a.start(), new B4(e, o, a)
          }
          static async stop(e) {
            await Promise.all([e.bitswap.stop(), e.libp2p.stop()])
          }
        };
      C6e.exports = B4;
      var d1t = (r, e) => {
        let t = r.toB58String(),
          i = [],
          n = e.Addresses && e.Addresses.Swarm || [];
        for (let s of n) {
          let o = new l1t(s);
          if (o.protoCodes().includes(p1t)) throw h1t(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"), "ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");
          let a = o.getPeerId();
          a && a !== t && (o = o.encapsulate(`/p2p/${t}`)), i.push(o)
        }
        return i
      },
        p1t = 479
    });
    var q6e = y((pRt, N6e) => {
      l();
      "use strict";
      var y1t = ze();
      N6e.exports = ({
        network: r
      }) => {
        async function e(t = {}) {
          let i = [],
            {
              libp2p: n
            } = await r.use(t);
          for (let [s, o] of n.peerStore.peers.entries()) i.push({
            id: s,
            addrs: o.addresses.map(a => a.multiaddr)
          });
          return i
        }
        return y1t(e)
      }
    });
    var B6e = y((yRt, M6e) => {
      l();
      "use strict";
      var g1t = ze();
      M6e.exports = ({
        network: r
      }) => {
        async function e(t, i = {}) {
          let {
            libp2p: n
          } = await r.use(i);
          await n.dial(t, i)
        }
        return g1t(e)
      }
    });
    var L6e = y((gRt, D6e) => {
      l();
      "use strict";
      var b1t = ze();
      D6e.exports = ({
        network: r
      }) => {
        async function e(t, i = {}) {
          let {
            libp2p: n
          } = await r.use(i);
          await n.hangUp(t)
        }
        return b1t(e)
      }
    });
    var U6e = y((bRt, F6e) => {
      l();
      "use strict";
      var m1t = ze();
      F6e.exports = ({
        network: r
      }) => {
        async function e(t = {}) {
          let {
            libp2p: i
          } = await r.use(t);
          return i.multiaddrs
        }
        return m1t(e)
      }
    });
    var z6e = y((mRt, K6e) => {
      l();
      "use strict";
      var v1t = ze();
      K6e.exports = ({
        network: r
      }) => {
        async function e(t = {}) {
          let {
            libp2p: i
          } = await r.use(t), n = [];
          for (let [s, o] of i.connections)
            for (let a of o) {
              let c = {
                addr: a.remoteAddr,
                peer: s
              };
              (t.verbose || t.direction) && (c.direction = a.stat.direction), t.verbose && (c.muxer = a.stat.multiplexer, c.latency = "n/a", c.streams = []), n.push(c)
            }
          return n
        }
        return v1t(e)
      }
    });
    var H6e = y((vRt, j6e) => {
      l();
      "use strict";
      var w1t = q6e(),
        _1t = B6e(),
        E1t = L6e(),
        S1t = U6e(),
        x1t = z6e(),
        V6e = class {
          constructor({
            network: e
          }) {
            this.addrs = w1t({
              network: e
            }), this.connect = _1t({
              network: e
            }), this.disconnect = E1t({
              network: e
            }), this.localAddrs = S1t({
              network: e
            }), this.peers = x1t({
              network: e
            })
          }
        };
      j6e.exports = V6e
    });
    var $6e = y((wRt, G6e) => {
      l();
      "use strict";
      var A1t = fA();
      G6e.exports = ({
        path: r,
        repoOwner: e
      }) => A1t(r, {
        singleProcess: e !== !1
      })
    });
    var Y6e = y((_Rt, W6e) => {
      l();
      "use strict";
      var I1t = Et(),
        mm = {
          success: !0,
          time: 0,
          text: ""
        },
        T1t = ze();
      W6e.exports = ({
        network: r
      }) => {
        async function* e(t, i = {}) {
          let {
            libp2p: n
          } = await r.use();
          i.count = i.count || 10;
          let s = I1t.createFromCID(t),
            o = n.peerStore.get(s),
            a = o && o.id;
          if (!a) {
            yield {
              ...mm,
              text: `Looking up peer ${t}`
            };
            let f = await n.peerRouting.findPeer(s);
            a = f && f.id
          }
          if (!a) throw new Error("Peer was not found");
          yield {
            ...mm,
            text: `PING ${a.toB58String()}`
          };
          let c = 0,
            u = 0;
          for (let f = 0; f < i.count; f++) try {
            let h = await n.ping(a);
            u += h, c++, yield {
              ...mm,
              time: h
            }
          } catch (h) {
            yield {
              ...mm,
              success: !1,
              text: h.toString()
            }
          }
          if (c) {
            let f = u / c;
            yield {
              ...mm,
              text: `Average latency: ${f}ms`
            }
          }
        }
        return T1t(e)
      }
    });
    var Q6e = y((ERt, J6e) => {
      l();
      "use strict";
      var X6e = Et(),
        Z6e = at(),
        D4 = xe(),
        {
          NotEnabledError: R1t
        } = of(),
        k1t = Qy(),
        w1 = ze();
      J6e.exports = ({
        network: r,
        repo: e
      }) => {
        let {
          get: t,
          put: i,
          findProvs: n,
          findPeer: s,
          provide: o,
          query: a
        } = {
          async get(c, u = {}) {
            let {
              libp2p: f
            } = await _1(r, u);
            return f._dht.get(pP(c), u)
          },
          async *put(c, u, f) {
            let {
              libp2p: h
            } = await _1(r, f);
            yield* h._dht.put(pP(c), u)
          },
          async *findProvs(c, u = {
            numProviders: 20
          }) {
            let {
              libp2p: f
            } = await _1(r, u);
            for await (let h of f._dht.findProviders(pP(c), {
              maxNumProviders: u.numProviders,
              signal: u.signal
            })) yield {
              id: h.id.toB58String(),
              addrs: h.addrs
            }
          },
          async findPeer(c, u) {
            let {
              libp2p: f
            } = await _1(r, u), h = await f._dht.findPeer(X6e.createFromCID(c));
            return {
              id: h.id.toB58String(),
              addrs: h.multiaddrs
            }
          },
          async *provide(c, u = {
            recursive: !1
          }) {
            let {
              libp2p: f
            } = await _1(r, u);
            c = Array.isArray(c) ? c : [c];
            for (let p in c)
              if (typeof c[p] == "string") try {
                c[p] = new Z6e(c[p])
              } catch (g) {
                throw D4(g, "ERR_INVALID_CID")
              }
            if (!(await Promise.all(c.map(p => e.blocks.has(p)))).every(p => p)) throw D4(new Error("block(s) not found locally, cannot provide"), "ERR_BLOCK_NOT_FOUND");
            if (u.recursive) throw D4(new Error("not implemented yet"), "ERR_NOT_IMPLEMENTED_YET");
            for (let p of c) yield f._dht.provide(p)
          },
          async *query(c, u) {
            let {
              libp2p: f
            } = await _1(r, u);
            for await (let h of f._dht.getClosestPeers(X6e.createFromCID(c).toBytes())) yield {
              id: h.toB58String(),
              addrs: []
            }
          }
        };
        return {
          get: w1(t),
          put: w1(i),
          findProvs: w1(n),
          findPeer: w1(s),
          provide: w1(o),
          query: w1(a)
        }
      };
      var P1t = r => {
        try {
          let e = r.toString().split("/").filter(t => t && t !== "ipfs" && t !== "ipns")[0];
          return new Z6e(e).bytes
        } catch (e) {
          throw D4(e, "ERR_INVALID_CID")
        }
      },
        pP = r => r instanceof Uint8Array ? r : P1t(r),
        _1 = async (r, e) => {
          let t = await r.use(e);
          if (k1t(t.libp2p, "_config.dht.enabled", !1)) return t;
          throw new R1t("dht not enabled")
        }
    });
    var t4e = y((SRt, e4e) => {
      l();
      "use strict";
      var vm = ze(),
        C1t = xe(),
        {
          NotEnabledError: O1t
        } = of(),
        N1t = Qy();
      e4e.exports = ({
        network: r,
        config: e
      }) => {
        let t = N1t(e || {}, "Pubsub.Enabled", !0);
        return {
          subscribe: t ? vm(i) : wm,
          unsubscribe: t ? vm(n) : wm,
          publish: t ? vm(s) : wm,
          ls: t ? vm(o) : wm,
          peers: t ? vm(a) : wm
        };
        async function i(c, u, f = {}) {
          let {
            libp2p: h
          } = await r.use(f);
          return h.pubsub.subscribe(c, u, f)
        }
        async function n(c, u, f = {}) {
          let {
            libp2p: h
          } = await r.use(f);
          h.pubsub.unsubscribe(c, u, f)
        }
        async function s(c, u, f = {}) {
          let {
            libp2p: h
          } = await r.use(f);
          if (!u) throw C1t(new Error('argument "data" is required'), "ERR_ARG_REQUIRED");
          await h.pubsub.publish(c, u)
        }
        async function o(c = {}) {
          let {
            libp2p: u
          } = await r.use(c);
          return u.pubsub.getTopics()
        }
        async function a(c, u = {}) {
          let {
            libp2p: f
          } = await r.use(u);
          return f.pubsub.getSubscribers(c)
        }
      };
      var wm = async () => {
        throw new O1t("pubsub not enabled")
      }
    });
    var n4e = y((xRt, r4e) => {
      l();
      "use strict";
      var {
        mergeOptions: q1t
      } = Ji(), {
        isTest: M1t
      } = iE(), yP = Oe()("ipfs"), i4e = xe(), {
        DAGNode: B1t
      } = Mr(), {
        UnixFS: D1t
      } = Ii(), L1t = $K(), {
        AlreadyInitializedError: F1t
      } = of(), U1t = gt(), K1t = JK(), z1t = ZK(), j1t = bz(), V1t = vz(), H1t = Iz(), G1t = lH(), $1t = C$(), W1t = nW(), Y1t = aW(), J1t = uW(), X1t = vW(), Z1t = MW(), Q1t = nY(), eyt = GX(), tyt = YX(), ryt = XX(), iyt = rA(), nyt = cZ(), syt = c0(), oyt = bZ(), ayt = _Z(), cyt = wee(), uyt = Fee(), fyt = hte(), lyt = hce(), hyt = mce(), dyt = Ece(), pyt = hue(), yyt = o_e(), gyt = O6e(), byt = yv(), myt = H6e(), vyt = $6e(), wyt = Y6e(), _yt = Q6e(), Eyt = t4e(), L4 = class {
        constructor({
          print: e,
          storage: t,
          options: i
        }) {
          let {
            peerId: n,
            repo: s,
            keychain: o
          } = t, a = byt.create(gyt), c = oyt(i.preload), u = new dyt(t.repo), f = pyt({
            blockService: u,
            options: i.ipld
          }), h = vyt({
            path: s.path,
            repoOwner: i.repoOwner
          }), d = j1t(), p = V1t({
            network: a
          }), g = new $1t(i), m = new W1t({
            dns: d,
            ipns: g,
            ipld: f,
            peerId: n,
            isOnline: p,
            keychain: o,
            options: i
          }), E = H1t({
            ipld: f,
            name: m
          }), w = new syt({
            repo: s,
            ipld: f
          }), O = new G1t({
            gcLock: h,
            pinManager: w,
            ipld: f
          }), q = new Q1t({
            blockService: u,
            preload: c,
            gcLock: h,
            pinManager: w,
            pin: O
          }), J = new nyt({
            ipld: f,
            preload: c,
            gcLock: h,
            pin: O
          }), Z = Object.assign(Y1t({
            ipld: f,
            resolve: E,
            preload: c
          }), {
            local: J1t({
              repo: t.repo
            })
          }), {
            add: H,
            addAll: te,
            cat: ae,
            get: oe,
            ls: U
          } = new eyt({
            gcLock: h,
            preload: c,
            pin: O,
            block: q,
            ipld: f,
            options: i.EXPERIMENTAL
          }), b = cyt({
            ipld: f,
            block: q,
            blockService: u,
            repo: s,
            preload: c,
            options: i
          }), _ = ayt({
            files: b,
            preload: c,
            options: i.preload
          });
          this.preload = c, this.name = m, this.ipld = f, this.ipns = g, this.pin = O, this.resolve = E, this.block = q, this.refs = Z, this.start = K1t({
            network: a,
            peerId: n,
            repo: s,
            blockService: u,
            preload: c,
            ipns: g,
            mfsPreload: _,
            print: e,
            keychain: o,
            options: i
          }), this.stop = z1t({
            network: a,
            preload: c,
            mfsPreload: _,
            blockService: u,
            ipns: g,
            repo: s
          }), this.dht = _yt({
            network: a,
            repo: s
          }), this.pubsub = Eyt({
            network: a,
            config: i.config
          }), this.dns = d, this.isOnline = p, this.id = ryt({
            network: a,
            peerId: n
          }), this.version = tyt({
            repo: s
          }), this.bitswap = new X1t({
            network: a
          }), this.bootstrap = new Z1t({
            repo: s
          }), this.config = iyt({
            repo: s
          }), this.ping = wyt({
            network: a
          }), this.add = H, this.addAll = te, this.cat = ae, this.get = oe, this.ls = U, this.dag = J, this.files = b, this.key = new uyt({
            keychain: o
          }), this.object = new fyt({
            ipld: f,
            preload: c,
            gcLock: h
          }), this.repo = new lyt({
            gcLock: h,
            pin: O,
            repo: s,
            refs: Z
          }), this.stats = new hyt({
            repo: s,
            network: a
          }), this.swarm = new myt({
            network: a
          }), Object.defineProperty(this, "libp2p", {
            get() {
              let K = a.try();
              return K ? K.libp2p : void 0
            }
          });
          let R = () => Promise.reject(i4e(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED")),
            D = async function* () {
              throw i4e(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED")
            };
          this.commands = R, this.diag = {
            cmds: R,
            net: R,
            sys: R
          }, this.log = {
            level: R,
            ls: R,
            tail: D
          }, this.mount = R
        }
        async init() {
          throw new F1t
        }
        static async create(e = {}) {
          e = q1t(xyt(), e);
          let t = e.init || {},
            i = e.silent ? yP : console.log,
            n = await yyt.start(i, e),
            s = await n.repo.config.getAll(),
            o = new L4({
              storage: n,
              print: i,
              options: {
                ...e,
                config: s
              }
            });
          if (await o.preload.start(), o.ipns.startOffline(n), n.isNew && !t.emptyRepo) {
            let a = await Syt(o);
            yP("adding default assets"), await L1t({
              addAll: o.addAll,
              print: i
            }), yP("initializing IPNS keyspace"), await o.ipns.initializeKeyspace(n.peerId.privKey, U1t(`/ipfs/${a}`))
          }
          return e.start !== !1 && await o.start(), o
        }
      };
      r4e.exports = L4;
      var Syt = async r => {
        let e = new B1t(new D1t({
          type: "directory"
        }).marshal()),
          t = await r.dag.put(e, {
            version: 0,
            format: "dag-pb",
            hashAlg: "sha2-256",
            preload: !1
          });
        return await r.pin.add(t), t
      }, xyt = () => ({
        start: !0,
        EXPERIMENTAL: {},
        preload: {
          enabled: !M1t,
          addresses: ["/dns4/node0.preload.ipfs.io/https", "/dns4/node1.preload.ipfs.io/https", "/dns4/node2.preload.ipfs.io/https", "/dns4/node3.preload.ipfs.io/https"]
        }
      })
    });
    var a4e = y((ARt, s4e) => {
      l();
      "use strict";
      var Ayt = zP(),
        Iyt = AC(),
        Tyt = Et(),
        Ryt = Ja(),
        kyt = Sl(),
        {
          multiaddr: Pyt
        } = pr(),
        Cyt = ln(),
        Oyt = Jr(),
        o4e = cr(),
        Nyt = o4e.multihash,
        qyt = at(),
        {
          create: Myt
        } = n4e();
      s4e.exports = {
        create: Myt,
        crypto: Ryt,
        isIPFS: kyt,
        CID: qyt,
        multiaddr: Pyt,
        multibase: Cyt,
        multihash: Nyt,
        multihashing: o4e,
        multicodec: Oyt,
        PeerId: Tyt,
        globSource: Ayt,
        urlSource: Iyt
      }
    });
    var Byt = y((IRt, c4e) => {
      l();
      "use strict";
      c4e.exports = {
        ...a4e()
      }
    });
    return Byt();
  })();
  /*!
   * prr
   * (c) 2013 Rod Vagg <rod@vagg.org>
   * https://github.com/rvagg/prr
   * License: MIT
   */
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*!
   * aead.js - aead for bcrypto
   * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources:
   *   https://tools.ietf.org/html/rfc7539#section-2.8
   *   https://github.com/openssh/openssh-portable
   */
  /*!
   * assert.js - assert for bcrypto
   * Copyright (c) 2020, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  /*!
   * bn.js - big numbers for bcrypto
   * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  /*!
   * bn.js - big numbers for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on indutny/bn.js:
   *   Copyright (c) 2015, Fedor Indutny (MIT License).
   *   https://github.com/indutny/bn.js
   *
   * Parts of this software are based on golang/go:
   *   Copyright (c) 2009, The Go Authors. All rights reserved.
   *   https://github.com/golang/go
   *
   * Parts of this software are based on openssl/openssl:
   *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
   *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
   *   https://github.com/openssl/openssl
   *
   * Parts of this software are based on libgmp:
   *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
   *   https://gmplib.org/
   *
   * Parts of this software are based on v8/v8:
   *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
   *   https://github.com/v8/v8
   *
   * Resources:
   *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
   *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
   *   https://github.com/golang/go/blob/master/src/math/big/int.go
   *   https://github.com/golang/go/blob/master/src/math/big/nat.go
   *   https://github.com/golang/go/blob/master/src/math/big/prime.go
   *   https://github.com/openssl/openssl/tree/master/crypto/bn
   *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
   *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
   *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
   */
  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */
  /*!
   * chacha20.js - chacha20 for bcrypto
   * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources
   *   https://en.wikipedia.org/wiki/Chacha20
   *   https://tools.ietf.org/html/rfc7539#section-2
   *   https://cr.yp.to/chacha.html
   */
  /*!
   * custom.js - custom inspect symbol for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  /*!
   * ecdh.js - ECDH for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources:
   *   https://cr.yp.to/ecdh.html
   *   https://cr.yp.to/ecdh/curve25519-20060209.pdf
   *   https://tools.ietf.org/html/rfc7748
   */
  /*!
   * elliptic.js - elliptic curves for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on indutny/elliptic:
   *   Copyright (c) 2014, Fedor Indutny (MIT License).
   *   https://github.com/indutny/elliptic
   *
   * Formulas from DJB and Tanja Lange [EFD].
   *
   * References:
   *
   *   [GECC] Guide to Elliptic Curve Cryptography
   *     D. Hankerson, A. Menezes, and S. Vanstone
   *     https://tinyurl.com/guide-to-ecc
   *
   *   [GLV] Faster Point Multiplication on Elliptic Curves
   *     R. Gallant, R. Lambert, and S. Vanstone
   *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
   *
   *   [MONT1] Montgomery curves and the Montgomery ladder
   *     Daniel J. Bernstein, Tanja Lange
   *     https://eprint.iacr.org/2017/293.pdf
   *
   *   [SQUARED] Elligator Squared
   *     Mehdi Tibouchi
   *     https://eprint.iacr.org/2014/043.pdf
   *
   *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
   *     Certicom Research
   *     https://www.secg.org/sec1-v2.pdf
   *
   *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
   *     Certicom Research
   *     https://www.secg.org/sec2-v2.pdf
   *
   *   [SIDE1] Elliptic Curves and Side-Channel Attacks
   *     Marc Joye
   *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
   *
   *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
   *     B. Feix, M. Roussellet, A. Venelli
   *     https://eprint.iacr.org/2014/191.pdf
   *
   *   [ALT] Alternative Elliptic Curve Representations
   *     R. Struik
   *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
   *
   *   [ARITH1] Arithmetic of Elliptic Curves
   *     Christophe Doche, Tanja Lange
   *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
   *     Page 267, Section 13 (978-1-58488-518-4)
   *     https://hyperelliptic.org/HEHCC/index.html
   *
   *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
   *     Joseph H. Silverman
   *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
   *
   *   [EFD] Explicit-Formulas Database
   *     Daniel J. Bernstein, Tanja Lange
   *     https://hyperelliptic.org/EFD/index.html
   *
   *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
   *     Daniel J. Bernstein
   *     https://safecurves.cr.yp.to/
   *
   *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
   *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
   *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
   *
   *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
   *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
   *     https://eprint.iacr.org/2009/340.pdf
   *
   *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
   *     Maciej Ulas
   *     https://arxiv.org/abs/0706.1448
   *
   *   [H2EC] Hashing to Elliptic Curves
   *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
   *     https://git.io/JeWz6
   *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
   *
   *   [SVDW1] Construction of Rational Points on Elliptic Curves
   *     A. Shallue, C. E. van de Woestijne
   *     https://works.bepress.com/andrew_shallue/1/download/
   *
   *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
   *     Pierre-Alain Fouque, Mehdi Tibouchi
   *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
   *
   *   [SVDW3] Covert ECDH over secp256k1
   *     Pieter Wuille
   *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
   *
   *   [MONT2] Montgomery Curve (wikipedia)
   *     https://en.wikipedia.org/wiki/Montgomery_curve
   *
   *   [MONT3] Montgomery Curves and their arithmetic
   *     C. Costello, B. Smith
   *     https://eprint.iacr.org/2017/212.pdf
   *
   *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
   *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
   *     https://elligator.cr.yp.to/elligator-20130828.pdf
   *
   *   [RFC7748] Elliptic Curves for Security
   *     A. Langley, M. Hamburg, S. Turner
   *     https://tools.ietf.org/html/rfc7748
   *
   *   [TWISTED] Twisted Edwards Curves
   *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
   *     https://eprint.iacr.org/2008/013.pdf
   *
   *   [ELL1] Injective Encodings to Elliptic Curves
   *     P. Fouque, A. Joux, M. Tibouchi
   *     https://eprint.iacr.org/2013/373.pdf
   *
   *   [ISOGENY] Twisting Edwards curves with isogenies
   *     Mike Hamburg
   *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
   *
   *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
   *     S. Josefsson, SJD AB, I. Liusvaara
   *     https://tools.ietf.org/html/rfc8032
   *
   *   [SCHNORR] Schnorr Signatures for secp256k1
   *     Pieter Wuille
   *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
   *
   *   [BIP340] Schnorr Signatures for secp256k1
   *     Pieter Wuille, Jonas Nick, Tim Ruffing
   *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
   *
   *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
   *            on Sensor Networks Using the MSP430X Microcontroller
   *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
   *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
   *
   *   [FIPS186] Federal Information Processing Standards Publication
   *     National Institute of Standards and Technology
   *     https://tinyurl.com/fips-186-3
   *
   *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
   *             Standard Curves and Curve Generation
   *     M. Lochter, BSI, J. Merkle
   *     https://tools.ietf.org/html/rfc5639
   *
   *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
   *     Christopher Jeffrey
   *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
   *
   *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
   *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
   */
  /*!
   * hkdf.js - hkdf for bcrypto
   * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources:
   *   https://en.wikipedia.org/wiki/HKDF
   *   https://tools.ietf.org/html/rfc5869
   */
  /*!
   * hkdf.js - hkdf for bcrypto
   * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  /*!
   * hmac.js - hmac for bcrypto
   * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on indutny/hash.js:
   *   Copyright (c) 2014, Fedor Indutny (MIT License).
   *   https://github.com/indutny/hash.js
   *
   * Resources:
   *   https://en.wikipedia.org/wiki/HMAC
   *   https://tools.ietf.org/html/rfc2104
   *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
   */
  /*!
   * poly1305.js - poly1305 for bcrypto
   * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on floodyberry/poly1305-donna:
   *   Placed into the public domain by Andrew Moon.
   *   https://github.com/floodyberry/poly1305-donna
   *
   * Resources:
   *   https://en.wikipedia.org/wiki/Poly1305
   *   https://cr.yp.to/mac.html
   *   https://tools.ietf.org/html/rfc7539#section-2.5
   *   https://github.com/floodyberry/poly1305-donna/blob/master/poly1305-donna-16.h
   */
  /*!
   * random.js - random for bcrypto
   * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  /*!
   * random.js - random number generator for bcrypto
   * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources:
   *   https://wiki.openssl.org/index.php/Random_Numbers
   *   https://csrc.nist.gov/projects/random-bit-generation/
   *   http://www.pcg-random.org/posts/bounded-rands.html
   *   https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
   */
  /*!
   * sha256.js - SHA256 implementation for bcrypto
   * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on indutny/hash.js:
   *   Copyright (c) 2014, Fedor Indutny (MIT License).
   *   https://github.com/indutny/hash.js
   *
   * Resources:
   *   https://en.wikipedia.org/wiki/SHA-2
   *   https://tools.ietf.org/html/rfc4634
   *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
   */
  /*!
   * x25519.js - x25519 for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources:
   *   https://en.wikipedia.org/wiki/Curve25519
   *   https://cr.yp.to/ecdh/curve25519-20060209.pdf
   *   https://tools.ietf.org/html/rfc7748#section-5
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /**
   * Timestamp for 64-bit time_t, nanosecond precision and strftime
   *
   * @author Yusuke Kawasaki
   * @license MIT
   * @see https://github.com/kawanet/timestamp-nano
   */
  /**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   */
  //! stable.js 0.1.8, https://github.com/Two-Screen/stable
  //! © 2018 Angry Bytes and contributors. MIT licensed.
  return Ipfs
}));